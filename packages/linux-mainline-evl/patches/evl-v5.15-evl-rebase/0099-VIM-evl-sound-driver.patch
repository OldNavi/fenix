diff -ruN a/drivers/evl/Kconfig b/evl/Kconfig
--- a/drivers/evl/Kconfig	2022-01-30 18:19:00.000000000 +0300
+++ b/evl/Kconfig	2021-12-16 16:31:15.139134388 +0300
@@ -21,4 +21,5 @@
 	  for running some tests from the EVL test suite.
 	  If in doubt, say 'Y'.
 
+source "drivers/evl/sound/evl-amlogic/Kconfig"
 endmenu
diff -ruN a/drivers/evl/Makefile b/evl/Makefile
--- a/drivers/evl/Makefile	2022-01-30 18:19:00.000000000 +0300
+++ b/evl/Makefile	2021-12-16 16:35:13.179136241 +0300
@@ -1,2 +1,3 @@
 obj-$(CONFIG_EVL_LATMUS)	+= latmus.o
 obj-$(CONFIG_EVL_HECTIC)	+= hectic.o
+obj-$(CONFIG_EVL_AMLOGIC_SND_AUGE_DIRECT)	+= sound/evl-amlogic/
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/CONTRIBUTING.md b/evl/sound/evl-amlogic/CONTRIBUTING.md
--- a/drivers/evl/sound/evl-amlogic/CONTRIBUTING.md	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/CONTRIBUTING.md	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,15 @@
+# Contributing to Elk Audio OS
+
+## Github Issues
+
+You can open a Github issue to signal a bug or request a new feature. Please don't create an issue to ask about general help, use the [Elk Audio Forum](https://forum.elk.audio) for generic questions and assistance.
+
+When writing a bug report, try to be as complete as you can regarding the context:
+  * Mention the version of Elk Audio OS that you are testing
+  * What is your run-time setup (plugins, buffer size, audio/CV channels, sensors, etc.)
+  * (if working on a plugin) what is your build environment
+  * Include relevant files that helps understand your issue or, better, to reproduce it
+
+## Submitting a PR
+
+A signed Contributor Agreement (CA) is required for submitting Pull Requests to this repository. Please contact tech@elk.audio for more information.
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/COPYING b/evl/sound/evl-amlogic/COPYING
--- a/drivers/evl/sound/evl-amlogic/COPYING	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/COPYING	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/Kconfig b/evl/sound/evl-amlogic/Kconfig
--- a/drivers/evl/sound/evl-amlogic/Kconfig	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/Kconfig	2021-12-16 16:30:54.639134228 +0300
@@ -0,0 +1,13 @@
+menu "Out-of-band sound device drivers"
+
+config EVL_AMLOGIC_SND_AUGE_DIRECT
+	tristate "This is direct Amlogic sound driver for AUGE"
+	depends on EVL
+	default y
+	help
+	  This driver supports the latmus application for
+	  determining the best gravity values for the EVL core
+	  clock, and measuring the response time to timer events.
+	  If in doubt, say 'Y'.
+
+endmenu
diff -ruN a/drivers/evl/sound/evl-amlogic/Makefile b/evl/sound/evl-amlogic/Makefile
--- a/drivers/evl/sound/evl-amlogic/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/Makefile	2022-01-10 18:56:49.031492147 +0300
@@ -0,0 +1,5 @@
+
+
+obj-$(CONFIG_EVL_AMLOGIC_SND_AUGE_DIRECT)	+= evl-audio-rt.o 
+
+evl-audio-rt-objs := evl-audio.o evl-axg-memory.o audio_io.o audio_controller.o ddr_mngr.o iomap.o tdm_hw.o  audio_clks.o sm1,clocks.o tl1,clocks.o tm2,clocks.o g12a,clocks.o axg,clocks.o tdm.o clk_measure.o sharebuffer.o spdif_hw.o spdif_info.o 
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/README.md b/evl/sound/evl-amlogic/README.md
--- a/drivers/evl/sound/evl-amlogic/README.md	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/README.md	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,52 @@
+# Audio RTDM driver
+
+Xenomai real-time audio driver for TI PCM3168A codec on the [Elk Pi hat](https://elk.audio/dev-kit/).
+
+## Building
+
+Have the kernel sources and an ARMv7 cross-compilation toolchain on your host machine, then do:
+
+(https://github.com/elk-audio/elkpi-sdk) available on the host machine, then:
+
+```
+$ export KERNEL_PATH=<path to kernel source tree>
+$ export CROSS_COMPILE=<arm compiler prefix>
+$ make
+```
+
+It's possible to just use the official [Elk Audio OS cross-compiling SDK](https://github.com/elk-audio/elkpi-sdk), in which case you don't have to set the `CROSS_COMPILE` environment variable since the SDK will do it automatically.
+
+As an alternative, you can build using the devshell option of Bitbake if you have all the Yocto layers ready on the host machine:
+
+```
+$ bitbake -c devshell virtual/kernel
+$ export KERNEL_PATH=<path to kernel source in your bitbake tmp build files>
+$ make
+```
+
+By default CV gates support is enabled with the definition `BCM2835_I2S_CVGATES_SUPPORT`.
+It is currently set in the `Makefile` script with this line:
+
+```
+ccflags-y += -DBCM2835_i2S_CVGATES_SUPPORT
+```
+
+Just remove the line if you want to compile without CV gate support.
+
+## Usage Example
+To load the driver as an out-of-tree module, run as sudo:
+
+```
+$ insmod pcm3168a-elk.ko
+$ insmod bcm2835-i2s-elk.ko
+$ insmod audio_rtdm.ko audio_buffer_size=<BUFFER SIZE>
+```
+
+If the modules are installed already as part of the Kernel you can just do instead:
+
+```
+ $ modprobe audio_rtdm audio_buffer_size=<BUFFER SIZE>
+```
+
+---
+Copyright 2021 Modern Ancient Instruments Networked AB, dba Elk, Stockholm
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_aed_reg_list.h b/evl/sound/evl-amlogic/audio_aed_reg_list.h
--- a/drivers/evl/sound/evl-amlogic/audio_aed_reg_list.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_aed_reg_list.h	2021-12-19 13:10:55.657452227 +0300
@@ -0,0 +1,159 @@
+/*
+ * sound/soc/amlogic/auge/audio_aed_reg_list.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_AUDIO_AED_REG_H_
+#define __AML_AUDIO_AED_REG_H_
+
+#include "regs.h"
+
+static const struct register_table aed_register_table[] = {
+{"AED_COEF_RAM_CNTL           ",     0x00},
+{"AED_COEF_RAM_DATA           ",     0x01},
+{"AED_EQ_EN                   ",     0x02},
+{"AED_EQ_TAP_CNTL             ",     0x03},
+{"AED_EQ_VOLUME               ",     0x04},
+{"AED_EQ_VOLUME_SLEW_CNT      ",     0x05},
+{"AED_MUTE                    ",     0x06},
+{"AED_DRC_CNTL                ",     0x07},
+{"AED_DRC_RMS_COEF0           ",     0x08},
+{"AED_DRC_RMS_COEF1           ",     0x09},
+{"AED_DRC_THD0                ",     0x0a},
+{"AED_DRC_THD1                ",     0x0b},
+{"AED_DRC_THD2                ",     0x0c},
+{"AED_DRC_THD3                ",     0x0d},
+{"AED_DRC_THD4                ",     0x0e},
+{"AED_DRC_K0                  ",     0x0f},
+{"AED_DRC_K1                  ",     0x10},
+{"AED_DRC_K2                  ",     0x11},
+{"AED_DRC_K3                  ",     0x12},
+{"AED_DRC_K4                  ",     0x13},
+{"AED_DRC_K5                  ",     0x14},
+{"AED_DRC_THD_OUT0            ",     0x15},
+{"AED_DRC_THD_OUT1            ",     0x16},
+{"AED_DRC_THD_OUT2            ",     0x17},
+{"AED_DRC_THD_OUT3            ",     0x18},
+{"AED_DRC_OFFSET              ",     0x19},
+{"AED_DRC_RELEASE_COEF00      ",     0x1a},
+{"AED_DRC_RELEASE_COEF01      ",     0x1b},
+{"AED_DRC_RELEASE_COEF10      ",     0x1c},
+{"AED_DRC_RELEASE_COEF11      ",     0x1d},
+{"AED_DRC_RELEASE_COEF20      ",     0x1e},
+{"AED_DRC_RELEASE_COEF21      ",     0x1f},
+{"AED_DRC_RELEASE_COEF30      ",     0x20},
+{"AED_DRC_RELEASE_COEF31      ",     0x21},
+{"AED_DRC_RELEASE_COEF40      ",     0x22},
+{"AED_DRC_RELEASE_COEF41      ",     0x23},
+{"AED_DRC_RELEASE_COEF50      ",     0x24},
+{"AED_DRC_RELEASE_COEF51      ",     0x25},
+{"AED_DRC_ATTACK_COEF00       ",     0x26},
+{"AED_DRC_ATTACK_COEF01       ",     0x27},
+{"AED_DRC_ATTACK_COEF10       ",     0x28},
+{"AED_DRC_ATTACK_COEF11       ",     0x29},
+{"AED_DRC_ATTACK_COEF20       ",     0x2a},
+{"AED_DRC_ATTACK_COEF21       ",     0x2b},
+{"AED_DRC_ATTACK_COEF30       ",     0x2c},
+{"AED_DRC_ATTACK_COEF31       ",     0x2d},
+{"AED_DRC_ATTACK_COEF40       ",     0x2e},
+{"AED_DRC_ATTACK_COEF41       ",     0x2f},
+{"AED_DRC_ATTACK_COEF50       ",     0x30},
+{"AED_DRC_ATTACK_COEF51       ",     0x31},
+{"AED_DRC_LOOPBACK_CNTL       ",     0x32},
+{"AED_MDRC_CNTL               ",     0x33},
+{"AED_MDRC_RMS_COEF00         ",     0x34},
+{"AED_MDRC_RMS_COEF01         ",     0x35},
+{"AED_MDRC_RELEASE_COEF00     ",     0x36},
+{"AED_MDRC_RELEASE_COEF01     ",     0x37},
+{"AED_MDRC_ATTACK_COEF00      ",     0x38},
+{"AED_MDRC_ATTACK_COEF01      ",     0x39},
+{"AED_MDRC_THD0               ",     0x3a},
+{"AED_MDRC_K0                 ",     0x3b},
+{"AED_MDRC_LOW_GAIN           ",     0x3c},
+{"AED_MDRC_OFFSET0            ",     0x3d},
+{"AED_MDRC_RMS_COEF10         ",     0x3e},
+{"AED_MDRC_RMS_COEF11         ",     0x3f},
+{"AED_MDRC_RELEASE_COEF10     ",     0x40},
+{"AED_MDRC_RELEASE_COEF11     ",     0x41},
+{"AED_MDRC_ATTACK_COEF10      ",     0x42},
+{"AED_MDRC_ATTACK_COEF11      ",     0x43},
+{"AED_MDRC_THD1               ",     0x44},
+{"AED_MDRC_K1                 ",     0x45},
+{"AED_MDRC_OFFSET1            ",     0x46},
+{"AED_MDRC_MID_GAIN           ",     0x47},
+{"AED_MDRC_RMS_COEF20         ",     0x48},
+{"AED_MDRC_RMS_COEF21         ",     0x49},
+{"AED_MDRC_RELEASE_COEF20     ",     0x4a},
+{"AED_MDRC_RELEASE_COEF21     ",     0x4b},
+{"AED_MDRC_ATTACK_COEF20      ",     0x4c},
+{"AED_MDRC_ATTACK_COEF21      ",     0x4d},
+{"AED_MDRC_THD2               ",     0x4e},
+{"AED_MDRC_K2                 ",     0x4f},
+{"AED_MDRC_OFFSET2            ",     0x50},
+{"AED_MDRC_HIGH_GAIN          ",     0x51},
+{"AED_ED_CNTL                 ",     0x52},
+{"AED_DC_EN                   ",     0x53},
+{"AED_ND_LOW_THD              ",     0x54},
+{"AED_ND_HIGH_THD             ",     0x55},
+{"AED_ND_CNT_THD              ",     0x56},
+{"AED_ND_SUM_NUM              ",     0x57},
+{"AED_ND_CZ_NUM               ",     0x58},
+{"AED_ND_SUM_THD0             ",     0x59},
+{"AED_ND_SUM_THD1             ",     0x5a},
+{"AED_ND_CZ_THD0              ",     0x5b},
+{"AED_ND_CZ_THD1              ",     0x5c},
+{"AED_ND_COND_CNTL            ",     0x5d},
+{"AED_ND_RELEASE_COEF0        ",     0x5e},
+{"AED_ND_RELEASE_COEF1        ",     0x5f},
+{"AED_ND_ATTACK_COEF0         ",     0x60},
+{"AED_ND_ATTACK_COEF1         ",     0x61},
+{"AED_ND_CNTL                 ",     0x62},
+{"AED_MIX0_LL                 ",     0x63},
+{"AED_MIX0_RL                 ",     0x64},
+{"AED_MIX0_LR                 ",     0x65},
+{"AED_MIX0_RR                 ",     0x66},
+{"AED_CLIP_THD                ",     0x67},
+{"AED_CH1_ND_SUM_OUT          ",     0x68},
+{"AED_CH2_ND_SUM_OUT          ",     0x69},
+{"AED_CH1_ND_CZ_OUT           ",     0x6a},
+{"AED_CH2_ND_CZ_OUT           ",     0x6b},
+{"AED_NOISE_STATUS            ",     0x6c},
+{"AED_POW_CURRENT_S0          ",     0x6d},
+{"AED_POW_CURRENT_S1          ",     0x6e},
+{"AED_POW_CURRENT_S2          ",     0x6f},
+{"AED_POW_OUT0                ",     0x70},
+{"AED_POW_OUT1                ",     0x71},
+{"AED_POW_OUT2                ",     0x72},
+{"AED_POW_ADJ_INDEX0          ",     0x73},
+{"AED_POW_ADJ_INDEX1          ",     0x74},
+{"AED_POW_ADJ_INDEX2          ",     0x75},
+{"AED_DRC_GAIN_INDEX0         ",     0x76},
+{"AED_DRC_GAIN_INDEX1         ",     0x77},
+{"AED_DRC_GAIN_INDEX2         ",     0x78},
+{"AED_CH1_VOLUME_STATE        ",     0x79},
+{"AED_CH2_VOLUME_STATE        ",     0x7a},
+{"AED_CH1_VOLUME_GAIN         ",     0x7b},
+{"AED_CH2_VOLUME_GAIN         ",     0x7c},
+{"AED_FULL_POW_CURRENT        ",     0x7d},
+{"AED_FULL_POW_OUT            ",     0x7e},
+{"AED_FULL_POW_ADJ            ",     0x7f},
+{"AED_FULL_DRC_GAIN           ",     0x80},
+{"AED_MASTER_VOLUME_STATE     ",     0x81},
+{"AED_MASTER_VOLUME_GAIN      ",     0x82},
+{"AED_TOP_CTL                 ",     0x83},
+{"AED_TOP_REQ_CTL             ",     0x84},
+};
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_clks.c b/evl/sound/evl-amlogic/audio_clks.c
--- a/drivers/evl/sound/evl-amlogic/audio_clks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_clks.c	2022-01-10 15:56:49.298880307 +0300
@@ -0,0 +1,118 @@
+/*
+ * sound/soc/amlogic/auge/clks.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "audio_clocks: " fmt
+
+#include <linux/of_device.h>
+
+#include "audio_clks.h"
+
+#define DRV_NAME "audio-clocks"
+
+static const struct of_device_id audio_clocks_of_match[] = {
+	{
+		.compatible = "amlogic, axg-audio-clocks",
+		.data       = &axg_audio_clks_init,
+	},
+	{
+		.compatible = "amlogic, g12a-audio-clocks",
+		.data       = &g12a_audio_clks_init,
+	},
+	{
+		.compatible = "amlogic, tl1-audio-clocks",
+		.data       = &tl1_audio_clks_init,
+	},
+	{
+		.compatible = "amlogic, sm1-audio-clocks",
+		.data		= &sm1_audio_clks_init,
+	},
+	{
+		.compatible = "amlogic, tm2-audio-clocks",
+		.data		= &tm2_audio_clks_init,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, audio_clocks_of_match);
+
+int audio_clocks_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *np = of_find_node_by_name(pdev->dev.of_node, "clocks");
+	struct clk **clks;
+	struct clk_onecell_data *clk_data;
+	void __iomem *clk_base;
+	struct audio_clk_init *p_audioclk_init;
+	int ret;
+	dev_info(&pdev->dev,"Registering clocks manager");
+
+	if(np == NULL)
+		return -ENOENT;
+
+	p_audioclk_init = (struct audio_clk_init *)
+		// of_device_get_match_data(dev);
+		of_match_node(audio_clocks_of_match, np)->data;
+	if (!p_audioclk_init) {
+		dev_warn_once(dev,
+			"check whether to update audio clock chipinfo\n");
+		return -EINVAL;
+	}
+
+	clk_base = of_iomap(np, 0);
+	if (!clk_base) {
+		dev_err(dev,
+			"Unable to map clk base\n");
+		return -ENXIO;
+	}
+
+	clk_data = devm_kmalloc(dev, sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		return -ENOMEM;
+
+	clks = devm_kmalloc(dev,
+			p_audioclk_init->clk_num * sizeof(*clks),
+			GFP_KERNEL);
+	if (!clks)
+		return -ENOMEM;
+
+	if (p_audioclk_init) {
+		p_audioclk_init->clk_gates(clks, clk_base);
+		p_audioclk_init->clks(clks, clk_base);
+	}
+
+	clk_data->clks = clks;
+	clk_data->clk_num = p_audioclk_init->clk_num;
+
+	ret = of_clk_add_provider(np, of_clk_src_onecell_get,
+			clk_data);
+	if (ret) {
+		dev_err(dev, "%s fail ret: %d\n", __func__, ret);
+
+		return ret;
+	}
+
+	return 0;
+}
+
+// static struct platform_driver audio_clocks_driver = {
+// 	.driver = {
+// 		.name           = DRV_NAME,
+// 		.of_match_table = audio_clocks_of_match,
+// 	},
+// 	.probe  = audio_clocks_probe,
+// };
+// module_platform_driver(audio_clocks_driver);
+
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_clks.h b/evl/sound/evl-amlogic/audio_clks.h
--- a/drivers/evl/sound/evl-amlogic/audio_clks.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_clks.h	2021-12-24 10:33:48.838783719 +0300
@@ -0,0 +1,118 @@
+/*
+ * sound/soc/amlogic/auge/audio_clks.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef __AML_AUDIO_CLKS_H__
+#define __AML_AUDIO_CLKS_H__
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+
+#include <linux/clk-provider.h>
+
+#define CLOCK_GATE(_name, _reg, _bit) \
+static struct clk_gate _name = { \
+	.reg = (void __iomem *)(_reg), \
+	.bit_idx = (_bit), \
+	.lock = &aclk_lock, \
+	.hw.init = &(struct clk_init_data) { \
+		.name = #_name, \
+		.ops = &clk_gate_ops, \
+		.parent_names = (const char *[]){ "clk81" }, \
+		.num_parents = 1, \
+		.flags = (CLK_SET_RATE_PARENT | CLK_IGNORE_UNUSED), \
+	}, \
+}
+
+#define CLOCK_COM_MUX(_name, _reg, _mask, _shift) \
+static struct clk_mux _name##_mux = { \
+	.reg = (void __iomem *)(_reg), \
+	.mask = (_mask), \
+	.shift = (_shift), \
+	.lock = &aclk_lock, \
+}
+#define CLOCK_COM_DIV(_name, _reg, _shift, _width) \
+static struct clk_divider _name##_div = { \
+	.reg = (void __iomem *)(_reg), \
+	.shift = (_shift), \
+	.width = (_width), \
+	.lock = &aclk_lock, \
+}
+#define CLOCK_COM_GATE(_name, _reg, _bit) \
+static struct clk_gate _name##_gate = { \
+	.reg = (void __iomem *)(_reg), \
+	.bit_idx = (_bit), \
+	.lock = &aclk_lock, \
+}
+
+#define IOMAP_COM_CLK(_name, _iobase) \
+do { \
+	_name##_mux.reg += (unsigned long)(iobase); \
+	_name##_div.reg += (unsigned long)(iobase); \
+	_name##_gate.reg += (unsigned long)(iobase); \
+} while (0)
+
+#define REGISTER_CLK_COM(_name) \
+	clk_register_composite(NULL, #_name, \
+			mclk_parent_names, ARRAY_SIZE(mclk_parent_names), \
+			&_name##_mux.hw, &clk_mux_ops, \
+			&_name##_div.hw, &clk_divider_ops, \
+			&_name##_gate.hw, &clk_gate_ops, \
+			CLK_SET_RATE_NO_REPARENT)
+
+#define REGISTER_AUDIOCLK_COM(_name) \
+	clk_register_composite(NULL, #_name, \
+			audioclk_parent_names, \
+			ARRAY_SIZE(audioclk_parent_names), \
+			&_name##_mux.hw, &clk_mux_ops, \
+			&_name##_div.hw, &clk_divider_ops, \
+			&_name##_gate.hw, &clk_gate_ops, \
+			CLK_SET_RATE_NO_REPARENT)
+
+#define REGISTER_CLK_COM_PARENTS(_name, pnames) \
+	clk_register_composite(NULL, #_name, \
+			pnames##_parent_names, \
+			ARRAY_SIZE(pnames##_parent_names), \
+			&_name##_mux.hw, &clk_mux_ops, \
+			&_name##_div.hw, &clk_divider_ops, \
+			&_name##_gate.hw, &clk_gate_ops, \
+			CLK_SET_RATE_NO_REPARENT)
+
+struct audio_clk_init {
+	int clk_num;
+	int (*clk_gates)(struct clk **clks, void __iomem *iobase);
+	int (*clks)(struct clk **clks, void __iomem *iobase);
+};
+
+extern struct audio_clk_init axg_audio_clks_init;
+extern struct audio_clk_init g12a_audio_clks_init;
+extern struct audio_clk_init tl1_audio_clks_init;
+extern struct audio_clk_init sm1_audio_clks_init;
+extern struct audio_clk_init tm2_audio_clks_init;
+
+struct clk_chipinfo {
+	/* force clock source as oscin(24M) */
+	bool force_oscin_fn;
+	/* Sclk_ws_inv for tdm; if not, echo for axg tdm
+	 * Sclk_ws_inv, for the capture ws sclk; 0: not revert; 1: revert clock;
+	 */
+	bool sclk_ws_inv;
+};
+int audio_clocks_probe(struct platform_device *pdev);
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_controller.c b/evl/sound/evl-amlogic/audio_controller.c
--- a/drivers/evl/sound/evl-amlogic/audio_controller.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_controller.c	2021-12-20 14:34:29.654349959 +0300
@@ -0,0 +1,151 @@
+/*
+ * sound/soc/amlogic/auge/audio_controller.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+
+/*#define DEBUG*/
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/regmap.h>
+#include <linux/clk-provider.h>
+
+#include "audio_io.h"
+#include "regs.h"
+#include "audio_aed_reg_list.h"
+#include "audio_top_reg_list.h"
+#include "evl-audio.h"
+
+#define DRV_NAME "aml-audio-controller"
+
+static unsigned int aml_audio_mmio_read(struct aml_audio_controller *actrlr,
+			unsigned int reg)
+{
+	struct regmap *regmap = actrlr->regmap;
+	unsigned int val;
+
+	regmap_read(regmap, (reg << 2), &val);
+
+	return val;
+}
+
+static int aml_audio_mmio_write(struct aml_audio_controller *actrlr,
+			unsigned int reg, unsigned int value)
+{
+	struct regmap *regmap = actrlr->regmap;
+	pr_debug("audio top reg:[%s] addr: [%#x] val: [%#x]\n",
+			top_register_table[reg].name,
+			top_register_table[reg].addr,
+			value);
+	return regmap_write(regmap, (reg << 2), value);
+}
+
+static int aml_audio_mmio_update_bits(struct aml_audio_controller *actrlr,
+			unsigned int reg, unsigned int mask, unsigned int value)
+{
+	struct regmap *regmap = actrlr->regmap;
+	pr_debug("audio top reg:[%s] addr: [%#x] mask: [%#x] val: [%#x]\n",
+			top_register_table[reg].name,
+			top_register_table[reg].addr,
+			mask, value);
+	return regmap_update_bits(regmap, (reg << 2), mask, value);
+}
+
+struct aml_audio_ctrl_ops aml_actrl_mmio_ops = {
+	.read			= aml_audio_mmio_read,
+	.write			= aml_audio_mmio_write,
+	.update_bits	= aml_audio_mmio_update_bits,
+};
+
+static struct regmap_config aml_audio_regmap_config = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+};
+
+static const struct of_device_id amlogic_audio_controller_of_match[] = {
+	{ .compatible = "amlogic, audio-controller" },
+	{},
+};
+
+static int register_audio_controller(struct platform_device *pdev,
+			struct aml_audio_controller *actrl)
+{
+	struct resource res_mem;
+	void __iomem *regs;
+	struct regmap *regmap;
+
+	/* get platform res from dtb */
+	struct device_node * np = pdev->dev.of_node;
+	if(!np)
+		return -ENOENT;
+
+	struct device_node * child = of_find_node_by_name(np, "audio_controller");
+
+	if(child == NULL)
+		return -ENOENT;
+
+		dev_info(&pdev->dev, "parent node at  = %pm", np);
+		dev_info(&pdev->dev, "parent node at  = %pm", child);
+
+	if (of_address_to_resource(child, 0, &res_mem)) {
+			pr_err("%s could not get resource",
+				__func__);
+			return -ENOENT;
+	}
+	dev_info(&pdev->dev, "resources  = %pR", &res_mem);
+	regs = devm_ioremap_resource(&pdev->dev, &res_mem);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	aml_audio_regmap_config.max_register = 4 * resource_size(&res_mem);
+
+	regmap = devm_regmap_init_mmio(&pdev->dev, regs,
+					    &aml_audio_regmap_config);
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	/* init aml audio bus mmio controller */
+	aml_init_audio_controller(actrl, regmap, &aml_actrl_mmio_ops);
+
+	struct audio_dev_context * ctx = platform_get_drvdata(pdev);
+	ctx->actrl = actrl;
+	/* gate on all clks on bringup stage, need gate separately */
+	aml_audiobus_write(actrl, EE_AUDIO_CLK_GATE_EN0, 0xffffffff);
+	aml_audiobus_write(actrl, EE_AUDIO_CLK_GATE_EN1, 0xffffffff);
+
+	return 0;
+}
+
+int aml_audio_controller_probe(struct platform_device *pdev)
+{
+	struct aml_audio_controller *actrl;
+
+	pr_info("asoc debug: %s-%d\n", __func__, __LINE__);
+	actrl = devm_kzalloc(&pdev->dev, sizeof(*actrl), GFP_KERNEL);
+	if (!actrl)
+		return -ENOMEM;
+
+	return register_audio_controller(pdev, actrl);
+}
+
+
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_controller.h b/evl/sound/evl-amlogic/audio_controller.h
--- a/drivers/evl/sound/evl-amlogic/audio_controller.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_controller.h	2021-12-19 13:20:47.007456831 +0300
@@ -0,0 +1,24 @@
+/*
+ * sound/soc/amlogic/auge/audio_controller.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_AUDIO_CONTROLLER_H_
+#define __AML_AUDIO_CONTROLLER_H_
+
+struct aml_audio_controller;
+int aml_audio_controller_probe(struct platform_device *pdev);
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_io.c b/evl/sound/evl-amlogic/audio_io.c
--- a/drivers/evl/sound/evl-amlogic/audio_io.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_io.c	2021-12-19 13:12:23.467452911 +0300
@@ -0,0 +1,57 @@
+/*
+ * sound/soc/amlogic/auge/audio_io.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include "audio_io.h"
+
+int aml_init_audio_controller(struct aml_audio_controller *actrlr,
+			struct regmap *regmap, struct aml_audio_ctrl_ops *ops)
+{
+	actrlr->regmap = regmap;
+	actrlr->ops = ops;
+
+	return 0;
+}
+
+int aml_audiobus_write(struct aml_audio_controller *actrlr,
+			unsigned int reg, unsigned int value)
+{
+	if (actrlr->ops->write)
+		return actrlr->ops->write(actrlr, reg, value);
+
+	return -1;
+}
+
+unsigned int aml_audiobus_read(struct aml_audio_controller *actrlr,
+		unsigned int reg)
+{
+	if (actrlr->ops->read)
+		return actrlr->ops->read(actrlr, reg);
+
+	return 0;
+}
+
+int aml_audiobus_update_bits(struct aml_audio_controller *actrlr,
+	unsigned int reg, unsigned int mask, unsigned int value)
+{
+	if (actrlr->ops->update_bits)
+		return actrlr->ops->update_bits(actrlr, reg, mask, value);
+
+	return -1;
+}
+
+
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_io.h b/evl/sound/evl-amlogic/audio_io.h
--- a/drivers/evl/sound/evl-amlogic/audio_io.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_io.h	2021-12-19 13:01:03.547447617 +0300
@@ -0,0 +1,47 @@
+/*
+ * sound/soc/amlogic/auge/audio_io.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_AUDIO_IO_H_
+#define __AML_AUDIO_IO_H_
+
+struct aml_audio_controller;
+
+struct aml_audio_ctrl_ops {
+	unsigned int (*read)(struct aml_audio_controller *actrlr,
+			unsigned int reg);
+	int (*write)(struct aml_audio_controller *actrlr,
+			unsigned int reg, unsigned int value);
+	int (*update_bits)(struct aml_audio_controller *actrlr,
+		unsigned int reg, unsigned int mask, unsigned int value);
+};
+
+struct aml_audio_controller {
+	struct regmap *regmap;
+	const struct aml_audio_ctrl_ops *ops;
+};
+
+/* audio io controller */
+int aml_init_audio_controller(struct aml_audio_controller *actrlr,
+			struct regmap *regmap, struct aml_audio_ctrl_ops *ops);
+int aml_audiobus_write(struct aml_audio_controller *actrlr,
+			unsigned int reg, unsigned int value);
+unsigned int aml_audiobus_read(struct aml_audio_controller *actrlr,
+			unsigned int reg);
+int aml_audiobus_update_bits(struct aml_audio_controller *actrlr,
+		unsigned int reg, unsigned int mask, unsigned int value);
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/audio_top_reg_list.h b/evl/sound/evl-amlogic/audio_top_reg_list.h
--- a/drivers/evl/sound/evl-amlogic/audio_top_reg_list.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/audio_top_reg_list.h	2021-12-19 13:11:13.557452367 +0300
@@ -0,0 +1,599 @@
+/*
+ * sound/soc/amlogic/auge/audio_top_reg_list.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_AUDIO_TOP_REG_H_
+#define __AML_AUDIO_TOP_REG_H_
+
+#include "regs.h"
+
+static const struct register_table top_register_table[] = {
+{"AUDIO_CLK_GATE_EN0        ",  0x00},
+{"AUDIO_CLK_GATE_EN1        ",  0x01},
+{"AUDIO_MCLK_A_CTRL         ",  0x02},
+{"AUDIO_MCLK_B_CTRL         ",  0x03},
+{"AUDIO_MCLK_C_CTRL         ",  0x04},
+{"AUDIO_MCLK_D_CTRL         ",  0x05},
+{"AUDIO_MCLK_E_CTRL         ",  0x06},
+{"AUDIO_MCLK_F_CTRL         ",  0x07},
+{"AUDIO_PAD_CTRL0           ",  0x08},
+{"AUDIO_PAD_CTRL1           ",  0x09},
+{"AUDIO_SW_RESET0           ",  0x0a},
+{"AUDIO_SW_RESET1           ",  0x0b},
+{"AUDIO_CLK81_CTRL          ",  0x0c},
+{"AUDIO_CLK81_EN            ",  0x0d},
+{"AUDIO_RESV_ADDR_0xe       ",  0x0e},
+{"AUDIO_RESV_ADDR_0xf       ",  0x0f},
+{"AUDIO_MST_A_SCLK_CTRL0    ",  0x10},
+{"AUDIO_MST_A_SCLK_CTRL1    ",  0x11},
+{"AUDIO_MST_B_SCLK_CTRL0    ",  0x12},
+{"AUDIO_MST_B_SCLK_CTRL1    ",  0x13},
+{"AUDIO_MST_C_SCLK_CTRL0    ",  0x14},
+{"AUDIO_MST_C_SCLK_CTRL1    ",  0x15},
+{"AUDIO_MST_D_SCLK_CTRL0    ",  0x16},
+{"AUDIO_MST_D_SCLK_CTRL1    ",  0x17},
+{"AUDIO_MST_E_SCLK_CTRL0    ",  0x18},
+{"AUDIO_MST_E_SCLK_CTRL1    ",  0x19},
+{"AUDIO_MST_F_SCLK_CTRL0    ",  0x1a},
+{"AUDIO_MST_F_SCLK_CTRL1    ",  0x1b},
+{"AUDIO_RESV_ADDR_0x1c      ",  0x1c},
+{"AUDIO_RESV_ADDR_0x1d      ",  0x1d},
+{"AUDIO_RESV_ADDR_0x1e      ",  0x1e},
+{"AUDIO_RESV_ADDR_0x1f      ",  0x1f},
+{"AUDIO_CLK_TDMIN_A_CTRL    ",  0x20},
+{"AUDIO_CLK_TDMIN_B_CTRL    ",  0x21},
+{"AUDIO_CLK_TDMIN_C_CTRL    ",  0x22},
+{"AUDIO_CLK_TDMIN_LB_CTRL   ",  0x23},
+{"AUDIO_CLK_TDMOUT_A_CTRL   ",  0x24},
+{"AUDIO_CLK_TDMOUT_B_CTRL   ",  0x25},
+{"AUDIO_CLK_TDMOUT_C_CTRL   ",  0x26},
+{"AUDIO_CLK_SPDIFIN_CTRL    ",  0x27},
+{"AUDIO_CLK_SPDIFOUT_CTRL   ",  0x28},
+{"AUDIO_CLK_RESAMPLEA_CTRL  ",  0x29},
+{"AUDIO_CLK_LOCKER_CTRL     ",  0x2a},
+{"AUDIO_CLK_PDMIN_CTRL0     ",  0x2b},
+{"AUDIO_CLK_PDMIN_CTRL1     ",  0x2c},
+{"AUDIO_CLK_SPDIFOUT_B_CTRL ",  0x2d},
+{"AUDIO_CLK_RESAMPLEB_CTRL  ",  0x2e},
+{"AUDIO_CLK_SPDIFIN_LB_CTRL ",  0x2f},
+{"AUDIO_CLK_EQDRC_CTRL0     ",  0x30},
+{"AUDIO_VAD_CLK_CTRL        ",  0x31},
+{"AUDIO_RESV_ADDR_0x32      ",  0x32},
+{"AUDIO_RESV_ADDR_0x33      ",  0x33},
+{"AUDIO_RESV_ADDR_0x34      ",  0x34},
+{"AUDIO_RESV_ADDR_0x35      ",  0x35},
+{"AUDIO_RESV_ADDR_0x36      ",  0x36},
+{"AUDIO_RESV_ADDR_0x37      ",  0x37},
+{"AUDIO_RESV_ADDR_0x38      ",  0x38},
+{"AUDIO_RESV_ADDR_0x39      ",  0x39},
+{"AUDIO_RESV_ADDR_0x3a      ",  0x3a},
+{"AUDIO_RESV_ADDR_0x3b      ",  0x3b},
+{"AUDIO_RESV_ADDR_0x3c      ",  0x3c},
+{"AUDIO_RESV_ADDR_0x3d      ",  0x3d},
+{"AUDIO_RESV_ADDR_0x3e      ",  0x3e},
+{"AUDIO_RESV_ADDR_0x3f      ",  0x3f},
+{"AUDIO_TODDR_A_CTRL0       ",  0x40},
+{"AUDIO_TODDR_A_CTRL1       ",  0x41},
+{"AUDIO_TODDR_A_START_ADDR  ",  0x42},
+{"AUDIO_TODDR_A_FINISH_ADDR ",  0x43},
+{"AUDIO_TODDR_A_INT_ADDR    ",  0x44},
+{"AUDIO_TODDR_A_STATUS1     ",  0x45},
+{"AUDIO_TODDR_A_STATUS2     ",  0x46},
+{"AUDIO_TODDR_A_START_ADDRB ",  0x47},
+{"AUDIO_TODDR_A_FINISH_ADDRB",  0x48},
+{"AUDIO_TODDR_A_INIT_ADDR   ",  0x49},
+{"AUDIO_TODDR_A_CTRL2       ",  0x4a},
+{"AUDIO_RESV_ADDR_0x4b      ",  0x4b},
+{"AUDIO_RESV_ADDR_0x4c      ",  0x4c},
+{"AUDIO_RESV_ADDR_0x4d      ",  0x4d},
+{"AUDIO_RESV_ADDR_0x4e      ",  0x4e},
+{"AUDIO_RESV_ADDR_0x4f      ",  0x4f},
+{"AUDIO_TODDR_B_CTRL0       ",  0x50},
+{"AUDIO_TODDR_B_CTRL1       ",  0x51},
+{"AUDIO_TODDR_B_START_ADDR  ",  0x52},
+{"AUDIO_TODDR_B_FINISH_ADDR ",  0x53},
+{"AUDIO_TODDR_B_INT_ADDR    ",  0x54},
+{"AUDIO_TODDR_B_STATUS1     ",  0x55},
+{"AUDIO_TODDR_B_STATUS2     ",  0x56},
+{"AUDIO_TODDR_B_START_ADDRB ",  0x57},
+{"AUDIO_TODDR_B_FINISH_ADDRB",  0x58},
+{"AUDIO_TODDR_B_INIT_ADDR   ",  0x59},
+{"AUDIO_TODDR_B_CTRL2       ",  0x5a},
+{"AUDIO_RESV_ADDR_0x5b      ",  0x5b},
+{"AUDIO_RESV_ADDR_0x5c      ",  0x5c},
+{"AUDIO_RESV_ADDR_0x5d      ",  0x5d},
+{"AUDIO_RESV_ADDR_0x5e      ",  0x5e},
+{"AUDIO_RESV_ADDR_0x5f      ",  0x5f},
+{"AUDIO_TODDR_C_CTRL0       ",  0x60},
+{"AUDIO_TODDR_C_CTRL1       ",  0x61},
+{"AUDIO_TODDR_C_START_ADDR  ",  0x62},
+{"AUDIO_TODDR_C_FINISH_ADDR ",  0x63},
+{"AUDIO_TODDR_C_INT_ADDR    ",  0x64},
+{"AUDIO_TODDR_C_STATUS1     ",  0x65},
+{"AUDIO_TODDR_C_STATUS2     ",  0x66},
+{"AUDIO_TODDR_C_START_ADDRB ",  0x67},
+{"AUDIO_TODDR_C_FINISH_ADDRB",  0x68},
+{"AUDIO_TODDR_C_INIT_ADDR   ",  0x69},
+{"AUDIO_TODDR_C_CTRL2       ",  0x6a},
+{"AUDIO_RESV_ADDR_0x6b      ",  0x6b},
+{"AUDIO_RESV_ADDR_0x6c      ",  0x6c},
+{"AUDIO_RESV_ADDR_0x6d      ",  0x6d},
+{"AUDIO_RESV_ADDR_0x6e      ",  0x6e},
+{"AUDIO_RESV_ADDR_0x6f      ",  0x6f},
+{"AUDIO_FRDDR_A_CTRL0       ",  0x70},
+{"AUDIO_FRDDR_A_CTRL1       ",  0x71},
+{"AUDIO_FRDDR_A_START_ADDR  ",  0x72},
+{"AUDIO_FRDDR_A_FINISH_ADDR ",  0x73},
+{"AUDIO_FRDDR_A_INT_ADDR    ",  0x74},
+{"AUDIO_FRDDR_A_STATUS1     ",  0x75},
+{"AUDIO_FRDDR_A_STATUS2     ",  0x76},
+{"AUDIO_FRDDR_A_START_ADDRB ",  0x77},
+{"AUDIO_FRDDR_A_FINISH_ADDRB",  0x78},
+{"AUDIO_FRDDR_A_INIT_ADDR   ",  0x79},
+{"AUDIO_FRDDR_A_CTRL2       ",  0x7a},
+{"AUDIO_RESV_ADDR_0x7b      ",  0x7b},
+{"AUDIO_RESV_ADDR_0x7c      ",  0x7c},
+{"AUDIO_RESV_ADDR_0x7d      ",  0x7d},
+{"AUDIO_RESV_ADDR_0x7e      ",  0x7e},
+{"AUDIO_RESV_ADDR_0x7f      ",  0x7f},
+{"AUDIO_FRDDR_B_CTRL0       ",  0x80},
+{"AUDIO_FRDDR_B_CTRL1       ",  0x81},
+{"AUDIO_FRDDR_B_START_ADDR  ",  0x82},
+{"AUDIO_FRDDR_B_FINISH_ADDR ",  0x83},
+{"AUDIO_FRDDR_B_INT_ADDR    ",  0x84},
+{"AUDIO_FRDDR_B_STATUS1     ",  0x85},
+{"AUDIO_FRDDR_B_STATUS2     ",  0x86},
+{"AUDIO_FRDDR_B_START_ADDRB ",  0x87},
+{"AUDIO_FRDDR_B_FINISH_ADDRB",  0x88},
+{"AUDIO_FRDDR_B_INIT_ADDR   ",  0x89},
+{"AUDIO_FRDDR_B_CTRL2       ",  0x8a},
+{"AUDIO_RESV_ADDR_0x8b      ",  0x8b},
+{"AUDIO_RESV_ADDR_0x8c      ",  0x8c},
+{"AUDIO_RESV_ADDR_0x8d      ",  0x8d},
+{"AUDIO_RESV_ADDR_0x8e      ",  0x8e},
+{"AUDIO_RESV_ADDR_0x8f      ",  0x8f},
+{"AUDIO_FRDDR_C_CTRL0       ",  0x90},
+{"AUDIO_FRDDR_C_CTRL1       ",  0x91},
+{"AUDIO_FRDDR_C_START_ADDR  ",  0x92},
+{"AUDIO_FRDDR_C_FINISH_ADDR ",  0x93},
+{"AUDIO_FRDDR_C_INT_ADDR    ",  0x94},
+{"AUDIO_FRDDR_C_STATUS1     ",  0x95},
+{"AUDIO_FRDDR_C_STATUS2     ",  0x96},
+{"AUDIO_FRDDR_C_START_ADDRB ",  0x97},
+{"AUDIO_FRDDR_C_FINISH_ADDRB",  0x98},
+{"AUDIO_FRDDR_C_INIT_ADDR   ",  0x99},
+{"AUDIO_FRDDR_C_CTRL2       ",  0x9a},
+{"AUDIO_RESV_ADDR_0x9b      ",  0x9b},
+{"AUDIO_RESV_ADDR_0x9c      ",  0x9c},
+{"AUDIO_RESV_ADDR_0x9d      ",  0x9d},
+{"AUDIO_RESV_ADDR_0x9e      ",  0x9e},
+{"AUDIO_RESV_ADDR_0x9f      ",  0x9f},
+{"AUDIO_ARB_CTRL            ",  0xa0},
+{"AUDIO_RESV_ADDR_0xa1      ",  0xa1},
+{"AUDIO_RESV_ADDR_0xa2      ",  0xa2},
+{"AUDIO_RESV_ADDR_0xa3      ",  0xa3},
+{"AUDIO_RESV_ADDR_0xa4      ",  0xa4},
+{"AUDIO_RESV_ADDR_0xa5      ",  0xa5},
+{"AUDIO_RESV_ADDR_0xa6      ",  0xa6},
+{"AUDIO_RESV_ADDR_0xa7      ",  0xa7},
+{"AUDIO_RESV_ADDR_0xa8      ",  0xa8},
+{"AUDIO_RESV_ADDR_0xa9      ",  0xa9},
+{"AUDIO_RESV_ADDR_0xaa      ",  0xaa},
+{"AUDIO_RESV_ADDR_0xab      ",  0xab},
+{"AUDIO_RESV_ADDR_0xac      ",  0xac},
+{"AUDIO_RESV_ADDR_0xad      ",  0xad},
+{"AUDIO_RESV_ADDR_0xae      ",  0xae},
+{"AUDIO_RESV_ADDR_0xaf      ",  0xaf},
+{"AUDIO_LB_A_CTRL0          ",  0xb0},
+{"AUDIO_LB_A_CTRL1          ",  0xb1},
+{"AUDIO_LB_A_CTRL2          ",  0xb2},
+{"AUDIO_LB_A_CTRL3          ",  0xb3},
+{"AUDIO_LB_A_DAT_CH_ID0     ",  0xb4},
+{"AUDIO_LB_A_DAT_CH_ID1     ",  0xb5},
+{"AUDIO_LB_A_DAT_CH_ID2     ",  0xb6},
+{"AUDIO_LB_A_DAT_CH_ID3     ",  0xb7},
+{"AUDIO_LB_A_LB_CH_ID0      ",  0xb8},
+{"AUDIO_LB_A_LB_CH_ID1      ",  0xb9},
+{"AUDIO_LB_A_LB_CH_ID2      ",  0xba},
+{"AUDIO_LB_A_LB_CH_ID3      ",  0xbb},
+{"AUDIO_LB_A_STS            ",  0xbc},
+{"AUDIO_RESV_ADDR_0xbd      ",  0xbd},
+{"AUDIO_RESV_ADDR_0xbe      ",  0xbe},
+{"AUDIO_RESV_ADDR_0xbf      ",  0xbf},
+{"AUDIO_TDMIN_A_CTRL        ",  0xc0},
+{"AUDIO_TDMIN_A_SWAP        ",  0xc1},
+{"AUDIO_TDMIN_A_MASK0       ",  0xc2},
+{"AUDIO_TDMIN_A_MASK1       ",  0xc3},
+{"AUDIO_TDMIN_A_MASK2       ",  0xc4},
+{"AUDIO_TDMIN_A_MASK3       ",  0xc5},
+{"AUDIO_TDMIN_A_STAT        ",  0xc6},
+{"AUDIO_TDMIN_A_MUTE_VAL    ",  0xc7},
+{"AUDIO_TDMIN_A_MUTE0       ",  0xc8},
+{"AUDIO_TDMIN_A_MUTE1       ",  0xc9},
+{"AUDIO_TDMIN_A_MUTE2       ",  0xca},
+{"AUDIO_TDMIN_A_MUTE3       ",  0xcb},
+{"AUDIO_RESV_ADDR_0xcc      ",  0xcc},
+{"AUDIO_RESV_ADDR_0xcd      ",  0xcd},
+{"AUDIO_RESV_ADDR_0xce      ",  0xce},
+{"AUDIO_RESV_ADDR_0xcf      ",  0xcf},
+{"AUDIO_TDMIN_B_CTRL        ",  0xd0},
+{"AUDIO_TDMIN_B_SWAP        ",  0xd1},
+{"AUDIO_TDMIN_B_MASK0       ",  0xd2},
+{"AUDIO_TDMIN_B_MASK1       ",  0xd3},
+{"AUDIO_TDMIN_B_MASK2       ",  0xd4},
+{"AUDIO_TDMIN_B_MASK3       ",  0xd5},
+{"AUDIO_TDMIN_B_STAT        ",  0xd6},
+{"AUDIO_TDMIN_B_MUTE_VAL    ",  0xd7},
+{"AUDIO_TDMIN_B_MUTE0       ",  0xd8},
+{"AUDIO_TDMIN_B_MUTE1       ",  0xd9},
+{"AUDIO_TDMIN_B_MUTE2       ",  0xda},
+{"AUDIO_TDMIN_B_MUTE3       ",  0xdb},
+{"AUDIO_RESV_ADDR_0xdc      ",  0xdc},
+{"AUDIO_RESV_ADDR_0xdd      ",  0xdd},
+{"AUDIO_RESV_ADDR_0xde      ",  0xde},
+{"AUDIO_RESV_ADDR_0xdf      ",  0xdf},
+{"AUDIO_TDMIN_C_CTRL        ",  0xe0},
+{"AUDIO_TDMIN_C_SWAP        ",  0xe1},
+{"AUDIO_TDMIN_C_MASK0       ",  0xe2},
+{"AUDIO_TDMIN_C_MASK1       ",  0xe3},
+{"AUDIO_TDMIN_C_MASK2       ",  0xe4},
+{"AUDIO_TDMIN_C_MASK3       ",  0xe5},
+{"AUDIO_TDMIN_C_STAT        ",  0xe6},
+{"AUDIO_TDMIN_C_MUTE_VAL    ",  0xe7},
+{"AUDIO_TDMIN_C_MUTE0       ",  0xe8},
+{"AUDIO_TDMIN_C_MUTE1       ",  0xe9},
+{"AUDIO_TDMIN_C_MUTE2       ",  0xea},
+{"AUDIO_TDMIN_C_MUTE3       ",  0xeb},
+{"AUDIO_RESV_ADDR_0xec      ",  0xec},
+{"AUDIO_RESV_ADDR_0xed      ",  0xed},
+{"AUDIO_RESV_ADDR_0xee      ",  0xee},
+{"AUDIO_RESV_ADDR_0xef      ",  0xef},
+{"AUDIO_TDMIN_LB_CTRL       ",  0xf0},
+{"AUDIO_TDMIN_LB_SWAP       ",  0xf1},
+{"AUDIO_TDMIN_LB_MASK0      ",  0xf2},
+{"AUDIO_TDMIN_LB_MASK1      ",  0xf3},
+{"AUDIO_TDMIN_LB_MASK2      ",  0xf4},
+{"AUDIO_TDMIN_LB_MASK3      ",  0xf5},
+{"AUDIO_TDMIN_LB_STAT       ",  0xf6},
+{"AUDIO_TDMIN_LB_MUTE_VAL   ",  0xf7},
+{"AUDIO_TDMIN_LB_MUTE0      ",  0xf8},
+{"AUDIO_TDMIN_LB_MUTE1      ",  0xf9},
+{"AUDIO_TDMIN_LB_MUTE2      ",  0xfa},
+{"AUDIO_TDMIN_LB_MUTE3      ",  0xfb},
+{"AUDIO_RESV_ADDR_0xfc      ",  0xfc},
+{"AUDIO_RESV_ADDR_0xfd      ",  0xfd},
+{"AUDIO_RESV_ADDR_0xfe      ",  0xfe},
+{"AUDIO_RESV_ADDR_0xff      ",  0xff},
+{"AUDIO_SPDIFIN_CTRL0       ", 0x100},
+{"AUDIO_SPDIFIN_CTRL1       ", 0x101},
+{"AUDIO_SPDIFIN_CTRL2       ", 0x102},
+{"AUDIO_SPDIFIN_CTRL3       ", 0x103},
+{"AUDIO_SPDIFIN_CTRL4       ", 0x104},
+{"AUDIO_SPDIFIN_CTRL5       ", 0x105},
+{"AUDIO_SPDIFIN_CTRL6       ", 0x106},
+{"AUDIO_SPDIFIN_STAT0       ", 0x107},
+{"AUDIO_SPDIFIN_STAT1       ", 0x108},
+{"AUDIO_SPDIFIN_STAT2       ", 0x109},
+{"AUDIO_SPDIFIN_MUTE_VAL    ", 0x10a},
+{"AUDIO_RESV_ADDR_0x10b     ", 0x10b},
+{"AUDIO_RESV_ADDR_0x10c     ", 0x10c},
+{"AUDIO_RESV_ADDR_0x10d     ", 0x10d},
+{"AUDIO_RESV_ADDR_0x10e     ", 0x10e},
+{"AUDIO_RESV_ADDR_0x10f     ", 0x10f},
+{"AUDIO_RESAMPLEA_CTRL0     ", 0x110},
+{"AUDIO_RESAMPLEA_CTRL1     ", 0x111},
+{"AUDIO_RESAMPLEA_CTRL2     ", 0x112},
+{"AUDIO_RESAMPLEA_CTRL3     ", 0x113},
+{"AUDIO_RESAMPLEA_COEF0     ", 0x114},
+{"AUDIO_RESAMPLEA_COEF1     ", 0x115},
+{"AUDIO_RESAMPLEA_COEF2     ", 0x116},
+{"AUDIO_RESAMPLEA_COEF3     ", 0x117},
+{"AUDIO_RESAMPLEA_COEF4     ", 0x118},
+{"AUDIO_RESAMPLEA_STATUS1   ", 0x119},
+{"AUDIO_RESV_ADDR_0x11a     ", 0x11a},
+{"AUDIO_RESV_ADDR_0x11b     ", 0x11b},
+{"AUDIO_RESV_ADDR_0x11c     ", 0x11c},
+{"AUDIO_RESV_ADDR_0x11d     ", 0x11d},
+{"AUDIO_RESV_ADDR_0x11e     ", 0x11e},
+{"AUDIO_RESV_ADDR_0x11f     ", 0x11f},
+{"AUDIO_SPDIFOUT_STAT       ", 0x120},
+{"AUDIO_SPDIFOUT_GAIN0      ", 0x121},
+{"AUDIO_SPDIFOUT_GAIN1      ", 0x122},
+{"AUDIO_SPDIFOUT_CTRL0      ", 0x123},
+{"AUDIO_SPDIFOUT_CTRL1      ", 0x124},
+{"AUDIO_SPDIFOUT_PREAMB     ", 0x125},
+{"AUDIO_SPDIFOUT_SWAP       ", 0x126},
+{"AUDIO_SPDIFOUT_CHSTS0     ", 0x127},
+{"AUDIO_SPDIFOUT_CHSTS1     ", 0x128},
+{"AUDIO_SPDIFOUT_CHSTS2     ", 0x129},
+{"AUDIO_SPDIFOUT_CHSTS3     ", 0x12a},
+{"AUDIO_SPDIFOUT_CHSTS4     ", 0x12b},
+{"AUDIO_SPDIFOUT_CHSTS5     ", 0x12c},
+{"AUDIO_SPDIFOUT_CHSTS6     ", 0x12d},
+{"AUDIO_SPDIFOUT_CHSTS7     ", 0x12e},
+{"AUDIO_SPDIFOUT_CHSTS8     ", 0x12f},
+{"AUDIO_SPDIFOUT_CHSTS9     ", 0x130},
+{"AUDIO_SPDIFOUT_CHSTSA     ", 0x131},
+{"AUDIO_SPDIFOUT_CHSTSB     ", 0x132},
+{"AUDIO_SPDIFOUT_MUTE_VAL   ", 0x133},
+{"AUDIO_RESV_ADDR_0x134     ", 0x134},
+{"AUDIO_RESV_ADDR_0x135     ", 0x135},
+{"AUDIO_RESV_ADDR_0x136     ", 0x136},
+{"AUDIO_RESV_ADDR_0x137     ", 0x137},
+{"AUDIO_RESV_ADDR_0x138     ", 0x138},
+{"AUDIO_RESV_ADDR_0x139     ", 0x139},
+{"AUDIO_RESV_ADDR_0x13a     ", 0x13a},
+{"AUDIO_RESV_ADDR_0x13b     ", 0x13b},
+{"AUDIO_RESV_ADDR_0x13c     ", 0x13c},
+{"AUDIO_RESV_ADDR_0x13d     ", 0x13d},
+{"AUDIO_RESV_ADDR_0x13e     ", 0x13e},
+{"AUDIO_RESV_ADDR_0x13f     ", 0x13f},
+{"AUDIO_TDMOUT_A_CTRL0      ", 0x140},
+{"AUDIO_TDMOUT_A_CTRL1      ", 0x141},
+{"AUDIO_TDMOUT_A_SWAP       ", 0x142},
+{"AUDIO_TDMOUT_A_MASK0      ", 0x143},
+{"AUDIO_TDMOUT_A_MASK1      ", 0x144},
+{"AUDIO_TDMOUT_A_MASK2      ", 0x145},
+{"AUDIO_TDMOUT_A_MASK3      ", 0x146},
+{"AUDIO_TDMOUT_A_STAT       ", 0x147},
+{"AUDIO_TDMOUT_A_GAIN0      ", 0x148},
+{"AUDIO_TDMOUT_A_GAIN1      ", 0x149},
+{"AUDIO_TDMOUT_A_MUTE_VAL   ", 0x14a},
+{"AUDIO_TDMOUT_A_MUTE0      ", 0x14b},
+{"AUDIO_TDMOUT_A_MUTE1      ", 0x14c},
+{"AUDIO_TDMOUT_A_MUTE2      ", 0x14d},
+{"AUDIO_TDMOUT_A_MUTE3      ", 0x14e},
+{"AUDIO_TDMOUT_A_MASK_VAL   ", 0x14f},
+{"AUDIO_TDMOUT_B_CTRL0      ", 0x150},
+{"AUDIO_TDMOUT_B_CTRL1      ", 0x151},
+{"AUDIO_TDMOUT_B_SWAP       ", 0x152},
+{"AUDIO_TDMOUT_B_MASK0      ", 0x153},
+{"AUDIO_TDMOUT_B_MASK1      ", 0x154},
+{"AUDIO_TDMOUT_B_MASK2      ", 0x155},
+{"AUDIO_TDMOUT_B_MASK3      ", 0x156},
+{"AUDIO_TDMOUT_B_STAT       ", 0x157},
+{"AUDIO_TDMOUT_B_GAIN0      ", 0x158},
+{"AUDIO_TDMOUT_B_GAIN1      ", 0x159},
+{"AUDIO_TDMOUT_B_MUTE_VAL   ", 0x15a},
+{"AUDIO_TDMOUT_B_MUTE0      ", 0x15b},
+{"AUDIO_TDMOUT_B_MUTE1      ", 0x15c},
+{"AUDIO_TDMOUT_B_MUTE2      ", 0x15d},
+{"AUDIO_TDMOUT_B_MUTE3      ", 0x15e},
+{"AUDIO_TDMOUT_B_MASK_VAL   ", 0x15f},
+{"AUDIO_TDMOUT_C_CTRL0      ", 0x160},
+{"AUDIO_TDMOUT_C_CTRL1      ", 0x161},
+{"AUDIO_TDMOUT_C_SWAP       ", 0x162},
+{"AUDIO_TDMOUT_C_MASK0      ", 0x163},
+{"AUDIO_TDMOUT_C_MASK1      ", 0x164},
+{"AUDIO_TDMOUT_C_MASK2      ", 0x165},
+{"AUDIO_TDMOUT_C_MASK3      ", 0x166},
+{"AUDIO_TDMOUT_C_STAT       ", 0x167},
+{"AUDIO_TDMOUT_C_GAIN0      ", 0x168},
+{"AUDIO_TDMOUT_C_GAIN1      ", 0x169},
+{"AUDIO_TDMOUT_C_MUTE_VAL   ", 0x16a},
+{"AUDIO_TDMOUT_C_MUTE0      ", 0x16b},
+{"AUDIO_TDMOUT_C_MUTE1      ", 0x16c},
+{"AUDIO_TDMOUT_C_MUTE2      ", 0x16d},
+{"AUDIO_TDMOUT_C_MUTE3      ", 0x16e},
+{"AUDIO_TDMOUT_C_MASK_VAL   ", 0x16f},
+{"AUDIO_RESV_ADDR_0x170     ", 0x170},
+{"AUDIO_RESV_ADDR_0x171     ", 0x171},
+{"AUDIO_RESV_ADDR_0x172     ", 0x172},
+{"AUDIO_RESV_ADDR_0x173     ", 0x173},
+{"AUDIO_RESV_ADDR_0x174     ", 0x174},
+{"AUDIO_RESV_ADDR_0x175     ", 0x175},
+{"AUDIO_RESV_ADDR_0x176     ", 0x176},
+{"AUDIO_RESV_ADDR_0x177     ", 0x177},
+{"AUDIO_RESV_ADDR_0x178     ", 0x178},
+{"AUDIO_RESV_ADDR_0x179     ", 0x179},
+{"AUDIO_RESV_ADDR_0x17a     ", 0x17a},
+{"AUDIO_RESV_ADDR_0x17b     ", 0x17b},
+{"AUDIO_RESV_ADDR_0x17c     ", 0x17c},
+{"AUDIO_RESV_ADDR_0x17d     ", 0x17d},
+{"AUDIO_RESV_ADDR_0x17e     ", 0x17e},
+{"AUDIO_RESV_ADDR_0x17f     ", 0x17f},
+{"AUDIO_RESV_ADDR_0x180     ", 0x180},
+{"AUDIO_RESV_ADDR_0x181     ", 0x181},
+{"AUDIO_RESV_ADDR_0x182     ", 0x182},
+{"AUDIO_RESV_ADDR_0x183     ", 0x183},
+{"AUDIO_RESV_ADDR_0x184     ", 0x184},
+{"AUDIO_RESV_ADDR_0x185     ", 0x185},
+{"AUDIO_RESV_ADDR_0x186     ", 0x186},
+{"AUDIO_RESV_ADDR_0x187     ", 0x187},
+{"AUDIO_RESV_ADDR_0x188     ", 0x188},
+{"AUDIO_RESV_ADDR_0x189     ", 0x189},
+{"AUDIO_RESV_ADDR_0x18a     ", 0x18a},
+{"AUDIO_RESV_ADDR_0x18b     ", 0x18b},
+{"AUDIO_RESV_ADDR_0x18c     ", 0x18c},
+{"AUDIO_RESV_ADDR_0x18d     ", 0x18d},
+{"AUDIO_RESV_ADDR_0x18e     ", 0x18e},
+{"AUDIO_RESV_ADDR_0x18f     ", 0x18f},
+{"AUDIO_SECURITY_CTRL0      ", 0x190},
+{"AUDIO_SECURITY_CTRL1      ", 0x191},
+{"AUDIO_RESV_ADDR_0x192     ", 0x192},
+{"AUDIO_RESV_ADDR_0x193     ", 0x193},
+{"AUDIO_RESV_ADDR_0x194     ", 0x194},
+{"AUDIO_RESV_ADDR_0x195     ", 0x195},
+{"AUDIO_RESV_ADDR_0x196     ", 0x196},
+{"AUDIO_RESV_ADDR_0x197     ", 0x197},
+{"AUDIO_RESV_ADDR_0x198     ", 0x198},
+{"AUDIO_RESV_ADDR_0x199     ", 0x199},
+{"AUDIO_RESV_ADDR_0x19a     ", 0x19a},
+{"AUDIO_RESV_ADDR_0x19b     ", 0x19b},
+{"AUDIO_RESV_ADDR_0x19c     ", 0x19c},
+{"AUDIO_RESV_ADDR_0x19d     ", 0x19d},
+{"AUDIO_RESV_ADDR_0x19e     ", 0x19e},
+{"AUDIO_RESV_ADDR_0x19f     ", 0x19f},
+{"AUDIO_SPDIFOUT_B_STAT     ", 0x1a0},
+{"AUDIO_SPDIFOUT_B_GAIN0    ", 0x1a1},
+{"AUDIO_SPDIFOUT_B_GAIN1    ", 0x1a2},
+{"AUDIO_SPDIFOUT_B_CTRL0    ", 0x1a3},
+{"AUDIO_SPDIFOUT_B_CTRL1    ", 0x1a4},
+{"AUDIO_SPDIFOUT_B_PREAMB   ", 0x1a5},
+{"AUDIO_SPDIFOUT_B_SWAP     ", 0x1a6},
+{"AUDIO_SPDIFOUT_B_CHSTS0   ", 0x1a7},
+{"AUDIO_SPDIFOUT_B_CHSTS1   ", 0x1a8},
+{"AUDIO_SPDIFOUT_B_CHSTS2   ", 0x1a9},
+{"AUDIO_SPDIFOUT_B_CHSTS3   ", 0x1aa},
+{"AUDIO_SPDIFOUT_B_CHSTS4   ", 0x1ab},
+{"AUDIO_SPDIFOUT_B_CHSTS5   ", 0x1ac},
+{"AUDIO_SPDIFOUT_B_CHSTS6   ", 0x1ad},
+{"AUDIO_SPDIFOUT_B_CHSTS7   ", 0x1ae},
+{"AUDIO_SPDIFOUT_B_CHSTS8   ", 0x1af},
+{"AUDIO_SPDIFOUT_B_CHSTS9   ", 0x1b0},
+{"AUDIO_SPDIFOUT_B_CHSTSA   ", 0x1b1},
+{"AUDIO_SPDIFOUT_B_CHSTSB   ", 0x1b2},
+{"AUDIO_SPDIFOUT_B_MUTE_VAL ", 0x1b3},
+{"AUDIO_RESV_ADDR_0x1b4     ", 0x1b4},
+{"AUDIO_RESV_ADDR_0x1b5     ", 0x1b5},
+{"AUDIO_RESV_ADDR_0x1b6     ", 0x1b6},
+{"AUDIO_RESV_ADDR_0x1b7     ", 0x1b7},
+{"AUDIO_RESV_ADDR_0x1b8     ", 0x1b8},
+{"AUDIO_RESV_ADDR_0x1b9     ", 0x1b9},
+{"AUDIO_RESV_ADDR_0x1ba     ", 0x1ba},
+{"AUDIO_RESV_ADDR_0x1bb     ", 0x1bb},
+{"AUDIO_RESV_ADDR_0x1bc     ", 0x1bc},
+{"AUDIO_RESV_ADDR_0x1bd     ", 0x1bd},
+{"AUDIO_RESV_ADDR_0x1be     ", 0x1be},
+{"AUDIO_RESV_ADDR_0x1bf     ", 0x1bf},
+{"AUDIO_TORAM_CTRL0         ", 0x1c0},
+{"AUDIO_TORAM_CTRL1         ", 0x1c1},
+{"AUDIO_TORAM_START_ADDR    ", 0x1c2},
+{"AUDIO_TORAM_FINISH_ADDR   ", 0x1c3},
+{"AUDIO_TORAM_INT_ADDR      ", 0x1c4},
+{"AUDIO_TORAM_STATUS1       ", 0x1c5},
+{"AUDIO_TORAM_STATUS2       ", 0x1c6},
+{"AUDIO_TORAM_INIT_ADDR     ", 0x1c7},
+{"AUDIO_RESV_ADDR_0x1c8     ", 0x1c8},
+{"AUDIO_RESV_ADDR_0x1c9     ", 0x1c9},
+{"AUDIO_RESV_ADDR_0x1ca     ", 0x1ca},
+{"AUDIO_RESV_ADDR_0x1cb     ", 0x1cb},
+{"AUDIO_RESV_ADDR_0x1cc     ", 0x1cc},
+{"AUDIO_RESV_ADDR_0x1cd     ", 0x1cd},
+{"AUDIO_RESV_ADDR_0x1ce     ", 0x1ce},
+{"AUDIO_RESV_ADDR_0x1cf     ", 0x1cf},
+{"AUDIO_TOACODEC_CTRL0      ", 0x1d0},
+{"AUDIO_TOHDMITX_CTRL0      ", 0x1d1},
+{"AUDIO_TOVAD_CTRL0         ", 0x1d2},
+{"AUDIO_FRATV_CTRL0         ", 0x1d3},
+{"AUDIO_RESV_ADDR_0x1d4     ", 0x1d4},
+{"AUDIO_RESV_ADDR_0x1d5     ", 0x1d5},
+{"AUDIO_RESV_ADDR_0x1d6     ", 0x1d6},
+{"AUDIO_RESV_ADDR_0x1d7     ", 0x1d7},
+{"AUDIO_RESV_ADDR_0x1d8     ", 0x1d8},
+{"AUDIO_RESV_ADDR_0x1d9     ", 0x1d9},
+{"AUDIO_RESV_ADDR_0x1da     ", 0x1da},
+{"AUDIO_RESV_ADDR_0x1db     ", 0x1db},
+{"AUDIO_RESV_ADDR_0x1dc     ", 0x1dc},
+{"AUDIO_RESV_ADDR_0x1dd     ", 0x1dd},
+{"AUDIO_RESV_ADDR_0x1de     ", 0x1de},
+{"AUDIO_RESV_ADDR_0x1df     ", 0x1df},
+{"AUDIO_RESAMPLEB_CTRL0     ", 0x1e0},
+{"AUDIO_RESAMPLEB_CTRL1     ", 0x1e1},
+{"AUDIO_RESAMPLEB_CTRL2     ", 0x1e2},
+{"AUDIO_RESAMPLEB_CTRL3     ", 0x1e3},
+{"AUDIO_RESAMPLEB_COEF0     ", 0x1e4},
+{"AUDIO_RESAMPLEB_COEF1     ", 0x1e5},
+{"AUDIO_RESAMPLEB_COEF2     ", 0x1e6},
+{"AUDIO_RESAMPLEB_COEF3     ", 0x1e7},
+{"AUDIO_RESAMPLEB_COEF4     ", 0x1e8},
+{"AUDIO_RESAMPLEB_STATUS1   ", 0x1e9},
+{"AUDIO_RESV_ADDR_0x1ea     ", 0x1ea},
+{"AUDIO_RESV_ADDR_0x1eb     ", 0x1eb},
+{"AUDIO_RESV_ADDR_0x1ec     ", 0x1ec},
+{"AUDIO_RESV_ADDR_0x1ed     ", 0x1ed},
+{"AUDIO_RESV_ADDR_0x1ee     ", 0x1ee},
+{"AUDIO_RESV_ADDR_0x1ef     ", 0x1ef},
+{"AUDIO_SPDIFIN_LB_CTRL0    ", 0x1f0},
+{"AUDIO_SPDIFIN_LB_CTRL1    ", 0x1f1},
+{"AUDIO_RESV_ADDR_0x1f2     ", 0x1f2},
+{"AUDIO_RESV_ADDR_0x1f3     ", 0x1f3},
+{"AUDIO_RESV_ADDR_0x1f4     ", 0x1f4},
+{"AUDIO_RESV_ADDR_0x1f5     ", 0x1f5},
+{"AUDIO_SPDIFIN_LB_CTRL6    ", 0x1f6},
+{"AUDIO_SPDIFIN_LB_STAT0    ", 0x1f7},
+{"AUDIO_SPDIFIN_LB_STAT1    ", 0x1f8},
+{"AUDIO_RESV_ADDR_0x1f9     ", 0x1f9},
+{"AUDIO_SPDIFIN_LB_MUTE_VAL ", 0x1fa},
+{"AUDIO_RESV_ADDR_0x1fb     ", 0x1fb},
+{"AUDIO_RESV_ADDR_0x1fc     ", 0x1fc},
+{"AUDIO_RESV_ADDR_0x1fd     ", 0x1fd},
+{"AUDIO_RESV_ADDR_0x1fe     ", 0x1fe},
+{"AUDIO_RESV_ADDR_0x1ff     ", 0x1ff},
+{"AUDIO_FRHDMIRX_CTRL0      ", 0x200},
+{"AUDIO_FRHDMIRX_CTRL1      ", 0x201},
+{"AUDIO_FRHDMIRX_CTRL2      ", 0x202},
+{"AUDIO_FRHDMIRX_CTRL3      ", 0x203},
+{"AUDIO_FRHDMIRX_CTRL4      ", 0x204},
+{"AUDIO_FRHDMIRX_CTRL5      ", 0x205},
+{"AUDIO_RESV_ADDR_0x206     ", 0x206},
+{"AUDIO_RESV_ADDR_0x207     ", 0x207},
+{"AUDIO_RESV_ADDR_0x208     ", 0x208},
+{"AUDIO_RESV_ADDR_0x209     ", 0x209},
+{"AUDIO_FRHDMIRX_STAT0      ", 0x20a},
+{"AUDIO_FRHDMIRX_STAT1      ", 0x20b},
+{"AUDIO_RESV_ADDR_0x20c     ", 0x20c},
+{"AUDIO_RESV_ADDR_0x20d     ", 0x20d},
+{"AUDIO_RESV_ADDR_0x20e     ", 0x20e},
+{"AUDIO_RESV_ADDR_0x20f     ", 0x20f},
+{"AUDIO_TODDR_D_CTRL0       ", 0x210},
+{"AUDIO_TODDR_D_CTRL1       ", 0x211},
+{"AUDIO_TODDR_D_START_ADDR  ", 0x212},
+{"AUDIO_TODDR_D_FINISH_ADDR ", 0x213},
+{"AUDIO_TODDR_D_INT_ADDR    ", 0x214},
+{"AUDIO_TODDR_D_STATUS1     ", 0x215},
+{"AUDIO_TODDR_D_STATUS2     ", 0x216},
+{"AUDIO_TODDR_D_START_ADDRB ", 0x217},
+{"AUDIO_TODDR_D_FINISH_ADDRB", 0x218},
+{"AUDIO_TODDR_D_INIT_ADDR   ", 0x219},
+{"AUDIO_TODDR_D_CTRL2       ", 0x21a},
+{"AUDIO_RESV_ADDR_0x21b     ", 0x21b},
+{"AUDIO_RESV_ADDR_0x21c     ", 0x21c},
+{"AUDIO_RESV_ADDR_0x21d     ", 0x21d},
+{"AUDIO_RESV_ADDR_0x21e     ", 0x21e},
+{"AUDIO_RESV_ADDR_0x21f     ", 0x21f},
+{"AUDIO_FRDDR_D_CTRL0       ", 0x220},
+{"AUDIO_FRDDR_D_CTRL1       ", 0x221},
+{"AUDIO_FRDDR_D_START_ADDR  ", 0x222},
+{"AUDIO_FRDDR_D_FINISH_ADDR ", 0x223},
+{"AUDIO_FRDDR_D_INT_ADDR    ", 0x224},
+{"AUDIO_FRDDR_D_STATUS1     ", 0x225},
+{"AUDIO_FRDDR_D_STATUS2     ", 0x226},
+{"AUDIO_FRDDR_D_START_ADDRB ", 0x227},
+{"AUDIO_FRDDR_D_FINISH_ADDRB", 0x228},
+{"AUDIO_FRDDR_D_INIT_ADDR   ", 0x229},
+{"AUDIO_FRDDR_D_CTRL2       ", 0x22a},
+{"AUDIO_RESV_ADDR_0x22b     ", 0x22b},
+{"AUDIO_RESV_ADDR_0x22c     ", 0x22c},
+{"AUDIO_RESV_ADDR_0x22d     ", 0x22d},
+{"AUDIO_RESV_ADDR_0x22e     ", 0x22e},
+{"AUDIO_RESV_ADDR_0x22f     ", 0x22f},
+{"AUDIO_LB_B_CTRL0          ", 0x230},
+{"AUDIO_LB_B_CTRL1          ", 0x231},
+{"AUDIO_LB_B_CTRL2          ", 0x232},
+{"AUDIO_LB_B_CTRL3          ", 0x233},
+{"AUDIO_LB_B_DAT_CH_ID0     ", 0x234},
+{"AUDIO_LB_B_DAT_CH_ID1     ", 0x235},
+{"AUDIO_LB_B_DAT_CH_ID2     ", 0x236},
+{"AUDIO_LB_B_DAT_CH_ID3     ", 0x237},
+{"AUDIO_LB_B_LB_CH_ID0      ", 0x238},
+{"AUDIO_LB_B_LB_CH_ID1      ", 0x239},
+{"AUDIO_LB_B_LB_CH_ID2      ", 0x23a},
+{"AUDIO_LB_B_LB_CH_ID3      ", 0x23b},
+{"AUDIO_LB_B_STS            ", 0x23c},
+};
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/axg,clocks.c b/evl/sound/evl-amlogic/axg,clocks.c
--- a/drivers/evl/sound/evl-amlogic/axg,clocks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/axg,clocks.c	2021-12-23 13:31:07.926159463 +0300
@@ -0,0 +1,237 @@
+/*
+ * sound/soc/amlogic/auge/audio_clocks.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "axg_clocks: " fmt
+
+#include "dt-bindings/amlogic,axg-audio-clk.h"
+
+#include "audio_clks.h"
+#include "regs.h"
+
+static spinlock_t aclk_lock;
+
+static const char *const mclk_parent_names[] = {"mpll0", "mpll1",
+	"mpll2", "mpll3", "hifi_pll", "fclk_div3", "fclk_div4", "gp0_pll"};
+
+static const char *const audioclk_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c", "mclk_d", "mclk_e",
+	"mclk_f", "i_slv_sclk_a", "i_slv_sclk_b", "i_slv_sclk_c",
+	"i_slv_sclk_d", "i_slv_sclk_e", "i_slv_sclk_f", "i_slv_sclk_g",
+	"i_slv_sclk_h", "i_slv_sclk_i", "i_slv_sclk_j"};
+
+CLOCK_GATE(audio_ddr_arb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 0);
+CLOCK_GATE(audio_pdm, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 1);
+CLOCK_GATE(audio_tdmina, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 2);
+CLOCK_GATE(audio_tdminb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 3);
+CLOCK_GATE(audio_tdminc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 4);
+CLOCK_GATE(audio_tdminlb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 5);
+CLOCK_GATE(audio_tdmouta, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 6);
+CLOCK_GATE(audio_tdmoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 7);
+CLOCK_GATE(audio_tdmoutc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 8);
+CLOCK_GATE(audio_frddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 9);
+CLOCK_GATE(audio_frddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 10);
+CLOCK_GATE(audio_frddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 11);
+CLOCK_GATE(audio_toddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 12);
+CLOCK_GATE(audio_toddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 13);
+CLOCK_GATE(audio_toddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 14);
+CLOCK_GATE(audio_loopback, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 15);
+CLOCK_GATE(audio_spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 16);
+CLOCK_GATE(audio_spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 17);
+CLOCK_GATE(audio_resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 18);
+CLOCK_GATE(audio_power_detect, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 19);
+
+static struct clk_gate *axg_audio_clk_gates[] = {
+	&audio_ddr_arb,
+	&audio_pdm,
+	&audio_tdmina,
+	&audio_tdminb,
+	&audio_tdminc,
+	&audio_tdminlb,
+	&audio_tdmouta,
+	&audio_tdmoutb,
+	&audio_tdmoutc,
+	&audio_frddra,
+	&audio_frddrb,
+	&audio_frddrc,
+	&audio_toddra,
+	&audio_toddrb,
+	&audio_toddrc,
+	&audio_loopback,
+	&audio_spdifin,
+	&audio_spdifout,
+	&audio_resample,
+	&audio_power_detect,
+};
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw *axg_audio_clk_hws[] = {
+	[CLKID_AUDIO_DDR_ARB] = &audio_ddr_arb.hw,
+	[CLKID_AUDIO_PDM] = &audio_pdm.hw,
+	[CLKID_AUDIO_TDMINA] = &audio_tdmina.hw,
+	[CLKID_AUDIO_TDMINB] = &audio_tdminb.hw,
+	[CLKID_AUDIO_TDMINC] = &audio_tdminc.hw,
+	[CLKID_AUDIO_TDMINLB] = &audio_tdminlb.hw,
+	[CLKID_AUDIO_TDMOUTA] = &audio_tdmouta.hw,
+	[CLKID_AUDIO_TDMOUTB] = &audio_tdmoutb.hw,
+	[CLKID_AUDIO_TDMOUTC] = &audio_tdmoutc.hw,
+	[CLKID_AUDIO_FRDDRA] = &audio_frddra.hw,
+	[CLKID_AUDIO_FRDDRB] = &audio_frddrb.hw,
+	[CLKID_AUDIO_FRDDRC] = &audio_frddrc.hw,
+	[CLKID_AUDIO_TODDRA] = &audio_toddra.hw,
+	[CLKID_AUDIO_TODDRB] = &audio_toddrb.hw,
+	[CLKID_AUDIO_TODDRC] = &audio_toddrc.hw,
+	[CLKID_AUDIO_LOOPBACK] = &audio_loopback.hw,
+	[CLKID_AUDIO_SPDIFIN] = &audio_spdifin.hw,
+	[CLKID_AUDIO_SPDIFOUT] = &audio_spdifout.hw,
+	[CLKID_AUDIO_RESAMPLE] = &audio_resample.hw,
+	[CLKID_AUDIO_POWER_DETECT] = &audio_power_detect.hw,
+};
+
+static int axg_clk_gates_init(struct clk **clks, void __iomem *iobase)
+{
+	int clkid;
+
+	if (ARRAY_SIZE(axg_audio_clk_gates) != MCLK_BASE) {
+		pr_err("check clk gates number\n");
+		return -EINVAL;
+	}
+
+	for (clkid = 0; clkid < MCLK_BASE; clkid++) {
+		axg_audio_clk_gates[clkid]->reg = iobase;
+		clks[clkid] = clk_register(NULL, axg_audio_clk_hws[clkid]);
+		WARN_ON(IS_ERR_OR_NULL(clks[clkid]));
+	}
+
+	return 0;
+}
+
+/* mclk_a */
+CLOCK_COM_MUX(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 31);
+/* mclk_b */
+CLOCK_COM_MUX(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 31);
+/* mclk_c */
+CLOCK_COM_MUX(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 31);
+/* mclk_d */
+CLOCK_COM_MUX(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 31);
+/* mclk_e */
+CLOCK_COM_MUX(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 31);
+/* mclk_f */
+CLOCK_COM_MUX(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 31);
+/* spdifin */
+CLOCK_COM_MUX(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0, 8);
+CLOCK_COM_GATE(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 31);
+/* spdifout */
+CLOCK_COM_MUX(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 31);
+/* pdmin0 */
+CLOCK_COM_MUX(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0, 16);
+CLOCK_COM_GATE(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 31);
+/* pdmin1 */
+CLOCK_COM_MUX(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0x7, 24);
+CLOCK_COM_DIV(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0, 16);
+CLOCK_COM_GATE(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 31);
+/* audio locker_out */
+CLOCK_COM_MUX(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 24);
+CLOCK_COM_DIV(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 16, 8);
+CLOCK_COM_GATE(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 31);
+/* audio locker_in */
+CLOCK_COM_MUX(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 8);
+CLOCK_COM_DIV(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0, 8);
+CLOCK_COM_GATE(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 15);
+/* resample*/
+CLOCK_COM_MUX(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0xf, 24);
+/* div is fake */
+CLOCK_COM_DIV(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0, 0);
+CLOCK_COM_GATE(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 31);
+
+static int axg_clks_init(struct clk **clks, void __iomem *iobase)
+{
+	IOMAP_COM_CLK(mclk_a, iobase);
+	clks[CLKID_AUDIO_MCLK_A] = REGISTER_CLK_COM(mclk_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_A]));
+
+	IOMAP_COM_CLK(mclk_b, iobase);
+	clks[CLKID_AUDIO_MCLK_B] = REGISTER_CLK_COM(mclk_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_B]));
+
+	IOMAP_COM_CLK(mclk_c, iobase);
+	clks[CLKID_AUDIO_MCLK_C] = REGISTER_CLK_COM(mclk_c);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_C]));
+
+	IOMAP_COM_CLK(mclk_d, iobase);
+	clks[CLKID_AUDIO_MCLK_D] = REGISTER_CLK_COM(mclk_d);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_D]));
+
+	IOMAP_COM_CLK(mclk_e, iobase);
+	clks[CLKID_AUDIO_MCLK_E] = REGISTER_CLK_COM(mclk_e);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_E]));
+
+	IOMAP_COM_CLK(mclk_f, iobase);
+	clks[CLKID_AUDIO_MCLK_F] = REGISTER_CLK_COM(mclk_f);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_F]));
+
+	IOMAP_COM_CLK(spdifin, iobase);
+	clks[CLKID_AUDIO_SPDIFIN_CTRL] = REGISTER_CLK_COM(spdifin);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN_CTRL]));
+
+	IOMAP_COM_CLK(spdifout, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_CTRL] = REGISTER_CLK_COM(spdifout);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_CTRL]));
+
+	IOMAP_COM_CLK(pdmin0, iobase);
+	clks[CLKID_AUDIO_PDMIN0] = REGISTER_CLK_COM(pdmin0);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN0]));
+
+	IOMAP_COM_CLK(pdmin1, iobase);
+	clks[CLKID_AUDIO_PDMIN1] = REGISTER_CLK_COM(pdmin1);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN1]));
+
+	IOMAP_COM_CLK(locker_out, iobase);
+	clks[CLKID_AUDIO_LOCKER_OUT] = REGISTER_AUDIOCLK_COM(locker_out);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_OUT]));
+
+	IOMAP_COM_CLK(locker_in, iobase);
+	clks[CLKID_AUDIO_LOCKER_IN] = REGISTER_AUDIOCLK_COM(locker_in);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_IN]));
+
+	IOMAP_COM_CLK(resample, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_CTRL] = REGISTER_AUDIOCLK_COM(resample);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_CTRL]));
+
+	return 0;
+}
+
+struct audio_clk_init axg_audio_clks_init = {
+	.clk_num   = NUM_AUDIO_CLKS,
+	.clk_gates = axg_clk_gates_init,
+	.clks      = axg_clks_init,
+};
diff -ruN a/drivers/evl/sound/evl-amlogic/bcm2835-i2s-elk.c b/evl/sound/evl-amlogic/bcm2835-i2s-elk.c
--- a/drivers/evl/sound/evl-amlogic/bcm2835-i2s-elk.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/bcm2835-i2s-elk.c	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,619 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @brief I2S module of the RTDM audio driver.
+ *	  A lot of stuff is based on the mainline I2S module by Florian Meier
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/of_address.h>
+#include <linux/delay.h>
+#include <rtdm/driver.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <linux/gpio.h>
+#include <linux/clk.h>
+#include <linux/dma/bcm2835-dma.h>
+
+#include "pcm3168a-elk.h"
+#include "rpi-audio-rtdm.h"
+#include "bcm2835-i2s-elk.h"
+#include "elk-pi-config.h"
+#include "hifi-berry-config.h"
+#include "hifi-berry-pro-config.h"
+
+#define BCM2835_PCM_WORD_LEN 	32
+#define BCM2835_PCM_SLOTS	2
+
+static struct audio_rtdm_dev *audio_dev_static;
+
+#ifdef BCM2835_I2S_CVGATES_SUPPORT
+static int cv_gate_out[NUM_OF_CVGATE_OUTS] = { CVGATE_OUTS_LIST };
+static int cv_gate_in[NUM_OF_CVGATE_INS] = { CVGATE_INS_LIST };
+#endif
+
+void bcm2835_i2s_clear_fifos(struct audio_rtdm_dev *audio_dev,
+				    bool tx, bool rx)
+{
+	uint32_t csreg, sync;
+	uint32_t i2s_active_state;
+	uint32_t off;
+	uint32_t clr;
+	int timeout = 1000;
+
+	off =  tx ? BCM2835_I2S_TXON : 0;
+	off |= rx ? BCM2835_I2S_RXON : 0;
+
+	clr =  tx ? BCM2835_I2S_TXCLR : 0;
+	clr |= rx ? BCM2835_I2S_RXCLR : 0;
+
+	/* Backup the current state */
+	rpi_reg_read(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, &csreg);
+	i2s_active_state = csreg & (BCM2835_I2S_RXON | BCM2835_I2S_TXON);
+
+	/* Stop I2S module */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, off, 0);
+
+	/*
+	 * Clear the FIFOs
+	 * Requires at least 2 PCM clock cycles to take effect
+	 */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, clr, clr);
+
+	rpi_reg_read(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, &sync);
+	sync &= BCM2835_I2S_SYNC;
+
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+			BCM2835_I2S_SYNC, ~sync);
+
+	/* Wait for the SYNC flag changing it's state */
+	while (--timeout) {
+		rpi_reg_read(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, &csreg);
+		if ((csreg & BCM2835_I2S_SYNC) != sync)
+			break;
+	}
+
+	/* Restore I2S state */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+			BCM2835_I2S_RXON | BCM2835_I2S_TXON, i2s_active_state);
+}
+
+static void bcm2835_i2s_synch_frame(struct audio_rtdm_dev *audio_dev,
+					uint32_t mask)
+{
+	uint32_t val, discarded = 0;
+	int32_t tmp[9], samples[2] = {0xff, 0xff};
+
+	rpi_reg_update_bits(audio_dev->i2s_base_addr,
+		BCM2835_I2S_CS_A_REG, mask, mask);
+	/* Make sure channels are aligned in right order.
+	Last two channels from pcm3168 are always zero &
+	the probability of getting two successive zero values is nearly impossible */
+	while (samples[0] != 0 || samples[1] != 0) {
+		rpi_reg_read(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+					&val);
+		if (val & BCM2835_I2S_RXD) {
+			rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_FIFO_A_REG,
+					0x00);
+			samples[1] = samples[0];
+			rpi_reg_read(audio_dev->i2s_base_addr, BCM2835_I2S_FIFO_A_REG,
+					&samples[0]);
+					tmp[discarded] = samples[0];
+					discarded++;
+		}
+	}
+	printk(KERN_INFO "bcm2835-i2s: %d samples discarded\n",
+							discarded);
+}
+
+void bcm2835_i2s_start_stop(struct audio_rtdm_dev *audio_dev, int cmd)
+{
+	uint32_t mask;
+	wmb();
+	mask = BCM2835_I2S_RXON | BCM2835_I2S_TXON;
+
+	if (cmd == BCM2835_I2S_START_CMD) {
+		if (!strcmp(audio_dev->audio_hat, "elk-pi")) {
+			bcm2835_i2s_synch_frame(audio_dev, mask);
+		} else {
+			rpi_reg_update_bits(audio_dev->i2s_base_addr,
+				BCM2835_I2S_CS_A_REG, mask, mask);
+		}
+	} else {
+		rpi_reg_update_bits(audio_dev->i2s_base_addr,
+			BCM2835_I2S_CS_A_REG, mask, 0);
+	}
+}
+EXPORT_SYMBOL_GPL(bcm2835_i2s_start_stop);
+
+static void bcm2835_i2s_dma_callback(void *data)
+{
+	int i;
+	uint32_t val;
+	struct audio_rtdm_dev *audio_dev = data;
+
+	audio_dev->kinterrupts++;
+	audio_dev->buffer_idx = ~(audio_dev->buffer_idx) & 0x1;
+
+	rtdm_event_signal(&audio_dev->irq_event);
+#ifdef BCM2835_I2S_CVGATES_SUPPORT
+	if (audio_dev->cv_gate_enabled) {
+		for (i = 0; i < NUM_OF_CVGATE_OUTS; i++) {
+			val = (unsigned long) *audio_dev->buffer->cv_gate_out &
+			BIT(i);
+			gpio_set_value(cv_gate_out[i], val);
+		}
+		val = 0;
+		for (i = 0; i < NUM_OF_CVGATE_INS; i++) {
+		val |= gpio_get_value(cv_gate_in[i]) << i;
+		}
+		*audio_dev->buffer->cv_gate_in = val;
+	}
+#endif
+}
+
+static struct dma_async_tx_descriptor *
+bcm2835_i2s_dma_prepare_cyclic(struct audio_rtdm_dev *audio_dev,
+			enum dma_transfer_direction dir)
+{
+	struct dma_slave_config cfg;
+	struct dma_chan *chan;
+	int  flags;
+	struct dma_async_tx_descriptor *desc;
+	struct audio_rtdm_buffers *audio_buffers = audio_dev->buffer;
+
+	memset(&cfg, 0, sizeof(cfg));
+	cfg.direction = dir;
+
+	if (dir == DMA_MEM_TO_DEV) {
+		cfg.dst_addr = audio_dev->fifo_dma_addr;
+		cfg.dst_addr_width = audio_dev->addr_width;
+		cfg.dst_maxburst = audio_dev->dma_burst_size;
+		chan = audio_dev->dma_tx;
+		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
+
+		if (dmaengine_slave_config(chan, &cfg)) {
+			dev_warn(audio_dev->dev, "DMA slave config failed\n");
+			return NULL;
+		}
+		desc = dmaengine_prep_dma_cyclic(chan,
+		audio_buffers->tx_phys_addr, audio_buffers->buffer_len,
+		audio_buffers->period_len, dir, flags);
+	} else if (dir == DMA_DEV_TO_MEM) {
+		cfg.src_addr = audio_dev->fifo_dma_addr;
+		cfg.src_addr_width = audio_dev->addr_width;
+		cfg.src_maxburst = audio_dev->dma_burst_size;
+		chan = audio_dev->dma_rx;
+		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
+
+		if (dmaengine_slave_config(chan, &cfg)) {
+			dev_warn(audio_dev->dev, "DMA slave config failed\n");
+			return NULL;
+		}
+		desc = dmaengine_prep_dma_cyclic(chan,
+		audio_buffers->rx_phys_addr, audio_buffers->buffer_len,
+		audio_buffers->period_len, dir, flags);
+	} else {
+		printk(KERN_ERR "bcm2835-i2s: unsupported dma direction\n");
+		return NULL;
+	}
+	return desc;
+}
+
+static int bcm2835_i2s_dma_prepare(struct audio_rtdm_dev *audio_dev)
+{
+	int err;
+	audio_dev->tx_desc = bcm2835_i2s_dma_prepare_cyclic(audio_dev, DMA_MEM_TO_DEV);
+	if (!audio_dev->tx_desc) {
+		dev_err(audio_dev->dev,
+			"failed to get DMA TX descriptor\n");
+		err = -EBUSY;
+		return err;
+	}
+
+	audio_dev->rx_desc = bcm2835_i2s_dma_prepare_cyclic(audio_dev, DMA_DEV_TO_MEM);
+	if (!audio_dev->rx_desc) {
+		dev_err(audio_dev->dev,
+			"failed to get DMA RX descriptor\n");
+		err = -EBUSY;
+		dmaengine_terminate_async(audio_dev->dma_tx);
+		return err;
+	}
+	audio_dev->rx_desc->callback = bcm2835_i2s_dma_callback;
+	audio_dev->rx_desc->callback_param = audio_dev;
+	return 0;
+}
+
+static void bcm2835_i2s_submit_dma(struct audio_rtdm_dev *audio_dev)
+{
+	dmaengine_submit(audio_dev->rx_desc);
+	dmaengine_submit(audio_dev->tx_desc);
+
+	dma_async_issue_pending(audio_dev->dma_rx);
+	dma_async_issue_pending(audio_dev->dma_tx);
+}
+
+static int bcm2835_i2s_dma_setup(struct audio_rtdm_dev *audio_dev)
+{
+	struct device *dev = (struct device *) audio_dev->dev;
+
+	audio_dev->dma_tx = dma_request_slave_channel(dev, "tx");
+	if (!audio_dev->dma_tx) {
+		return -ENODEV;
+	}
+	if (bcm2835_dma_alloc_rtdm_resources(audio_dev->dma_tx,
+		DMA_MEM_TO_DEV)) {
+		printk(KERN_INFO "Failed to allocate RTDM \
+		resources for dma tx\n");
+		return -1;
+	}
+
+	audio_dev->dma_rx = dma_request_slave_channel(dev, "rx");
+	if (!audio_dev->dma_rx) {
+		dma_release_channel(audio_dev->dma_tx);
+		audio_dev->dma_tx = NULL;
+		return -ENODEV;
+	}
+	if (bcm2835_dma_alloc_rtdm_resources(audio_dev->dma_rx,
+		DMA_DEV_TO_MEM)) {
+		printk(KERN_INFO "Failed to allocate RTDM \
+		resources for dma rx\n");
+		return -1;
+	}
+	printk(KERN_INFO "bcm2835-i2s: dma setup successful.\n");
+	return 0;
+}
+
+#ifdef BCM2835_I2S_CVGATES_SUPPORT
+static int bcm2835_init_cv_gates(void)
+{
+	int  i, ret;
+	for (i = 0; i < NUM_OF_CVGATE_OUTS; i++) {
+		ret = gpio_request(cv_gate_out[i], "cv_out_gate");
+		if (ret < 0) {
+			printk(KERN_ERR "bcm2835-i2s: failed to get cv out\n");
+			return ret;
+		}
+		ret = gpio_direction_output(cv_gate_out[i], 0);
+		if (ret < 0) {
+			printk(KERN_ERR "bcm2835-i2s: failed to set gpio dir\n");
+			return ret;
+		}
+	}
+	for (i = 0; i < NUM_OF_CVGATE_INS; i++) {
+		ret = gpio_request(cv_gate_in[i], "cv_in_gate");
+		if (ret < 0) {
+			printk(KERN_ERR "bcm2835-i2s: failed to get cv out\n");
+			return ret;
+		}
+		ret = gpio_direction_input(cv_gate_in[i]);
+		if (ret < 0) {
+			printk(KERN_ERR "bcm2835-i2s: failed to set gpio dir\n");
+			return ret;
+		}
+	}
+	return ret;
+}
+
+static void bcm2835_free_cv_gates(void)
+{
+	int i;
+	for (i = 0; i < NUM_OF_CVGATE_OUTS; i++)
+		gpio_free(cv_gate_out[i]);
+
+	for (i = 0; i < NUM_OF_CVGATE_INS; i++)
+		gpio_free(cv_gate_in[i]);
+}
+#endif
+
+static void bcm2835_i2s_configure(struct audio_rtdm_dev *audio_dev)
+{
+	unsigned int data_length, framesync_length;
+	unsigned int slots, slot_width;
+	int frame_length, bclk_rate;
+	unsigned int ch1_pos, ch2_pos;
+	unsigned int mode = 0, format = 0;
+	bool bit_clock_master = false;
+	bool frame_sync_master = false;
+	bool frame_start_falling_edge = true;
+
+	data_length = BCM2835_PCM_WORD_LEN;
+	slots = BCM2835_PCM_SLOTS;
+	slot_width = BCM2835_PCM_WORD_LEN;
+	frame_length = slots * slot_width;
+	format = BCM2835_I2S_CHEN | BCM2835_I2S_CHWEX;
+	format |= BCM2835_I2S_CHWID((data_length-8)&0xf);
+	framesync_length = frame_length / 2;
+	frame_start_falling_edge = false;
+	if (!strcmp(audio_dev->audio_hat, "hifi-berry")) {
+		bit_clock_master = true;
+		frame_sync_master = true;
+		bclk_rate = frame_length * HIFI_BERRY_SAMPLING_RATE;
+		if (clk_set_rate(audio_dev->clk, bclk_rate))
+			printk(KERN_ERR "bcm2835_i2s_configure: clk_set_rate failed\n");
+
+		audio_dev->clk_rate = bclk_rate;
+		mode = BCM2835_I2S_CLKI;
+		ch1_pos = 1;
+		ch2_pos = 33;
+		clk_prepare_enable(audio_dev->clk);
+	} else if (!strcmp(audio_dev->audio_hat, "hifi-berry-pro")) {
+		ch1_pos = 1;
+		ch2_pos = 33;
+	} else {
+		ch1_pos = 0;
+		ch2_pos = 32; /* calculated manually for now */
+	}
+	/* CH2 format is the same as for CH1 */
+	format = BCM2835_I2S_CH1(format) | BCM2835_I2S_CH2(format);
+
+	mode |= BCM2835_I2S_FLEN(frame_length - 1);
+	mode |= BCM2835_I2S_FSLEN(framesync_length);
+
+	if (!bit_clock_master)
+		mode |= BCM2835_I2S_CLKDIS | BCM2835_I2S_CLKM | BCM2835_I2S_CLKI;
+
+	if (!frame_sync_master)
+		mode |= BCM2835_I2S_FSM;
+
+	if (frame_start_falling_edge)
+		mode |= BCM2835_I2S_FSI;
+
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_MODE_A_REG, mode);
+
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_RXC_A_REG, format
+		| BCM2835_I2S_CH1_POS(ch1_pos)
+		| BCM2835_I2S_CH2_POS(ch2_pos));
+
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_TXC_A_REG, format
+		|BCM2835_I2S_CH1_POS(ch1_pos)
+		| BCM2835_I2S_CH2_POS(ch2_pos));
+
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_MODE_A_REG,
+			BCM2835_I2S_CLKDIS, 0);
+	/* Setup the DMA parameters */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+			BCM2835_I2S_RXTHR(1)
+			| BCM2835_I2S_TXTHR(1)
+			| BCM2835_I2S_DMAEN, 0xffffffff);
+
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_DREQ_A_REG,
+			  BCM2835_I2S_TX_PANIC(BCM2835_DMA_TX_PANIC_THR)
+			| BCM2835_I2S_RX_PANIC(BCM2835_DMA_RX_PANIC_THR)
+			| BCM2835_I2S_TX(BCM2835_DMA_THR_TX)
+			| BCM2835_I2S_RX(BCM2835_DMA_THR_RX), 0xffffffff);
+}
+
+static void bcm2835_i2s_enable(struct audio_rtdm_dev *audio_dev)
+{
+	/* Disable RAM STBY */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+			BCM2835_I2S_STBY, BCM2835_I2S_STBY);
+
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_INTEN_A_REG,
+			BCM2835_I2S_INT_TXERR | BCM2835_I2S_INT_RXERR,
+			BCM2835_I2S_INT_TXERR | BCM2835_I2S_INT_RXERR);
+
+	/* Enable PCM block */
+	rpi_reg_update_bits(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG,
+			BCM2835_I2S_EN, BCM2835_I2S_EN);
+}
+
+static void bcm2835_i2s_clear_regs(struct audio_rtdm_dev *audio_dev)
+{
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_CS_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_MODE_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_RXC_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_TXC_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_DREQ_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_INTEN_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_INTSTC_A_REG, 0);
+	rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_GRAY_REG, 0);
+}
+
+int bcm2835_i2s_init(char *audio_hat)
+{
+	dma_addr_t dummy_phys_addr;
+	struct audio_rtdm_dev *audio_dev = audio_dev_static;
+	struct audio_rtdm_buffers *audio_buffer = audio_dev->buffer;
+	audio_dev->audio_hat = audio_hat;
+
+	printk(KERN_INFO "Elk hat: %s\n", audio_dev->audio_hat);
+
+	audio_buffer->rx_buf = dma_alloc_coherent(audio_dev->dma_rx->device->dev,
+	RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE,
+	&dummy_phys_addr,
+	GFP_KERNEL);
+	if (!audio_buffer->rx_buf) {
+		printk(KERN_ERR "bcm2835-i2s: couldn't allocate dma mem\n");
+		return -ENOMEM;
+	}
+	audio_buffer->rx_phys_addr = dummy_phys_addr;
+
+	if (!strcmp(audio_dev->audio_hat, "elk-pi")) {
+		audio_dev->cv_gate_enabled = true;
+		bcm2835_init_cv_gates();
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm2835_i2s_init);
+
+int bcm2835_i2s_buffers_setup(int audio_buffer_size, int audio_channels)
+{
+	int ret, i;
+	struct audio_rtdm_dev *audio_dev = audio_dev_static;
+	struct audio_rtdm_buffers *audio_buffer = audio_dev->buffer;
+	dma_addr_t dummy_phys_addr = audio_buffer->rx_phys_addr;
+
+	audio_buffer->period_len = audio_buffer_size * audio_channels
+					 * sizeof(uint32_t);
+	audio_buffer->buffer_len = 2 * audio_buffer->period_len;
+	audio_buffer->tx_buf = audio_buffer->rx_buf +
+			audio_buffer->buffer_len;
+	audio_buffer->tx_phys_addr = dummy_phys_addr + audio_buffer->buffer_len;
+	audio_buffer->cv_gate_out = audio_buffer->rx_buf +
+			audio_buffer->buffer_len * 2;
+	audio_buffer->cv_gate_in = audio_buffer->rx_buf +
+			audio_buffer->buffer_len * 2 + sizeof(uint32_t);
+	*audio_buffer->cv_gate_out = 0x0f;
+
+	ret = bcm2835_i2s_dma_prepare(audio_dev);
+	if (ret) {
+		printk(KERN_ERR "bcm2835-i2s: dma_prepare failed\n");
+		return -EINVAL;
+	}
+
+	bcm2835_i2s_clear_regs(audio_dev);
+	bcm2835_i2s_configure(audio_dev);
+	bcm2835_i2s_enable(audio_dev);
+	bcm2835_i2s_clear_fifos(audio_dev, true, true);
+
+	for (i = 0; i < (BCM2835_DMA_THR_TX + audio_channels); i++)
+		rpi_reg_write(audio_dev->i2s_base_addr, BCM2835_I2S_FIFO_A_REG, 0);
+
+	bcm2835_i2s_submit_dma(audio_dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm2835_i2s_buffers_setup);
+
+struct audio_rtdm_dev *bcm2835_get_i2s_dev(void)
+{
+	return audio_dev_static;
+}
+EXPORT_SYMBOL_GPL(bcm2835_get_i2s_dev);
+
+int bcm2835_i2s_exit(void)
+{
+	int ret = 0;
+	struct audio_rtdm_dev *audio_dev = audio_dev_static;
+
+	ret = dmaengine_terminate_async(audio_dev->dma_tx);
+	if (ret < 0) {
+		printk(KERN_ERR "bcm2835-i2s: dmaengine_terminate_async \
+		 failed\n");
+		return ret;
+	}
+	ret = dmaengine_terminate_async(audio_dev->dma_rx);
+	if (ret < 0) {
+		printk(KERN_ERR "bcm2835-i2s: dmaengine_terminate_async \
+		 failed\n");
+		return ret;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bcm2835_i2s_exit);
+
+static int bcm2835_i2s_probe(struct platform_device *pdev)
+{
+	struct audio_rtdm_dev *audio_dev;
+	int ret = 0;
+	struct resource *mem_resource;
+	void __iomem *base;
+	const __be32 *addr;
+	dma_addr_t dma_base;
+	struct audio_rtdm_buffers *audio_buffer;
+
+	audio_dev = devm_kzalloc(&pdev->dev, sizeof(*audio_dev),
+			   GFP_KERNEL);
+	if (!audio_dev)
+		return -ENOMEM;
+
+	audio_dev->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(audio_dev->clk)) {
+		dev_err(&pdev->dev, "could not get clk: %ld\n",
+			PTR_ERR(audio_dev->clk));
+		return PTR_ERR(audio_dev->clk);
+	}
+
+	audio_dev_static = audio_dev;
+
+	mem_resource = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, mem_resource);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "devm_ioremap_resource failed.");
+		return PTR_ERR(base);
+	}
+	audio_dev->i2s_base_addr = base;
+
+	addr = of_get_address(pdev->dev.of_node, 0, NULL, NULL);
+	if (!addr) {
+		dev_err(&pdev->dev, "could not get DMA-register address\n");
+		return -EINVAL;
+	}
+
+	dma_base = be32_to_cpup(addr);
+	audio_dev->fifo_dma_addr = dma_base + BCM2835_I2S_FIFO_A_REG;
+	audio_dev->addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	audio_dev->dma_burst_size = 2;
+	audio_dev->dev = &pdev->dev;
+	rtdm_event_init(&audio_dev->irq_event, 0);
+
+	if (bcm2835_i2s_dma_setup(audio_dev))
+		return -ENODEV;
+
+	audio_buffer = kcalloc(1, sizeof(struct audio_rtdm_buffers),
+		GFP_KERNEL);
+
+	if (!audio_buffer) {
+		dev_err(&pdev->dev, "couldn't allocate audio_buffer\n");
+		return -ENOMEM;
+	}
+	audio_dev->buffer = audio_buffer;
+	return ret;
+}
+
+static int bcm2835_i2s_remove(struct platform_device *pdev)
+{
+	struct audio_rtdm_dev *audio_dev = audio_dev_static;
+	struct audio_rtdm_buffers *audio_buffers =
+					audio_dev_static->buffer;
+
+	if (bcm2835_dma_free_rtdm_resources(audio_dev->dma_tx,
+				DMA_MEM_TO_DEV)) {
+		printk(KERN_INFO "Failed to free rtdm dma resources\n");
+	}
+	if (bcm2835_dma_free_rtdm_resources(audio_dev->dma_rx,
+				DMA_DEV_TO_MEM)) {
+		printk(KERN_INFO "Failed to free rtdm dma resources\n");
+	}
+	dma_free_coherent(audio_dev->dma_rx->device->dev,
+				RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE,
+				audio_dev->buffer->rx_buf,
+				audio_dev->buffer->rx_phys_addr);
+	dma_release_channel(audio_dev->dma_tx);
+	dma_release_channel(audio_dev->dma_rx);
+	kfree(audio_buffers);
+
+#ifdef BCM2835_I2S_CVGATES_SUPPORT
+	if (audio_dev_static->cv_gate_enabled)
+		bcm2835_free_cv_gates();
+#endif
+	devm_iounmap(&pdev->dev, (void *)audio_dev_static->i2s_base_addr);
+	devm_kfree(&pdev->dev, (void *)audio_dev_static);
+	return 0;
+}
+
+static const struct of_device_id bcm2835_i2s_of_match[] = {
+	{ .compatible = "brcm,bcm2835-i2s", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, bcm2835_i2s_of_match);
+
+static struct platform_driver bcm2835_i2s_driver = {
+	.probe		= bcm2835_i2s_probe,
+	.remove		= bcm2835_i2s_remove,
+	.driver		= {
+		.name	= "bcm2835-i2s",
+		.of_match_table = bcm2835_i2s_of_match,
+	},
+};
+
+module_platform_driver(bcm2835_i2s_driver);
+MODULE_DESCRIPTION("BCM2835 I2S interface for ELK Pi");
+MODULE_AUTHOR("Nitin Kulkarni (nitin@elk.audio)");
+MODULE_LICENSE("GPL");
diff -ruN a/drivers/evl/sound/evl-amlogic/bcm2835-i2s-elk.h b/evl/sound/evl-amlogic/bcm2835-i2s-elk.h
--- a/drivers/evl/sound/evl-amlogic/bcm2835-i2s-elk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/bcm2835-i2s-elk.h	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#ifndef BCM2835_I2S_ELK_H
+#define BCM2835_I2S_ELK_H
+
+#include <linux/bitops.h>
+#include <asm/barrier.h>
+#include <linux/err.h>
+#include <linux/sizes.h>
+
+#define BCM2835_I2S_IRQ_NUM 85
+
+#define BCM2835_I2S_PERIPHERAL_BASE	0x20203000
+#define BCM2835_I2S_STOP_CMD 		0
+#define BCM2835_I2S_START_CMD 		1
+#define BCM2835_DMA_THR_TX		24
+#define BCM2835_DMA_THR_RX		8
+#define BCM2835_DMA_TX_PANIC_THR	8
+#define BCM2835_DMA_RX_PANIC_THR	40
+
+/* I2S registers */
+#define BCM2835_I2S_CS_A_REG		0x00
+#define BCM2835_I2S_FIFO_A_REG		0x04
+#define BCM2835_I2S_MODE_A_REG		0x08
+#define BCM2835_I2S_RXC_A_REG		0x0c
+#define BCM2835_I2S_TXC_A_REG		0x10
+#define BCM2835_I2S_DREQ_A_REG		0x14
+#define BCM2835_I2S_INTEN_A_REG		0x18
+#define BCM2835_I2S_INTSTC_A_REG	0x1c
+#define BCM2835_I2S_GRAY_REG		0x20
+
+/* I2S register settings */
+/* CS_A Register Masks */
+#define BCM2835_I2S_STBY		BIT(25)
+#define BCM2835_I2S_SYNC		BIT(24)
+#define BCM2835_I2S_RXSEX		BIT(23)
+#define BCM2835_I2S_RXF		BIT(22)
+#define BCM2835_I2S_TXE		BIT(21)
+#define BCM2835_I2S_RXD		BIT(20)
+#define BCM2835_I2S_TXD		BIT(19)
+#define BCM2835_I2S_RXR		BIT(18)
+#define BCM2835_I2S_TXW		BIT(17)
+#define BCM2835_I2S_CS_RXERR		BIT(16)
+#define BCM2835_I2S_CS_TXERR		BIT(15)
+#define BCM2835_I2S_RXSYNC		BIT(14)
+#define BCM2835_I2S_TXSYNC		BIT(13)
+#define BCM2835_I2S_DMAEN		BIT(9)
+#define BCM2835_I2S_RXTHR(v)		((v) << 7)
+#define BCM2835_I2S_TXTHR(v)		((v) << 5)
+#define BCM2835_I2S_RXCLR		BIT(4)
+#define BCM2835_I2S_TXCLR		BIT(3)
+#define BCM2835_I2S_TXON		BIT(2)
+#define BCM2835_I2S_RXON		BIT(1)
+#define BCM2835_I2S_EN			(1)
+
+/* MODE_A Register Masks */
+#define BCM2835_I2S_CLKDIS		BIT(28)
+#define BCM2835_I2S_PDMN		BIT(27)
+#define BCM2835_I2S_PDME		BIT(26)
+#define BCM2835_I2S_FRXP		BIT(25)
+#define BCM2835_I2S_FTXP		BIT(24)
+#define BCM2835_I2S_CLKM		BIT(23)
+#define BCM2835_I2S_CLKI		BIT(22)
+#define BCM2835_I2S_FSM		BIT(21)
+#define BCM2835_I2S_FSI		BIT(20)
+#define BCM2835_I2S_FLEN(v)		((v) << 10)
+#define BCM2835_I2S_FSLEN(v)		(v)
+
+/* RXC_A Register Masks */
+#define BCM2835_I2S_CHWEX		BIT(15)
+#define BCM2835_I2S_CHEN		BIT(14)
+#define BCM2835_I2S_CHPOS(v)		((v) << 4)
+#define BCM2835_I2S_CHWID(v)		(v)
+#define BCM2835_I2S_CH1(v)		((v) << 16)
+#define BCM2835_I2S_CH2(v)		(v)
+#define BCM2835_I2S_CH1_POS(v)		BCM2835_I2S_CH1(BCM2835_I2S_CHPOS(v))
+#define BCM2835_I2S_CH2_POS(v)		BCM2835_I2S_CH2(BCM2835_I2S_CHPOS(v))
+
+/* DREQ_A Register Masks*/
+#define BCM2835_I2S_TX_PANIC(v)	((v) << 24)
+#define BCM2835_I2S_RX_PANIC(v)	((v) << 16)
+#define BCM2835_I2S_TX(v)		((v) << 8)
+#define BCM2835_I2S_RX(v)		(v)
+
+#define BCM2835_I2S_INT_RXERR		BIT(3)
+#define BCM2835_I2S_INT_TXERR		BIT(2)
+#define BCM2835_I2S_INT_RXR		BIT(1)
+#define BCM2835_I2S_INT_TXW		BIT(0)
+
+/* Frame length register is 10 bit, maximum length 1024 */
+#define BCM2835_I2S_MAX_FRAME_LENGTH	1024
+#define RESERVED_BUFFER_SIZE_IN_PAGES	20
+
+static inline void rpi_reg_write(void *base_addr, uint32_t reg_addr,
+				uint32_t value)
+{
+	uint32_t *reg = base_addr + reg_addr;
+	wmb();
+	*reg = value;
+}
+
+static inline void rpi_reg_update_bits(void *base_addr, uint32_t reg_addr,
+				uint32_t mask, uint32_t value)
+{
+	uint32_t *reg = base_addr + reg_addr;
+	wmb();
+	*reg &= (~mask);
+	*reg |= (mask & value);
+}
+
+static inline void rpi_reg_read(void *base_addr, uint32_t reg_addr,
+			uint32_t *value)
+{
+	uint32_t *reg = base_addr + reg_addr;
+	rmb();
+	*value = *reg;
+}
+
+extern int bcm2835_i2s_init(char *audio_hat);
+extern int bcm2835_i2s_exit(void);
+extern struct audio_rtdm_dev *bcm2835_get_i2s_dev(void);
+extern int bcm2835_i2s_buffers_setup(int audio_buffer_size, int audio_channels);
+extern void bcm2835_i2s_start_stop(struct audio_rtdm_dev *audio_dev, int cmd);
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/clk_measure.c b/evl/sound/evl-amlogic/clk_measure.c
--- a/drivers/evl/sound/evl-amlogic/clk_measure.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/clk_measure.c	2021-12-24 10:26:57.558779183 +0300
@@ -0,0 +1,1675 @@
+/*
+ * drivers/amlogic/clk/clk_measure.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include <linux/clk-provider.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include "cpu_version.h"
+#include <linux/iomap.h>
+#include "clk_measure.h"
+#include <linux/scpi_protocol.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+
+#undef pr_fmt
+#define pr_fmt(fmt) "clkmsr: " fmt
+
+void __iomem *msr_clk_reg0;
+void __iomem *msr_clk_reg2;
+void __iomem *msr_clk_reg3;
+void __iomem *msr_ring_reg0;
+
+static DEFINE_SPINLOCK(clk_measure_lock);
+
+#define CLKMSR_DEVICE_NAME	"clkmsr"
+unsigned int clk_msr_index = 0xff;
+
+struct meson_clkmsr_data {
+	const char * const *clk_table;
+	unsigned int table_size;
+	unsigned int (*clk_msr_function)(unsigned int clk_mux);
+
+/* sentinel maybe new diference between deferent SoCs */
+};
+
+static struct meson_clkmsr_data *clk_data;
+
+static unsigned int m8b_clk_util_clk_msr(unsigned int clk_mux)
+{
+	unsigned int msr;
+	unsigned int regval = 0;
+	unsigned int val;
+
+	writel_relaxed(0, msr_clk_reg0);
+	/* Set the measurement gate to 64uS */
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~0xFFFF)) | (64-1);
+	writel_relaxed(val, msr_clk_reg0);
+
+	/* Disable continuous measurement */
+	/* disable interrupts */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~((1<<18)|(1<<17)));
+	writel_relaxed(val, msr_clk_reg0);
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~(0x1f<<20))) | (clk_mux<<20)|(1<<19)|(1<<16);
+	writel_relaxed(val, msr_clk_reg0);
+
+	/* Wait for the measurement to be done */
+	do {
+		regval = readl_relaxed(msr_clk_reg0);
+	} while (regval & (1 << 31));
+	/* disable measuring */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~(1<<16));
+	writel_relaxed(val, msr_clk_reg0);
+
+	msr = (readl_relaxed(msr_clk_reg2)+31)&0x000FFFFF;
+	/* Return value in MHz*measured_val */
+	return (msr>>6)*1000000;
+}
+
+static unsigned int gxbb_clk_util_clk_msr(unsigned int clk_mux)
+{
+	unsigned int  msr;
+	unsigned int regval = 0;
+	unsigned int val;
+
+	writel_relaxed(0, msr_clk_reg0);
+    /* Set the measurement gate to 50uS */
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~0xFFFF)) | (64-1);
+	writel_relaxed(val, msr_clk_reg0);
+    /* Disable continuous measurement */
+    /* disable interrupts */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~((1<<18)|(1<<17)));
+	writel_relaxed(val, msr_clk_reg0);
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~(0x7f<<20))) | (clk_mux<<20)|(1<<19)|(1<<16);
+	writel_relaxed(val, msr_clk_reg0);
+    /* Wait for the measurement to be done */
+	do {
+		regval = readl_relaxed(msr_clk_reg0);
+	} while (regval & (1 << 31));
+    /* disable measuring */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~(1<<16));
+	msr = (readl_relaxed(msr_clk_reg2)+31)&0x000FFFFF;
+    /* Return value in MHz*measured_val */
+	return (msr>>6)*1000000;
+
+}
+
+static unsigned int meson_clk_util_ring_msr(unsigned int clk_mux)
+{
+	unsigned int  msr;
+	unsigned int regval = 0;
+	unsigned int val;
+
+	writel_relaxed(0, msr_clk_reg0);
+    /* Set the measurement gate to 50uS */
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~0xFFFF)) | (10000-1);
+	writel_relaxed(val, msr_clk_reg0);
+    /* Disable continuous measurement */
+    /* disable interrupts */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~((1<<18)|(1<<17)));
+	writel_relaxed(val, msr_clk_reg0);
+	val = readl_relaxed(msr_clk_reg0);
+	val = (val & (~(0x7f<<20))) | (clk_mux<<20)|(1<<19)|(1<<16);
+	writel_relaxed(val, msr_clk_reg0);
+    /* Wait for the measurement to be done */
+	do {
+		regval = readl_relaxed(msr_clk_reg0);
+	} while (regval & (1 << 31));
+    /* disable measuring */
+	val = readl_relaxed(msr_clk_reg0);
+	val = val & (~(1<<16));
+	msr = (readl_relaxed(msr_clk_reg2)+31)&0x000FFFFF;
+    /* Return value in MHz*measured_val */
+	return (msr / 10);
+
+}
+
+int m8b_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[63] = "CTS_MIPI_CSI_CFG_CLK(63)",
+		[62] = "VID2_PLL_CLK(62)        ",
+		[61] = "GPIO_CLK(61)            ",
+		[60] = "USB_32K_ALT(60)         ",
+		[59] = "CTS_HCODEC_CLK(59)      ",
+		[58] = "Reserved(58)            ",
+		[57] = "Reserved(57)            ",
+		[56] = "Reserved(56)            ",
+		[55] = "Reserved(55)            ",
+		[54] = "Reserved(54)            ",
+		[53] = "Reserved(53)            ",
+		[52] = "Reserved(52)            ",
+		[51] = "Reserved(51)            ",
+		[50] = "Reserved(50)            ",
+		[49] = "CTS_PWM_E_CLK(49)       ",
+		[48] = "CTS_PWM_F_CLK(48)       ",
+		[47] = "DDR_DPLL_PT_CLK(47)     ",
+		[46] = "CTS_PCM2_SCLK(46)       ",
+		[45] = "CTS_PWM_A_CLK(45)       ",
+		[44] = "CTS_PWM_B_CLK(44)       ",
+		[43] = "CTS_PWM_C_CLK(43)       ",
+		[42] = "CTS_PWM_D_CLK(42)       ",
+		[41] = "CTS_ETH_RX_TX(41)       ",
+		[40] = "CTS_PCM_MCLK(40)        ",
+		[39] = "CTS_PCM_SCLK(39)        ",
+		[38] = "CTS_VDIN_MEAS_CLK(38)   ",
+		[37] = "Reserved(37)            ",
+		[36] = "CTS_HDMI_TX_PIXEL_CLK(36)",
+		[35] = "CTS_MALI_CLK (35)       ",
+		[34] = "CTS_SDHC_SDCLK(34)      ",
+		[33] = "CTS_SDHC_RXCLK(33)      ",
+		[32] = "CTS_VDAC_CLK(32)        ",
+		[31] = "CTS_AUDAC_CLKPI(31)     ",
+		[30] = "MPLL_CLK_TEST_OUT(30)   ",
+		[29] = "Reserved(29)            ",
+		[28] = "CTS_SAR_ADC_CLK(28)     ",
+		[27] = "Reserved(27)            ",
+		[26] = "SC_CLK_INT(26)          ",
+		[25] = "Reserved(25)            ",
+		[24] = "LVDS_FIFO_CLK(24)       ",
+		[23] = "HDMI_CH0_TMDSCLK(23)    ",
+		[22] = "CLK_RMII_FROM_PAD (22)  ",
+		[21] = "I2S_CLK_IN_SRC0(21)     ",
+		[20] = "RTC_OSC_CLK_OUT(20)     ",
+		[19] = "CTS_HDMI_SYS_CLK(19)    ",
+		[18] = "A9_CLK_DIV16(18)        ",
+		[17] = "Reserved(17)            ",
+		[16] = "CTS_FEC_CLK_2(16)       ",
+		[15] = "CTS_FEC_CLK_1 (15)      ",
+		[14] = "CTS_FEC_CLK_0 (14)      ",
+		[13] = "CTS_AMCLK(13)           ",
+		[12] = "Reserved(12)            ",
+		[11] = "CTS_ETH_RMII(11)        ",
+		[10] = "Reserved(10)            ",
+		[9] = "CTS_ENCL_CLK(9)          ",
+		[8] = "CTS_ENCP_CLK(8)          ",
+		[7] = "CLK81(7)                 ",
+		[6] = "VID_PLL_CLK(6)           ",
+		[5] = "Reserved(5)              ",
+		[4] = "Reserved(4)              ",
+		[3] = "A9_RING_OSC_CLK(3)       ",
+		[2] = "AM_RING_OSC_CLK_OUT_EE2(2)",
+		[1] = "AM_RING_OSC_CLK_OUT_EE1(1)",
+		[0] = "AM_RING_OSC_CLK_OUT_EE0(0)",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, m8b_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", m8b_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int gxl_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[82] = "Cts_ge2d_clk       ",
+		[81] = "Cts_vapbclk        ",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "cts_aoclk_int      ",
+		[75] = "cts_aoclkx2_int    ",
+		[74] = "0                  ",
+		[73] = "cts_pwm_C_clk      ",
+		[72] = "cts_pwm_D_clk      ",
+		[71] = "cts_pwm_E_clk      ",
+		[70] = "cts_pwm_F_clk      ",
+		[69] = "0                  ",
+		[68] = "0                  ",
+		[67] = "0                  ",
+		[66] = "cts_vid_lock_clk   ",
+		[65] = "0                  ",
+		[64] = "0                  ",
+		[63] = "0                  ",
+		[62] = "cts_hevc_clk       ",
+		[61] = "gpio_clk_msr       ",
+		[60] = "alt_32k_clk        ",
+		[59] = "cts_hcodec_clk     ",
+		[58] = "0                  ",
+		[57] = "0					",
+		[56] = "0					",
+		[55] = "vid_pll_div_clk_out	",
+		[54] = "0					",
+		[53] = "Sd_emmc_clk_A		",
+		[52] = "Sd_emmc_clk_B		",
+		[51] = "Cts_nand_core_clk	",
+		[50] = "Mp3_clk_out			",
+		[49] = "mp2_clk_out			",
+		[48] = "mp1_clk_out			",
+		[47] = "ddr_dpll_pt_clk		",
+		[46] = "cts_vpu_clk			",
+		[45] = "cts_pwm_A_clk		",
+		[44] = "cts_pwm_B_clk		",
+		[43] = "fclk_div5			",
+		[42] = "mp0_clk_out			",
+		[41] = "eth_rx_clk_or_clk_rmii",
+		[40] = "cts_pcm_mclk			",
+		[39] = "cts_pcm_sclk			",
+		[38] = "cts_vdin_meas_clk			",
+		[37] = "cts_clk_i958			",
+		[36] = "cts_hdmi_tx_pixel_clk ",
+		[35] = "cts_mali_clk			",
+		[34] = "0					",
+		[33] = "0					",
+		[32] = "cts_vdec_clk			",
+		[31] = "MPLL_CLK_TEST_OUT	",
+		[30] = "0					",
+		[29] = "0					",
+		[28] = "cts_sar_adc_clk					   ",
+		[27] = "0					   ",
+		[26] = "sc_clk_int			   ",
+		[25] = "0					   ",
+		[24] = "0					   ",
+		[23] = "HDMI_CLK_TODIG		   ",
+		[22] = "eth_phy_ref_clk		   ",
+		[21] = "i2s_clk_in_src0		   ",
+		[20] = "rtc_osc_clk_out		   ",
+		[19] = "cts_hdmitx_sys_clk	   ",
+		[18] = "sys_cpu_clk_div16		   ",
+		[17] = "sys_pll_div16					   ",
+		[16] = "cts_FEC_CLK_2		   ",
+		[15] = "cts_FEC_CLK_1		   ",
+		[14] = "cts_FEC_CLK_0		   ",
+		[13] = "cts_amclk			   ",
+		[12] = "Cts_pdm_clk			   ",
+		[11] = "rgmii_tx_clk_to_phy	   ",
+		[10] = "cts_vdac_clk			   ",
+		[9] = "cts_encl_clk			  ",
+		[8] = "cts_encp_clk			  ",
+		[7] = "clk81					  ",
+		[6] = "cts_enci_clk			  ",
+		[5] = "0						  ",
+		[4] = "gp0_pll_clk			  ",
+		[3] = "A53_ring_osc_clk		  ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+int gxm_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[82] = "Cts_ge2d_clk       ",
+		[81] = "Cts_vapbclk        ",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "cts_aoclk_int      ",
+		[75] = "cts_aoclkx2_int    ",
+		[74] = "0                  ",
+		[73] = "cts_pwm_C_clk      ",
+		[72] = "cts_pwm_D_clk      ",
+		[71] = "cts_pwm_E_clk      ",
+		[70] = "cts_pwm_F_clk      ",
+		[69] = "0                  ",
+		[68] = "0                  ",
+		[67] = "0                  ",
+		[66] = "cts_vid_lock_clk   ",
+		[65] = "0                  ",
+		[64] = "0                  ",
+		[63] = "0                  ",
+		[62] = "cts_hevc_clk       ",
+		[61] = "gpio_clk_msr       ",
+		[60] = "alt_32k_clk        ",
+		[59] = "cts_hcodec_clk     ",
+		[58] = "cts_wave420l_bclk                  ",
+		[57] = "cts_wave420l_cclk	",
+		[56] = "cts_cci_clk			",
+		[55] = "vid_pll_div_clk_out	",
+		[54] = "0					",
+		[53] = "Sd_emmc_clk_A		",
+		[52] = "Sd_emmc_clk_B		",
+		[51] = "Cts_nand_core_clk	",
+		[50] = "Mp3_clk_out			",
+		[49] = "mp2_clk_out			",
+		[48] = "mp1_clk_out			",
+		[47] = "ddr_dpll_pt_clk		",
+		[46] = "cts_vpu_clk			",
+		[45] = "cts_pwm_A_clk		",
+		[44] = "cts_pwm_B_clk		",
+		[43] = "fclk_div5			",
+		[42] = "mp0_clk_out			",
+		[41] = "eth_rx_clk_or_clk_rmii",
+		[40] = "cts_pcm_mclk			",
+		[39] = "cts_pcm_sclk			",
+		[38] = "cts_vdin_meas_clk			",
+		[37] = "cts_clk_i958			",
+		[36] = "cts_hdmi_tx_pixel_clk ",
+		[35] = "cts_mali_clk			",
+		[34] = "0					",
+		[33] = "0					",
+		[32] = "cts_vdec_clk			",
+		[31] = "MPLL_CLK_TEST_OUT	",
+		[30] = "0					",
+		[29] = "0					",
+		[28] = "cts_sar_adc_clk					   ",
+		[27] = "0					   ",
+		[26] = "sc_clk_int			   ",
+		[25] = "0					   ",
+		[24] = "sys_cpu1_clk_div16			",
+		[23] = "HDMI_CLK_TODIG		   ",
+		[22] = "eth_phy_ref_clk		   ",
+		[21] = "i2s_clk_in_src0		   ",
+		[20] = "rtc_osc_clk_out		   ",
+		[19] = "cts_hdmitx_sys_clk	   ",
+		[18] = "sys_cpu_clk_div16		   ",
+		[17] = "sys_pll_div16					   ",
+		[16] = "cts_FEC_CLK_2		   ",
+		[15] = "cts_FEC_CLK_1		   ",
+		[14] = "cts_FEC_CLK_0		   ",
+		[13] = "cts_amclk			   ",
+		[12] = "Cts_pdm_clk			   ",
+		[11] = "mac_eth_tx_clk	   ",
+		[10] = "cts_vdac_clk			   ",
+		[9] = "cts_encl_clk			  ",
+		[8] = "cts_encp_clk			  ",
+		[7] = "clk81					  ",
+		[6] = "cts_enci_clk			  ",
+		[5] = "0						  ",
+		[4] = "gp0_pll_clk			  ",
+		[3] = "A53_ring_osc_clk		  ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int axg_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[109] = "audio_locker_in   ",
+		[108] = "audio_locker_out  ",
+		[107] = "pcie_refclk_p     ",
+		[106] = "pcie_refclk_n     ",
+		[105] = "audio_mclk_a      ",
+		[104] = "audio_mclk_b      ",
+		[103] = "audio_mclk_c      ",
+		[102] = "audio_mclk_d      ",
+		[101] = "audio_mclk_e      ",
+		[100] = "audio_mclk_f      ",
+		[99] = "audio_sclk_a       ",
+		[98] = "audio_sclk_b       ",
+		[97] = "audio_sclk_c       ",
+		[96] = "audio_sclk_d       ",
+		[95] = "audio_sclk_e       ",
+		[94] = "audio_sclk_f       ",
+		[93] = "audio_lrclk_a      ",
+		[92] = "audio_lrclk_b      ",
+		[91] = "audio_lrclk_c      ",
+		[90] = "audio_lrclk_d      ",
+		[89] = "audio_lrclk_e      ",
+		[88] = "audio_lrclk_f      ",
+		[87] = "audio_spdifint_clk ",
+		[86] = "audio_spdifout_clk ",
+		[85] = "audio_pdm_sysclk   ",
+		[84] = "audio_resample_clk ",
+		[83] = "0                  ",
+		[82] = "Cts_ge2d_clk       ",
+		[81] = "Cts_vapbclk        ",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "tdmin_lb_sclk      ",
+		[75] = "tdmin_lb_lrclk     ",
+		[74] = "wifi_beacon        ",
+		[73] = "cts_pwm_C_clk      ",
+		[72] = "cts_pwm_D_clk      ",
+		[71] = "audio_slv_sclk_a   ",
+		[70] = "audio_slv_sclk_b   ",
+		[69] = "audio_slv_sclk_c   ",
+		[68] = "audio_slv_lrclk_a  ",
+		[67] = "audio_slv_lrclk_b  ",
+		[66] = "audio_slv_lrclk_c  ",
+		[65] = "0                  ",
+		[64] = "0                  ",
+		[63] = "0                  ",
+		[62] = "0                  ",
+		[61] = "gpio_clk_msr       ",
+		[60] = "0                  ",
+		[59] = "0                  ",
+		[58] = "0                  ",
+		[57] = "0                  ",
+		[56] = "0                  ",
+		[55] = "0	                 ",
+		[54] = "0                  ",
+		[53] = "0	                 ",
+		[52] = "sd_emmc_clk_B		   ",
+		[51] = "sd_emmc_clk_C      ",
+		[50] = "mp3_clk_out			   ",
+		[49] = "mp2_clk_out			   ",
+		[48] = "mp1_clk_out			   ",
+		[47] = "ddr_dpll_pt_clk		 ",
+		[46] = "cts_vpu_clk			   ",
+		[45] = "cts_pwm_A_clk		   ",
+		[44] = "cts_pwm_B_clk		   ",
+		[43] = "fclk_div5			     ",
+		[42] = "mp0_clk_out			   ",
+		[41] = "mod_eth_rx_clk_rmii",
+		[40] = "mod_eth_tx_clk     ",
+		[39] = "0	                 ",
+		[38] = "0	                 ",
+		[37] = "0	                 ",
+		[36] = "0	                 ",
+		[35] = "0	                 ",
+		[34] = "0	                 ",
+		[33] = "0	                 ",
+		[32] = "0	                 ",
+		[31] = "MPLL_CLK_TEST_OUT	 ",
+		[30] = "0	                 ",
+		[29] = "0	                 ",
+		[28] = "Cts_sar_adc_clk		 ",
+		[27] = "0	                 ",
+		[26] = "0	                 ",
+		[25] = "0	                 ",
+		[24] = "0	                 ",
+		[23] = "mmc_clk            ",
+		[22] = "0	                 ",
+		[21] = "0	                 ",
+		[20] = "rtc_osc_clk_out    ",
+		[19] = "0	                 ",
+		[18] = "sys_cpu_clk_div16  ",
+		[17] = "sys_pll_div16      ",
+		[16] = "0	                 ",
+		[15] = "0	                 ",
+		[14] = "0	                 ",
+		[13] = "0	                 ",
+		[12] = "0	                 ",
+		[11] = "0	                 ",
+		[10] = "0	                 ",
+		[9] = "cts_encl_clk          ",
+		[8] = "0	                 ",
+		[7] = "clk81               ",
+		[6] = "0	                 ",
+		[5] = "gp1_pll_clk         ",
+		[4] = "gp0_pll_clk         ",
+		[3] = "A53_ring_osc_clk    ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int txl_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[88] = "hdmirx_vid_clk",
+		[87] = "lvds_fifo_clk",
+		[86] = "hdmirx_phy_dtb[3]",
+		[85] = "hdmirx_phy_dtb[2]",
+		[84] = "hdmirx_phy_dtb[1]",
+		[83] = "hdmirx_phy_dtb[0]",
+		[82] = "Cts_ge2d_clk",
+		[81] = "Cts_vapbclk",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "cts_aoclk_int",
+		[75] = "cts_aoclkx2_int",
+		[74] = "cts_atv_dmd_vdac_clk",
+		[73] = "cts_pwm_C_clk",
+		[72] = "cts_pwm_D_clk",
+		[71] = "cts_pwm_E_clk",
+		[70] = "cts_pwm_F_clk",
+		[69] = "Cts_hdcp22_skp",
+		[68] = "Cts_hdcp22_esm",
+		[67] = "tvfe_sample_clk",
+		[66] = "cts_vid_lock_clk",
+		[65] = "atv_dmd_sys_clk",
+		[64] = "Cts_hdmirx_cfg_clk",
+		[63] = "adc_dpll_intclk",
+		[62] = "cts_hevc_clk",
+		[61] = "gpio_clk_msr",
+		[60] = "alt_32k_clk",
+		[59] = "cts_hcodec_clk",
+		[58] = "Hdmirx_aud_clk",
+		[57] = "Cts_hdmirx_audmeas",
+		[56] = "Cts_hdmirx_modet_clk",
+		[55] = "vid_pll_div_clk_out",
+		[54] = "Cts_hdmirx_arc_ref_clk",
+		[53] = "Sd_emmc_clk_A",
+		[52] = "Sd_emmc_clk_B",
+		[51] = "Sd_emmc_clk_C",
+		[50] = "Mp3_clk_out",
+		[49] = "mp2_clk_out",
+		[48] = "mp1_clk_out",
+		[47] = "ddr_dpll_pt_clk",
+		[46] = "cts_vpu_clk",
+		[45] = "cts_pwm_A_clk",
+		[44] = "cts_pwm_B_clk",
+		[43] = "fclk_div5",
+		[42] = "mp0_clk_out",
+		[41] = "eth_rx_clk_or_clk_rmii",
+		[40] = "cts_pcm_mclk",
+		[39] = "cts_pcm_sclk",
+		[38] = "Cts_vdin_meas_clk",
+		[37] = "cts_clk_i958",
+		[36] = "cts_hdmi_tx_pixel_clk",
+		[35] = "cts_mali_clk",
+		[34] = "adc_dpll_clk_b3",
+		[33] = "adc_dpll_clk_b2",
+		[32] = "cts_vdec_clk",
+		[31] = "MPLL_CLK_TEST_OUT",
+		[30] = "Hdmirx_audmeas_clk",
+		[29] = "Hdmirx_pix_clk",
+		[28] = "cts_sar_adc_clk",
+		[27] = "Hdmirx_mpll_div_clk",
+		[26] = "sc_clk_int",
+		[25] = "Hdmirx_tmds_clk",
+		[24] = "Hdmirx_aud_pll_clk",
+		[23] = "mmc_clk",
+		[22] = "eth_phy_ref_clk",
+		[21] = "i2s_clk_in_src0",
+		[20] = "rtc_osc_clk_out",
+		[19] = "adc_dpll_clka2",
+		[18] = "sys_cpu_clk_div16",
+		[17] = "sys_pll_div16",
+		[16] = "cts_FEC_CLK_2",
+		[15] = "cts_FEC_CLK_1",
+		[14] = "cts_FEC_CLK_0",
+		[13] = "cts_amclk",
+		[12] = "Cts_pdm_clk",
+		[11] = "mac_eth_tx_clk",
+		[10] = "cts_vdac_clk",
+		[9] = "cts_encl_clk",
+		[8] = "cts_encp_clk",
+		[7] = "clk81",
+		[6] = "cts_enci_clk",
+		[5] = "gp1_pll_clk",
+		[4] = "gp0_pll_clk",
+		[3] = "A53_ring_osc_clk",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+
+	return 0;
+}
+
+
+int txlx_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[109] = "cts_alocker_in_clk",
+		[108] = "cts_alocker_out_clk",
+		[107] = "am_ring_osc_clk_out_ee[11]",
+		[106] = "am_ring_osc_clk_out_ee[10]",
+		[105] = "am_ring_osc_clk_out_ee[9]",
+		[104] = "am_ring_osc_clk_out_ee[8]",
+		[103] = "am_ring_osc_clk_out_ee[7]",
+		[102] = "am_ring_osc_clk_out_ee[6]",
+		[101] = "am_ring_osc_clk_out_ee[5]",
+		[100] = "am_ring_osc_clk_out_ee[4]",
+		[99] = "am_ring_osc_clk_out_ee[3]",
+		[98] = "cts_hdmirx_aud_pll_clk",
+		[97] = "cts_vpu_clkb_tmp   ",
+		[96] = "cts_vpu_clkb       ",
+		[95] = "ethphy_test_clk_out",
+		[94] = "atv_dmd_mono_clk_32",
+		[93] = "cts_audin_lrclk",
+		[92] = "cts_audin_sclk ",
+		[91] = "cts_audin_mclk     ",
+		[90] = "cts_hdmitx_sys_clk ",
+		[89] = "HDMI_CLK_TODIG     ",
+		[88] = "hdmirx_vid_clk     ",
+		[87] = "lvds_fifo_clk      ",
+		[86] = "hdmirx_phy_dtb[3]  ",
+		[85] = "hdmirx_phy_dtb[2]  ",
+		[84] = "hdmirx_phy_dtb[1]  ",
+		[83] = "hdmirx_phy_dtb[0]  ",
+		[82] = "Cts_ge2d_clk       ",
+		[81] = "Cts_vapbclk        ",
+		[80] = "Rng_ring_osc_clk[3]",
+		[79] = "Rng_ring_osc_clk[2]",
+		[78] = "Rng_ring_osc_clk[1]",
+		[77] = "Rng_ring_osc_clk[0]",
+		[76] = "cts_aoclk_int      ",
+		[75] = "cts_aoclkx2_int    ",
+		[74] = "cts_atv_dmd_vdac_clk",
+		[73] = "cts_pwm_C_clk      ",
+		[72] = "cts_pwm_D_clk      ",
+		[71] = "cts_pwm_E_clk      ",
+		[70] = "cts_pwm_F_clk      ",
+		[69] = "Cts_hdcp22_skp     ",
+		[68] = "Cts_hdcp22_esm     ",
+		[67] = "tvfe_sample_clk    ",
+		[66] = "cts_vid_lock_clk   ",
+		[65] = "cts_atv_dmd_sys_clk",
+		[64] = "Cts_hdmirx_cfg_clk ",
+		[63] = "adc_dpll_intclk    ",
+		[62] = "cts_hevc_clk       ",
+		[61] = "gpio_clk_msr       ",
+		[60] = "alt_32k_clk        ",
+		[59] = "cts_hcodec_clk     ",
+		[58] = "Hdmirx_aud_clk     ",
+		[57] = "Cts_hdmirx_audmeas ",
+		[56] = "Cts_hdmirx_modet_clk",
+		[55] = "vid_pll_div_clk_out	",
+		[54] = "Cts_hdmirx_arc_ref_clk",
+		[53] = "sd_emmc_clk_A		",
+		[52] = "sd_emmc_clk_B		",
+		[51] = "sd_emmc_clk_C       ",
+		[50] = "mp3_clk_out			",
+		[49] = "mp2_clk_out			",
+		[48] = "mp1_clk_out			",
+		[47] = "ddr_dpll_pt_clk		",
+		[46] = "cts_vpu_clk			",
+		[45] = "cts_pwm_A_clk		",
+		[44] = "cts_pwm_B_clk		",
+		[43] = "fclk_div5			",
+		[42] = "mp0_clk_out			",
+		[41] = "eth_rx_clk_rmii     ",
+		[40] = "cts_pcm_mclk        ",
+		[39] = "cts_pcm_sclk        ",
+		[38] = "Cts_vdin_meas_clk   ",
+		[37] = "cts_clk_i958        ",
+		[36] = "cts_hdmi_tx_pixel_clk",
+		[35] = "cts_mali_clk		",
+		[34] = "adc_dpll_clk_b3     ",
+		[33] = "adc_dpll_clk_b2     ",
+		[32] = "cts_vdec_clk        ",
+		[31] = "MPLL_CLK_TEST_OUT	",
+		[30] = "Hdmirx_audmeas_clk	",
+		[29] = "Hdmirx_pix_clk		",
+		[28] = "Cts_sar_adc_clk		",
+		[27] = "Hdmirx_mpll_div_clk	",
+		[26] = "sc_clk_int          ",
+		[25] = "Hdmirx_tmds_clk	    ",
+		[24] = "Hdmirx_aud_pll_clk ",
+		[23] = "mmc_clk             ",
+		[22] = "eth_phy_ref_clk     ",
+		[21] = "i2s_clk_in_src0     ",
+		[20] = "rtc_osc_clk_out     ",
+		[19] = "adc_dpll_clka2      ",
+		[18] = "sys_cpu_clk_div16   ",
+		[17] = "sys_pll_div16       ",
+		[16] = "cts_FEC_CLK_2       ",
+		[15] = "cts_FEC_CLK_1       ",
+		[14] = "cts_FEC_CLK_0       ",
+		[13] = "cts_amclk           ",
+		[12] = "Cts_demod_core_clk  ",
+		[11] = "mac_eth_tx_clk      ",
+		[10] = "cts_vdac_clk        ",
+		[9] = "cts_encl_clk         ",
+		[8] = "cts_encp_clk         ",
+		[7] = "clk81                ",
+		[6] = "cts_enci_clk         ",
+		[5] = "gp1_pll_clk          ",
+		[4] = "gp0_pll_clk          ",
+		[3] = "A53_ring_osc_clk     ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int g12a_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[122] = "mod_audio_pdm_dclk_o       ",
+		[121] = "audio_spdifin_mst_clk      ",
+		[120] = "audio_spdifout_mst_clk     ",
+		[119] = "audio_spdifout_b_mst_clk   ",
+		[118] = "audio_pdm_sysclk           ",
+		[117] = "audio_resample_clk         ",
+		[116] = "audio_tdmin_a_sclk         ",
+		[115] = "audio_tdmin_b_sclk         ",
+		[114] = "audio_tdmin_c_sclk         ",
+		[113] = "audio_tdmin_lb_sclk        ",
+		[112] = "audio_tdmout_a_sclk        ",
+		[111] = "audio_tdmout_b_sclk        ",
+		[110] = "audio_tdmout_c_sclk        ",
+		[109] = "c_alocker_out_clk          ",
+		[108] = "c_alocker_in_clk           ",
+		[107] = "au_dac_clk_g128x           ",
+		[106] = "ephy_test_clk              ",
+		[105] = "am_ring_osc_clk_out_ee[9]  ",
+		[104] = "am_ring_osc_clk_out_ee[8]  ",
+		[103] = "am_ring_osc_clk_out_ee[7]  ",
+		[102] = "am_ring_osc_clk_out_ee[6]  ",
+		[101] = "am_ring_osc_clk_out_ee[5]  ",
+		[100] = "am_ring_osc_clk_out_ee[4]  ",
+		[99] = "am_ring_osc_clk_out_ee[3]   ",
+		[98] = "cts_ts_clk                 ",
+		[97] = "cts_vpu_clkb_tmp           ",
+		[96] = "cts_vpu_clkb               ",
+		[95] = "eth_phy_plltxclk           ",
+		[94] = "eth_phy_rxclk              ",
+		[93] = "1'b0                       ",
+		[92] = "1'b0                       ",
+		[91] = "1'b0                       ",
+		[90] = "cts_hdmitx_sys_clk         ",
+		[89] = "HDMI_CLK_TODIG             ",
+		[88] = "1'b0                       ",
+		[87] = "1'b0                       ",
+		[86] = "1'b0                       ",
+		[85] = "1'b0                       ",
+		[84] = "co_tx_clk                  ",
+		[83] = "co_rx_clk                  ",
+		[82] = "cts_ge2d_clk               ",
+		[81] = "cts_vapbclk                ",
+		[80] = "rng_ring_osc_clk[3]        ",
+		[79] = "rng_ring_osc_clk[2]        ",
+		[78] = "rng_ring_osc_clk[1]        ",
+		[77] = "rng_ring_osc_clk[0]        ",
+		[76] = "1'b0                       ",
+		[75] = "cts_hevcf_clk              ",
+		[74] = "1'b0                       ",
+		[73] = "cts_pwm_C_clk              ",
+		[72] = "cts_pwm_D_clk              ",
+		[71] = "cts_pwm_E_clk              ",
+		[70] = "cts_pwm_F_clk              ",
+		[69] = "cts_hdcp22_skpclk          ",
+		[68] = "cts_hdcp22_esmclk          ",
+		[67] = "cts_dsi_phy_clk            ",
+		[66] = "cts_vid_lock_clk           ",
+		[65] = "cts_spicc_0_clk            ",
+		[64] = "cts_spicc_1_clk            ",
+		[63] = "cts_dsi_meas_clk           ",
+		[62] = "cts_hevcb_clk              ",
+		[61] = "gpio_clk_msr               ",
+		[60] = "1'b0                       ",
+		[59] = "cts_hcodec_clk             ",
+		[58] = "cts_wave420l_bclk          ",
+		[57] = "cts_wave420l_cclk          ",
+		[56] = "cts_wave420l_aclk          ",
+		[55] = "vid_pll_div_clk_out        ",
+		[54] = "cts_vpu_clkc               ",
+		[53] = "cts_sd_emmc_clk_A          ",
+		[52] = "cts_sd_emmc_clk_B          ",
+		[51] = "cts_sd_emmc_clk_C          ",
+		[50] = "mp3_clk_out                ",
+		[49] = "mp2_clk_out                ",
+		[48] = "mp1_clk_out                ",
+		[47] = "ddr_dpll_pt_clk            ",
+		[46] = "cts_vpu_clk                ",
+		[45] = "cts_pwm_A_clk              ",
+		[44] = "cts_pwm_B_clk              ",
+		[43] = "fclk_div5                  ",
+		[42] = "mp0_clk_out                ",
+		[41] = "mac_eth_rx_clk_rmii        ",
+		[40] = "1'b0                       ",
+		[39] = "cts_bt656_clk0             ",
+		[38] = "cts_vdin_meas_clk          ",
+		[37] = "cts_cdac_clk_c             ",
+		[36] = "cts_hdmi_tx_pixel_clk      ",
+		[35] = "cts_mali_clk               ",
+		[34] = "eth_mppll_50m_ckout        ",
+		[33] = "sys_cpu_ring_osc_clk[1]    ",
+		[32] = "cts_vdec_clk               ",
+		[31] = "mpll_clk_test_out          ",
+		[30] = "pcie_clk_inn               ",
+		[29] = "pcie_clk_inp               ",
+		[28] = "cts_sar_adc_clk            ",
+		[27] = "co_clkin_to_mac            ",
+		[26] = "sc_clk_int                 ",
+		[25] = "cts_eth_clk_rmii           ",
+		[24] = "cts_eth_clk125Mhz          ",
+		[23] = "mpll_clk_50m               ",
+		[22] = "mac_eth_phy_ref_clk        ",
+		[21] = "lcd_an_clk_ph3             ",
+		[20] = "rtc_osc_clk_out            ",
+		[19] = "lcd_an_clk_ph2             ",
+		[18] = "sys_cpu_clk_div16          ",
+		[17] = "sys_pll_div16              ",
+		[16] = "cts_FEC_CLK_2              ",
+		[15] = "cts_FEC_CLK_1              ",
+		[14] = "cts_FEC_CLK_0              ",
+		[13] = "mod_tcon_clko              ",
+		[12] = "hifi_pll_clk               ",
+		[11] = "mac_eth_tx_clk             ",
+		[10] = "cts_vdac_clk               ",
+		[9] = "cts_encl_clk             ",
+		[8] = "cts_encp_clk             ",
+		[7] = "clk81                    ",
+		[6] = "cts_enci_clk             ",
+		[5] = "1'b0                     ",
+		[4] = "gp0_pll_clk              ",
+		[3] = "sys_cpu_ring_osc_clk[0]  ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int g12_ring_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+			[11] = "sys_cpu_ring_osc_clk[1] ",
+			[10] = "sys_cpu_ring_osc_clk[0] ",
+			[9] = "am_ring_osc_clk_out_ee[9] ",
+			[8] = "am_ring_osc_clk_out_ee[8] ",
+			[7] = "am_ring_osc_clk_out_ee[7] ",
+			[6] = "am_ring_osc_clk_out_ee[6] ",
+			[5] = "am_ring_osc_clk_out_ee[5] ",
+			[4] = "am_ring_osc_clk_out_ee[4] ",
+			[3] = "am_ring_osc_clk_out_ee[3] ",
+			[2] = "am_ring_osc_clk_out_ee[2] ",
+			[1] = "am_ring_osc_clk_out_ee[1] ",
+			[0] = "am_ring_osc_clk_out_ee[0] ",
+		};
+	const int tb[] = {0, 1, 2, 99, 100, 101, 102, 103, 104, 105, 3, 33};
+	unsigned long i;
+	unsigned char ringinfo[8] = {0, 0, 0, 0, 0, 0, 0, 0};
+
+	/*RING_OSCILLATOR       0x7f: set slow ring*/
+	if (msr_ring_reg0 != NULL) {
+		writel_relaxed(0x555555, msr_ring_reg0);
+		for (i = 0; i < 12; i++)
+			seq_printf(s, "%s	:%10d	KHz\n",
+			  clk_table[i], meson_clk_util_ring_msr(tb[i]));
+	} else {
+		seq_puts(s, "fail test osc ring info\n");
+	}
+
+	// if (scpi_get_ring_value(ringinfo) != 0) {
+	// 	seq_puts(s, "fail get osc ring efuse info\n");
+	// 	return 0;
+	// }
+
+	seq_puts(s, "osc ring efuse info:\n");
+
+	for (i = 0; i < 8; i++)
+		seq_printf(s, "0x%x ", ringinfo[i]);
+	seq_puts(s, "\n");
+
+	/*efuse to test value*/
+	seq_puts(s, "ee[9], ee[1], ee[0], cpu[1], cpu[0], iddee, iddcpu\n");
+
+	for (i = 1; i <= 5; i++)
+		seq_printf(s, "%d KHz ", (ringinfo[i] * 20));
+
+	for (i = 6; i <= 7; i++)
+		seq_printf(s, "%d uA ", (ringinfo[i] * 200));
+
+	seq_puts(s, "\n");
+
+	return 0;
+}
+
+int g12b_clk_measure(struct seq_file *s, void *what, unsigned int index)
+{
+	static const char * const clk_table[] = {
+		[126] = "mipi_csi_phy1_clk_out",
+		[125] = "mipi_csi_phy0_clk_out",
+		[124] = "cts_gdc_core_clk",
+		[123] = "cts_gdc_axi_clk",
+		[122] = "mod_audio_pdm_dclk_o       ",
+		[121] = "audio_spdifin_mst_clk      ",
+		[120] = "audio_spdifout_mst_clk     ",
+		[119] = "audio_spdifout_b_mst_clk   ",
+		[118] = "audio_pdm_sysclk           ",
+		[117] = "audio_resample_clk         ",
+		[116] = "audio_tdmin_a_sclk         ",
+		[115] = "audio_tdmin_b_sclk         ",
+		[114] = "audio_tdmin_c_sclk         ",
+		[113] = "audio_tdmin_lb_sclk        ",
+		[112] = "audio_tdmout_a_sclk        ",
+		[111] = "audio_tdmout_b_sclk        ",
+		[110] = "audio_tdmout_c_sclk        ",
+		[109] = "c_alocker_out_clk          ",
+		[108] = "c_alocker_in_clk           ",
+		[107] = "au_dac_clk_g128x           ",
+		[106] = "ephy_test_clk              ",
+		[105] = "am_ring_osc_clk_out_ee[9]  ",
+		[104] = "am_ring_osc_clk_out_ee[8]  ",
+		[103] = "am_ring_osc_clk_out_ee[7]  ",
+		[102] = "am_ring_osc_clk_out_ee[6]  ",
+		[101] = "am_ring_osc_clk_out_ee[5]  ",
+		[100] = "am_ring_osc_clk_out_ee[4]  ",
+		[99] = "am_ring_osc_clk_out_ee[3]   ",
+		[98] = "cts_ts_clk                 ",
+		[97] = "cts_vpu_clkb_tmp           ",
+		[96] = "cts_vpu_clkb               ",
+		[95] = "eth_phy_plltxclk           ",
+		[94] = "eth_phy_rxclk              ",
+		[93] = "1'b0                       ",
+		[92] = "sys_pllB_div16             ",
+		[91] = "sys_cpuB_clk_div16         ",
+		[90] = "cts_hdmitx_sys_clk         ",
+		[89] = "HDMI_CLK_TODIG             ",
+		[88] = "cts_mipi_isp_clk           ",
+		[87] = "1'b0                       ",
+		[86] = "cts_vipnanoq_core_clk      ",
+		[85] = "cts_vipnanoq_axi_clk       ",
+		[84] = "co_tx_clk                  ",
+		[83] = "co_rx_clk                  ",
+		[82] = "cts_ge2d_clk               ",
+		[81] = "cts_vapbclk                ",
+		[80] = "rng_ring_osc_clk[3]        ",
+		[79] = "rng_ring_osc_clk[2]        ",
+		[78] = "rng_ring_osc_clk[1]        ",
+		[77] = "rng_ring_osc_clk[0]        ",
+		[76] = "cts_cci_clk                ",
+		[75] = "cts_hevcf_clk              ",
+		[74] = "cts_mipi_csi_phy_clk       ",
+		[73] = "cts_pwm_C_clk              ",
+		[72] = "cts_pwm_D_clk              ",
+		[71] = "cts_pwm_E_clk              ",
+		[70] = "cts_pwm_F_clk              ",
+		[69] = "cts_hdcp22_skpclk          ",
+		[68] = "cts_hdcp22_esmclk          ",
+		[67] = "cts_dsi_phy_clk            ",
+		[66] = "cts_vid_lock_clk           ",
+		[65] = "cts_spicc_0_clk            ",
+		[64] = "cts_spicc_1_clk            ",
+		[63] = "cts_dsi_meas_clk           ",
+		[62] = "cts_hevcb_clk              ",
+		[61] = "gpio_clk_msr               ",
+		[60] = "1'b0                       ",
+		[59] = "cts_hcodec_clk             ",
+		[58] = "cts_wave420l_bclk          ",
+		[57] = "cts_wave420l_cclk          ",
+		[56] = "cts_wave420l_aclk          ",
+		[55] = "vid_pll_div_clk_out        ",
+		[54] = "cts_vpu_clkc               ",
+		[53] = "cts_sd_emmc_clk_A          ",
+		[52] = "cts_sd_emmc_clk_B          ",
+		[51] = "cts_sd_emmc_clk_C          ",
+		[50] = "mp3_clk_out                ",
+		[49] = "mp2_clk_out                ",
+		[48] = "mp1_clk_out                ",
+		[47] = "ddr_dpll_pt_clk            ",
+		[46] = "cts_vpu_clk                ",
+		[45] = "cts_pwm_A_clk              ",
+		[44] = "cts_pwm_B_clk              ",
+		[43] = "fclk_div5                  ",
+		[42] = "mp0_clk_out                ",
+		[41] = "mac_eth_rx_clk_rmii        ",
+		[40] = "1'b0                       ",
+		[39] = "cts_bt656_clk0             ",
+		[38] = "cts_vdin_meas_clk          ",
+		[37] = "cts_cdac_clk_c             ",
+		[36] = "cts_hdmi_tx_pixel_clk      ",
+		[35] = "cts_mali_clk               ",
+		[34] = "eth_mppll_50m_ckout        ",
+		[33] = "sys_cpu_ring_osc_clk[1]    ",
+		[32] = "cts_vdec_clk               ",
+		[31] = "mpll_clk_test_out          ",
+		[30] = "pcie_clk_inn               ",
+		[29] = "pcie_clk_inp               ",
+		[28] = "cts_sar_adc_clk            ",
+		[27] = "co_clkin_to_mac            ",
+		[26] = "sc_clk_int                 ",
+		[25] = "cts_eth_clk_rmii           ",
+		[24] = "cts_eth_clk125Mhz          ",
+		[23] = "mpll_clk_50m               ",
+		[22] = "mac_eth_phy_ref_clk        ",
+		[21] = "lcd_an_clk_ph3             ",
+		[20] = "rtc_osc_clk_out            ",
+		[19] = "lcd_an_clk_ph2             ",
+		[18] = "sys_cpu_clk_div16          ",
+		[17] = "sys_pll_div16              ",
+		[16] = "cts_FEC_CLK_2              ",
+		[15] = "cts_FEC_CLK_1              ",
+		[14] = "cts_FEC_CLK_0              ",
+		[13] = "mod_tcon_clko              ",
+		[12] = "hifi_pll_clk               ",
+		[11] = "mac_eth_tx_clk             ",
+		[10] = "cts_vdac_clk               ",
+		[9] = "cts_encl_clk             ",
+		[8] = "cts_encp_clk             ",
+		[7] = "clk81                    ",
+		[6] = "cts_enci_clk             ",
+		[5] = "1'b0                     ",
+		[4] = "gp0_pll_clk              ",
+		[3] = "sys_cpu_ring_osc_clk[0]  ",
+		[2] = "am_ring_osc_clk_out_ee[2]",
+		[1] = "am_ring_osc_clk_out_ee[1]",
+		[0] = "am_ring_osc_clk_out_ee[0]",
+	};
+	int  i;
+	int len = sizeof(clk_table)/sizeof(char *);
+
+	if (index  == 0xff) {
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n",
+				   i, gxbb_clk_util_clk_msr(i),
+					clk_table[i]);
+		return 0;
+	}
+	seq_printf(s, "[%10d]%s\n", gxbb_clk_util_clk_msr(index),
+		   clk_table[index]);
+	clk_msr_index = 0xff;
+	return 0;
+}
+
+int meson_clk_measure(unsigned int clk_mux)
+{
+	int clk_val;
+	unsigned long flags;
+
+	spin_lock_irqsave(&clk_measure_lock, flags);
+	if (clk_data) {
+		clk_val = clk_data->clk_msr_function(clk_mux);
+	} else {
+		switch (get_cpu_type()) {
+		case MESON_CPU_MAJOR_ID_M8B:
+			clk_val = m8b_clk_util_clk_msr(clk_mux);
+			break;
+		case MESON_CPU_MAJOR_ID_GXL:
+		case MESON_CPU_MAJOR_ID_GXM:
+		case MESON_CPU_MAJOR_ID_TXL:
+		case MESON_CPU_MAJOR_ID_TXLX:
+		case MESON_CPU_MAJOR_ID_G12A:
+		case MESON_CPU_MAJOR_ID_G12B:
+		case MESON_CPU_MAJOR_ID_AXG:
+			clk_val = gxbb_clk_util_clk_msr(clk_mux);
+			break;
+		default:
+			pr_info("Unsupported chip clk measure\n");
+			clk_val = 0;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&clk_measure_lock, flags);
+
+	return clk_val;
+
+}
+EXPORT_SYMBOL(meson_clk_measure);
+
+static int dump_clk(struct seq_file *s, void *what)
+{
+	if (clk_data) {
+		int i;
+		const char * const *clk_table = clk_data->clk_table;
+		int len = clk_data->table_size;
+
+		for (i = 0; i < len; i++)
+			seq_printf(s, "[%2d][%10d]%s\n", i,
+			clk_data->clk_msr_function(i), clk_table[i]);
+	} else {
+		if (get_cpu_type() == MESON_CPU_MAJOR_ID_M8B)
+			m8b_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXL)
+			gxl_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_GXM)
+			gxm_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_AXG)
+			axg_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_TXL)
+			txl_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_TXLX)
+			txlx_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_G12A)
+			g12a_clk_measure(s, what, clk_msr_index);
+		else if (get_cpu_type() == MESON_CPU_MAJOR_ID_G12B)
+			g12b_clk_measure(s, what, clk_msr_index);
+	}
+
+	return 0;
+}
+
+static int dump_ring(struct seq_file *s, void *what)
+{
+	if (get_cpu_type() == MESON_CPU_MAJOR_ID_G12A)
+		g12_ring_measure(s, what, clk_msr_index);
+	return 0;
+}
+
+
+static ssize_t clkmsr_write(struct file *file, const char __user *userbuf,
+				   size_t count, loff_t *ppos)
+{
+	char buf[80];
+	int ret;
+
+	count = min_t(size_t, count, (sizeof(buf)-1));
+	if (copy_from_user(buf, userbuf, count))
+		return -EFAULT;
+
+	buf[count] = 0;
+
+	/* ret = sscanf(buf, "%i", &clk_msr_index); */
+	ret = kstrtouint(buf, 0, &clk_msr_index);
+	switch (ret) {
+	case 1:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t ringmsr_write(struct file *file, const char __user *userbuf,
+				   size_t count, loff_t *ppos)
+{
+	return count;
+}
+
+static int clkmsr_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dump_clk, inode->i_private);
+}
+
+static int ringmsr_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dump_ring, inode->i_private);
+}
+
+
+static const struct file_operations clkmsr_file_ops = {
+	.open		= clkmsr_open,
+	.read		= seq_read,
+	.write		= clkmsr_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static const struct file_operations ringmsr_file_ops = {
+	.open		= ringmsr_open,
+	.read		= seq_read,
+	.write		= ringmsr_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+static int aml_clkmsr_probe(struct platform_device *pdev)
+{
+	static struct dentry *debugfs_root;
+	struct device_node *np;
+	u32 ringctrl;
+
+	np = pdev->dev.of_node;
+	debugfs_root = debugfs_create_dir("aml_clkmsr", NULL);
+	if (IS_ERR(debugfs_root) || !debugfs_root) {
+		pr_warn("failed to create debugfs directory\n");
+		debugfs_root = NULL;
+		return -1;
+	}
+	debugfs_create_file("clkmsr", S_IFREG | 0444,
+			    debugfs_root, NULL, &clkmsr_file_ops);
+
+	debugfs_create_file("ringmsr", S_IFREG | 0444,
+			    debugfs_root, NULL, &ringmsr_file_ops);
+
+	msr_clk_reg0 = of_iomap(np, 0);
+	msr_clk_reg2 = of_iomap(np, 1);
+	pr_info("msr_clk_reg0=%p,msr_clk_reg2=%p\n",
+		msr_clk_reg0, msr_clk_reg2);
+
+	if (of_property_read_u32(pdev->dev.of_node,
+				"ringctrl", &ringctrl)) {
+		dev_err(&pdev->dev,
+			"failed to get msr ring reg0\n");
+		msr_ring_reg0 = NULL;
+	} else {
+		msr_ring_reg0 = ioremap(ringctrl, 1);
+		pr_info("msr_ring_reg0=%p\n", msr_ring_reg0);
+	}
+
+	clk_data = (struct meson_clkmsr_data *)
+	of_device_get_match_data(&pdev->dev);
+
+	return 0;
+}
+
+static const char * const tl1_table[] = {
+	[144] = "ts_pll_clk",
+	[143] = "mainclk",
+	[142] = "demode_ts_clk",
+	[141] = "ts_ddr_clk",
+	[140] = "audio_toacodec_bclk",
+	[139] = "aud_adc_clk_g128x",
+	[138] = "dsu_pll_clk_cpu",
+	[137] = "atv_dmd_i2c_sclk",
+	[136] = "sys_pll_clk",
+	[135] = "tvfe_sample_clk",
+	[134] = "adc_extclk_in",
+	[133] = "atv_dmd_mono_clk_32",
+	[132] = "audio_toacode_mclk",
+	[131] = "ts_sar_clk",
+	[130] = "au_dac2_clk_gf128x",
+	[129] = "lvds_fifo_clk",
+	[128] = "cts_tcon_pll_clk",
+	[127] = "hdmirx_vid_clk",
+	[126] = "sar_ring_osc_clk",
+	[125] = "cts_hdmi_axi_clk",
+	[124] =	"cts_demod_core_clk",
+	[123] =	"mod_audio_pdm_dclk_o",
+	[122] =	"audio_spdifin_mst_clk",
+	[121] = "audio_spdifout_mst_clk",
+	[120] = "audio_spdifout_b_mst_clk",
+	[119] = "audio_pdm_sysclk",
+	[118] = "audio_resamplea_clk",
+	[117] = "audio_resampleb_clk",
+	[116] = "audio_tdmin_a_sclk",
+	[115] = "audio_tdmin_b_sclk",
+	[114] = "audio_tdmin_c_sclk",
+	[113] = "audio_tdmin_lb_sclk",
+	[112] = "audio_tdmout_a_sclk",
+	[111] = "audio_tdmout_b_sclk",
+	[110] = "audio_tdmout_c_sclk",
+	[109] = "o_vad_clk",
+	[108] = "acodec_i2sout_bclk",
+	[107] = "au_dac_clk_g128x",
+	[106] = "ephy_test_clk",
+	[105] = "am_ring_osc_clk_out_ee[9]",
+	[104] = "am_ring_osc_clk_out_ee[8]",
+	[103] = "am_ring_osc_clk_out_ee[7]",
+	[102] = "am_ring_osc_clk_out_ee[6]",
+	[101] = "am_ring_osc_clk_out_ee[5]",
+	[100] = "am_ring_osc_clk_out_ee[4]",
+	[99] = "am_ring_osc_clk_out_ee[3]",
+	[98] = "cts_ts_clk",
+	[97] = "cts_vpu_clkb_tmp",
+	[96] = "cts_vpu_clkb",
+	[95] = "eth_phy_plltxclk",
+	[94] = "eth_phy_exclk",
+	[93] = "sys_cpu_ring_osc_clk[3]",
+	[92] = "sys_cpu_ring_osc_clk[2]",
+	[91] = "hdmirx_audmeas_clk",
+	[90] = "am_ring_osc_clk_out_ee[11]",
+	[89] = "am_ring_osc_clk_out_ee[10]",
+	[88] = "cts_hdmirx_meter_clk",
+	[87] = "1'b0",
+	[86] = "cts_hdmirx_modet_clk",
+	[85] = "cts_hdmirx_acr_ref_clk",
+	[84] = "co_tx_cl",
+	[83] = "co_rx_clk",
+	[82] = "cts_ge2d_clk",
+	[81] = "cts_vapbclk",
+	[80] = "rng_ring_osc_clk[3]",
+	[79] = "rng_ring_osc_clk[2]",
+	[78] = "rng_ring_osc_clk[1]",
+	[77] = "rng_ring_osc_clk[0]",
+	[76] = "hdmix_aud_clk",
+	[75] = "cts_hevcf_clk",
+	[74] = "hdmirx_aud_pll_clk",
+	[73] = "cts_pwm_C_clk",
+	[72] = "cts_pwm_D_clk",
+	[71] = "cts_pwm_E_clk",
+	[70] = "cts_pwm_F_clk",
+	[69] = "cts_hdcp22_skpclk",
+	[68] = "cts_hdcp22_esmclk",
+	[67] = "hdmirx_apll_clk_audio",
+	[66] = "cts_vid_lock_clk",
+	[65] = "cts_spicc_0_clk",
+	[64] = "cts_spicc_1_clk",
+	[63] = "hdmirx_tmds_clk",
+	[62] = "cts_hevcb_clk",
+	[61] = "gpio_clk_msr",
+	[60] = "cts_hdmirx_aud_pll_clk",
+	[59] = "cts_hcodec_clk",
+	[58] = "cts_vafe_datack",
+	[57] = "cts_atv_dmd_vdac_clk",
+	[56] = "cts_atv_dmd_sys_clk",
+	[55] = "vid_pll_div_clk_out",
+	[54] = "cts_vpu_clkc",
+	[53] = "ddr_2xclk",
+	[52] = "cts_sd_emmc_clk_B",
+	[51] = "cts_sd_emmc_clk_C",
+	[50] = "mp3_clk_out",
+	[49] = "mp2_clk_out",
+	[48] = "mp1_clk_out",
+	[47] = "ddr_dpll_pt_clk",
+	[46] = "cts_vpu_clk",
+	[45] = "cts_pwm_A_clk",
+	[44] = "cts_pwm_B_clk",
+	[43] = "fclk_div5",
+	[42] = "mp0_clk_out",
+	[41] = "mac_eth_rx_clk_rmii",
+	[40] = "cts_hdmirx_cfg_clk",
+	[39] = "cts_bt656_clk0",
+	[38] = "cts_vdin_meas_clk",
+	[37] = "cts_cdac_clk_c",
+	[36] = "cts_hdmi_tx_pixel_clk",
+	[35] = "cts_mali_clk",
+	[34] = "eth_mppll_50m_ckout",
+	[33] = "sys_cpu_ring_osc_clk[1]",
+	[32] = "cts_vdec_clk",
+	[31] = "mpll_clk_test_out",
+	[30] = "hdmirx_cable_clk",
+	[29] = "hdmirx_apll_clk_out_div",
+	[28] = "cts_sar_adc_clk",
+	[27] = "co_clkin_to_mac",
+	[26] = "sc_clk_int",
+	[25] = "cts_eth_clk_rmii",
+	[24] = "cts_eth_clk125Mhz",
+	[23] = "mpll_clk_50m",
+	[22] = "mac_eth_phy_ref_clk",
+	[21] = "lcd_an_clk_ph3",
+	[20] = "rtc_osc_clk_out",
+	[19] = "lcd_an_clk_ph2",
+	[18] = "sys_cpu_clk_div16",
+	[17] = "sys_pll_div16",
+	[16] = "cts_FEC_CLK_2",
+	[15] = "cts_FEC_CLK_1",
+	[14] = "cts_FEC_CLK_0",
+	[13] = "mod_tcon_clko",
+	[12] = "hifi_pll_clk",
+	[11] = "mac_eth_tx_clk",
+	[10] = "cts_vdac_clk",
+	[9] = "cts_encl_clk",
+	[8] = "cts_encp_clk",
+	[7] = "clk81",
+	[6] = "cts_enci_clk",
+	[5] = "gp1_pll_clk",
+	[4] = "gp0_pll_clk",
+	[3] = "sys_cpu_ring_osc_clk[0]",
+	[2] = "am_ring_osc_clk_out_ee[2]",
+	[1] = "am_ring_osc_clk_out_ee[1]",
+	[0] = "am_ring_osc_clk_out_ee[0]",
+};
+
+static const struct meson_clkmsr_data tl1_data = {
+	.clk_table = tl1_table,
+	.table_size = ARRAY_SIZE(tl1_table),
+	.clk_msr_function = gxbb_clk_util_clk_msr,
+};
+
+static const char * const sm1_table[] = {
+	[127] = "clk_csi2_data              ",
+	[126] = "csi_phy0_clk_out           ",
+	[125] = "earcrx_pll_test_clk        ",
+	[124] = "earcx_pll_(dmac)_clk       ",
+	[123] = "audio_resampled_clk        ",
+	[122] = "mod_audio_pdm_dclk_o       ",
+	[121] = "audio_spdifin_mst_clk      ",
+	[120] = "audio_spdifout_mst_clk     ",
+	[119] = "audio_spdifout_b_mst_clk   ",
+	[118] = "audio_pdm_sysclk           ",
+	[117] = "audio_resampleA_clk         ",
+	[116] = "audio_tdmin_a_sclk         ",
+	[115] = "audio_tdmin_b_sclk         ",
+	[114] = "audio_tdmin_c_sclk         ",
+	[113] = "audio_tdmin_lb_sclk        ",
+	[112] = "audio_tdmout_a_sclk        ",
+	[111] = "audio_tdmout_b_sclk        ",
+	[110] = "audio_tdmout_c_sclk        ",
+	[109] = "c_alocker_out_clk          ",
+	[108] = "c_alocker_in_clk           ",
+	[107] = "au_dac_clk_g128x           ",
+	[106] = "ephy_test_clk              ",
+	[105] = "arm_ring_osc_clk_out[16]  ",
+	[104] = "arm_ring_osc_clk_out[15]  ",
+	[103] = "arm_ring_osc_clk_out[14]  ",
+	[102] = "arm_ring_osc_clk_out[13]  ",
+	[101] = "arm_ring_osc_clk_out[12]  ",
+	[100] = "arm_ring_osc_clk_out[11]  ",
+	[99] = "arm_ring_osc_clk_out[10]   ",
+	[98] = "cts_ts_clk                 ",
+	[97] = "cts_vpu_clkb_tmp           ",
+	[96] = "cts_vpu_clkb               ",
+	[95] = "eth_phy_plltxclk           ",
+	[94] = "eth_phy_rxclk              ",
+	[93] = "vad_clk                    ",
+	[92] = "nna_axi_clk                ",
+	[91] = "nna_core_clk               ",
+	[90] = "cts_hdmitx_sys_clk         ",
+	[89] = "HDMI_CLK_TODIG             ",
+	[88] = "csi2_adapt_clk             ",
+	[87] = "mipi_csi_phy_clk           ",
+	[86] = "arm_ring_osc_clk_out[9]    ",
+	[85] = "arm_ring_osc_clk_out[8]    ",
+	[84] = "co_tx_clk                  ",
+	[83] = "co_rx_clk                  ",
+	[82] = "cts_ge2d_clk               ",
+	[81] = "cts_vapbclk                ",
+	[80] = "rng_ring_osc_clk[3]        ",
+	[79] = "rng_ring_osc_clk[2]        ",
+	[78] = "rng_ring_osc_clk[1]        ",
+	[77] = "rng_ring_osc_clk[0]        ",
+	[76] = "arm_ring_osc_clk_out[7]    ",
+	[75] = "cts_hevcf_clk              ",
+	[74] = "arm_ring_osc_clk_out[6]    ",
+	[73] = "cts_pwm_C_clk              ",
+	[72] = "cts_pwm_D_clk              ",
+	[71] = "cts_pwm_E_clk              ",
+	[70] = "cts_pwm_F_clk              ",
+	[69] = "cts_hdcp22_skpclk          ",
+	[68] = "cts_hdcp22_esmclk          ",
+	[67] = "cts_dsi_phy_clk            ",
+	[66] = "cts_vid_lock_clk           ",
+	[65] = "cts_spicc_0_clk            ",
+	[64] = "cts_spicc_1_clk            ",
+	[63] = "cts_dsi_meas_clk           ",
+	[62] = "cts_hevcb_clk              ",
+	[61] = "gpio_clk_msr               ",
+	[60] = "arm_ring_osc_clk_out[5]    ",
+	[59] = "cts_hcodec_clk             ",
+	[58] = "cts_wave420l_bclk          ",
+	[57] = "cts_wave420l_cclk          ",
+	[56] = "cts_wave420l_aclk          ",
+	[55] = "vid_pll_div_clk_out        ",
+	[54] = "cts_vpu_clkc               ",
+	[53] = "cts_sd_emmc_clk_A          ",
+	[52] = "cts_sd_emmc_clk_B          ",
+	[51] = "cts_sd_emmc_clk_C          ",
+	[50] = "mp3_clk_out                ",
+	[49] = "mp2_clk_out                ",
+	[48] = "mp1_clk_out                ",
+	[47] = "ddr_dpll_pt_clk            ",
+	[46] = "cts_vpu_clk                ",
+	[45] = "cts_pwm_A_clk              ",
+	[44] = "cts_pwm_B_clk              ",
+	[43] = "fclk_div5                  ",
+	[42] = "mp0_clk_out                ",
+	[41] = "mac_eth_rx_clk_rmii        ",
+	[40] = "arm_ring_osc_clk_out[4]    ",
+	[39] = "cts_bt656_clk0             ",
+	[38] = "cts_vdin_meas_clk          ",
+	[37] = "cts_cdac_clk_c             ",
+	[36] = "cts_hdmi_tx_pixel_clk      ",
+	[35] = "cts_mali_clk               ",
+	[34] = "eth_mppll_50m_ckout        ",
+	[33] = "1'b0                       ",
+	[32] = "cts_vdec_clk               ",
+	[31] = "mpll_clk_test_out          ",
+	[30] = "pcie_clk_inn               ",
+	[29] = "pcie_clk_inp               ",
+	[28] = "cts_sar_adc_clk            ",
+	[27] = "co_clkin_to_mac            ",
+	[26] = "sc_clk_int                 ",
+	[25] = "cts_eth_clk_rmii           ",
+	[24] = "cts_eth_clk125Mhz          ",
+	[23] = "mpll_clk_50m               ",
+	[22] = "mac_eth_phy_ref_clk        ",
+	[21] = "lcd_an_clk_ph3             ",
+	[20] = "rtc_osc_clk_out            ",
+	[19] = "lcd_an_clk_ph2             ",
+	[18] = "sys_cpu_clk_div16          ",
+	[17] = "sys_pll_div16              ",
+	[16] = "cts_FEC_CLK_2              ",
+	[15] = "cts_FEC_CLK_1              ",
+	[14] = "cts_FEC_CLK_0              ",
+	[13] = "mod_tcon_clko              ",
+	[12] = "hifi_pll_clk               ",
+	[11] = "mac_eth_tx_clk             ",
+	[10] = "cts_vdac_clk               ",
+	[9] = "cts_encl_clk             ",
+	[8] = "cts_encp_clk             ",
+	[7] = "clk81                    ",
+	[6] = "cts_enci_clk             ",
+	[5] = "gp1_pll_clk              ",
+	[4] = "gp0_pll_clk              ",
+	[3] = "am_ring_osc_clk_out_ee[3]",
+	[2] = "am_ring_osc_clk_out_ee[2]",
+	[1] = "am_ring_osc_clk_out_ee[1]",
+	[0] = "am_ring_osc_clk_out_ee[0]",
+};
+
+static const struct meson_clkmsr_data sm1_data = {
+	.clk_table = sm1_table,
+	.table_size = ARRAY_SIZE(sm1_table),
+	.clk_msr_function = gxbb_clk_util_clk_msr,
+};
+
+static const struct of_device_id meson_clkmsr_dt_match[] = {
+	{	.compatible = "amlogic, gxl_measure",},
+	{	.compatible = "amlogic, m8b_measure",},
+	{	.compatible = "amlogic,tl1-measure", .data = &tl1_data },
+	{	.compatible = "amlogic, sm1-measure", .data = &sm1_data },
+
+	{},
+};
+
+static struct platform_driver aml_clkmsr_driver = {
+	.probe = aml_clkmsr_probe,
+	.driver = {
+		.name = CLKMSR_DEVICE_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = meson_clkmsr_dt_match,
+	},
+};
+
+static int __init aml_clkmsr_init(void)
+{
+	int ret = -1;
+
+	ret = platform_driver_register(&aml_clkmsr_driver);
+
+	if (ret != 0) {
+		pr_err("clkmsr:failed to register driver, error %d\n", ret);
+		return -ENODEV;
+	}
+	pr_info("clkmsr: driver init\n");
+
+	return ret;
+}
+
+static void __exit aml_clkmsr_exit(void)
+{
+	platform_driver_unregister(&aml_clkmsr_driver);
+}
+
+// arch_initcall(aml_clkmsr_init);
+// module_exit(aml_clkmsr_exit);
+
+// MODULE_DESCRIPTION("Amlogic clkmsr module");
+// MODULE_LICENSE("GPL");
+
diff -ruN a/drivers/evl/sound/evl-amlogic/clk_measure.h b/evl/sound/evl-amlogic/clk_measure.h
--- a/drivers/evl/sound/evl-amlogic/clk_measure.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/clk_measure.h	2021-12-24 09:40:59.188748761 +0300
@@ -0,0 +1,23 @@
+/*
+ * include/linux/amlogic/clk_measure.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __CLK_MEASURE_H__
+#define __CLK_MEASURE_H__
+
+extern int meson_clk_measure(unsigned int clk_mux);
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/cpu_version.h b/evl/sound/evl-amlogic/cpu_version.h
--- a/drivers/evl/sound/evl-amlogic/cpu_version.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/cpu_version.h	2021-12-24 09:44:33.868751129 +0300
@@ -0,0 +1,236 @@
+/*
+ * include/linux/amlogic/cpu_version.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/*
+ * All of these api should be call after early_initcall stage
+ */
+#ifndef __PLAT_MESON_CPU_H
+#define __PLAT_MESON_CPU_H
+
+#define MESON_CPU_MAJOR_ID_M8B		0x1B
+#define MESON_CPU_MAJOR_ID_GXBB		0x1F
+#define MESON_CPU_MAJOR_ID_GXTVBB	0x20
+#define MESON_CPU_MAJOR_ID_GXL		0x21
+#define MESON_CPU_MAJOR_ID_GXM		0x22
+#define MESON_CPU_MAJOR_ID_TXL		0x23
+#define MESON_CPU_MAJOR_ID_TXLX		0x24
+#define MESON_CPU_MAJOR_ID_AXG		0x25
+#define MESON_CPU_MAJOR_ID_GXLX		0x26
+#define MESON_CPU_MAJOR_ID_TXHD		0x27
+
+#define MESON_CPU_MAJOR_ID_G12A		0x28
+#define MESON_CPU_MAJOR_ID_G12B		0x29
+#define MESON_CPU_MAJOR_ID_SM1		0x2B
+
+#define MESON_CPU_MAJOR_ID_TL1		0x2E
+#define MESON_CPU_MAJOR_ID_TM2		0x2F
+
+#define MESON_CPU_VERSION_LVL_MAJOR	0
+#define MESON_CPU_VERSION_LVL_MINOR	1
+#define MESON_CPU_VERSION_LVL_PACK	2
+#define MESON_CPU_VERSION_LVL_MISC	3
+#define MESON_CPU_VERSION_LVL_MAX	MESON_CPU_VERSION_LVL_MISC
+
+extern const char *machine_model;
+
+#define CHIPID_LEN 16
+void cpuinfo_get_chipid(unsigned char *cid, unsigned int size);
+int  meson_cpu_version_init(void);
+#ifdef CONFIG_AMLOGIC_CPU_VERSION
+int get_meson_cpu_version(int level);
+int arch_big_cpu(int cpu);
+#else
+static inline int get_meson_cpu_version(int level)
+{
+	return -1;
+}
+
+static inline int arch_big_cpu(int cpu)
+{
+	return 0;
+}
+#endif
+
+static inline int get_cpu_type(void)
+{
+	return get_meson_cpu_version(MESON_CPU_VERSION_LVL_MAJOR);
+}
+
+static inline u32 get_cpu_package(void)
+{
+	unsigned int pk;
+
+	pk = get_meson_cpu_version(MESON_CPU_VERSION_LVL_PACK) & 0xF0;
+	return pk;
+}
+
+static inline bool package_id_is(unsigned int id)
+{
+	return get_cpu_package() == id;
+}
+
+static inline bool is_meson_m8b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_M8B;
+}
+
+static inline bool is_meson_gxbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB;
+}
+
+static inline bool is_meson_gxtvbb_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXTVBB;
+}
+
+static inline bool is_meson_gxbb_package_905(void)
+{
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() != 0x20);
+}
+
+static inline bool is_meson_gxbb_package_905m(void)
+{
+	return (get_cpu_type() == MESON_CPU_MAJOR_ID_GXBB) &&
+		(get_cpu_package() == 0x20);
+}
+
+static inline bool is_meson_gxl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXL;
+}
+
+static inline bool is_meson_gxl_package_905D(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x0);
+}
+static inline bool is_meson_gxl_package_905X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x80);
+}
+
+static inline bool is_meson_gxl_package_905L(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xc0);
+}
+
+static inline bool is_meson_gxl_package_905M2(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xe0);
+}
+
+static inline bool is_meson_gxl_package_805X(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0x30);
+}
+
+static inline bool is_meson_gxl_package_805Y(void)
+{
+	return is_meson_gxl_cpu() && package_id_is(0xb0);
+}
+
+static inline bool is_meson_gxm_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXM;
+}
+
+static inline bool is_meson_txl_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXL;
+}
+
+static inline bool is_meson_txl_package_950(void)
+{
+	return is_meson_txl_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_txlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXLX;
+}
+
+static inline bool is_meson_axg_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_AXG;
+}
+
+static inline bool is_meson_gxlx_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_GXLX;
+}
+
+static inline bool is_meson_txhd_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TXHD;
+}
+
+static inline bool is_meson_g12a_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12A;
+}
+
+static inline bool is_meson_g12b_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_G12B;
+}
+
+static inline bool is_meson_tl1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TL1;
+}
+
+static inline bool is_meson_sm1_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_SM1;
+}
+static inline bool is_meson_tm2_cpu(void)
+{
+	return get_cpu_type() == MESON_CPU_MAJOR_ID_TM2;
+}
+
+static inline bool cpu_after_eq(unsigned int id)
+{
+	return get_cpu_type() >= id;
+}
+
+static inline bool is_meson_txlx_package_962X(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x10);
+}
+
+static inline bool is_meson_txlx_package_962E(void)
+{
+	return is_meson_txlx_cpu() && package_id_is(0x20);
+}
+
+static inline bool is_meson_rev_a(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xA);
+}
+
+static inline bool is_meson_rev_b(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xB);
+}
+
+static inline bool is_meson_rev_c(void)
+{
+	return (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xC);
+}
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/ddr_mngr.c b/evl/sound/evl-amlogic/ddr_mngr.c
--- a/drivers/evl/sound/evl-amlogic/ddr_mngr.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/ddr_mngr.c	2021-12-31 16:20:03.747506883 +0300
@@ -0,0 +1,1806 @@
+/*
+ * sound/soc/amlogic/auge/ddr_mngr.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG
+#undef pr_fmt
+#define pr_fmt(fmt) "audio_ddr_mngr: " fmt
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include "regs.h"
+#include "ddr_mngr.h"
+
+// #include "resample.h"
+// #include "resample_hw.h"
+// #include "effects_hw.h"
+// #include "effects_hw_v2.h"
+// #include "effects_v2.h"
+// #include "pwrdet_hw.h"
+#include "iomap.h"
+#include "evl-audio.h"
+
+#define DRV_NAME "audio-ddr-manager"
+
+static DEFINE_MUTEX(ddr_mutex);
+
+#define DDRMAX 4
+static struct frddr frddrs[DDRMAX];
+static struct toddr toddrs[DDRMAX];
+
+/* resample */
+static struct toddr_attach attach_resample_a;
+static struct toddr_attach attach_resample_b;
+static void aml_check_resample(struct toddr *to, bool enable);
+
+/* power detect */
+static struct toddr_attach attach_pwrdet;
+static void aml_check_pwrdet(bool enable);
+static bool aml_check_pwrdet_module(int src);
+
+static inline unsigned int
+	calc_frddr_address(unsigned int reg, unsigned int base)
+{
+	return base + reg - EE_AUDIO_FRDDR_A_CTRL0;
+}
+
+
+/* Audio EQ DRC */
+static struct frddr_attach attach_aed;
+
+static irqreturn_t aml_ddr_isr(int irq, void *devid)
+{
+	(void)devid;
+	return IRQ_WAKE_THREAD;
+}
+
+/* to DDRS */
+static struct toddr *register_toddr_l(struct device *dev,
+	struct aml_audio_controller *actrl,
+	irq_handler_t handler, void *data)
+{
+	struct toddr *to;
+	unsigned int mask_bit;
+	int i, ret;
+
+	/* lookup unused toddr */
+	for (i = 0; i < DDRMAX; i++) {
+		if (!toddrs[i].in_use)
+			break;
+	}
+
+	if (i >= DDRMAX)
+		return NULL;
+
+	to = &toddrs[i];
+
+	/* irqs request */
+	ret = request_irq(to->irq, handler,
+		IRQF_OOB , dev_name(dev), data);
+	if (ret) {
+		dev_err(dev, "failed to claim irq %u\n", to->irq);
+		return NULL;
+	}
+	ret = irq_set_affinity(to->irq,&evl_oob_cpus);
+		if (ret) {
+		dev_err(dev, "failed to set irq %u  affinity to OOB cpus \n", to->irq);
+	}
+	/* enable audio ddr arb */
+	mask_bit = i;
+	/*aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*		(1 << 31)|(1 << mask_bit),*/
+	/*		(1 << 31)|(1 << mask_bit));*/
+
+	to->dev = dev;
+	to->actrl = actrl;
+	to->in_use = true;
+	pr_debug("toddrs[%d] registered by device %s\n", i, dev_name(dev));
+	return to;
+}
+
+static int unregister_toddr_l(struct device *dev, void *data)
+{
+	struct toddr *to;
+	struct aml_audio_controller *actrl;
+	unsigned int mask_bit;
+	unsigned int value;
+	int i;
+
+	if (dev == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if ((toddrs[i].dev) == dev && toddrs[i].in_use)
+			break;
+	}
+
+	if (i >= DDRMAX)
+		return -EINVAL;
+
+	to = &toddrs[i];
+
+	/* disable audio ddr arb */
+	mask_bit = i;
+	actrl = to->actrl;
+	/*aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*		1 << mask_bit, 0 << mask_bit);*/
+
+	/* no ddr active, disable arb switch */
+	value = aml_audiobus_read(actrl, EE_AUDIO_ARB_CTRL) & 0x77;
+	/*if (value == 0)*/
+	/*	aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*			1 << 31, 0 << 31);*/
+
+	free_irq(to->irq, data);
+	to->dev = NULL;
+	to->actrl = NULL;
+	to->in_use = false;
+	pr_debug("toddrs[%d] released by device %s\n", i, dev_name(dev));
+
+	return 0;
+}
+
+int fetch_toddr_index_by_src(int toddr_src)
+{
+	int i;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if (toddrs[i].in_use
+			&& (toddrs[i].src == toddr_src)) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+struct toddr *fetch_toddr_by_src(int toddr_src)
+{
+	int i;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if (toddrs[i].in_use
+			&& (toddrs[i].src == toddr_src)) {
+			return &toddrs[i];
+		}
+	}
+
+	return NULL;
+}
+
+struct toddr *aml_audio_register_toddr(struct device *dev,
+	struct aml_audio_controller *actrl,
+	irq_handler_t handler, void *data)
+{
+	struct toddr *to = NULL;
+
+	mutex_lock(&ddr_mutex);
+	to = register_toddr_l(dev, actrl,
+		handler, data);
+	mutex_unlock(&ddr_mutex);
+	return to;
+}
+
+int aml_audio_unregister_toddr(struct device *dev, void *data)
+{
+	int ret;
+
+	mutex_lock(&ddr_mutex);
+	ret = unregister_toddr_l(dev, data);
+	mutex_unlock(&ddr_mutex);
+	return ret;
+}
+
+static inline unsigned int
+	calc_toddr_address(unsigned int reg, unsigned int base)
+{
+	return base + reg - EE_AUDIO_TODDR_A_CTRL0;
+}
+
+int aml_toddr_set_buf(struct toddr *to, unsigned int start_a,
+			unsigned int end_a,unsigned int start_b,
+			unsigned int end_b)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	to->start_addr_a = start_a;
+	to->end_addr_a   = end_a;
+
+
+	// Switch to 2 buffers scheme - single for debug
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+	// aml_audiobus_update_bits(actrl, reg, 1<<29, 1<<29);
+	aml_audiobus_update_bits(actrl, reg, 1<<28, 1<<28);
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_START_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, start_a);
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_FINISH_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, end_a);
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_START_ADDRB, reg_base);
+	aml_audiobus_write(actrl, reg, start_b);
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_FINISH_ADDRB, reg_base);
+	aml_audiobus_write(actrl, reg, end_b);
+	/* int address */
+	if (to->chipinfo
+		&& (!to->chipinfo->int_start_same_addr)) {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_INIT_ADDR, reg_base);
+		aml_audiobus_write(actrl, reg, start_a);
+	}
+
+	return 0;
+}
+
+int aml_toddr_set_buf_startaddr_a(struct toddr *to, unsigned int start)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	to->start_addr_a = start;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_START_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, start);
+
+	/* int address */
+	if (to->chipinfo
+		&& (!to->chipinfo->int_start_same_addr)) {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_INIT_ADDR, reg_base);
+		aml_audiobus_write(actrl, reg, start);
+	}
+
+	return 0;
+}
+
+int aml_toddr_set_buf_endaddr_a(struct toddr *to, unsigned int end)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	to->end_addr_a   = end;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_FINISH_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, end);
+
+	return 0;
+}
+
+int aml_toddr_set_intrpt(struct toddr *to, unsigned int intrpt)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_INT_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, intrpt);
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+	aml_audiobus_update_bits(actrl, reg, 0xff << 16, 0x1 << 16);
+
+	return 0;
+}
+
+unsigned int aml_toddr_get_position(struct toddr *to)
+{
+	return aml_toddr_read_status2(to);
+}
+
+unsigned int aml_toddr_get_addr(struct toddr *to, enum status_sel sel)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg_sel, reg, addr;
+
+	reg_sel = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+	aml_audiobus_update_bits(actrl, reg_sel,
+		0xf << 8,
+		sel << 8);
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_STATUS2, reg_base);
+	addr = aml_audiobus_read(actrl, reg);
+
+
+	/* reset to default, current write addr */
+	aml_audiobus_update_bits(actrl, reg_sel,
+		0xf << 8,
+		0x2 << 8);
+
+	return addr;
+}
+
+void aml_toddr_enable(struct toddr *to, bool enable)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+	aml_audiobus_update_bits(actrl,	reg, 1<<31, enable<<31);
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+	pr_info("TDDR playback debug, TDDR CTRL0 = 0x%08x\n", aml_audiobus_read(actrl,reg));
+
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_START_ADDR, reg_base);
+	pr_info("TDDR playback debug, TDDR A_START = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_FINISH_ADDR, reg_base);
+	pr_info("TDDR playback debug, TDDR A_END = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_START_ADDRB, reg_base);
+	pr_info("TDDR playback debug, TDDR B_START = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_FINISH_ADDRB, reg_base);
+	pr_info("TDDR playback debug, TDDR B_END = 0x%08x\n", aml_audiobus_read(actrl,reg));
+
+	/* check resample */
+	// aml_check_resample(to, enable);
+
+	// if (to->chipinfo
+	// 	&& to->chipinfo->wakeup) {
+	// 	if (to->chipinfo->wakeup == 1) {
+	// 		/* check power detect */
+	// 		if (aml_check_pwrdet_module(to->src))
+	// 			aml_check_pwrdet(enable);
+	// 	} else if (to->chipinfo->wakeup == 2) {}
+	// 		/* check VAD */
+	// 		// aml_check_vad(to, enable);
+	// }
+
+	if (!enable)
+		aml_audiobus_write(actrl, reg, 0x0);
+}
+
+void aml_toddr_select_src(struct toddr *to, enum toddr_src src)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+	pr_info("TODDR source number selected = %d",src);
+	/* store to check toddr num */
+	to->src = src;
+
+	if (to->chipinfo
+		&& to->chipinfo->src_sel_ctrl) {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+		aml_audiobus_update_bits(actrl, reg,
+			0xf << 28,
+			(src & 0xf) << 28);
+	} else {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+		aml_audiobus_update_bits(actrl,	reg, 0x7, src & 0x7);
+	}
+}
+
+void aml_toddr_set_fifos(struct toddr *to, unsigned int thresh)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg, mask, val;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+	
+	if (to->chipinfo
+			&& to->chipinfo->src_sel_ctrl) {
+		mask = 0xfff << 12 | 0xf << 8;
+		val = (thresh-2) << 12 | 2 << 8;
+	} else {
+		mask = 0xff << 16 | 0xf << 8;
+		val = (thresh-2) << 16 | 2 << 8;
+	}
+
+	aml_audiobus_update_bits(actrl, reg, mask, val);
+
+	if (to->chipinfo && to->chipinfo->ugt) {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+		aml_audiobus_update_bits(actrl, reg, 0x1, 0x1);
+	}
+}
+
+void aml_toddr_update_fifos_rd_th(struct toddr *to, int th)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg, mask, val;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+	if (to->chipinfo
+		&& to->chipinfo->src_sel_ctrl) {
+		mask = 0xfff << 12;
+		val = (th - 1) << 12;
+	} else {
+		mask = 0xff << 16;
+		val = (th - 1) << 16;
+	}
+	aml_audiobus_update_bits(actrl, reg, mask, val);
+}
+
+void aml_toddr_force_finish(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+	aml_audiobus_update_bits(actrl, reg, 1 << 25, 1 << 25);
+	aml_audiobus_update_bits(actrl, reg, 1 << 25, 0 << 25);
+}
+
+void aml_toddr_set_format(struct toddr *to, struct toddr_fmt *fmt)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+	printk("TODDR Set format, bit depth = %d",fmt->bit_depth);
+	printk("TODDR Set format, rate = %d",fmt->rate);
+	printk("TODDR Set format, chnum = %d",fmt->ch_num);
+
+	to->bitdepth = fmt->bit_depth;
+	to->channels = fmt->ch_num;
+	to->rate     = fmt->rate;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+	aml_audiobus_update_bits(actrl, reg,
+		// Debug
+		0x7 << 24 | 0x1fff << 3,
+		fmt->endian << 24 | fmt->type << 13 |
+		fmt->msb << 8 | fmt->lsb << 3);
+}
+
+unsigned int aml_toddr_get_status(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_STATUS1, reg_base);
+
+	return aml_audiobus_read(actrl, reg);
+}
+
+void aml_toddr_ack_irq(struct toddr *to, int status)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+
+	aml_audiobus_update_bits(actrl, reg, MEMIF_INT_MASK, status);
+	aml_audiobus_update_bits(actrl, reg, MEMIF_INT_MASK, 0);
+}
+
+void aml_frddr_ack_irq(struct frddr *fr, int status)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL1, reg_base);
+
+	aml_audiobus_update_bits(actrl, reg, MEMIF_INT_MASK, status);
+	aml_audiobus_update_bits(actrl, reg, MEMIF_INT_MASK, 0);
+}
+
+void aml_toddr_insert_chanum(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+	aml_audiobus_update_bits(actrl, reg, 1 << 24, 1 << 24);
+}
+
+unsigned int aml_toddr_read(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+
+	return aml_audiobus_read(actrl, reg);
+}
+
+void aml_toddr_write(struct toddr *to, unsigned int val)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+
+	aml_audiobus_write(actrl, reg, val);
+}
+
+unsigned int aml_toddr_read1(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+
+	return aml_audiobus_read(actrl, reg);
+}
+
+void aml_toddr_write1(struct toddr *to, unsigned int val)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+
+	aml_audiobus_write(actrl, reg, val);
+}
+
+unsigned int aml_toddr_read_status2(struct toddr *to)
+{
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	reg = calc_toddr_address(EE_AUDIO_TODDR_A_STATUS2, reg_base);
+
+	return aml_audiobus_read(actrl, reg);
+}
+
+bool aml_toddr_burst_finished(struct toddr *to)
+{
+	unsigned int addr_request, addr_reply, i = 0;
+	struct aml_audio_controller *actrl = to->actrl;
+	unsigned int reg_base = to->reg_base;
+	unsigned int reg;
+
+	/* max 200us delay */
+	for (i = 0; i < 200; i++) {
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+		aml_audiobus_update_bits(actrl,	reg, 0xf << 8, 0x0 << 8);
+		addr_request = aml_toddr_get_position(to);
+
+		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+		aml_audiobus_update_bits(actrl,	reg, 0xf << 8, 0x2 << 8);
+		addr_reply = aml_toddr_get_position(to);
+
+		if (addr_request == addr_reply)
+			return true;
+
+		udelay(1);
+		pr_debug("delay:[%dus]; FRDDR_STATUS2: [0x%x] [0x%x]\n",
+			i, addr_request, addr_reply);
+	}
+	pr_err("Error: 200us time out, TODDR_STATUS2: [0x%x] [0x%x]\n",
+				addr_request, addr_reply);
+	return false;
+}
+
+/* not for tl1 */
+// static void aml_toddr_set_resample(struct toddr *to, bool enable)
+// {
+// 	struct aml_audio_controller *actrl = to->actrl;
+// 	unsigned int reg_base = to->reg_base;
+// 	unsigned int reg;
+
+// 	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+// 	aml_audiobus_update_bits(actrl,	reg, 1<<30, !!enable<<30);
+// }
+// /* tl1 after */
+// static void aml_toddr_set_resample_ab(struct toddr *to,
+// 		enum resample_idx index, bool enable)
+// {
+// 	struct aml_audio_controller *actrl = to->actrl;
+// 	unsigned int reg_base = to->reg_base;
+// 	unsigned int reg;
+
+// 	reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL1, reg_base);
+// 	if (index == RESAMPLE_A)
+// 		aml_audiobus_update_bits(actrl,	reg, 1 << 27, !!enable << 27);
+// 	else if (index == RESAMPLE_B)
+// 		aml_audiobus_update_bits(actrl,	reg, 1 << 26, !!enable << 26);
+// }
+
+// static void aml_resample_enable(
+// 	struct toddr *to,
+// 	struct toddr_attach *p_attach_resample,
+// 	bool enable)
+// {
+// 	if (!to || !p_attach_resample) {
+// 		pr_err("%s(), NULL pointer.", __func__);
+// 		return;
+// 	}
+
+// 	if (to->chipinfo
+// 			&& to->chipinfo->asrc_src_sel_ctrl) {
+// 		/* fix asrc_src_sel */
+// 		switch (p_attach_resample->attach_module) {
+// 		case LOOPBACK_A:
+// 			to->asrc_src_sel = ASRC_LOOPBACK_A;
+// 			break;
+// 		case LOOPBACK_B:
+// 			to->asrc_src_sel = ASRC_LOOPBACK_B;
+// 			break;
+// 		default:
+// 			to->asrc_src_sel = to->fifo_id;
+// 			break;
+// 		}
+
+// 		/*to->asrc_src_sel = p_attach_resample->attach_module;*/
+// 	}
+
+// 	pr_info("toddr %d selects data to %s resample_%c for module:%s\n",
+// 		to->fifo_id,
+// 		enable ? "enable" : "disable",
+// 		(p_attach_resample->id == RESAMPLE_A) ? 'a' : 'b',
+// 		toddr_src_get_str(p_attach_resample->attach_module)
+// 		);
+
+// 	if (enable) {
+// 		int bitwidth = to->bitdepth;
+// 		/* channels and bit depth for resample */
+
+// 		if (to->chipinfo
+// 			&& to->chipinfo->asrc_only_left_j
+// 			/*&& (to->src == SPDIFIN)*/
+// 			&& (bitwidth == 32)) {
+// 			struct aml_audio_controller *actrl = to->actrl;
+// 			unsigned int reg_base = to->reg_base;
+// 			unsigned int reg;
+// 			unsigned int endian, toddr_type;
+
+// 			/* TODO: fixed me */
+// 			pr_info("Warning: Not support 32bit sample rate for axg chipset\n");
+// 			bitwidth = 24;
+// 			endian = 5;
+// 			toddr_type = 4;
+
+// 			/* FIX ME */
+// 			reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0,
+// 				reg_base);
+// 			aml_audiobus_update_bits(actrl, reg,
+// 				0x7 << 24 | 0x7 << 13,
+// 				endian << 24 | toddr_type << 13);
+// 		}
+
+// 		resample_format_set(p_attach_resample->id,
+// 			to->channels, bitwidth);
+
+// 		/* toddr index for resample */
+// 		if (to->chipinfo
+// 			&& to->chipinfo->asrc_src_sel_ctrl)
+// 			resample_src_select_ab(p_attach_resample->id,
+// 				to->asrc_src_sel);
+// 		else
+// 			resample_src_select(to->fifo_id);
+// 	}
+
+// 	/* resample enable or not */
+// 	resample_enable(p_attach_resample->id, enable);
+
+// 	/* select reample data */
+// 	if (to->chipinfo
+// 			&& to->chipinfo->asrc_src_sel_ctrl)
+// 		aml_toddr_set_resample_ab(to, p_attach_resample->id, enable);
+// 	else
+// 		aml_toddr_set_resample(to, enable);
+// }
+
+// void aml_set_resample(enum resample_idx id,
+// 		bool enable, enum toddr_src resample_module)
+// {
+// 	struct toddr_attach *p_attach_resample;
+// 	struct toddr *to;
+// 	bool update_running = false;
+
+// 	if (id == RESAMPLE_A)
+// 		p_attach_resample = &attach_resample_a;
+// 	else
+// 		p_attach_resample = &attach_resample_b;
+
+// 	p_attach_resample->enable        = enable;
+// 	p_attach_resample->id            = id;
+// 	p_attach_resample->attach_module = resample_module;
+
+// 	mutex_lock(&ddr_mutex);
+// 	to = fetch_toddr_by_src(
+// 		p_attach_resample->attach_module);
+// 	if (to == NULL) {
+// 		pr_info("%s(), toddr NULL\n", __func__);
+// 		goto exit;
+// 	}
+
+// 	if (enable) {
+// 		if ((p_attach_resample->status == DISABLED)
+// 			|| (p_attach_resample->status == READY)) {
+
+// 			if (!to) {
+// 				p_attach_resample->status = READY;
+// 			} else {
+// 				p_attach_resample->status = RUNNING;
+// 				update_running = true;
+// 				pr_info("Capture with resample\n");
+// 			}
+// 		}
+// 	} else {
+// 		if (p_attach_resample->status == RUNNING)
+// 			update_running = true;
+
+// 		p_attach_resample->status = DISABLED;
+// 	}
+
+// 	if (update_running && to)
+// 		aml_resample_enable(to, p_attach_resample, enable);
+
+// exit:
+// 	mutex_unlock(&ddr_mutex);
+// }
+
+// /*
+//  * when try to enable resample, if toddr is not in used,
+//  * set resample status as ready
+//  */
+// static void aml_check_resample(struct toddr *to, bool enable)
+// {
+// 	struct toddr_attach *p_attach_resample;
+// 	bool is_module_resample;
+// 	bool resample_b_check = false;
+
+// 	p_attach_resample = &attach_resample_a;
+
+// start_check:
+// 	is_module_resample = false;
+// 	if (p_attach_resample->enable
+// 		&& (to->src == p_attach_resample->attach_module))
+// 		is_module_resample = true;
+
+// 	/* resample in enable */
+// 	if (is_module_resample) {
+// 		if (enable)
+// 			p_attach_resample->status = RUNNING;
+// 		else
+// 			p_attach_resample->status = DISABLED;
+
+// 		aml_resample_enable(to, p_attach_resample, enable);
+// 	}
+
+// 	if ((!resample_b_check)
+// 		&& (get_resample_module_num() == 2)) {
+// 		p_attach_resample = &attach_resample_b;
+// 		resample_b_check = true;
+// 		goto start_check;
+// 	}
+// }
+
+// static void aml_set_pwrdet(struct toddr *to,
+// 	bool enable)
+// {
+// 	if (enable) {
+// 		struct aml_audio_controller *actrl = to->actrl;
+// 		unsigned int reg_base = to->reg_base;
+// 		unsigned int reg, val;
+// 		unsigned int toddr_type, msb, lsb;
+
+// 		reg = calc_toddr_address(EE_AUDIO_TODDR_A_CTRL0, reg_base);
+// 		val = aml_audiobus_read(actrl, reg);
+// 		toddr_type = (val >> 13) & 0x7;
+// 		msb = (val >> 8) & 0x1f;
+// 		lsb = (val >> 3) & 0x1f;
+
+// 		aml_pwrdet_format_set(toddr_type, msb, lsb);
+// 	}
+// 	pwrdet_src_select(enable, to->src);
+// }
+
+// void aml_pwrdet_enable(bool enable, int pwrdet_module)
+// {
+// 	attach_pwrdet.enable = enable;
+// 	attach_pwrdet.attach_module = pwrdet_module;
+// 	if (enable) {
+// 		if ((attach_pwrdet.status == DISABLED)
+// 			|| (attach_pwrdet.status == READY)) {
+// 			struct toddr *to = fetch_toddr_by_src(pwrdet_module);
+
+// 			if (!to) {
+// 				attach_pwrdet.status = READY;
+// 			} else {
+// 				attach_pwrdet.status = RUNNING;
+// 				aml_set_pwrdet(to, enable);
+// 				pr_info("Capture with power detect\n");
+// 			}
+// 		}
+// 	} else {
+// 		if (attach_pwrdet.status == RUNNING) {
+// 			struct toddr *to = fetch_toddr_by_src(pwrdet_module);
+
+// 			if (to)
+// 				aml_set_pwrdet(to, enable);
+// 		}
+// 		attach_pwrdet.status = DISABLED;
+// 	}
+// }
+
+// static bool aml_check_pwrdet_module(int src)
+// {
+// 	bool is_module_pwrdet = false;
+
+// 	if (attach_pwrdet.enable
+// 		&& (src == attach_pwrdet.attach_module))
+// 		is_module_pwrdet = true;
+
+// 	return is_module_pwrdet;
+// }
+
+// static void aml_check_pwrdet(bool enable)
+// {
+// 	/* power detect in enable */
+// 	if (attach_pwrdet.enable) {
+// 		if (enable) {
+// 			/* check whether ready ? */
+// 			if (attach_pwrdet.status == READY)
+// 				aml_pwrdet_enable(true,
+// 					attach_pwrdet.attach_module);
+// 		} else {
+// 			if (attach_pwrdet.status == RUNNING)
+// 				attach_pwrdet.status = READY;
+// 		}
+// 	}
+// }
+
+
+
+
+
+/* from DDRS */
+static struct frddr *register_frddr_l(struct device *dev,
+	struct aml_audio_controller *actrl,
+	irq_handler_t handler, void *data, bool rvd_dst)
+{
+	struct frddr *from;
+	unsigned int mask_bit;
+	int i, ret;
+
+	for (i = 0; i < DDRMAX; i++) {
+		/* lookup reserved frddr */
+		if (frddrs[i].in_use == false &&
+			frddrs[i].reserved == true &&
+			rvd_dst == true)
+			break;
+		/* lookup unused frddr */
+		if (frddrs[i].in_use == false &&
+			frddrs[i].reserved == false &&
+			rvd_dst == false)
+			break;
+	}
+
+	if (i >= DDRMAX)
+		return NULL;
+
+	from = &frddrs[i];
+
+	/* enable audio ddr arb */
+	mask_bit = i + 4;
+	/*aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*		(1 << 31)|(1 << mask_bit),*/
+	/*		(1 << 31)|(1 << mask_bit));*/
+
+	/* irqs request */
+	ret = request_irq(from->irq,  handler,
+		IRQF_OOB , dev_name(dev), data);
+	if (ret) {
+		dev_err(dev, "failed to claim irq %u\n", from->irq);
+		return NULL;
+	}
+	ret = irq_set_affinity(from->irq,&evl_oob_cpus);
+		if (ret) {
+		dev_err(dev, "failed to set irq %u  affinity to OOB cpus \n", from->irq);
+	}
+	from->dev = dev;
+	from->actrl = actrl;
+	from->in_use = true;
+	pr_debug("frddrs[%d] registered by device %s\n", i, dev_name(dev));
+	return from;
+}
+
+static int unregister_frddr_l(struct device *dev, void *data)
+{
+	struct frddr *from;
+	struct aml_audio_controller *actrl;
+	unsigned int mask_bit;
+	unsigned int value;
+	int i;
+
+	if (dev == NULL)
+		return -EINVAL;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if ((frddrs[i].dev) == dev && frddrs[i].in_use)
+			break;
+	}
+
+	if (i >= DDRMAX)
+		return -EINVAL;
+
+	from = &frddrs[i];
+
+	/* disable audio ddr arb */
+	mask_bit = i + 4;
+	actrl = from->actrl;
+	/*aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*		1 << mask_bit, 0 << mask_bit);*/
+
+	/* no ddr active, disable arb switch */
+	value = aml_audiobus_read(actrl, EE_AUDIO_ARB_CTRL) & 0x77;
+	/*if (value == 0)*/
+	/*	aml_audiobus_update_bits(actrl, EE_AUDIO_ARB_CTRL,*/
+	/*			1 << 31, 0 << 31);*/
+
+	free_irq(from->irq, data);
+	from->dev = NULL;
+	from->actrl = NULL;
+	from->in_use = false;
+	pr_debug("frddrs[%d] released by device %s\n", i, dev_name(dev));
+	return 0;
+}
+
+int fetch_frddr_index_by_src(int frddr_src)
+{
+	int i;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if (frddrs[i].in_use
+			&& (frddrs[i].dest == frddr_src)) {
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+struct frddr *fetch_frddr_by_src(int frddr_src)
+{
+	int i;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if (frddrs[i].in_use
+			&& (frddrs[i].dest == frddr_src)) {
+			return &frddrs[i];
+		}
+	}
+
+	return NULL;
+}
+
+struct frddr *aml_audio_register_frddr(struct device *dev,
+	struct aml_audio_controller *actrl,
+	irq_handler_t handler, void *data, bool rvd_dst)
+{
+	struct frddr *fr = NULL;
+
+	mutex_lock(&ddr_mutex);
+	fr = register_frddr_l(dev, actrl, handler, data, rvd_dst);
+	mutex_unlock(&ddr_mutex);
+	return fr;
+}
+
+int aml_audio_unregister_frddr(struct device *dev, void *data)
+{
+	int ret;
+
+	mutex_lock(&ddr_mutex);
+	ret = unregister_frddr_l(dev, data);
+	mutex_unlock(&ddr_mutex);
+	return ret;
+}
+
+
+
+/*
+ * check frddr_src is used by other frddr for sharebuffer
+ * if used, disabled the other share frddr src, the module would
+ * for current frddr, and the checked frddr
+ */
+int aml_check_sharebuffer_valid(struct frddr *fr, int ss_sel)
+{
+	int current_fifo_id = fr->fifo_id;
+	unsigned int i;
+	int ret = 1;
+
+	for (i = 0; i < DDRMAX; i++) {
+		if (frddrs[i].in_use
+			&& (frddrs[i].fifo_id != current_fifo_id)
+			&& (frddrs[i].dest == ss_sel)) {
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/* select dst for same source
+ * sel: share buffer req_sel 1~2
+ * sel 0 is aleardy used for reg_frddr_src_sel1
+ * sel 1 is for reg_frddr_src_sel2
+ * sel 2 is for reg_frddr_src_sel3
+ */
+static void frddr_set_sharebuffer_enable(
+	struct frddr *fr,  int dst, int sel, bool enable)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+	int s_v = 0, s_m = 0;
+
+	if (fr->chipinfo
+		&& fr->chipinfo->src_sel_ctrl) {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL2,
+				reg_base);
+
+		switch (sel) {
+		case 1:
+			s_m = 0x17 << 8;
+			s_v = enable ?
+				(dst << 8 | 1 << 12) : 0 << 8;
+			break;
+		case 2:
+			s_m = 0x17 << 16;
+			s_v = enable ?
+				(dst << 16 | 1 << 20) : 0 << 16;
+			break;
+		default:
+			pr_warn_once("sel :%d is not supported for same source\n",
+				sel);
+			break;
+		}
+	} else {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0,
+				reg_base);
+
+		switch (sel) {
+		case 1:
+			s_m = 0xf << 4;
+			s_v = enable ?
+				(dst << 4 | 1 << 7) : 0 << 4;
+			break;
+		case 2:
+			s_m = 0xf << 8;
+			s_v = enable ?
+				(dst << 8 | 1 << 11) : 0 << 8;
+			break;
+		default:
+			pr_warn_once("sel :%d is not supported for same source\n",
+				sel);
+			break;
+		}
+	}
+	pr_debug("%s sel:%d, dst_src:%d\n",
+		__func__, sel, dst);
+	fr->ss_dest = enable ? dst : 0;
+	fr->ss_en = enable;
+
+	aml_audiobus_update_bits(actrl, reg, s_m, s_v);
+}
+
+/*
+ * check frddr_src is used by other frddr for sharebuffer
+ * if used for share frddr src, release from sharebuffer
+ * and used for new frddr
+ */
+static int aml_check_and_release_sharebuffer(struct frddr *fr, int ss_sel)
+{
+	int current_fifo_id = fr->fifo_id;
+	unsigned int i;
+	int ret = 1;
+
+	for (i = 0; i < DDRMAX; i++) {
+		struct frddr *from = &frddrs[i];
+
+		if (from->in_use
+			&& (from->fifo_id != current_fifo_id)
+			&& from->ss_en
+			&& (from->ss_dest == ss_sel)) {
+
+			frddr_set_sharebuffer_enable(from,
+				ss_sel,
+				1,
+				false);
+
+			pr_debug("%s, ss_sel:%d release from share buffer, use for new playback\n",
+				__func__,
+				ss_sel);
+			ret = 0;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+int aml_frddr_set_buf(struct frddr *fr, unsigned int start_a,
+			unsigned int end_a,unsigned int start_b,
+			unsigned int end_b)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	// Switch to 2 buffers scheme
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+	aml_audiobus_update_bits(actrl, reg, 1<<30, 1<<30);
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_START_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, start_a);
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_FINISH_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, end_a);
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_START_ADDRB, reg_base);
+	aml_audiobus_write(actrl, reg, start_b);
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_FINISH_ADDRB, reg_base);
+	aml_audiobus_write(actrl, reg, end_b);
+	/* int address */
+	if (fr->chipinfo
+		&& (!fr->chipinfo->int_start_same_addr)) {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_INIT_ADDR, reg_base);
+		aml_audiobus_write(actrl, reg, start_a);
+	}
+
+	return 0;
+}
+
+int aml_frddr_set_intrpt(struct frddr *fr, unsigned int intrpt)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_INT_ADDR, reg_base);
+	aml_audiobus_write(actrl, reg, intrpt);
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+	// Enable intr on finish address
+	// aml_audiobus_update_bits(actrl, reg, 0xff<<16, 4<<16);
+	// Debug - no interupts at all
+	aml_audiobus_update_bits(actrl, reg, 0xff<<16, 1<<16);
+
+	return 0;
+}
+
+unsigned int aml_frddr_get_position(struct frddr *fr)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_STATUS2, reg_base);
+	return aml_audiobus_read(actrl, reg);
+}
+
+void aml_frddr_enable(struct frddr *fr, bool enable)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+	/* ensure disable before enable frddr */
+	aml_audiobus_update_bits(actrl,	reg, 1<<31, enable<<31);
+
+	// Debugging
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+	pr_info("FDDR playback debug, FDDR CTRL0 = 0x%08x\n", aml_audiobus_read(actrl,reg));
+
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_START_ADDR, reg_base);
+	pr_info("FDDR playback debug, FDDR A_START = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_FINISH_ADDR, reg_base);
+	pr_info("FDDR playback debug, FDDR A_END = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_START_ADDRB, reg_base);
+	pr_info("FDDR playback debug, FDDR B_START = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_FINISH_ADDRB, reg_base);
+	pr_info("FDDR playback debug, FDDR B_END = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	if (!enable) {
+		aml_audiobus_write(actrl, reg, 0x0);
+
+		/* clr src sel and its en */
+		if (fr->chipinfo
+			&& fr->chipinfo->src_sel_ctrl) {
+			reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL2,
+				reg_base);
+			aml_audiobus_write(actrl, reg, 0x0);
+		}
+	}
+}
+
+void aml_frddr_select_dst(struct frddr *fr, enum frddr_dest dst)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg, src_sel_en;
+
+	fr->dest = dst;
+
+	if (fr->chipinfo
+		&& fr->chipinfo->src_sel_ctrl) {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL2, reg_base);
+		src_sel_en = 4;
+		/*update frddr channel*/
+		aml_audiobus_update_bits(actrl, reg,
+			0xff << 24, (fr->channels - 1) << 24);
+	} else {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+		src_sel_en = 3;
+	}
+
+	/* if sharebuffer in use, release it */
+	if (fr->chipinfo
+		&& fr->chipinfo->same_src_fn)
+		aml_check_and_release_sharebuffer(fr, dst);
+
+	aml_audiobus_update_bits(actrl, reg, 0x7, dst & 0x7);
+
+	/* same source en */
+	if (fr->chipinfo
+		&& fr->chipinfo->same_src_fn) {
+		aml_audiobus_update_bits(actrl, reg,
+			1 << src_sel_en, 1 << src_sel_en);
+	}
+}
+
+/* select dst for same source
+ * sel: share buffer req_sel 1~2
+ * sel 0 is aleardy used for reg_frddr_src_sel1
+ * sel 1 is for reg_frddr_src_sel2
+ * sel 2 is for reg_frddr_src_sel3
+ */
+void aml_frddr_select_dst_ss(struct frddr *fr,
+	enum frddr_dest dst, int sel, bool enable)
+{
+	unsigned int ss_valid = aml_check_sharebuffer_valid(fr, dst);
+
+	/* same source en */
+	if (fr->chipinfo
+		&& fr->chipinfo->same_src_fn
+		&& ss_valid) {
+		frddr_set_sharebuffer_enable(fr,
+			dst, sel, enable);
+	}
+}
+
+void aml_frddr_set_fifos(struct frddr *fr,
+		unsigned int depth, unsigned int thresh)
+{
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL1, reg_base);
+	aml_audiobus_update_bits(actrl,	reg,
+			0xffff<<16 | 0xf<<8,
+			(depth - 1)<<24 | (thresh - 1)<<16 | 2<<8);
+
+	if (fr->chipinfo && fr->chipinfo->ugt) {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL0, reg_base);
+		aml_audiobus_update_bits(actrl, reg, 0x1, 0x1);
+	}
+}
+
+unsigned int aml_frddr_get_fifo_id(struct frddr *fr)
+{
+	return fr->fifo_id;
+}
+
+void aml_frddr_set_format(struct frddr *fr,
+	unsigned int chnum,
+	unsigned int msb,
+	unsigned int frddr_type)
+{
+	fr->channels = chnum;
+	fr->msb  = msb;
+	fr->type = frddr_type;
+	printk("FRDDR Set format, msb = %d",msb);
+	printk("FRDDR Set format, type = %d",frddr_type);
+	printk("FRDDR Set format, chnum = %d",chnum);
+
+}
+
+// static void aml_aed_enable(struct frddr_attach *p_attach_aed, bool enable)
+// {
+// 	struct frddr *fr = fetch_frddr_by_src(p_attach_aed->attach_module);
+// 	int aed_version = check_aed_version();
+
+// 	if (aed_version == VERSION2 || aed_version == VERSION3) {
+// 		struct aml_audio_controller *actrl = fr->actrl;
+// 		unsigned int reg_base = fr->reg_base;
+// 		unsigned int reg;
+
+// 		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL2, reg_base);
+// 		if (enable) {
+// 			aml_audiobus_update_bits(actrl,
+// 				reg, 0x1 << 3, enable << 3);
+// 			if (aed_version == VERSION3) {
+// 				aed_set_ctrl(enable, 0,
+// 					p_attach_aed->attach_module, 1);
+// 				aed_set_format(fr->msb,
+// 					fr->type, fr->fifo_id, 1);
+// 			} else {
+// 				aed_set_ctrl(enable, 0,
+// 					p_attach_aed->attach_module, 0);
+// 				aed_set_format(fr->msb,
+// 					fr->type, fr->fifo_id, 0);
+// 			}
+// 			aed_enable(enable);
+// 		} else {
+// 			aed_enable(enable);
+// 			if (aed_version == VERSION3) {
+// 				aed_set_ctrl(enable, 0,
+// 					p_attach_aed->attach_module, 1);
+// 			} else {
+// 				aed_set_ctrl(enable, 0,
+// 					p_attach_aed->attach_module, 0);
+// 			}
+// 			aml_audiobus_update_bits(actrl,
+// 				reg, 0x1 << 3, enable << 3);
+// 		}
+// 	} else if (aed_version == VERSION1) {
+// 		if (enable) {
+// 			/* frddr type and bit depth for AED */
+// 			aml_aed_format_set(fr->dest);
+// 		}
+// 		aed_src_select(enable, fr->dest, fr->fifo_id);
+// 	}
+// }
+
+// static bool aml_check_aed_module(int dst)
+// {
+// 	bool is_module_aed = false;
+
+// 	if (attach_aed.enable
+// 		&& (dst == attach_aed.attach_module))
+// 		is_module_aed = true;
+
+// 	return is_module_aed;
+// }
+
+// void aml_set_aed(bool enable, int aed_module)
+// {
+// 	attach_aed.enable = enable;
+// 	attach_aed.attach_module = aed_module;
+// }
+
+// void aml_aed_top_enable(struct frddr *fr, bool enable)
+// {
+// 	if (aml_check_aed_module(fr->dest))
+// 		aml_aed_enable(&attach_aed, enable);
+// }
+
+// void aml_aed_set_frddr_reserved(void)
+// {
+// 	frddrs[DDR_A].reserved = true;
+// }
+
+void aml_frddr_check(struct frddr *fr)
+{
+	unsigned int tmp, tmp1, i = 0;
+	struct aml_audio_controller *actrl = fr->actrl;
+	unsigned int reg_base = fr->reg_base;
+	unsigned int reg;
+
+	/*max 200us delay*/
+	for (i = 0; i < 200; i++) {
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL1, reg_base);
+		aml_audiobus_update_bits(actrl,	reg, 0xf << 8, 0x0 << 8);
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_STATUS2, reg_base);
+		tmp = aml_audiobus_read(actrl, reg);
+
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_CTRL1, reg_base);
+		aml_audiobus_update_bits(actrl,	reg, 0xf << 8, 0x2 << 8);
+		reg = calc_frddr_address(EE_AUDIO_FRDDR_A_STATUS2, reg_base);
+		tmp1 = aml_audiobus_read(actrl, reg);
+
+		if (tmp == tmp1)
+			return;
+
+		udelay(1);
+		pr_debug("delay:[%dus]; FRDDR_STATUS2: [0x%x] [0x%x]\n",
+			i, tmp, tmp1);
+	}
+	pr_err("Error: 200us time out, FRDDR_STATUS2: [0x%x] [0x%x]\n",
+				tmp, tmp1);
+	return;
+}
+
+void aml_frddr_reset(struct frddr *fr, int offset)
+{
+	unsigned int reg = 0, val = 0;
+
+	if (fr == NULL) {
+		pr_err("%s(), frddr NULL pointer\n", __func__);
+		return;
+	}
+
+	if ((offset != 0) && (offset != 1)) {
+		pr_err("%s(), invalid offset = %d\n", __func__, offset);
+		return;
+	}
+
+	if (fr->fifo_id == 0) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_FRDDRA;
+	} else if (fr->fifo_id == 1) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_FRDDRB;
+	} else if (fr->fifo_id == 2) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_FRDDRC;
+	} else if (fr->fifo_id == 3) {
+		reg = EE_AUDIO_SW_RESET1;
+		val = REG_BIT_RESET_FRDDRD;
+	} else {
+		pr_err("invalid frddr id %d\n", fr->fifo_id);
+		return;
+	}
+
+	audiobus_update_bits(reg, val, val);
+	audiobus_update_bits(reg, val, 0);
+}
+
+// void frddr_init_without_mngr(unsigned int frddr_index, unsigned int src0_sel)
+// {
+// 	unsigned int offset, reg;
+// 	unsigned int start_addr, end_addr, int_addr;
+// 	static int buf[256];
+
+// 	memset(buf, 0x0, sizeof(buf));
+// 	start_addr = virt_to_phys(buf);
+// 	end_addr = start_addr + sizeof(buf) - 1;
+// 	int_addr = sizeof(buf) / 64;
+
+// 	offset = EE_AUDIO_FRDDR_B_START_ADDR - EE_AUDIO_FRDDR_A_START_ADDR;
+// 	reg = EE_AUDIO_FRDDR_A_START_ADDR + offset * frddr_index;
+// 	audiobus_write(reg, start_addr);
+
+// 	offset = EE_AUDIO_FRDDR_B_INIT_ADDR - EE_AUDIO_FRDDR_A_INIT_ADDR;
+// 	reg = EE_AUDIO_FRDDR_A_INIT_ADDR + offset * frddr_index;
+// 	audiobus_write(reg, start_addr);
+
+// 	offset = EE_AUDIO_FRDDR_B_FINISH_ADDR - EE_AUDIO_FRDDR_A_FINISH_ADDR;
+// 	reg = EE_AUDIO_FRDDR_A_FINISH_ADDR + offset * frddr_index;
+// 	audiobus_write(reg, end_addr);
+
+// 	offset = EE_AUDIO_FRDDR_B_INT_ADDR - EE_AUDIO_FRDDR_A_INT_ADDR;
+// 	reg = EE_AUDIO_FRDDR_A_INT_ADDR + offset * frddr_index;
+// 	audiobus_write(reg, int_addr);
+
+// 	offset = EE_AUDIO_FRDDR_B_CTRL1 - EE_AUDIO_FRDDR_A_CTRL1;
+// 	reg = EE_AUDIO_FRDDR_A_CTRL1 + offset * frddr_index;
+// 	audiobus_write(reg,
+// 		(0x40 - 1) << 24 | (0x20 - 1) << 16 | 2 << 8 | 0 << 0);
+
+// 	offset = EE_AUDIO_FRDDR_B_CTRL0 - EE_AUDIO_FRDDR_A_CTRL0;
+// 	reg = EE_AUDIO_FRDDR_A_CTRL0 + offset * frddr_index;
+// 	audiobus_write(reg,
+// 		1 << 31
+// 		| 0 << 24
+// 		| 4 << 16
+// 		| 1 << 3 /* src0 enable */
+// 		| src0_sel << 0 /* src0 sel */
+// 	);
+// }
+
+// void frddr_deinit_without_mngr(unsigned int frddr_index)
+// {
+// 	unsigned int offset, reg;
+
+// 	offset = EE_AUDIO_FRDDR_B_CTRL0 - EE_AUDIO_FRDDR_A_CTRL0;
+// 	reg = EE_AUDIO_FRDDR_A_CTRL0 + offset * frddr_index;
+// 	audiobus_write(reg, 0x0);
+// }
+
+// static enum toddr_src toddr_src_idx = TODDR_INVAL;
+
+// static const char *const toddr_src_sel_texts[] = {
+// 	"TDMIN_A", "TDMIN_B", "TDMIN_C", "SPDIFIN",
+// 	"PDMIN", "FRATV", "TDMIN_LB", "LOOPBACK_A",
+// 	"FRHDMIRX", "LOOPBACK_B", "SPDIFIN_LB",
+// 	"EARCRX_DMAC", "RESERVED_0", "RESERVED_1", "RESERVED_2"
+
+// };
+
+// static const struct soc_enum toddr_input_source_enum =
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(toddr_src_sel_texts),
+// 		toddr_src_sel_texts);
+
+// enum toddr_src toddr_src_get(void)
+// {
+// 	return toddr_src_idx;
+// }
+
+// const char *toddr_src_get_str(enum toddr_src idx)
+// {
+// 	if (idx < TDMIN_A || idx > EARCRX_DMAC)
+// 		return NULL;
+
+// 	return toddr_src_sel_texts[idx];
+// }
+
+// static int toddr_src_enum_get(struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol)
+// {
+// 	ucontrol->value.enumerated.item[0] = toddr_src_idx;
+
+// 	return 0;
+// }
+
+// static int toddr_src_enum_set(struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol)
+// {
+// 	toddr_src_idx = ucontrol->value.enumerated.item[0];
+// 	/* also update to resample src */
+// 	//set_resample_source(toddr_src_idx);
+
+// 	return 0;
+// }
+
+// static int frddr_src_idx = -1;
+
+static const char *const frddr_src_sel_texts[] = {
+	"TDMOUT_A", "TDMOUT_B", "TDMOUT_C", "SPDIFOUT_A", "SPDIFOUT_B"
+};
+
+// static const struct soc_enum frddr_output_source_enum =
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(frddr_src_sel_texts),
+// 		frddr_src_sel_texts);
+
+// int frddr_src_get(void)
+// {
+// 	return frddr_src_idx;
+// }
+
+// const char *frddr_src_get_str(int idx)
+// {
+// 	if (idx < 0 || idx > 4)
+// 		return NULL;
+
+// 	return frddr_src_sel_texts[idx];
+// }
+
+// static int frddr_src_enum_get(struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol)
+// {
+// 	ucontrol->value.enumerated.item[0] = frddr_src_idx;
+
+// 	return 0;
+// }
+
+// static int frddr_src_enum_set(struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol)
+// {
+// 	frddr_src_idx = ucontrol->value.enumerated.item[0];
+
+// 	return 0;
+// }
+
+// static const struct snd_kcontrol_new snd_ddr_controls[] = {
+// 	SOC_ENUM_EXT("Audio In Source",
+// 		toddr_input_source_enum,
+// 		toddr_src_enum_get,
+// 		toddr_src_enum_set),
+// 	SOC_ENUM_EXT("Audio Out Sink",
+// 		toddr_input_source_enum,
+// 		frddr_src_enum_get,
+// 		frddr_src_enum_set),
+// };
+
+// int card_add_ddr_kcontrols(struct snd_soc_card *card)
+// {
+// 	unsigned int idx;
+// 	int err;
+
+// 	for (idx = 0; idx < ARRAY_SIZE(snd_ddr_controls); idx++) {
+// 		err = snd_ctl_add(card->snd_card,
+// 				snd_ctl_new1(&snd_ddr_controls[idx],
+// 				NULL));
+// 		if (err < 0)
+// 			return err;
+// 	}
+
+// 	return 0;
+// }
+
+static struct ddr_chipinfo axg_ddr_chipinfo = {
+	.int_start_same_addr   = true,
+	.asrc_only_left_j      = true,
+	.wakeup                = 1,
+};
+
+static struct ddr_chipinfo g12a_ddr_chipinfo = {
+	.same_src_fn           = true,
+	.asrc_only_left_j      = true,
+	.wakeup                = 1,
+};
+
+static struct ddr_chipinfo tl1_ddr_chipinfo = {
+	.same_src_fn           = true,
+	.ugt                   = true,
+	.src_sel_ctrl          = true,
+	.asrc_src_sel_ctrl     = true,
+	.fifo_num              = 4,
+	.wakeup                = 2,
+};
+
+static struct ddr_chipinfo sm1_ddr_chipinfo = {
+	.same_src_fn           = true,
+	.ugt                   = true,
+	.src_sel_ctrl          = true,
+	// .asrc_src_sel_ctrl     = true,
+	.fifo_num              = 4,
+	.wakeup                = 2,
+};
+
+static const struct of_device_id aml_ddr_mngr_device_id[] = {
+	{
+		.compatible = "amlogic, axg-audio-ddr-manager",
+		.data       = &axg_ddr_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-audio-ddr-manager",
+		.data       = &g12a_ddr_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-audio-ddr-manager",
+		.data       = &tl1_ddr_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-audio-ddr-manager",
+		.data       = &sm1_ddr_chipinfo,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, aml_ddr_mngr_device_id);
+
+static bool pm_audio_in_suspend;
+
+void pm_audio_set_suspend(bool is_suspend)
+{
+	pm_audio_in_suspend = is_suspend;
+}
+
+bool pm_audio_is_suspend(void)
+{
+	return pm_audio_in_suspend;
+}
+
+/* Detects a suspend and resume event */
+static int ddr_pm_event(struct notifier_block *notifier,
+	unsigned long pm_event, void *unused)
+{
+	pr_info("%s, pm_event:%lu\n", __func__, pm_event);
+
+	switch (pm_event) {
+	case PM_SUSPEND_PREPARE:
+		pm_audio_set_suspend(true);
+		break;
+	case PM_POST_SUSPEND:
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ddr_pm_notifier_block = {
+	.notifier_call = ddr_pm_event,
+};
+
+int aml_ddr_mngr_platform_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct device_node *np, *child;
+	struct ddr_chipinfo *p_ddr_chipinfo;
+	int ddr_num = 3; /* early chipset support max 3 ddr num */
+	int i, ret;
+	dev_info(&pdev->dev,"Registering ddr manager");
+	np  = of_find_node_by_name(pdev->dev.of_node, "ddr_manager");
+
+	if(np == NULL)
+		return -ENOENT;
+
+	p_ddr_chipinfo = (struct ddr_chipinfo *)
+		of_match_node(aml_ddr_mngr_device_id, np)->data;
+	if (!p_ddr_chipinfo)
+		dev_info(&pdev->dev,
+			"check whether to update ddr_mngr chipinfo\n");
+
+	/* irqs */
+	toddrs[DDR_A].irq = of_irq_get_byname(np, "toddr_a");
+	toddrs[DDR_B].irq = of_irq_get_byname(np, "toddr_b");
+	toddrs[DDR_C].irq = of_irq_get_byname(np, "toddr_c");
+
+	frddrs[DDR_A].irq = of_irq_get_byname(np, "frddr_a");
+	frddrs[DDR_B].irq = of_irq_get_byname(np, "frddr_b");
+	frddrs[DDR_C].irq = of_irq_get_byname(np, "frddr_c");
+
+	if (p_ddr_chipinfo
+		&& (p_ddr_chipinfo->fifo_num == 4)) {
+		toddrs[DDR_D].irq = of_irq_get_byname(np, "toddr_d");
+		frddrs[DDR_D].irq = of_irq_get_byname(np, "frddr_d");
+		if (toddrs[DDR_D].irq < 0 || frddrs[DDR_D].irq < 0)
+			dev_err(&pdev->dev, "check irq for DDR_D\n");
+		ddr_num = p_ddr_chipinfo->fifo_num;
+	}
+
+	for (i = 0; i < ddr_num; i++) {
+		pr_info("%d, irqs toddr %d, frddr %d\n",
+			i, toddrs[i].irq, frddrs[i].irq);
+		if (toddrs[i].irq <= 0 || frddrs[i].irq <= 0) {
+			dev_err(&pdev->dev, "platform_get_irq_byname failed\n");
+			return -ENXIO;
+		}
+	}
+
+	/* inits */
+	toddrs[DDR_A].reg_base = EE_AUDIO_TODDR_A_CTRL0;
+	toddrs[DDR_B].reg_base = EE_AUDIO_TODDR_B_CTRL0;
+	toddrs[DDR_C].reg_base = EE_AUDIO_TODDR_C_CTRL0;
+	toddrs[DDR_A].fifo_id  = DDR_A;
+	toddrs[DDR_B].fifo_id  = DDR_B;
+	toddrs[DDR_C].fifo_id  = DDR_C;
+
+	frddrs[DDR_A].reg_base = EE_AUDIO_FRDDR_A_CTRL0;
+	frddrs[DDR_B].reg_base = EE_AUDIO_FRDDR_B_CTRL0;
+	frddrs[DDR_C].reg_base = EE_AUDIO_FRDDR_C_CTRL0;
+	frddrs[DDR_A].fifo_id  = DDR_A;
+	frddrs[DDR_B].fifo_id  = DDR_B;
+	frddrs[DDR_C].fifo_id  = DDR_C;
+
+	if (p_ddr_chipinfo) {
+		toddrs[DDR_A].chipinfo = p_ddr_chipinfo;
+		toddrs[DDR_B].chipinfo = p_ddr_chipinfo;
+		toddrs[DDR_C].chipinfo = p_ddr_chipinfo;
+		frddrs[DDR_A].chipinfo = p_ddr_chipinfo;
+		frddrs[DDR_B].chipinfo = p_ddr_chipinfo;
+		frddrs[DDR_C].chipinfo = p_ddr_chipinfo;
+
+		if (p_ddr_chipinfo->fifo_num == 4) {
+			toddrs[DDR_D].reg_base = EE_AUDIO_TODDR_D_CTRL0;
+			toddrs[DDR_D].fifo_id  = DDR_D;
+
+			frddrs[DDR_D].reg_base = EE_AUDIO_FRDDR_D_CTRL0;
+			frddrs[DDR_D].fifo_id  = DDR_D;
+		}
+	}
+
+	ret = register_pm_notifier(&ddr_pm_notifier_block);
+	if (ret)
+		pr_warn("[%s] failed to register PM notifier %d\n",
+				__func__, ret);
+
+	return 0;
+}
+
+struct platform_driver aml_audio_ddr_manager = {
+	.driver = {
+		.name = DRV_NAME,
+		.of_match_table = aml_ddr_mngr_device_id,
+	},
+	.probe   = aml_ddr_mngr_platform_probe,
+};
+
+
diff -ruN a/drivers/evl/sound/evl-amlogic/ddr_mngr.h b/evl/sound/evl-amlogic/ddr_mngr.h
--- a/drivers/evl/sound/evl-amlogic/ddr_mngr.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/ddr_mngr.h	2021-12-31 16:22:41.947506575 +0300
@@ -0,0 +1,327 @@
+/*
+ * sound/soc/amlogic/auge/ddr_mngr.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_AUDIO_DDR_MANAGER_H_
+#define __AML_AUDIO_DDR_MANAGER_H_
+
+#include <linux/device.h>
+#include <linux/interrupt.h>
+// #include <sound/soc.h>
+#include "audio_io.h"
+
+#define MEMIF_INT_ADDR_FINISH       BIT(0)
+#define MEMIF_INT_ADDR_INT          BIT(1)
+#define MEMIF_INT_COUNT_REPEAT      BIT(2)
+#define MEMIF_INT_COUNT_ONCE        BIT(3)
+#define MEMIF_INT_FIFO_ZERO         BIT(4)
+#define MEMIF_INT_FIFO_DEPTH        BIT(5)
+#define MEMIF_INT_MASK              GENMASK(7, 0)
+
+enum ddr_num {
+	DDR_A,
+	DDR_B,
+	DDR_C,
+	DDR_D,
+};
+
+enum ddr_types {
+	LJ_8BITS,
+	LJ_16BITS,
+	RJ_16BITS,
+	LJ_32BITS,
+	RJ_32BITS,
+};
+
+/*
+ * from tl1, add new source FRATV, FRHDMIRX, LOOPBACK_B, SPDIFIN_LB, VAD
+ */
+enum toddr_src {
+	TODDR_INVAL = -1,
+	TDMIN_A = 0,
+	TDMIN_B = 1,
+	TDMIN_C = 2,
+	SPDIFIN = 3,
+	PDMIN = 4,
+	FRATV = 5, /* NONE for axg, g12a, g12b */
+	TDMIN_LB = 6,
+	LOOPBACK_A = 7,
+	FRHDMIRX = 8, /* from tl1 chipset*/
+	LOOPBACK_B = 9,
+	SPDIFIN_LB = 10,
+	EARCRX_DMAC = 11,/* from sm1 chipset */
+	RESERVED_0 = 12,
+	RESERVED_1 = 13,
+	RESERVED_2 = 14,
+	VAD = 15,
+	TODDR_SRC_MAX = 16
+};
+
+enum resample_idx {
+	RESAMPLE_A,
+	RESAMPLE_B
+};
+
+enum resample_src {
+	ASRC_TODDR_A,
+	ASRC_TODDR_B,
+	ASRC_TODDR_C,
+	ASRC_TODDR_D,      /* from tl1 chipset */
+	ASRC_LOOPBACK_A,
+	ASRC_LOOPBACK_B,
+};
+
+enum frddr_dest {
+	TDMOUT_A,
+	TDMOUT_B,
+	TDMOUT_C,
+	SPDIFOUT_A,
+	SPDIFOUT_B,
+};
+
+enum status_sel {
+	CURRENT_DDR_ADDR,
+	NEXT_FINISH_ADDR,
+	COUNT_CURRENT_DDR_ACK,
+	COUNT_NEXT_FINISH_DDR_ACK,
+	VAD_WAKEUP_ADDR,   /* from tl1, vad */
+	VAD_FS_ADDR,
+	VAD_FIFO_CNT,
+};
+
+struct toddr_fmt {
+	unsigned int type;
+	unsigned int msb;
+	unsigned int lsb;
+	unsigned int endian;
+	unsigned int bit_depth;
+	unsigned int ch_num;
+	unsigned int rate;
+};
+
+struct ddr_chipinfo {
+	/* INT and Start address is same or separated */
+	bool int_start_same_addr;
+	/* force finished */
+	bool force_finished;
+	/* same source */
+	bool same_src_fn;
+	/* insert channel number */
+	bool insert_chnum;
+
+	/* ddr bus in urgent */
+	bool ugt;
+
+	/* source sel switch to ctrl1
+	 * for toddr, 0: source sel is controlled by ctrl0
+	 *            1: source sel is controlled by ctrl1
+	 * for frddr, 0: source sel is controlled by ctrl0
+	 *            1: source sel is controlled by ctrl2
+	 */
+	bool src_sel_ctrl;
+
+	/*
+	 * resample source sel switch
+	 * resample : from ctrl0 to ctrl3
+	 * toddr : from ctrl0 to ctrl1
+	 */
+	bool asrc_src_sel_ctrl;
+	/* spdif in 32bit, only support left justified */
+	bool asrc_only_left_j;
+
+	/* toddr number max
+	 * 0: default, 3 toddr, axg, g12a, g12b
+	 * 4: 4 toddr, tl1
+	 */
+	int fifo_num;
+
+	/* power detect or VAD
+	 * 0: disabled
+	 * 1: power detect
+	 * 2: vad
+	 */
+	int wakeup;
+};
+
+struct toddr {
+	struct device *dev;
+	unsigned int resample: 1;
+	unsigned int ext_signed: 1;
+	unsigned int msb_bit;
+	unsigned int lsb_bit;
+	unsigned int reg_base;
+	unsigned int bitdepth;
+	unsigned int channels;
+	unsigned int rate;
+
+	unsigned int start_addr_a;
+	unsigned int end_addr_a;
+	unsigned int start_addr_b;
+	unsigned int end_addr_b;
+	enum toddr_src src;
+	unsigned int fifo_id;
+
+	enum resample_src asrc_src_sel;
+
+	int is_lb; /* check whether for loopback */
+	int irq;
+	bool in_use: 1;
+	struct aml_audio_controller *actrl;
+	struct ddr_chipinfo *chipinfo;
+};
+
+enum status {
+	DISABLED,
+	READY,    /* controls has set enable, but ddr is not in running */
+	RUNNING,
+};
+
+struct toddr_attach {
+	bool enable;
+	enum resample_idx id;
+	int status;
+	/* which module should be attached,
+	 * check which toddr in use should be attached
+	 */
+	enum toddr_src attach_module;
+};
+
+struct frddr_attach {
+	bool enable;
+	int status;
+	/* which module for attach ,
+	 * check which frddr in use should be added
+	 */
+	enum frddr_dest attach_module;
+};
+
+struct frddr {
+	struct device *dev;
+	enum frddr_dest dest;
+
+	/* dest for same source, whether enable */
+	enum frddr_dest ss_dest;
+	bool ss_en;
+
+	struct aml_audio_controller *actrl;
+	unsigned int reg_base;
+	enum ddr_num fifo_id;
+
+	unsigned int channels;
+	unsigned int msb;
+	unsigned int type;
+
+	int irq;
+	bool in_use;
+	struct ddr_chipinfo *chipinfo;
+
+	bool reserved;
+};
+
+/* to ddrs */
+struct toddr *fetch_toddr_by_src(int toddr_src);
+struct toddr *aml_audio_register_toddr(struct device *dev,
+		struct aml_audio_controller *actrl,
+		irq_handler_t handler, void *data);
+int aml_audio_unregister_toddr(struct device *dev, void *data);
+int aml_toddr_set_buf(struct toddr *to, unsigned int start_a,
+			unsigned int end_a,unsigned int start_b,
+			unsigned int end_b);
+int aml_toddr_set_buf_startaddr(struct toddr *to, unsigned int start);
+int aml_toddr_set_buf_endaddr(struct toddr *to,	unsigned int end);
+
+int aml_toddr_set_intrpt(struct toddr *to, unsigned int intrpt);
+unsigned int aml_toddr_get_position(struct toddr *to);
+unsigned int aml_toddr_get_addr(struct toddr *to, enum status_sel sel);
+void aml_toddr_select_src(struct toddr *to, enum toddr_src);
+void aml_toddr_enable(struct toddr *to, bool enable);
+void aml_toddr_set_fifos(struct toddr *to, unsigned int thresh);
+void aml_toddr_update_fifos_rd_th(struct toddr *to, int th);
+void aml_toddr_force_finish(struct toddr *to);
+void aml_toddr_set_format(struct toddr *to, struct toddr_fmt *fmt);
+
+unsigned int aml_toddr_get_status(struct toddr *to);
+void aml_toddr_ack_irq(struct toddr *to, int status);
+void aml_frddr_ack_irq(struct frddr *to, int status);
+
+void aml_toddr_insert_chanum(struct toddr *to);
+unsigned int aml_toddr_read(struct toddr *to);
+void aml_toddr_write(struct toddr *to, unsigned int val);
+unsigned int aml_toddr_read1(struct toddr *to);
+void aml_toddr_write1(struct toddr *to, unsigned int val);
+unsigned int aml_toddr_read_status2(struct toddr *to);
+bool aml_toddr_burst_finished(struct toddr *to);
+
+/* resample */
+void aml_set_resample(enum resample_idx id,
+		bool enable, enum toddr_src resample_module);
+/* power detect */
+void aml_pwrdet_enable(bool enable, int pwrdet_module);
+/* Voice Activity Detection */
+void aml_set_vad(bool enable, int module);
+
+/* from ddrs */
+struct frddr *fetch_frddr_by_src(int frddr_src);
+
+struct frddr *aml_audio_register_frddr(struct device *dev,
+		struct aml_audio_controller *actrl,
+		irq_handler_t handler, void *data, bool rvd_dst);
+int aml_audio_unregister_frddr(struct device *dev, void *data);
+int aml_frddr_set_buf(struct frddr *fr, unsigned int start_a,
+			unsigned int end_a,unsigned int start_b,
+			unsigned int end_b);
+			
+int aml_frddr_set_intrpt(struct frddr *fr, unsigned int intrpt);
+unsigned int aml_frddr_get_position(struct frddr *fr);
+void aml_frddr_enable(struct frddr *fr, bool enable);
+void aml_frddr_select_dst(struct frddr *fr, enum frddr_dest);
+extern void aml_frddr_select_dst_ss(struct frddr *fr,
+	enum frddr_dest dst, int sel, bool enable);
+
+int aml_check_sharebuffer_valid(struct frddr *fr, int ss_sel);
+
+void aml_frddr_set_fifos(struct frddr *fr,
+		unsigned int depth, unsigned int thresh);
+unsigned int aml_frddr_get_fifo_id(struct frddr *fr);
+void aml_frddr_set_format(struct frddr *fr,
+	unsigned int chnum,
+	unsigned int msb,
+	unsigned int frddr_type);
+
+void aml_frddr_reset(struct frddr *fr, int offset);
+
+/* audio eq drc */
+void aml_set_aed(bool enable, int aed_module);
+// void aml_aed_top_enable(struct frddr *fr, bool enable);
+
+// void frddr_init_without_mngr(unsigned int frddr_index, unsigned int src0_sel);
+// void frddr_deinit_without_mngr(unsigned int frddr_index);
+
+// enum toddr_src toddr_src_get(void);
+// const char *toddr_src_get_str(enum toddr_src idx);
+// int frddr_src_get(void);
+// const char *frddr_src_get_str(int idx);
+
+// int card_add_ddr_kcontrols(struct snd_soc_card *card);
+
+// void pm_audio_set_suspend(bool is_suspend);
+// bool pm_audio_is_suspend(void);
+
+void aml_frddr_check(struct frddr *fr);
+void aml_aed_set_frddr_reserved(void);
+int aml_ddr_mngr_platform_probe(struct platform_device *pdev);
+#endif
+
diff -ruN a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,axg-audio-clk.h b/evl/sound/evl-amlogic/dt-bindings/amlogic,axg-audio-clk.h
--- a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,axg-audio-clk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/dt-bindings/amlogic,axg-audio-clk.h	2021-12-23 13:27:12.799000000 +0300
@@ -0,0 +1,63 @@
+/*
+ * include/dt-bindings/clock/amlogic,axg-audio-clk.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AGX_AUDIO_CLK_H
+#define __AGX_AUDIO_CLK_H
+
+/*
+ * CLKID audio index values
+ */
+
+#define CLKID_AUDIO_DDR_ARB					0
+#define CLKID_AUDIO_PDM						1
+#define CLKID_AUDIO_TDMINA					2
+#define CLKID_AUDIO_TDMINB					3
+#define CLKID_AUDIO_TDMINC					4
+#define CLKID_AUDIO_TDMINLB					5
+#define CLKID_AUDIO_TDMOUTA					6
+#define CLKID_AUDIO_TDMOUTB					7
+#define CLKID_AUDIO_TDMOUTC					8
+#define CLKID_AUDIO_FRDDRA					9
+#define CLKID_AUDIO_FRDDRB					10
+#define CLKID_AUDIO_FRDDRC					11
+#define CLKID_AUDIO_TODDRA					12
+#define CLKID_AUDIO_TODDRB					13
+#define CLKID_AUDIO_TODDRC					14
+#define CLKID_AUDIO_LOOPBACK				15
+#define CLKID_AUDIO_SPDIFIN					16
+#define CLKID_AUDIO_SPDIFOUT				17
+#define CLKID_AUDIO_RESAMPLE				18
+#define CLKID_AUDIO_POWER_DETECT			19
+
+#define MCLK_BASE							20
+#define CLKID_AUDIO_MCLK_A		(MCLK_BASE + 0)
+#define CLKID_AUDIO_MCLK_B		(MCLK_BASE + 1)
+#define CLKID_AUDIO_MCLK_C		(MCLK_BASE + 2)
+#define CLKID_AUDIO_MCLK_D		(MCLK_BASE + 3)
+#define CLKID_AUDIO_MCLK_E		(MCLK_BASE + 4)
+#define CLKID_AUDIO_MCLK_F		(MCLK_BASE + 5)
+
+#define CLKID_AUDIO_SPDIFIN_CTRL		(MCLK_BASE + 6)
+#define CLKID_AUDIO_SPDIFOUT_CTRL		(MCLK_BASE + 7)
+#define CLKID_AUDIO_PDMIN0		(MCLK_BASE + 8)
+#define CLKID_AUDIO_PDMIN1		(MCLK_BASE + 9)
+#define CLKID_AUDIO_LOCKER_OUT		(MCLK_BASE + 10)
+#define CLKID_AUDIO_LOCKER_IN		(MCLK_BASE + 11)
+#define CLKID_AUDIO_RESAMPLE_CTRL	(MCLK_BASE + 12)
+
+#define NUM_AUDIO_CLKS			(MCLK_BASE + 13)
+#endif /* __AGX_AUDIO_CLK_H */
diff -ruN a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,g12a-audio-clk.h b/evl/sound/evl-amlogic/dt-bindings/amlogic,g12a-audio-clk.h
--- a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,g12a-audio-clk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/dt-bindings/amlogic,g12a-audio-clk.h	2021-12-23 13:27:12.963000000 +0300
@@ -0,0 +1,67 @@
+/*
+ * include/dt-bindings/clock/amlogic,g12a-audio-clk.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __G12A_AUDIO_CLK_H
+#define __G12A_AUDIO_CLK_H
+
+/*
+ * CLKID audio index values
+ */
+
+#define CLKID_AUDIO_DDR_ARB					0
+#define CLKID_AUDIO_PDM						1
+#define CLKID_AUDIO_TDMINA					2
+#define CLKID_AUDIO_TDMINB					3
+#define CLKID_AUDIO_TDMINC					4
+#define CLKID_AUDIO_TDMINLB					5
+#define CLKID_AUDIO_TDMOUTA					6
+#define CLKID_AUDIO_TDMOUTB					7
+#define CLKID_AUDIO_TDMOUTC					8
+#define CLKID_AUDIO_FRDDRA					9
+#define CLKID_AUDIO_FRDDRB					10
+#define CLKID_AUDIO_FRDDRC					11
+#define CLKID_AUDIO_TODDRA					12
+#define CLKID_AUDIO_TODDRB					13
+#define CLKID_AUDIO_TODDRC					14
+#define CLKID_AUDIO_LOOPBACK				15
+#define CLKID_AUDIO_SPDIFIN					16
+#define CLKID_AUDIO_SPDIFOUT				17
+#define CLKID_AUDIO_RESAMPLE				18
+#define CLKID_AUDIO_POWER_DETECT			19
+#define CLKID_AUDIO_TORAM					20
+#define CLKID_AUDIO_SPDIFOUTB				21
+#define CLKID_AUDIO_EQDRC					22
+
+#define MCLK_BASE							23
+#define CLKID_AUDIO_MCLK_A		(MCLK_BASE + 0)
+#define CLKID_AUDIO_MCLK_B		(MCLK_BASE + 1)
+#define CLKID_AUDIO_MCLK_C		(MCLK_BASE + 2)
+#define CLKID_AUDIO_MCLK_D		(MCLK_BASE + 3)
+#define CLKID_AUDIO_MCLK_E		(MCLK_BASE + 4)
+#define CLKID_AUDIO_MCLK_F		(MCLK_BASE + 5)
+
+#define CLKID_AUDIO_SPDIFIN_CTRL		(MCLK_BASE + 6)
+#define CLKID_AUDIO_SPDIFOUT_CTRL		(MCLK_BASE + 7)
+#define CLKID_AUDIO_PDMIN0		(MCLK_BASE + 8)
+#define CLKID_AUDIO_PDMIN1		(MCLK_BASE + 9)
+#define CLKID_AUDIO_SPDIFOUTB_CTRL		(MCLK_BASE + 10)
+#define CLKID_AUDIO_LOCKER_OUT		(MCLK_BASE + 11)
+#define CLKID_AUDIO_LOCKER_IN		(MCLK_BASE + 12)
+#define CLKID_AUDIO_RESAMPLE_CTRL		(MCLK_BASE + 13)
+
+#define NUM_AUDIO_CLKS			(MCLK_BASE + 14)
+#endif /* __G12A_AUDIO_CLK_H */
diff -ruN a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,sm1-audio-clk.h b/evl/sound/evl-amlogic/dt-bindings/amlogic,sm1-audio-clk.h
--- a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,sm1-audio-clk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/dt-bindings/amlogic,sm1-audio-clk.h	2021-12-23 13:27:13.076000000 +0300
@@ -0,0 +1,95 @@
+/*
+ * include/dt-bindings/clock/amlogic,sm1-audio-clk.h
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SM1_AUDIO_CLK_H__
+#define __SM1_AUDIO_CLK_H__
+
+/*
+ * CLKID audio index values
+ */
+/* Gate En0 */
+#define CLKID_AUDIO_GATE_DDR_ARB                0
+#define CLKID_AUDIO_GATE_PDM                    1
+#define CLKID_AUDIO_GATE_TDMINA                 2
+#define CLKID_AUDIO_GATE_TDMINB                 3
+#define CLKID_AUDIO_GATE_TDMINC                 4
+#define CLKID_AUDIO_GATE_TDMINLB                5
+#define CLKID_AUDIO_GATE_TDMOUTA                6
+#define CLKID_AUDIO_GATE_TDMOUTB                7
+#define CLKID_AUDIO_GATE_TDMOUTC                8
+#define CLKID_AUDIO_GATE_FRDDRA                 9
+#define CLKID_AUDIO_GATE_FRDDRB                 10
+#define CLKID_AUDIO_GATE_FRDDRC                 11
+#define CLKID_AUDIO_GATE_TODDRA                 12
+#define CLKID_AUDIO_GATE_TODDRB                 13
+#define CLKID_AUDIO_GATE_TODDRC                 14
+#define CLKID_AUDIO_GATE_LOOPBACKA              15
+#define CLKID_AUDIO_GATE_SPDIFIN                16
+#define CLKID_AUDIO_GATE_SPDIFOUT_A             17
+#define CLKID_AUDIO_GATE_RESAMPLEA              18
+#define CLKID_AUDIO_GATE_RESERVED0              19
+#define CLKID_AUDIO_GATE_TORAM                  20
+#define CLKID_AUDIO_GATE_SPDIFOUT_B             21
+#define CLKID_AUDIO_GATE_EQDRC                  22
+#define CLKID_AUDIO_GATE_RESERVED1              23
+#define CLKID_AUDIO_GATE_RESERVED2              24
+#define CLKID_AUDIO_GATE_RESERVED3              25
+#define CLKID_AUDIO_GATE_RESAMPLEB              26
+#define CLKID_AUDIO_GATE_TOVAD                  27
+#define CLKID_AUDIO_GATE_AUDIOLOCKER            28
+#define CLKID_AUDIO_GATE_SPDIFIN_LB             29
+#define CLKID_AUDIO_GATE_RESERVED4              30
+#define CLKID_AUDIO_GATE_RESERVED5              31
+
+/* Gate En1 */
+#define CLKID_AUDIO_GATE_FRDDRD                 32
+#define CLKID_AUDIO_GATE_TODDRD                 33
+#define CLKID_AUDIO_GATE_LOOPBACKB              34
+#define CLKID_AUDIO_GATE_EARCRX                 35
+
+#define CLKID_AUDIO_GATE_MAX                    36
+
+#define MCLK_BASE                               CLKID_AUDIO_GATE_MAX
+#define CLKID_AUDIO_MCLK_A                      (MCLK_BASE + 0)
+#define CLKID_AUDIO_MCLK_B                      (MCLK_BASE + 1)
+#define CLKID_AUDIO_MCLK_C                      (MCLK_BASE + 2)
+#define CLKID_AUDIO_MCLK_D                      (MCLK_BASE + 3)
+#define CLKID_AUDIO_MCLK_E                      (MCLK_BASE + 4)
+#define CLKID_AUDIO_MCLK_F                      (MCLK_BASE + 5)
+
+#define CLKID_AUDIO_SPDIFIN                     (MCLK_BASE + 6)
+#define CLKID_AUDIO_SPDIFOUT_A                  (MCLK_BASE + 7)
+#define CLKID_AUDIO_RESAMPLE_A                  (MCLK_BASE + 8)
+#define CLKID_AUDIO_LOCKER_OUT                  (MCLK_BASE + 9)
+#define CLKID_AUDIO_LOCKER_IN                   (MCLK_BASE + 10)
+#define CLKID_AUDIO_PDMIN0                      (MCLK_BASE + 11)
+#define CLKID_AUDIO_PDMIN1                      (MCLK_BASE + 12)
+#define CLKID_AUDIO_SPDIFOUT_B                  (MCLK_BASE + 13)
+#define CLKID_AUDIO_RESAMPLE_B                  (MCLK_BASE + 14)
+#define CLKID_AUDIO_SPDIFIN_LB                  (MCLK_BASE + 15)
+#define CLKID_AUDIO_EQDRC                       (MCLK_BASE + 16)
+#define CLKID_AUDIO_VAD                         (MCLK_BASE + 17)
+#define CLKID_EARCTX_CMDC                       (MCLK_BASE + 18)
+#define CLKID_EARCTX_DMAC                       (MCLK_BASE + 19)
+#define CLKID_EARCRX_CMDC                       (MCLK_BASE + 20)
+#define CLKID_EARCRX_DMAC                       (MCLK_BASE + 21)
+
+#define CLKID_AUDIO_MCLK_PAD0                   (MCLK_BASE + 22)
+#define CLKID_AUDIO_MCLK_PAD1                   (MCLK_BASE + 23)
+
+#define NUM_AUDIO_CLKS                          (MCLK_BASE + 24)
+#endif /* __SM1_AUDIO_CLK_H__ */
diff -ruN a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,tl1-audio-clk.h b/evl/sound/evl-amlogic/dt-bindings/amlogic,tl1-audio-clk.h
--- a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,tl1-audio-clk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/dt-bindings/amlogic,tl1-audio-clk.h	2021-12-23 13:27:13.129000000 +0300
@@ -0,0 +1,80 @@
+/*
+ * include/dt-bindings/clock/amlogic,tl1-audio-clk.h
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __TL1_AUDIO_CLK_H__
+#define __TL1_AUDIO_CLK_H__
+
+/*
+ * CLKID audio index values
+ */
+
+#define CLKID_AUDIO_GATE_DDR_ARB                0
+#define CLKID_AUDIO_GATE_PDM                    1
+#define CLKID_AUDIO_GATE_TDMINA                 2
+#define CLKID_AUDIO_GATE_TDMINB                 3
+#define CLKID_AUDIO_GATE_TDMINC                 4
+#define CLKID_AUDIO_GATE_TDMINLB                5
+#define CLKID_AUDIO_GATE_TDMOUTA                6
+#define CLKID_AUDIO_GATE_TDMOUTB                7
+#define CLKID_AUDIO_GATE_TDMOUTC                8
+#define CLKID_AUDIO_GATE_FRDDRA                 9
+#define CLKID_AUDIO_GATE_FRDDRB                 10
+#define CLKID_AUDIO_GATE_FRDDRC                 11
+#define CLKID_AUDIO_GATE_TODDRA                 12
+#define CLKID_AUDIO_GATE_TODDRB                 13
+#define CLKID_AUDIO_GATE_TODDRC                 14
+#define CLKID_AUDIO_GATE_LOOPBACKA              15
+#define CLKID_AUDIO_GATE_SPDIFIN                16
+#define CLKID_AUDIO_GATE_SPDIFOUT_A             17
+#define CLKID_AUDIO_GATE_RESAMPLEA              18
+#define CLKID_AUDIO_GATE_RESERVED0              19
+#define CLKID_AUDIO_GATE_RESERVED1              20
+#define CLKID_AUDIO_GATE_SPDIFOUT_B             21
+#define CLKID_AUDIO_GATE_EQDRC                  22
+#define CLKID_AUDIO_GATE_RESAMPLEB              23
+#define CLKID_AUDIO_GATE_TOVAD                  24
+#define CLKID_AUDIO_GATE_AUDIOLOCKER            25
+#define CLKID_AUDIO_GATE_SPDIFIN_LB             26
+#define CLKID_AUDIO_GATE_FRATV                  27
+#define CLKID_AUDIO_GATE_FRHDMIRX               28
+#define CLKID_AUDIO_GATE_FRDDRD                 29
+#define CLKID_AUDIO_GATE_TODDRD                 30
+#define CLKID_AUDIO_GATE_LOOPBACKB              31
+
+#define MCLK_BASE                               32
+#define CLKID_AUDIO_MCLK_A                      (MCLK_BASE + 0)
+#define CLKID_AUDIO_MCLK_B                      (MCLK_BASE + 1)
+#define CLKID_AUDIO_MCLK_C                      (MCLK_BASE + 2)
+#define CLKID_AUDIO_MCLK_D                      (MCLK_BASE + 3)
+#define CLKID_AUDIO_MCLK_E                      (MCLK_BASE + 4)
+#define CLKID_AUDIO_MCLK_F                      (MCLK_BASE + 5)
+
+#define CLKID_AUDIO_SPDIFIN                     (MCLK_BASE + 6)
+#define CLKID_AUDIO_SPDIFOUT_A                  (MCLK_BASE + 7)
+#define CLKID_AUDIO_RESAMPLE_A                  (MCLK_BASE + 8)
+#define CLKID_AUDIO_LOCKER_OUT                  (MCLK_BASE + 9)
+#define CLKID_AUDIO_LOCKER_IN                   (MCLK_BASE + 10)
+#define CLKID_AUDIO_PDMIN0                      (MCLK_BASE + 11)
+#define CLKID_AUDIO_PDMIN1                      (MCLK_BASE + 12)
+#define CLKID_AUDIO_SPDIFOUT_B                  (MCLK_BASE + 13)
+#define CLKID_AUDIO_RESAMPLE_B                  (MCLK_BASE + 14)
+#define CLKID_AUDIO_SPDIFIN_LB                  (MCLK_BASE + 15)
+#define CLKID_AUDIO_EQDRC                       (MCLK_BASE + 16)
+#define CLKID_AUDIO_VAD                         (MCLK_BASE + 17)
+
+#define NUM_AUDIO_CLKS                          (MCLK_BASE + 18)
+#endif /* __TL1_AUDIO_CLK_H__ */
diff -ruN a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,tm2-audio-clk.h b/evl/sound/evl-amlogic/dt-bindings/amlogic,tm2-audio-clk.h
--- a/drivers/evl/sound/evl-amlogic/dt-bindings/amlogic,tm2-audio-clk.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/dt-bindings/amlogic,tm2-audio-clk.h	2021-12-23 13:28:54.536157991 +0300
@@ -0,0 +1,100 @@
+/*
+ * include/dt-bindings/clock/amlogic,tm2-audio-clk.h
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __TM2_AUDIO_CLK_H__
+#define __TM2_AUDIO_CLK_H__
+
+/*
+ * CLKID audio index values
+ */
+
+#define CLKID_AUDIO_GATE_DDR_ARB                0
+#define CLKID_AUDIO_GATE_PDM                    1
+#define CLKID_AUDIO_GATE_TDMINA                 2
+#define CLKID_AUDIO_GATE_TDMINB                 3
+#define CLKID_AUDIO_GATE_TDMINC                 4
+#define CLKID_AUDIO_GATE_TDMINLB                5
+#define CLKID_AUDIO_GATE_TDMOUTA                6
+#define CLKID_AUDIO_GATE_TDMOUTB                7
+#define CLKID_AUDIO_GATE_TDMOUTC                8
+#define CLKID_AUDIO_GATE_FRDDRA                 9
+#define CLKID_AUDIO_GATE_FRDDRB                 10
+#define CLKID_AUDIO_GATE_FRDDRC                 11
+#define CLKID_AUDIO_GATE_TODDRA                 12
+#define CLKID_AUDIO_GATE_TODDRB                 13
+#define CLKID_AUDIO_GATE_TODDRC                 14
+#define CLKID_AUDIO_GATE_LOOPBACKA              15
+#define CLKID_AUDIO_GATE_SPDIFIN                16
+#define CLKID_AUDIO_GATE_SPDIFOUT_A             17
+#define CLKID_AUDIO_GATE_RESAMPLEA              18
+#define CLKID_AUDIO_GATE_RESERVED0              19
+#define CLKID_AUDIO_GATE_RESERVED1              20
+#define CLKID_AUDIO_GATE_SPDIFOUT_B             21
+#define CLKID_AUDIO_GATE_EQDRC                  22
+#define CLKID_AUDIO_GATE_RESERVED2              23
+#define CLKID_AUDIO_GATE_RESERVED3              24
+#define CLKID_AUDIO_GATE_RESERVED4              25
+#define CLKID_AUDIO_GATE_RESAMPLEB              26
+#define CLKID_AUDIO_GATE_TOVAD                  27
+#define CLKID_AUDIO_GATE_AUDIOLOCKER            28
+#define CLKID_AUDIO_GATE_SPDIFIN_LB             29
+#define CLKID_AUDIO_GATE_FRATV                  30
+#define CLKID_AUDIO_GATE_FRHDMIRX               31
+
+/* Gate En1 */
+#define CLKID_AUDIO_GATE_FRDDRD                 32
+#define CLKID_AUDIO_GATE_TODDRD                 33
+#define CLKID_AUDIO_GATE_LOOPBACKB              34
+#define CLKID_AUDIO_GATE_FRDDRE                 35
+#define CLKID_AUDIO_GATE_TODDRE                 36
+#define CLKID_AUDIO_GATE_EARCTX                 37
+#define CLKID_AUDIO_GATE_EARCRX                 38
+#define CLKID_AUDIO_GATE_RESAMPLEB_OLD          39
+#define CLKID_AUDIO_GATE_LOCKER                 40
+
+#define CLKID_AUDIO_GATE_MAX                    41
+
+#define MCLK_BASE                               CLKID_AUDIO_GATE_MAX
+#define CLKID_AUDIO_MCLK_A                      (MCLK_BASE + 0)
+#define CLKID_AUDIO_MCLK_B                      (MCLK_BASE + 1)
+#define CLKID_AUDIO_MCLK_C                      (MCLK_BASE + 2)
+#define CLKID_AUDIO_MCLK_D                      (MCLK_BASE + 3)
+#define CLKID_AUDIO_MCLK_E                      (MCLK_BASE + 4)
+#define CLKID_AUDIO_MCLK_F                      (MCLK_BASE + 5)
+
+#define CLKID_AUDIO_SPDIFIN                     (MCLK_BASE + 6)
+#define CLKID_AUDIO_SPDIFOUT_A                  (MCLK_BASE + 7)
+#define CLKID_AUDIO_RESAMPLE_A                  (MCLK_BASE + 8)
+#define CLKID_AUDIO_LOCKER_OUT                  (MCLK_BASE + 9)
+#define CLKID_AUDIO_LOCKER_IN                   (MCLK_BASE + 10)
+#define CLKID_AUDIO_PDMIN0                      (MCLK_BASE + 11)
+#define CLKID_AUDIO_PDMIN1                      (MCLK_BASE + 12)
+#define CLKID_AUDIO_SPDIFOUT_B                  (MCLK_BASE + 13)
+#define CLKID_AUDIO_RESAMPLE_B                  (MCLK_BASE + 14)
+#define CLKID_AUDIO_SPDIFIN_LB                  (MCLK_BASE + 15)
+#define CLKID_AUDIO_EQDRC                       (MCLK_BASE + 16)
+#define CLKID_AUDIO_VAD                         (MCLK_BASE + 17)
+#define CLKID_EARCTX_CMDC                       (MCLK_BASE + 18)
+#define CLKID_EARCTX_DMAC                       (MCLK_BASE + 19)
+#define CLKID_EARCRX_CMDC                       (MCLK_BASE + 20)
+#define CLKID_EARCRX_DMAC                       (MCLK_BASE + 21)
+
+#define CLKID_AUDIO_MCLK_PAD0                   (MCLK_BASE + 22)
+#define CLKID_AUDIO_MCLK_PAD1                   (MCLK_BASE + 23)
+
+#define NUM_AUDIO_CLKS                          (MCLK_BASE + 24)
+#endif /* __TM2_AUDIO_CLK_H__ */
diff -ruN a/drivers/evl/sound/evl-amlogic/elk-pi-config.h b/evl/sound/evl-amlogic/elk-pi-config.h
--- a/drivers/evl/sound/evl-amlogic/elk-pi-config.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/elk-pi-config.h	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,41 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* @brief config file to keep board specific configs (e.g. num of CV gates)
+* @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+* Stockholm
+*/
+#ifndef ELK_PI_CONFIG_H
+#define ELK_PI_CONFIG_H
+
+#define ELK_PI_NUM_INPUT_CHANNELS	6
+#define ELK_PI_NUM_OUTPUT_CHANNELS	8
+
+// num channels sent by the codec
+#define ELK_PI_NUM_CODEC_CHANNELS	8
+
+#define ELK_PI_CODEC_FORMAT		INT24_LJ
+
+#define ELK_PI_SAMPLING_RATE		48000
+
+/* BCM2835_I2S_CVGATES_SUPPORT should be defined (through Make file or here or a Kconfig if this module is part of kernel tree) to enable cv gates support */
+
+/**
+ * Cv gate gpio pin definitions
+ */
+#define 	NUM_OF_CVGATE_OUTS	4
+#define		NUM_OF_CVGATE_INS	2
+#define		CVGATE_OUT1_PIN	17
+#define		CVGATE_OUT2_PIN	27
+#define		CVGATE_OUT3_PIN	22
+#define		CVGATE_OUT4_PIN	23
+#define		CVGATE_IN1_PIN		24
+#define		CVGATE_IN2_PIN		25
+
+#define CVGATE_OUTS_LIST CVGATE_OUT1_PIN, \
+						CVGATE_OUT2_PIN, \
+						CVGATE_OUT3_PIN, \
+						CVGATE_OUT4_PIN
+
+#define CVGATE_INS_LIST CVGATE_IN1_PIN, CVGATE_IN2_PIN
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/evl-audio.c b/evl/sound/evl-amlogic/evl-audio.c
--- a/drivers/evl/sound/evl-amlogic/evl-audio.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/evl-audio.c	2022-01-10 16:15:08.008878168 +0300
@@ -0,0 +1,513 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @brief Initial version of real-time audio driver for rpi
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+/* RTDM headers */
+//#include <rtdm/driver.h>
+//#include <rtdm/rtdm.h>
+#include <evl/device.h>
+
+#include "evl-audio.h"
+#include "evl-axg-memory.h"
+#include "audio_controller.h"
+#include "iomap.h"
+#include "ddr_mngr.h"
+#include "audio_clks.h"
+#include "spdif.h"
+MODULE_AUTHOR("Old Navi (old.navi@bk.ru)");
+MODULE_DESCRIPTION("Realtime Amlogic SOC AUGE direct sound driver");
+MODULE_LICENSE("GPL");
+
+
+
+static uint audio_rtdm_ver_maj = AUDIO_RTDM_VERSION_MAJ;
+static uint audio_rtdm_ver_min = AUDIO_RTDM_VERSION_MIN;
+static uint audio_rtdm_ver_rev = AUDIO_RTDM_VERSION_VER;
+static uint audio_input_channels = DEFAULT_AUDIO_NUM_INPUT_CHANNELS;
+static uint audio_output_channels = DEFAULT_AUDIO_NUM_OUTPUT_CHANNELS;
+static uint audio_sampling_rate = DEFAULT_AUDIO_SAMPLING_RATE;
+static uint audio_format = DEFAULT_AUDIO_CODEC_FORMAT;
+static uint platform_type = PLATFORM_TYPE;
+
+static uint audio_buffer_size = DEFAULT_AUDIO_N_FRAMES_PER_BUFFER;
+static const int supported_buffer_sizes[] = {SUPPORTED_BUFFER_SIZES};
+
+
+
+
+static ssize_t audio_buffer_size_show(struct class *cls,
+                                      struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", audio_buffer_size);
+}
+
+static ssize_t audio_buffer_size_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t size)
+{
+	unsigned long bs;
+	ssize_t result;
+	result = sscanf(buf, "%lu", &bs);
+	if (result != 1)
+		return -EINVAL;
+	audio_buffer_size = bs;
+	return size;
+}
+
+
+static ssize_t audio_sampling_rate_show(struct class *cls,
+                                        struct class_attribute *attr,
+                                        char *buf) {
+  return sprintf(buf, "%u\n", audio_sampling_rate);
+}
+
+static ssize_t audio_sampling_rate_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t size)
+{
+	unsigned long bs;
+	ssize_t result;
+	result = sscanf(buf, "%lu", &bs);
+	if (result != 1)
+		return -EINVAL;
+	audio_sampling_rate = bs;
+	return size;
+}
+
+static ssize_t audio_rtdm_ver_maj_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_maj);
+}
+
+static ssize_t audio_rtdm_ver_min_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_min);
+}
+
+static ssize_t audio_rtdm_ver_rev_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_rev);
+}
+
+static ssize_t audio_input_channels_show(struct class *cls,
+                                         struct class_attribute *attr,
+                                         char *buf) {
+  return sprintf(buf, "%d\n", audio_input_channels);
+}
+
+static ssize_t audio_output_channels_show(struct class *cls,
+                                          struct class_attribute *attr,
+                                          char *buf) {
+  return sprintf(buf, "%d\n", audio_output_channels);
+}
+
+static ssize_t audio_format_show(struct class *cls,
+                                 struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", audio_format);
+}
+
+static ssize_t platform_type_show(struct class *cls,
+                                  struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", platform_type);
+}
+
+static CLASS_ATTR_RW(audio_buffer_size);
+static CLASS_ATTR_RW(audio_sampling_rate);
+static CLASS_ATTR_RO(audio_rtdm_ver_maj);
+static CLASS_ATTR_RO(audio_rtdm_ver_min);
+static CLASS_ATTR_RO(audio_rtdm_ver_rev);
+static CLASS_ATTR_RO(audio_input_channels);
+static CLASS_ATTR_RO(audio_output_channels);
+static CLASS_ATTR_RO(audio_format);
+static CLASS_ATTR_RO(platform_type);
+
+static struct attribute *audio_rtdm_class_attrs[] = {
+	&class_attr_audio_buffer_size.attr,
+	&class_attr_audio_sampling_rate.attr,
+	&class_attr_audio_rtdm_ver_maj.attr,
+	&class_attr_audio_rtdm_ver_min.attr,
+	&class_attr_audio_rtdm_ver_rev.attr,
+	&class_attr_audio_input_channels.attr,
+	&class_attr_audio_output_channels.attr,
+	&class_attr_audio_format.attr,
+	&class_attr_platform_type.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(audio_rtdm_class);
+
+struct class audio_rtdm_class = {
+    .name = "audio_rt",
+    .class_groups = audio_rtdm_class_groups,
+};
+
+static int audio_driver_open(struct inode *inode, struct file *fd)
+{
+	struct audio_dev_context *dev_context;
+	uint64_t flags;
+	int ret = 0;
+	dev_context = get_audio_dev_context(fd);
+	if(dev_context==NULL)
+		return -ENOMEM;
+	spin_lock_irqsave(&dev_context->lock, flags);
+
+	if(dev_context->i2s_dev != NULL)
+		{
+			ret = -EBUSY;
+			goto exit;
+		}
+	
+	dev_context->i2s_dev = kzalloc(sizeof(*(dev_context->i2s_dev)),GFP_KERNEL);
+	if(dev_context->i2s_dev==NULL) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	ret = evl_open_file(&dev_context->i2s_dev->oob.efile, fd);
+	if (ret) {
+		kfree(dev_context->i2s_dev);
+		dev_context->i2s_dev=NULL;
+		goto exit;
+	}
+	// dev_context = (struct audio_dev_context *)fd->private_data;
+	// dev_context->i2s_dev = bcm2835_get_i2s_dev();
+	dev_context->i2s_dev->wait_flag = 0;
+	dev_context->user_proc_calls = 0;
+	dev_context->i2s_dev->kinterrupts = 0;
+	dev_context->i2s_dev->buffer_idx = 0;
+	dev_context->i2s_dev->buffer_frame_size = audio_buffer_size;
+	evl_init_flag(&dev_context->i2s_dev->irq_event);
+	// bcm2835_i2s_buffers_setup(audio_buffer_size, audio_output_channels);
+	dev_context->i2s_dev->buffer = &dev_context->buffer;
+	dev_info(&dev_context->pdev->dev,"audio_open.\n");
+	aml_tdm_open(fd);
+
+
+
+exit:
+	spin_unlock_irqrestore(&dev_context->lock,flags);
+	return ret;
+}
+
+static int audio_driver_close(struct inode *inode, struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	unsigned long flags;
+	if(dev_context->i2s_dev->busy) {
+			aml_dai_tdm_mute_stream(fd,1,0);
+			aml_dai_tdm_mute_stream(fd,1,1);	
+			aml_dai_tdm_trigger(fd, 0);
+	}
+	aml_tdm_close(fd);
+	dev_info(&dev_context->pdev->dev,"audio_close.\n");
+	evl_destroy_flag(&dev_context->i2s_dev->irq_event);
+	if (dev_context->i2s_dev->wait_flag) {
+		// for (i = 0; i < i2s_buffer->buffer_len/4; i++) {
+		// 	tx[i] = 0;
+		// }
+		dev_context->i2s_dev->wait_flag = 0;
+	}
+	// bcm2835_i2s_exit();
+	evl_release_file(&dev_context->i2s_dev->oob.efile);
+	spin_lock_irqsave(&dev_context->lock, flags);
+	kfree(dev_context->i2s_dev);
+	dev_context->i2s_dev=NULL;
+	spin_unlock_irqrestore(&dev_context->lock,flags);
+	return 0;
+}
+
+
+
+static int audio_driver_mmap_nrt(struct file *fd, struct vm_area_struct *vma)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+
+	struct audio_rtdm_buffer *i2s_buffer = dev_context->i2s_dev->buffer;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	return dma_mmap_coherent(&dev_context->pdev->dev,vma,i2s_buffer->buffer,i2s_buffer->dma,i2s_buffer->buffer_len);
+	// return  remap_pfn_range(vma, vma->vm_start, vir(i2s_buffer->page), vma->vm_end - vma->vm_start, vma->vm_page_prot);
+
+}
+
+static long audio_driver_ioctl_nrt(struct file *fd, unsigned int request,
+								unsigned long arg)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct audio_rtdm_dev *dev = dev_context->i2s_dev;
+	unsigned int fmt = 0;
+	unsigned int rate = 0;
+	unsigned int cmd = 0;
+	unsigned int val = 0; 
+	if(dev->busy)
+		return -EBUSY;
+	switch (request) {
+		case AUDIO_SET_FORMAT:
+			copy_from_user(&fmt,(void *)arg,sizeof(unsigned int));
+			dev_info(&dev_context->pdev->dev,"Calling set format ioctl, format is %d",fmt);
+			return aml_dai_set_tdm_fmt(fd,fmt);
+		case AUDIO_SET_RATE:
+			copy_from_user(&rate,(void *)arg,sizeof(unsigned int));
+			if(rate<8000 || rate > 96000)
+					return -EINVAL;
+			audio_sampling_rate = rate;
+			aml_dai_set_tdm_slot(dev_context->tdm,3, 3, 2, 32);
+			dev_info(&dev_context->pdev->dev,"Calling set rate ioctl, rate is %d",rate);
+			return aml_dai_tdm_hw_params(fd,rate);
+		case AUDIO_GET_BUFFER_SIZE:
+			val = dev_context->i2s_dev->buffer_frame_size;
+			return copy_to_user((void *)arg,&val,sizeof(val));
+		case AUDIO_GET_RATE:
+			val =  audio_sampling_rate;
+			return copy_to_user((void *)arg,&val,sizeof(val));
+		case AUDIO_SET_BUFFER:
+			copy_from_user(&cmd,(void *)arg,sizeof(unsigned int));
+			dev_info(&dev_context->pdev->dev,"Calling set buffer ioctl, buffer size is %d",cmd);
+			switch (cmd)
+			{
+			case 16:
+			case 32:
+			case 64:
+			case 128:
+			case 256:
+				dev_context->i2s_dev->buffer_frame_size = cmd;
+				audio_buffer_size = cmd;
+				break;
+			
+			default:
+				return -EINVAL;
+				break;
+			}
+			return aml_tdm_prepare(fd);
+			
+
+		default:
+		dev_warn(&dev_context->pdev->dev,"audio_ioctl_nrt: invalid value"
+							" %d\n", request);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static long audio_driver_ioctl_rt(struct file *fd, unsigned int request,
+								unsigned long arg)
+{
+	int result;
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct audio_rtdm_dev *dev = dev_context->i2s_dev;
+	long ret_val = 0;
+	switch (request) {
+
+	case AUDIO_IRQ_WAIT:
+	{
+		result = evl_wait_flag(&dev->irq_event);
+		if (result < 0) {
+			dev_err(&dev_context->pdev->dev,"evl_wait_flag failed with err = %d\n",result);
+			return result;
+		}
+		dev_context->user_proc_calls = dev->kinterrupts;
+		ret_val = !dev->buffer_idx;
+		// dev_info(&dev_context->pdev->dev,"buffer idx = %d\n",ret_val);
+		return copy_to_user((void *)arg,&ret_val,sizeof(ret_val));
+	}
+	break;
+
+	case AUDIO_PROC_START:
+	{
+		// bcm2835_i2s_start_stop(dev, BCM2835_I2S_START_CMD);
+		if(dev->busy)
+			return -EBUSY;
+		dev->busy = true;
+		aml_tdm_prepare(fd);
+		aml_dai_tdm_prepare(fd);
+
+			aml_dai_tdm_mute_stream(fd,0,0);
+			aml_dai_tdm_mute_stream(fd,0,1);
+			return aml_dai_tdm_trigger(fd, 1);
+
+	}
+	break;
+
+	case AUDIO_PROC_STOP:
+	{
+		// bcm2835_i2s_start_stop(dev, BCM2835_I2S_STOP_CMD);
+		if(!dev->busy)
+			return 0;
+		dev->busy = false;
+			aml_dai_tdm_mute_stream(fd,1,0);
+			aml_dai_tdm_mute_stream(fd,1,1);	
+			return aml_dai_tdm_trigger(fd, 0);
+
+	
+	}
+	break;
+
+	case AUDIO_USERPROC_FINISHED:
+	{
+		result = (dev->kinterrupts -
+				dev_context->user_proc_calls);
+		return result;
+	}
+	break;
+
+	default:
+		dev_warn(&dev_context->pdev->dev,"audio_ioctl_rt: invalid value"
+							" %d\n", request);
+		return -EINVAL;
+	}
+}
+
+
+
+static struct cdev  rtdm_audio_device;
+static dev_t audio_devt;
+static const struct file_operations audio_ops  = {
+		.open		= audio_driver_open,
+		.release		= audio_driver_close,
+		.mmap		= audio_driver_mmap_nrt,
+		.oob_ioctl	= audio_driver_ioctl_rt,
+		.unlocked_ioctl		= audio_driver_ioctl_nrt,
+	};
+
+int audio_rtdm_init(void)
+{
+	int ret;
+	struct device *dev;
+	ret = class_register(&audio_rtdm_class);
+	if (ret < 0)
+		return ret;
+
+	if (!evl_enabled()) {
+		printk(KERN_ERR "asnd_auge_rt: realtime core not enabled\n");
+		return -ENODEV;
+	}
+	ret = alloc_chrdev_region(&audio_devt, 0, 1, "aml_snd");
+	if (ret)
+		{
+			class_unregister(&audio_rtdm_class);
+			return ret;
+		}
+
+	cdev_init(&rtdm_audio_device, &audio_ops);
+	ret = cdev_add(&rtdm_audio_device, audio_devt, 1);
+	if (ret)
+		{
+			unregister_chrdev_region(audio_devt, 1);
+			class_unregister(&audio_rtdm_class);
+			return ret;
+		}
+
+	dev = device_create(&audio_rtdm_class, NULL, audio_devt, NULL, "aml-snd");
+	if (IS_ERR(dev)) {
+		ret = PTR_ERR(dev);
+			cdev_del(&rtdm_audio_device);
+			unregister_chrdev_region(audio_devt, 1);
+			class_unregister(&audio_rtdm_class);
+			printk(KERN_ERR "snd_auge_rt: driver init failed\n");
+			return ret;
+	}
+
+	printk(KERN_INFO "snd_auge_rt: Amlogic SOC sound realtime driver initialized\n");
+	return 0;
+}
+
+void audio_rtdm_exit(void)
+{
+	printk(KERN_INFO "snd_auge_rt: Amlogic SOC sound realtime driver exiting...\n");
+	// if (!strcmp(audio_hat, "hifi-berry")) {
+	// 	pcm5122_codec_exit();
+	// } else if (!strcmp(audio_hat, "elk-pi")) {
+	// 	pcm3168a_codec_exit();
+	// }
+	device_destroy(&audio_rtdm_class, MKDEV(MAJOR(audio_devt), 0));
+	cdev_del(&rtdm_audio_device);
+	class_unregister(&audio_rtdm_class);
+}
+
+int snd_realtime_card_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct audio_dev_context *ctx;
+	int ret;
+	ctx = devm_kzalloc(dev,sizeof(*ctx),GFP_KERNEL);
+	if(ctx == NULL)
+	{
+		return -ENOMEM;
+	}
+	ret = allocate_axg_buffers(dev,&ctx->buffer);
+	if(ret) {
+		return ret;
+	}
+	platform_set_drvdata(pdev, ctx);
+	ctx->pdev = pdev;
+    ctx->mdev.minor  = MISC_DYNAMIC_MINOR;
+    ctx->mdev.name   = "aml-sound";
+    ctx->mdev.fops   = &audio_ops;
+    ctx->mdev.parent = NULL;
+	spin_lock_init(&ctx->lock);
+    ret = misc_register(&ctx->mdev);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to register realtime sound driver device\n");
+        return ret;
+    }
+	ret = class_register(&audio_rtdm_class);
+	ret |= aml_audio_controller_probe(pdev);
+	ret |= audio_clocks_probe(pdev);
+	ret |= aml_tdm_platform_setup(pdev);
+	ret |= aml_ddr_mngr_platform_probe(pdev);
+	ret |= snd_iomap_probe(pdev);
+	// ret |= aml_spdif_platform_probe(pdev);
+	if(ret)
+	{
+		// Drop off device in case of failure
+		misc_deregister(&ctx->mdev);
+	}
+    	dev_info(&pdev->dev, "Registered\n");
+
+	return ret;
+}
+static int snd_realtime_card_remove(struct platform_device *pdev)
+{
+    struct audio_dev_context *my = platform_get_drvdata(pdev);
+	dev_err(&pdev->dev, "memory = %pm", my);
+	if(my)
+		free_axg_buffers(&pdev->dev,&my->buffer);
+    misc_deregister(&my->mdev);
+	class_unregister(&audio_rtdm_class);
+    dev_info(&pdev->dev, "Unregistered\n");
+
+    return 0;
+}
+
+static const struct of_device_id sound_card_of_match[] = {
+	{
+		.compatible = "amlogic,axg-sound-realtime",
+	}, {}
+};
+MODULE_DEVICE_TABLE(of, sound_card_of_match);
+
+static struct platform_driver axg_card_realtime_pdrv = {
+	.probe = snd_realtime_card_probe,
+	.remove = snd_realtime_card_remove,
+	.driver = {
+		.name = "axg-sound-realtime",
+		.of_match_table = sound_card_of_match,
+	},
+};
+
+module_platform_driver(axg_card_realtime_pdrv);
+// module_init(audio_rtdm_init)
+// module_exit(audio_rtdm_exit)
diff -ruN a/drivers/evl/sound/evl-amlogic/evl-audio.h b/evl/sound/evl-amlogic/evl-audio.h
--- a/drivers/evl/sound/evl-amlogic/evl-audio.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/evl-audio.h	2022-01-10 13:50:14.418895095 +0300
@@ -0,0 +1,216 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#ifndef AUDIO_RTDM_H
+#define AUDIO_RTDM_H
+
+#include <linux/io.h>
+#include <linux/ioctl.h>
+#include <linux/dma-mapping.h>
+#include <evl/flag.h>
+#include <linux/miscdevice.h>
+
+
+#define RTDM_SUBCLASS_GPIO	0
+#define DEVICE_NAME		"audio_rt"
+#define RTAUDIO_PROFILE_VER	1
+#define AUDIO_RTDM_VERSION_MAJ	0
+#define AUDIO_RTDM_VERSION_MIN	3
+#define AUDIO_RTDM_VERSION_VER	0
+
+#define AUDIO_IOC_MAGIC		'r'
+
+/* ioctl request to wait on dma callback */
+#define AUDIO_IRQ_WAIT			_IOR(AUDIO_IOC_MAGIC, 1,unsigned long)
+/* This ioctl not used anymore but kept for backwards compatibility */
+#define AUDIO_IMMEDIATE_SEND		_IOW(AUDIO_IOC_MAGIC, 2, int)
+/* ioctl request to start receiving audio callbacks */
+#define AUDIO_PROC_START		_IO(AUDIO_IOC_MAGIC, 3)
+/* ioctl to inform the driver the user space process has completed */
+#define AUDIO_USERPROC_FINISHED		_IOW(AUDIO_IOC_MAGIC, 4, int)
+/* ioctl to stop receiving audio callbacks */
+#define AUDIO_PROC_STOP			_IO(AUDIO_IOC_MAGIC, 5)
+
+#define AUDIO_SET_FORMAT		_IOW(AUDIO_IOC_MAGIC, 6, unsigned int)
+#define AUDIO_SET_RATE			_IOW(AUDIO_IOC_MAGIC, 7, unsigned int)
+#define AUDIO_SET_BUFFER		_IOW(AUDIO_IOC_MAGIC, 8, unsigned int)
+
+#define AUDIO_GET_RATE			_IOR(AUDIO_IOC_MAGIC, 9, unsigned int)
+#define AUDIO_GET_BUFFER_SIZE	_IOR(AUDIO_IOC_MAGIC, 10, unsigned int)
+
+// Copies from sound/soc
+
+#define SND_SOC_DAI_FORMAT_I2S          1 /* I2S mode */
+#define SND_SOC_DAI_FORMAT_RIGHT_J      2 /* Right Justified mode */
+#define SND_SOC_DAI_FORMAT_LEFT_J       3 /* Left Justified mode */
+#define SND_SOC_DAI_FORMAT_DSP_A        4 /* L data MSB after FRM LRC */
+#define SND_SOC_DAI_FORMAT_DSP_B        5 /* L data MSB during FRM LRC */
+#define SND_SOC_DAI_FORMAT_AC97         6 /* AC97 */
+#define SND_SOC_DAI_FORMAT_PDM          7 /* Pulse density modulation */
+
+#define SND_SOC_DAIFMT_I2S		SND_SOC_DAI_FORMAT_I2S
+#define SND_SOC_DAIFMT_RIGHT_J		SND_SOC_DAI_FORMAT_RIGHT_J
+#define SND_SOC_DAIFMT_LEFT_J		SND_SOC_DAI_FORMAT_LEFT_J
+#define SND_SOC_DAIFMT_DSP_A		SND_SOC_DAI_FORMAT_DSP_A
+#define SND_SOC_DAIFMT_DSP_B		SND_SOC_DAI_FORMAT_DSP_B
+#define SND_SOC_DAIFMT_AC97		SND_SOC_DAI_FORMAT_AC97
+#define SND_SOC_DAIFMT_PDM		SND_SOC_DAI_FORMAT_PDM
+
+/* left and right justified also known as MSB and LSB respectively */
+#define SND_SOC_DAIFMT_MSB		SND_SOC_DAIFMT_LEFT_J
+#define SND_SOC_DAIFMT_LSB		SND_SOC_DAIFMT_RIGHT_J
+
+/*
+ * DAI hardware clock providers/consumers
+ *
+ * This is wrt the codec, the inverse is true for the interface
+ * i.e. if the codec is clk and FRM provider then the interface is
+ * clk and frame consumer.
+ */
+#define SND_SOC_DAIFMT_CBP_CFP		(1 << 12) /* codec clk provider & frame provider */
+#define SND_SOC_DAIFMT_CBC_CFP		(2 << 12) /* codec clk consumer & frame provider */
+#define SND_SOC_DAIFMT_CBP_CFC		(3 << 12) /* codec clk provider & frame consumer */
+#define SND_SOC_DAIFMT_CBC_CFC		(4 << 12) /* codec clk consumer & frame consumer */
+
+/* previous definitions kept for backwards-compatibility, do not use in new contributions */
+#define SND_SOC_DAIFMT_CBM_CFM		SND_SOC_DAIFMT_CBP_CFP
+#define SND_SOC_DAIFMT_CBS_CFM		SND_SOC_DAIFMT_CBC_CFP
+#define SND_SOC_DAIFMT_CBM_CFS		SND_SOC_DAIFMT_CBP_CFC
+#define SND_SOC_DAIFMT_CBS_CFS		SND_SOC_DAIFMT_CBC_CFC
+
+/*
+ * Master Clock Directions
+ */
+#define SND_SOC_CLOCK_IN		0
+#define SND_SOC_CLOCK_OUT		1
+
+
+#define SND_SOC_DAIFMT_FORMAT_MASK		0x000f
+#define SND_SOC_DAIFMT_CLOCK_MASK		0x00f0
+#define SND_SOC_DAIFMT_INV_MASK			0x0f00
+#define SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK	0xf000
+
+#define SND_SOC_DAIFMT_MASTER_MASK	SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK
+
+/*
+ * DAI Clock gating.
+ *
+ * DAI bit clocks can be gated (disabled) when the DAI is not
+ * sending or receiving PCM data in a frame. This can be used to save power.
+ */
+#define SND_SOC_DAIFMT_CONT		(1 << 4) /* continuous clock */
+#define SND_SOC_DAIFMT_GATED		(0 << 4) /* clock is gated */
+
+enum {
+	SNDRV_PCM_STREAM_PLAYBACK = 0,
+	SNDRV_PCM_STREAM_CAPTURE,
+	SNDRV_PCM_STREAM_LAST = SNDRV_PCM_STREAM_CAPTURE,
+};
+
+#define SNDRV_PCM_TRIGGER_STOP		0
+#define SNDRV_PCM_TRIGGER_START		1
+#define SNDRV_PCM_TRIGGER_PAUSE_PUSH	3
+#define SNDRV_PCM_TRIGGER_PAUSE_RELEASE	4
+#define SNDRV_PCM_TRIGGER_SUSPEND	5
+#define SNDRV_PCM_TRIGGER_RESUME	6
+#define SNDRV_PCM_TRIGGER_DRAIN		7
+
+
+/* If you change this don't forget to change rates[] table in pcm_native.c */
+#define SNDRV_PCM_RATE_5512		(1<<0)		/* 5512Hz */
+#define SNDRV_PCM_RATE_8000		(1<<1)		/* 8000Hz */
+#define SNDRV_PCM_RATE_11025		(1<<2)		/* 11025Hz */
+#define SNDRV_PCM_RATE_16000		(1<<3)		/* 16000Hz */
+#define SNDRV_PCM_RATE_22050		(1<<4)		/* 22050Hz */
+#define SNDRV_PCM_RATE_32000		(1<<5)		/* 32000Hz */
+#define SNDRV_PCM_RATE_44100		(1<<6)		/* 44100Hz */
+#define SNDRV_PCM_RATE_48000		(1<<7)		/* 48000Hz */
+#define SNDRV_PCM_RATE_64000		(1<<8)		/* 64000Hz */
+#define SNDRV_PCM_RATE_88200		(1<<9)		/* 88200Hz */
+#define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
+#define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
+#define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+
+#define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
+#define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
+
+enum codec_sample_format {
+	INT24_LJ = 1,
+	INT24_I2S,
+	INT24_RJ,
+	INT32_RJ
+};
+
+enum platform_type {
+	NATIVE_AUDIO = 1,
+	SYNC_WITH_UC_AUDIO,
+	ASYNC_WITH_UC_AUDIO,
+};
+
+struct audio_rtdm_buffer {
+	void			*buffer;
+	dma_addr_t		dma;
+	size_t			buffer_len;
+	struct 	page	*page;
+	size_t			pages;
+};
+struct aml_audio_controller;
+/* General audio rtdm device struct */
+struct audio_rtdm_dev {
+	struct {
+	    struct evl_file		efile;
+	} 				oob;
+	unsigned int				buffer_frame_size;
+	struct audio_rtdm_buffer 	*buffer;
+	struct evl_flag				irq_event;
+	unsigned int				wait_flag;
+	volatile int				buffer_idx;
+	volatile uint64_t			kinterrupts;
+	volatile uint64_t			nsecs;	
+	bool 						busy;
+};
+
+struct audio_dev_context {
+	struct platform_device *pdev;
+    struct miscdevice 		mdev;
+	struct audio_rtdm_dev *i2s_dev;
+	struct audio_rtdm_buffer buffer;
+	uint64_t user_proc_calls;
+	spinlock_t lock;
+	struct aml_audio_controller * actrl;
+	struct aml_tdm *tdm;
+	struct aml_spdif *spdif;
+};
+int aml_tdm_prepare(struct file* fd);
+int aml_dai_tdm_prepare(struct file* fd);
+int aml_tdm_open(struct file *fd);
+int aml_tdm_close(struct file *fd);
+int aml_dai_tdm_mute_stream(struct file* fd,int mute, int stream);
+
+int aml_dai_tdm_trigger(struct file* fd, int cmd);
+int aml_dai_set_tdm_fmt(struct file *fd, unsigned int fmt);
+int aml_dai_tdm_hw_params(struct file *fd,	unsigned int rate);
+int aml_dai_set_tdm_slot(struct aml_tdm *p_tdm,	unsigned int tx_mask, unsigned int rx_mask,	int slots, int slot_width);
+int aml_tdm_platform_setup(struct platform_device *pdev);
+unsigned int aml_tdm_pointer(struct file *fd);
+unsigned int  aml_tdm_pointer_tddr(struct file *fd);
+static inline struct audio_dev_context *get_audio_dev_context(struct file *file)
+{
+    struct miscdevice *miscdev = file->private_data;
+
+    return container_of(miscdev, struct audio_dev_context, mdev);
+}
+
+#define DEFAULT_AUDIO_SAMPLING_RATE			48000
+#define DEFAULT_AUDIO_NUM_INPUT_CHANNELS		2
+#define DEFAULT_AUDIO_NUM_OUTPUT_CHANNELS		2
+#define DEFAULT_AUDIO_NUM_CODEC_CHANNELS		2
+#define DEFAULT_AUDIO_N_FRAMES_PER_BUFFER		64
+#define DEFAULT_AUDIO_CODEC_FORMAT				INT24_LJ
+#define DEFAULT_AUDIO_LOW_LATENCY_VAL			1
+#define PLATFORM_TYPE					NATIVE_AUDIO
+#define SUPPORTED_BUFFER_SIZES 16, 32, 64, 128, 256
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/evl-axg-memory.c b/evl/sound/evl-amlogic/evl-axg-memory.c
--- a/drivers/evl/sound/evl-amlogic/evl-axg-memory.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/evl-axg-memory.c	2021-12-28 12:28:03.484634361 +0300
@@ -0,0 +1,54 @@
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+
+#include "evl-axg-memory.h"
+
+inline int allocate_axg_buffers(struct device *dev, struct audio_rtdm_buffer *ptr)
+{
+    int i;
+    gfp_t gfp_flags;
+    if(!ptr)
+        return -ENOMEM;
+    gfp_flags = GFP_KERNEL
+		| __GFP_COMP	/* compound page lets parts be mapped */
+		| __GFP_NORETRY /* don't trigger OOM-killer */
+		| __GFP_NOWARN;
+    // ptr->buffer = dma_alloc_coherent(dev,
+	// 			    RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE,
+	// 			    &ptr->dma, GFP_KERNEL | );
+    ptr->buffer =  dma_alloc_coherent(dev, RESERVED_BUFFER_SIZE_IN_PAGES*PAGE_SIZE , &ptr->dma, gfp_flags);
+    ptr->pages = 2;
+    // ptr->page = alloc_pages(GFP_KERNEL | __GFP_ZERO  ,1); // Need 2 pages
+    if(!ptr->buffer)
+        return -ENOMEM;
+    // ptr->buffer = page_address(ptr->page);
+    ptr->buffer_len = RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE;
+    // SetPageReserved(virt_to_page(ptr->buffer));
+    // for(i=0;i<ptr->pages;i++)
+    //     SetPageReserved(ptr->page + i);
+    dev_info(dev,"Allocated buffers at %px with ",ptr->buffer);
+    char * tmp = ptr->buffer;
+    memset(tmp,0xFF,8192);
+    return 0;
+
+}
+
+inline int free_axg_buffers(struct device *dev, struct audio_rtdm_buffer *ptr)
+{
+    int i;
+    dev_info(dev,"First byte is  %hd",((char *)(ptr->buffer))[0]);
+
+    dev_info(dev,"Cleaning buffers at %px",ptr->buffer);
+    // for( i=0;i<ptr->pages;i++)
+    //     ClearPageReserved(ptr->page + i);
+    // ClearPageReserved(virt_to_page(ptr->buffer));
+    // __free_pages(ptr->page,1); // Clear 2 pages
+    dma_free_coherent(dev,
+				    RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE,
+				    ptr->buffer, ptr->dma);
+    dev_info(dev,"Success ");
+    return 0;
+
+}
+
+
diff -ruN a/drivers/evl/sound/evl-amlogic/evl-axg-memory.h b/evl/sound/evl-amlogic/evl-axg-memory.h
--- a/drivers/evl/sound/evl-amlogic/evl-axg-memory.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/evl-axg-memory.h	2021-12-18 13:19:47.431075156 +0300
@@ -0,0 +1,11 @@
+#ifndef EVL_AXG_MEM_H
+#define EVL_AXG_MEM_H
+
+#define RESERVED_BUFFER_SIZE_IN_PAGES 2
+
+#include "evl-audio.h"
+
+inline int allocate_axg_buffers(struct device *dev, struct audio_rtdm_buffer *ptr);
+inline int free_axg_buffers(struct device *dev, struct audio_rtdm_buffer *ptr);
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/g12a,clocks.c b/evl/sound/evl-amlogic/g12a,clocks.c
--- a/drivers/evl/sound/evl-amlogic/g12a,clocks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/g12a,clocks.c	2021-12-23 13:30:23.466158972 +0300
@@ -0,0 +1,254 @@
+/*
+ * sound/soc/amlogic/auge/audio_clocks.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "g12a_clocks: " fmt
+
+#include "dt-bindings/amlogic,g12a-audio-clk.h"
+
+#include "audio_clks.h"
+#include "regs.h"
+
+static spinlock_t aclk_lock;
+
+static const char *const mclk_parent_names[] = {"mpll0", "mpll1",
+	"mpll2", "mpll3", "hifi_pll", "fclk_div3", "fclk_div4", "gp0_pll"};
+
+static const char *const audioclk_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c", "mclk_d", "mclk_e",
+	"mclk_f", "i_slv_sclk_a", "i_slv_sclk_b", "i_slv_sclk_c",
+	"i_slv_sclk_d", "i_slv_sclk_e", "i_slv_sclk_f", "i_slv_sclk_g",
+	"i_slv_sclk_h", "i_slv_sclk_i", "i_slv_sclk_j"};
+
+CLOCK_GATE(audio_ddr_arb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 0);
+CLOCK_GATE(audio_pdm, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 1);
+CLOCK_GATE(audio_tdmina, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 2);
+CLOCK_GATE(audio_tdminb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 3);
+CLOCK_GATE(audio_tdminc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 4);
+CLOCK_GATE(audio_tdminlb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 5);
+CLOCK_GATE(audio_tdmouta, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 6);
+CLOCK_GATE(audio_tdmoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 7);
+CLOCK_GATE(audio_tdmoutc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 8);
+CLOCK_GATE(audio_frddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 9);
+CLOCK_GATE(audio_frddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 10);
+CLOCK_GATE(audio_frddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 11);
+CLOCK_GATE(audio_toddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 12);
+CLOCK_GATE(audio_toddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 13);
+CLOCK_GATE(audio_toddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 14);
+CLOCK_GATE(audio_loopback, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 15);
+CLOCK_GATE(audio_spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 16);
+CLOCK_GATE(audio_spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 17);
+CLOCK_GATE(audio_resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 18);
+CLOCK_GATE(audio_power_detect, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 19);
+CLOCK_GATE(audio_toram, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 20);
+CLOCK_GATE(audio_spdifoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 21);
+CLOCK_GATE(audio_eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 22);
+
+static struct clk_gate *g12a_audio_clk_gates[] = {
+	&audio_ddr_arb,
+	&audio_pdm,
+	&audio_tdmina,
+	&audio_tdminb,
+	&audio_tdminc,
+	&audio_tdminlb,
+	&audio_tdmouta,
+	&audio_tdmoutb,
+	&audio_tdmoutc,
+	&audio_frddra,
+	&audio_frddrb,
+	&audio_frddrc,
+	&audio_toddra,
+	&audio_toddrb,
+	&audio_toddrc,
+	&audio_loopback,
+	&audio_spdifin,
+	&audio_spdifout,
+	&audio_resample,
+	&audio_power_detect,
+	&audio_toram,
+	&audio_spdifoutb,
+	&audio_eqdrc,
+};
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw *g12a_audio_clk_hws[] = {
+	[CLKID_AUDIO_DDR_ARB] = &audio_ddr_arb.hw,
+	[CLKID_AUDIO_PDM] = &audio_pdm.hw,
+	[CLKID_AUDIO_TDMINA] = &audio_tdmina.hw,
+	[CLKID_AUDIO_TDMINB] = &audio_tdminb.hw,
+	[CLKID_AUDIO_TDMINC] = &audio_tdminc.hw,
+	[CLKID_AUDIO_TDMINLB] = &audio_tdminlb.hw,
+	[CLKID_AUDIO_TDMOUTA] = &audio_tdmouta.hw,
+	[CLKID_AUDIO_TDMOUTB] = &audio_tdmoutb.hw,
+	[CLKID_AUDIO_TDMOUTC] = &audio_tdmoutc.hw,
+	[CLKID_AUDIO_FRDDRA] = &audio_frddra.hw,
+	[CLKID_AUDIO_FRDDRB] = &audio_frddrb.hw,
+	[CLKID_AUDIO_FRDDRC] = &audio_frddrc.hw,
+	[CLKID_AUDIO_TODDRA] = &audio_toddra.hw,
+	[CLKID_AUDIO_TODDRB] = &audio_toddrb.hw,
+	[CLKID_AUDIO_TODDRC] = &audio_toddrc.hw,
+	[CLKID_AUDIO_LOOPBACK] = &audio_loopback.hw,
+	[CLKID_AUDIO_SPDIFIN] = &audio_spdifin.hw,
+	[CLKID_AUDIO_SPDIFOUT] = &audio_spdifout.hw,
+	[CLKID_AUDIO_RESAMPLE] = &audio_resample.hw,
+	[CLKID_AUDIO_POWER_DETECT] = &audio_power_detect.hw,
+	[CLKID_AUDIO_TORAM] = &audio_toram.hw,
+	[CLKID_AUDIO_SPDIFOUTB] = &audio_spdifoutb.hw,
+	[CLKID_AUDIO_EQDRC] = &audio_eqdrc.hw,
+};
+
+static int g12a_clk_gates_init(struct clk **clks, void __iomem *iobase)
+{
+	int clkid;
+
+	if (ARRAY_SIZE(g12a_audio_clk_gates) != MCLK_BASE) {
+		pr_err("check clk gates number\n");
+		return -EINVAL;
+	}
+
+	for (clkid = 0; clkid < MCLK_BASE; clkid++) {
+		g12a_audio_clk_gates[clkid]->reg = iobase;
+		clks[clkid] = clk_register(NULL, g12a_audio_clk_hws[clkid]);
+		WARN_ON(IS_ERR_OR_NULL(clks[clkid]));
+	}
+
+	return 0;
+}
+
+/* mclk_a */
+CLOCK_COM_MUX(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(0)), 31);
+/* mclk_b */
+CLOCK_COM_MUX(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(0)), 31);
+/* mclk_c */
+CLOCK_COM_MUX(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(0)), 31);
+/* mclk_d */
+CLOCK_COM_MUX(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(0)), 31);
+/* mclk_e */
+CLOCK_COM_MUX(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(0)), 31);
+/* mclk_f */
+CLOCK_COM_MUX(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 0x7, 24);
+CLOCK_COM_DIV(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 0, 16);
+CLOCK_COM_GATE(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(0)), 31);
+/* spdifin */
+CLOCK_COM_MUX(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0, 8);
+CLOCK_COM_GATE(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 31);
+/* spdifout */
+CLOCK_COM_MUX(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 31);
+/* pdmin0 */
+CLOCK_COM_MUX(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0, 16);
+CLOCK_COM_GATE(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 31);
+/* pdmin1 */
+CLOCK_COM_MUX(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0x7, 24);
+CLOCK_COM_DIV(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0, 16);
+CLOCK_COM_GATE(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 31);
+/* spdifout b*/
+CLOCK_COM_MUX(spdifout_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio locker_out */
+CLOCK_COM_MUX(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 24);
+CLOCK_COM_DIV(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 16, 8);
+CLOCK_COM_GATE(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 31);
+/* audio locker_in */
+CLOCK_COM_MUX(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 8);
+CLOCK_COM_DIV(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0, 8);
+CLOCK_COM_GATE(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 15);
+/* audio resample */
+CLOCK_COM_MUX(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0, 8);
+CLOCK_COM_GATE(resample, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 31);
+
+static int g12a_clks_init(struct clk **clks, void __iomem *iobase)
+{
+	IOMAP_COM_CLK(mclk_a, iobase);
+	clks[CLKID_AUDIO_MCLK_A] = REGISTER_CLK_COM(mclk_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_A]));
+
+	IOMAP_COM_CLK(mclk_b, iobase);
+	clks[CLKID_AUDIO_MCLK_B] = REGISTER_CLK_COM(mclk_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_B]));
+
+	IOMAP_COM_CLK(mclk_c, iobase);
+	clks[CLKID_AUDIO_MCLK_C] = REGISTER_CLK_COM(mclk_c);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_C]));
+
+	IOMAP_COM_CLK(mclk_d, iobase);
+	clks[CLKID_AUDIO_MCLK_D] = REGISTER_CLK_COM(mclk_d);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_D]));
+
+	IOMAP_COM_CLK(mclk_e, iobase);
+	clks[CLKID_AUDIO_MCLK_E] = REGISTER_CLK_COM(mclk_e);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_E]));
+
+	IOMAP_COM_CLK(mclk_f, iobase);
+	clks[CLKID_AUDIO_MCLK_F] = REGISTER_CLK_COM(mclk_f);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_F]));
+
+	IOMAP_COM_CLK(spdifin, iobase);
+	clks[CLKID_AUDIO_SPDIFIN_CTRL] = REGISTER_CLK_COM(spdifin);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN_CTRL]));
+
+	IOMAP_COM_CLK(spdifout, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_CTRL] = REGISTER_CLK_COM(spdifout);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_CTRL]));
+
+	IOMAP_COM_CLK(pdmin0, iobase);
+	clks[CLKID_AUDIO_PDMIN0] = REGISTER_CLK_COM(pdmin0);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN0]));
+
+	IOMAP_COM_CLK(pdmin1, iobase);
+	clks[CLKID_AUDIO_PDMIN1] = REGISTER_CLK_COM(pdmin1);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN1]));
+
+	IOMAP_COM_CLK(spdifout_b, iobase);
+	clks[CLKID_AUDIO_SPDIFOUTB_CTRL] = REGISTER_CLK_COM(spdifout_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUTB_CTRL]));
+
+	IOMAP_COM_CLK(locker_out, iobase);
+	clks[CLKID_AUDIO_LOCKER_OUT] = REGISTER_AUDIOCLK_COM(locker_out);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_OUT]));
+
+	IOMAP_COM_CLK(locker_in, iobase);
+	clks[CLKID_AUDIO_LOCKER_IN] = REGISTER_AUDIOCLK_COM(locker_in);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_IN]));
+
+	IOMAP_COM_CLK(resample, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_CTRL] = REGISTER_AUDIOCLK_COM(resample);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_CTRL]));
+
+	return 0;
+}
+
+struct audio_clk_init g12a_audio_clks_init = {
+	.clk_num   = NUM_AUDIO_CLKS,
+	.clk_gates = g12a_clk_gates_init,
+	.clks      = g12a_clks_init,
+};
diff -ruN a/drivers/evl/sound/evl-amlogic/hifi-berry-config.h b/evl/sound/evl-amlogic/hifi-berry-config.h
--- a/drivers/evl/sound/evl-amlogic/hifi-berry-config.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/hifi-berry-config.h	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* @brief config file to keep board specific configs (e.g. num of CV gates)
+* @copyright 2017-2020 Modern Ancient Instruments Networked AB, dba Elk,
+* Stockholm
+*/
+#ifndef HIFI_BERRY_CONFIG_H_
+#define HIFI_BERRY_CONFIG_H_
+
+#define HIFI_BERRY_NUM_INPUT_CHANNELS		2
+#define HIFI_BERRY_NUM_OUTPUT_CHANNELS		2
+
+// num channels sent by the codec
+#define HIFI_BERRY_NUM_CODEC_CHANNELS		2
+
+#define HIFI_BERRY_CODEC_FORMAT			INT24_LJ
+
+#define HIFI_BERRY_SAMPLING_RATE		48000
+
+#define HIFI_BERRY_DAC_MODE			PCM5122_SLAVE_MODE
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/hifi-berry-pro-config.h b/evl/sound/evl-amlogic/hifi-berry-pro-config.h
--- a/drivers/evl/sound/evl-amlogic/hifi-berry-pro-config.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/hifi-berry-pro-config.h	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+* @brief config file to keep board specific configs (e.g. num of CV gates)
+* @copyright 2017-2020 Modern Ancient Instruments Networked AB, dba Elk,
+* Stockholm
+*/
+#ifndef HIFI_BERRY_PRO_CONFIG_H_
+#define HIFI_BERRY_PRO_CONFIG_H_
+
+#define HIFI_BERRY_PRO_NUM_INPUT_CHANNELS	2
+#define HIFI_BERRY_PRO_NUM_OUTPUT_CHANNELS	2
+
+// num channels sent by the codec
+#define HIFI_BERRY_PRO_NUM_CODEC_CHANNELS	2
+
+#define HIFI_BERRY_PRO_CODEC_FORMAT		INT24_LJ
+
+#define HIFI_BERRY_PRO_SAMPLING_RATE		48000
+
+#define HIFI_BERRY_PRO_DAC_MODE			PCM5122_MASTER_MODE
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/iomap.c b/evl/sound/evl-amlogic/iomap.c
--- a/drivers/evl/sound/evl-amlogic/iomap.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/iomap.c	2021-12-24 15:40:00.178986338 +0300
@@ -0,0 +1,364 @@
+/*
+ * sound/soc/amlogic/auge/iomap.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/*#define DEBUG*/
+
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+
+#include "iomap.h"
+#include "audio_aed_reg_list.h"
+#include "audio_top_reg_list.h"
+
+#define DEV_NAME	"auge_snd_iomap"
+
+static void __iomem *aml_snd_reg_map[IO_MAX];
+
+#ifdef DEBUG
+static void register_debug(u32 base_type, unsigned int reg, unsigned int val)
+{
+	if (base_type == IO_AUDIO_BUS) {
+		pr_debug("audio top reg:[%s] addr: [%#x] val: [%#x]\n",
+			top_register_table[reg].name,
+			top_register_table[reg].addr, val);
+	} else if (base_type == IO_EQDRC_BUS) {
+		pr_debug("audio aed reg:[%s] addr: [%#x] val: [%#x]\n",
+			aed_register_table[reg].name,
+			aed_register_table[reg].addr, val);
+	}
+}
+#endif
+
+static int aml_snd_read(u32 base_type, unsigned int reg, unsigned int *val)
+{
+	if (base_type < IO_MAX) {
+		*val = readl((aml_snd_reg_map[base_type] + (reg << 2)));
+
+		return 0;
+	}
+
+	return -1;
+}
+
+static void aml_snd_write(u32 base_type, unsigned int reg, unsigned int val)
+{
+
+	if (base_type < IO_MAX) {
+		writel(val, (aml_snd_reg_map[base_type] + (reg << 2)));
+#ifdef DEBUG
+		register_debug(base_type, reg, val);
+#endif
+		return;
+	}
+
+	pr_err("write snd reg %x error\n", reg);
+}
+
+static void aml_snd_update_bits(u32 base_type,
+			unsigned int reg, unsigned int mask,
+			unsigned int val)
+{
+	if (base_type < IO_MAX) {
+		unsigned int tmp, orig;
+
+		if (aml_snd_read(base_type, reg, &orig) == 0) {
+			tmp = orig & ~mask;
+			tmp |= val & mask;
+			aml_snd_write(base_type, reg, tmp);
+
+			return;
+		}
+	}
+	pr_err("write snd reg %x error\n", reg);
+
+}
+
+int aml_pdm_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_PDM_BUS, reg, &val);
+
+	if (ret) {
+		pr_err("read pdm reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(aml_pdm_read);
+
+void aml_pdm_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_PDM_BUS, reg, val);
+}
+EXPORT_SYMBOL(aml_pdm_write);
+
+void aml_pdm_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_PDM_BUS, reg, mask, val);
+}
+EXPORT_SYMBOL(aml_pdm_update_bits);
+
+int audiobus_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_AUDIO_BUS, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(audiobus_read);
+
+void audiobus_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_AUDIO_BUS, reg, val);
+}
+EXPORT_SYMBOL(audiobus_write);
+
+void audiobus_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_AUDIO_BUS, reg, mask, val);
+}
+EXPORT_SYMBOL(audiobus_update_bits);
+
+int audiolocker_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_AUDIO_LOCKER, reg, &val);
+
+	if (ret) {
+		pr_err("read reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(audiolocker_read);
+
+void audiolocker_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_AUDIO_LOCKER, reg, val);
+}
+EXPORT_SYMBOL(audiolocker_write);
+
+void audiolocker_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_AUDIO_LOCKER, reg, mask, val);
+}
+EXPORT_SYMBOL(audiolocker_update_bits);
+
+int eqdrc_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_EQDRC_BUS, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(eqdrc_read);
+
+void eqdrc_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_EQDRC_BUS, reg, val);
+}
+EXPORT_SYMBOL(eqdrc_write);
+
+void eqdrc_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_EQDRC_BUS, reg, mask, val);
+}
+EXPORT_SYMBOL(eqdrc_update_bits);
+
+int audioreset_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_RESET, reg, &val);
+
+	if (ret) {
+		pr_err("read reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(audioreset_read);
+
+void audioreset_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_RESET, reg, val);
+}
+EXPORT_SYMBOL(audioreset_write);
+
+void audioreset_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_RESET, reg, mask, val);
+}
+EXPORT_SYMBOL(audioreset_update_bits);
+
+int vad_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_VAD, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(vad_read);
+
+void vad_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_VAD, reg, val);
+}
+EXPORT_SYMBOL(vad_write);
+
+void vad_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_VAD, reg, mask, val);
+}
+EXPORT_SYMBOL(vad_update_bits);
+
+int earcrx_cmdc_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_EARCRX_CMDC, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(earcrx_cmdc_read);
+
+void earcrx_cmdc_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_EARCRX_CMDC, reg, val);
+}
+EXPORT_SYMBOL(earcrx_cmdc_write);
+
+void earcrx_cmdc_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_EARCRX_CMDC, reg, mask, val);
+}
+EXPORT_SYMBOL(earcrx_cmdc_update_bits);
+
+int earcrx_dmac_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_EARCRX_DMAC, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(earcrx_dmac_read);
+
+void earcrx_dmac_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_EARCRX_DMAC, reg, val);
+}
+EXPORT_SYMBOL(earcrx_dmac_write);
+
+void earcrx_dmac_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_EARCRX_DMAC, reg, mask, val);
+}
+EXPORT_SYMBOL(earcrx_dmac_update_bits);
+
+int earcrx_top_read(unsigned int reg)
+{
+	int ret, val = 0;
+
+	ret = aml_snd_read(IO_EARCRX_TOP, reg, &val);
+
+	if (ret) {
+		pr_err("read audio reg %x error %d\n", reg, ret);
+		return -1;
+	}
+	return val;
+}
+EXPORT_SYMBOL(earcrx_top_read);
+
+void earcrx_top_write(unsigned int reg, unsigned int val)
+{
+	aml_snd_write(IO_EARCRX_TOP, reg, val);
+}
+EXPORT_SYMBOL(earcrx_top_write);
+
+void earcrx_top_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val)
+{
+	aml_snd_update_bits(IO_EARCRX_TOP, reg, mask, val);
+}
+EXPORT_SYMBOL(earcrx_top_update_bits);
+
+int snd_iomap_probe(struct platform_device *pdev)
+{
+	struct resource res;
+	struct device_node *np, *child;
+	int i = 0;
+	int ret = 0;
+
+	np  = of_find_node_by_name(pdev->dev.of_node, "aml_snd_iomap");
+
+	if(np == NULL)
+		return -ENOENT;
+	for_each_child_of_node(np, child) {
+		if (of_address_to_resource(child, 0, &res)) {
+			ret = -1;
+			dev_info(&pdev->dev,"%s could not get resource",
+				__func__);
+			break;
+		}
+		aml_snd_reg_map[i] =
+			ioremap(res.start, resource_size(&res));
+		dev_info(&pdev->dev,"aml_snd_reg_map[%d], reg:%x, size:%x\n",
+			i, (u32)res.start, (u32)resource_size(&res));
+
+		i++;
+	}
+	dev_info(&pdev->dev,"amlogic %s probe done\n", DEV_NAME);
+
+	return ret;
+}
+
diff -ruN a/drivers/evl/sound/evl-amlogic/iomap.h b/evl/sound/evl-amlogic/iomap.h
--- a/drivers/evl/sound/evl-amlogic/iomap.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/iomap.h	2021-12-20 17:16:45.434253746 +0300
@@ -0,0 +1,79 @@
+/*
+ * sound/soc/amlogic/auge/iomap.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SND_IOMAP_H__
+#define __AML_SND_IOMAP_H__
+
+enum{
+	IO_PDM_BUS = 0,
+	IO_AUDIO_BUS,
+	IO_AUDIO_LOCKER,
+	IO_EQDRC_BUS,
+	IO_RESET,
+	IO_VAD,
+	IO_EARCRX_CMDC,
+	IO_EARCRX_DMAC,
+	IO_EARCRX_TOP,
+
+	IO_MAX,
+};
+
+extern int aml_pdm_read(unsigned int reg);
+extern void aml_pdm_write(unsigned int reg, unsigned int val);
+extern void aml_pdm_update_bits(unsigned int reg,
+	unsigned int mask, unsigned int val);
+
+extern int audiobus_read(unsigned int reg);
+extern void audiobus_write(unsigned int reg, unsigned int val);
+extern void audiobus_update_bits(unsigned int reg,
+	unsigned int mask, unsigned int val);
+
+extern int audiolocker_read(unsigned int reg);
+extern void audiolocker_write(unsigned int reg, unsigned int val);
+extern void audiolocker_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+extern int eqdrc_read(unsigned int reg);
+extern void eqdrc_write(unsigned int reg, unsigned int val);
+extern void eqdrc_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+extern int audioreset_read(unsigned int reg);
+extern void audioreset_write(unsigned int reg, unsigned int val);
+extern void audioreset_update_bits(unsigned int reg,
+	unsigned int mask, unsigned int val);
+
+extern int vad_read(unsigned int reg);
+extern void vad_write(unsigned int reg, unsigned int val);
+extern void vad_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+extern int earcrx_cmdc_read(unsigned int reg);
+extern void earcrx_cmdc_write(unsigned int reg, unsigned int val);
+extern void earcrx_cmdc_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+extern int earcrx_dmac_read(unsigned int reg);
+extern void earcrx_dmac_write(unsigned int reg, unsigned int val);
+extern void earcrx_dmac_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+extern int earcrx_top_read(unsigned int reg);
+extern void earcrx_top_write(unsigned int reg, unsigned int val);
+extern void earcrx_top_update_bits(unsigned int reg,
+		unsigned int mask, unsigned int val);
+
+int snd_iomap_probe(struct platform_device *pdev);
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/regs.h b/evl/sound/evl-amlogic/regs.h
--- a/drivers/evl/sound/evl-amlogic/regs.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/regs.h	2021-12-19 13:00:42.727447455 +0300
@@ -0,0 +1,1165 @@
+/*
+ * sound/soc/amlogic/auge/regs.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_REGS_H_
+#define __AML_REGS_H_
+
+enum clk_sel {
+	MASTER_A,
+	MASTER_B,
+	MASTER_C,
+	MASTER_D,
+	MASTER_E,
+	MASTER_F,
+	SLAVE_A,
+	SLAVE_B,
+	SLAVE_C,
+	SLAVE_D,
+	SLAVE_E,
+	SLAVE_F,
+	SLAVE_G,
+	SLAVE_H,
+	SLAVE_I,
+	SLAVE_J
+};
+
+struct register_table {
+	char *name;
+	unsigned int addr;
+};
+
+#define AUD_ADDR_OFFSET(addr)              ((addr) << 2)
+
+/*
+ *  PDM - Registers
+ */
+#define PDM_CTRL                           0x00
+#define PDM_HCIC_CTRL1                     0x01
+#define PDM_HCIC_CTRL2                     0x02
+#define PDM_F1_CTRL                        0x03
+#define PDM_F2_CTRL                        0x04
+#define PDM_F3_CTRL                        0x05
+#define PDM_HPF_CTRL                       0x06
+#define PDM_CHAN_CTRL                      0x07
+#define PDM_CHAN_CTRL1                     0x08
+#define PDM_COEFF_ADDR                     0x09
+#define PDM_COEFF_DATA                     0x0A
+#define PDM_CLKG_CTRL                      0x0B
+#define PDM_STS                            0x0C
+#define PDM_MUTE_VALUE                     0x0D
+#define PDM_MASK_NUM                       0x0E
+
+/*
+ *	AUDIO CLOCK, MST PAD,
+ */
+#define EE_AUDIO_CLK_GATE_EN0              0x000
+#define EE_AUDIO_CLK_GATE_EN1              0x001
+#define EE_AUDIO_MCLK_A_CTRL(offset)       (0x001 + offset)
+#define EE_AUDIO_MCLK_B_CTRL(offset)       (0x002 + offset)
+#define EE_AUDIO_MCLK_C_CTRL(offset)       (0x003 + offset)
+#define EE_AUDIO_MCLK_D_CTRL(offset)       (0x004 + offset)
+#define EE_AUDIO_MCLK_E_CTRL(offset)       (0x005 + offset)
+#define EE_AUDIO_MCLK_F_CTRL(offset)       (0x006 + offset)
+#define EE_AUDIO_MST_PAD_CTRL0(offset)     (0x007 + offset)
+#define EE_AUDIO_MST_PAD_CTRL1(offset)     (0x008 + offset)
+
+#define REG_BIT_RESET_PDM				(1)
+#define REG_BIT_RESET_TDMINA				(1 << 1)
+#define REG_BIT_RESET_TDMINB				(1 << 2)
+#define REG_BIT_RESET_TDMINC				(1 << 3)
+#define REG_BIT_RESET_TDMIN_LB				(1 << 4)
+#define REG_BIT_RESET_LOOPBACK				(1 << 5)
+#define REG_BIT_RESET_TODDRA				(1 << 6)
+#define REG_BIT_RESET_TODDRB				(1 << 7)
+#define REG_BIT_RESET_TODDRC				(1 << 8)
+#define REG_BIT_RESET_FRDDRA				(1 << 9)
+#define REG_BIT_RESET_FRDDRB				(1 << 10)
+#define REG_BIT_RESET_FRDDRC				(1 << 11)
+#define REG_BIT_RESET_TDMOUTA				(1 << 12)
+#define REG_BIT_RESET_TDMOUTB				(1 << 13)
+#define REG_BIT_RESET_TDMOUTC				(1 << 14)
+#define REG_BIT_RESET_SPDIFOUTA				(1 << 15)
+#define REG_BIT_RESET_SPDIFOUTB				(1 << 16)
+#define REG_BIT_RESET_SPDIFIN				(1 << 17)
+#define REG_BIT_RESET_EQDRC				(1 << 18)
+#define REG_BIT_RESET_RESAMPLE				(1 << 19)
+#define REG_BIT_RESET_DDRARB				(1 << 20)
+#define REG_BIT_RESET_POWDET				(1 << 21)
+#define REG_BIT_RESET_TORAM				(1 << 22)
+#define REG_BIT_RESET_TOACODEC				(1 << 23)
+#define REG_BIT_RESET_TOHDMITX				(1 << 24)
+#define REG_BIT_RESET_CLKTREE				(1 << 25)
+#define REG_BIT_RESET_RESAMPLEB				(1 << 26)
+#define REG_BIT_RESET_TOVAD				(1 << 27)
+#define REG_BIT_RESET_LOCKER				(1 << 28)
+#define REG_BIT_RESET_SPDIFIN_LB			(1 << 29)
+#define REG_BIT_RESET_FRATV				(1 << 30)
+#define REG_BIT_RESET_FRHDMIRX				(1 << 31)
+
+#define EE_AUDIO_SW_RESET0(offset)         (0x009 + offset)
+
+#define REG_BIT_RESET_FRDDRD				(1)
+#define REG_BIT_RESET_TODDRD				(1 << 1)
+#define REG_BIT_RESET_LOOPBACKB				(1 << 2)
+
+#define EE_AUDIO_SW_RESET1                 0x00b
+#define EE_AUDIO_CLK81_CTRL                0x00c
+#define EE_AUDIO_CLK81_EN                  0x00d
+
+
+#define EE_AUDIO_MST_A_SCLK_CTRL0          0x010
+#define EE_AUDIO_MST_A_SCLK_CTRL1          0x011
+#define EE_AUDIO_MST_B_SCLK_CTRL0          0x012
+#define EE_AUDIO_MST_B_SCLK_CTRL1          0x013
+#define EE_AUDIO_MST_C_SCLK_CTRL0          0x014
+#define EE_AUDIO_MST_C_SCLK_CTRL1          0x015
+#define EE_AUDIO_MST_D_SCLK_CTRL0          0x016
+#define EE_AUDIO_MST_D_SCLK_CTRL1          0x017
+#define EE_AUDIO_MST_E_SCLK_CTRL0          0x018
+#define EE_AUDIO_MST_E_SCLK_CTRL1          0x019
+#define EE_AUDIO_MST_F_SCLK_CTRL0          0x01a
+#define EE_AUDIO_MST_F_SCLK_CTRL1          0x01b
+
+#define EE_AUDIO_CLK_TDMIN_A_CTRL          0x020
+#define EE_AUDIO_CLK_TDMIN_B_CTRL          0x021
+#define EE_AUDIO_CLK_TDMIN_C_CTRL          0x022
+#define EE_AUDIO_CLK_TDMIN_LB_CTRL         0x023
+#define EE_AUDIO_CLK_TDMOUT_A_CTRL         0x024
+#define EE_AUDIO_CLK_TDMOUT_B_CTRL         0x025
+#define EE_AUDIO_CLK_TDMOUT_C_CTRL         0x026
+#define EE_AUDIO_CLK_SPDIFIN_CTRL          0x027
+#define EE_AUDIO_CLK_SPDIFOUT_CTRL         0x028
+#define EE_AUDIO_CLK_RESAMPLEA_CTRL        0x029
+#define EE_AUDIO_CLK_LOCKER_CTRL           0x02a
+#define EE_AUDIO_CLK_PDMIN_CTRL0           0x02b
+#define EE_AUDIO_CLK_PDMIN_CTRL1           0x02c
+#define EE_AUDIO_CLK_SPDIFOUT_B_CTRL       0x02d
+#define EE_AUDIO_CLK_RESAMPLEB_CTRL        0x02e
+#define EE_AUDIO_CLK_SPDIFIN_LB_CTRL       0x02f
+#define EE_AUDIO_CLK_EQDRC_CTRL0           0x030
+#define EE_AUDIO_CLK_VAD_CTRL              0x031
+#define EE_AUDIO_EARCTX_CMDC_CLK_CTRL      0x032
+#define EE_AUDIO_EARCTX_DMAC_CLK_CTRL      0x033
+#define EE_AUDIO_EARCRX_CMDC_CLK_CTRL      0x034
+#define EE_AUDIO_EARCRX_DMAC_CLK_CTRL      0x035
+
+/*
+ *	AUDIO TODDR
+ */
+#define EE_AUDIO_TODDR_A_CTRL0             0x040
+#define EE_AUDIO_TODDR_A_CTRL1             0x041
+#define EE_AUDIO_TODDR_A_START_ADDR        0x042
+#define EE_AUDIO_TODDR_A_FINISH_ADDR       0x043
+#define EE_AUDIO_TODDR_A_INT_ADDR          0x044
+#define EE_AUDIO_TODDR_A_STATUS1           0x045
+#define EE_AUDIO_TODDR_A_STATUS2           0x046
+#define EE_AUDIO_TODDR_A_START_ADDRB       0x047
+#define EE_AUDIO_TODDR_A_FINISH_ADDRB      0x048
+#define EE_AUDIO_TODDR_A_INIT_ADDR         0x049
+#define EE_AUDIO_TODDR_A_CTRL2             0x04a
+
+#define EE_AUDIO_TODDR_B_CTRL0             0x050
+#define EE_AUDIO_TODDR_B_CTRL1             0x051
+#define EE_AUDIO_TODDR_B_START_ADDR        0x052
+#define EE_AUDIO_TODDR_B_FINISH_ADDR       0x053
+#define EE_AUDIO_TODDR_B_INT_ADDR          0x054
+#define EE_AUDIO_TODDR_B_STATUS1           0x055
+#define EE_AUDIO_TODDR_B_STATUS2           0x056
+#define EE_AUDIO_TODDR_B_START_ADDRB       0x057
+#define EE_AUDIO_TODDR_B_FINISH_ADDRB      0x058
+#define EE_AUDIO_TODDR_B_INIT_ADDR         0x059
+#define EE_AUDIO_TODDR_B_CTRL2             0x05a
+
+#define EE_AUDIO_TODDR_C_CTRL0             0x060
+#define EE_AUDIO_TODDR_C_CTRL1             0x061
+#define EE_AUDIO_TODDR_C_START_ADDR        0x062
+#define EE_AUDIO_TODDR_C_FINISH_ADDR       0x063
+#define EE_AUDIO_TODDR_C_INT_ADDR          0x064
+#define EE_AUDIO_TODDR_C_STATUS1           0x065
+#define EE_AUDIO_TODDR_C_STATUS2           0x066
+#define EE_AUDIO_TODDR_C_START_ADDRB       0x067
+#define EE_AUDIO_TODDR_C_FINISH_ADDRB      0x068
+#define EE_AUDIO_TODDR_C_INIT_ADDR         0x069
+#define EE_AUDIO_TODDR_C_CTRL2             0x06a
+
+/*
+ *	AUDIO FRDDR
+ */
+#define EE_AUDIO_FRDDR_A_CTRL0             0x070
+#define EE_AUDIO_FRDDR_A_CTRL1             0x071
+#define EE_AUDIO_FRDDR_A_START_ADDR        0x072
+#define EE_AUDIO_FRDDR_A_FINISH_ADDR       0x073
+#define EE_AUDIO_FRDDR_A_INT_ADDR          0x074
+#define EE_AUDIO_FRDDR_A_STATUS1           0x075
+#define EE_AUDIO_FRDDR_A_STATUS2           0x076
+#define EE_AUDIO_FRDDR_A_START_ADDRB       0x077
+#define EE_AUDIO_FRDDR_A_FINISH_ADDRB      0x078
+#define EE_AUDIO_FRDDR_A_INIT_ADDR         0x079
+#define EE_AUDIO_FRDDR_A_CTRL2             0x07a
+
+#define EE_AUDIO_FRDDR_B_CTRL0             0x080
+#define EE_AUDIO_FRDDR_B_CTRL1             0x081
+#define EE_AUDIO_FRDDR_B_START_ADDR        0x082
+#define EE_AUDIO_FRDDR_B_FINISH_ADDR       0x083
+#define EE_AUDIO_FRDDR_B_INT_ADDR          0x084
+#define EE_AUDIO_FRDDR_B_STATUS1           0x085
+#define EE_AUDIO_FRDDR_B_STATUS2           0x086
+#define EE_AUDIO_FRDDR_B_START_ADDRB       0x087
+#define EE_AUDIO_FRDDR_B_FINISH_ADDRB      0x088
+#define EE_AUDIO_FRDDR_B_INIT_ADDR         0x089
+#define EE_AUDIO_FRDDR_B_CTRL2             0x08a
+
+#define EE_AUDIO_FRDDR_C_CTRL0             0x090
+#define EE_AUDIO_FRDDR_C_CTRL1             0x091
+#define EE_AUDIO_FRDDR_C_START_ADDR        0x092
+#define EE_AUDIO_FRDDR_C_FINISH_ADDR       0x093
+#define EE_AUDIO_FRDDR_C_INT_ADDR          0x094
+#define EE_AUDIO_FRDDR_C_STATUS1           0x095
+#define EE_AUDIO_FRDDR_C_STATUS2           0x096
+#define EE_AUDIO_FRDDR_C_START_ADDRB       0x097
+#define EE_AUDIO_FRDDR_C_FINISH_ADDRB      0x098
+#define EE_AUDIO_FRDDR_C_INIT_ADDR         0x099
+#define EE_AUDIO_FRDDR_C_CTRL2             0x09a
+
+/*
+ *	AUDIO ARB,
+ */
+#define EE_AUDIO_ARB_CTRL                  0x0a0
+
+/*
+ *	AUDIO LOOPBACK
+ */
+#define EE_AUDIO_LB_CTRL0                  0x0b0
+
+#define EE_AUDIO_LB_A_CTRL0                0xb0
+#define EE_AUDIO_LB_A_CTRL1                0xb1
+#define EE_AUDIO_LB_A_CTRL2                0xb2
+#define EE_AUDIO_LB_A_CTRL3                0xb3
+#define EE_AUDIO_LB_A_DAT_CH_ID0           0xb4
+#define EE_AUDIO_LB_A_DAT_CH_ID1           0xb5
+#define EE_AUDIO_LB_A_DAT_CH_ID2           0xb6
+#define EE_AUDIO_LB_A_DAT_CH_ID3           0xb7
+#define EE_AUDIO_LB_A_LB_CH_ID0            0xb8
+#define EE_AUDIO_LB_A_LB_CH_ID1            0xb9
+#define EE_AUDIO_LB_A_LB_CH_ID2            0xba
+#define EE_AUDIO_LB_A_LB_CH_ID3            0xbb
+#define EE_AUDIO_LB_A_STS                  0xbc
+
+#define EE_AUDIO_LB_B_CTRL0                0x230
+#define EE_AUDIO_LB_B_CTRL1                0x231
+#define EE_AUDIO_LB_B_CTRL2                0x232
+#define EE_AUDIO_LB_B_CTRL3                0x233
+#define EE_AUDIO_LB_B_DAT_CH_ID0           0x234
+#define EE_AUDIO_LB_B_DAT_CH_ID1           0x235
+#define EE_AUDIO_LB_B_DAT_CH_ID2           0x236
+#define EE_AUDIO_LB_B_DAT_CH_ID3           0x237
+#define EE_AUDIO_LB_B_LB_CH_ID0            0x238
+#define EE_AUDIO_LB_B_LB_CH_ID1            0x239
+#define EE_AUDIO_LB_B_LB_CH_ID2            0x23a
+#define EE_AUDIO_LB_B_LB_CH_ID3            0x23b
+#define EE_AUDIO_LB_B_STS                  0x23c
+
+/*
+ *	AUDIO TDM
+ */
+#define EE_AUDIO_TDMIN_A_CTRL              0x0c0
+#define EE_AUDIO_TDMIN_A_SWAP0             0x0c1
+#define EE_AUDIO_TDMIN_A_SWAP1             0x260
+#define EE_AUDIO_TDMIN_A_MASK0             0x0c2
+#define EE_AUDIO_TDMIN_A_MASK1             0x0c3
+#define EE_AUDIO_TDMIN_A_MASK2             0x0c4
+#define EE_AUDIO_TDMIN_A_MASK3             0x0c5
+#define EE_AUDIO_TDMIN_A_MASK4             0x261
+#define EE_AUDIO_TDMIN_A_MASK5             0x262
+#define EE_AUDIO_TDMIN_A_MASK6             0x263
+#define EE_AUDIO_TDMIN_A_MASK7             0x264
+#define EE_AUDIO_TDMIN_A_STAT              0x0c6
+#define EE_AUDIO_TDMIN_A_MUTE_VAL          0x0c7
+#define EE_AUDIO_TDMIN_A_MUTE0             0x0c8
+#define EE_AUDIO_TDMIN_A_MUTE1             0x0c9
+#define EE_AUDIO_TDMIN_A_MUTE2             0x0ca
+#define EE_AUDIO_TDMIN_A_MUTE3             0x0cb
+#define EE_AUDIO_TDMIN_A_MUTE4             0x265
+#define EE_AUDIO_TDMIN_A_MUTE5             0x266
+#define EE_AUDIO_TDMIN_A_MUTE6             0x267
+#define EE_AUDIO_TDMIN_A_MUTE7             0x268
+
+#define EE_AUDIO_TDMIN_B_CTRL              0x0d0
+#define EE_AUDIO_TDMIN_B_SWAP0             0x0d1
+#define EE_AUDIO_TDMIN_B_SWAP1             0x270
+#define EE_AUDIO_TDMIN_B_MASK0             0x0d2
+#define EE_AUDIO_TDMIN_B_MASK1             0x0d3
+#define EE_AUDIO_TDMIN_B_MASK2             0x0d4
+#define EE_AUDIO_TDMIN_B_MASK3             0x0d5
+#define EE_AUDIO_TDMIN_B_MASK4             0x271
+#define EE_AUDIO_TDMIN_B_MASK5             0x272
+#define EE_AUDIO_TDMIN_B_MASK6             0x273
+#define EE_AUDIO_TDMIN_B_MASK7             0x274
+#define EE_AUDIO_TDMIN_B_STAT              0x0d6
+#define EE_AUDIO_TDMIN_B_MUTE_VAL          0x0d7
+#define EE_AUDIO_TDMIN_B_MUTE0             0x0d8
+#define EE_AUDIO_TDMIN_B_MUTE1             0x0d9
+#define EE_AUDIO_TDMIN_B_MUTE2             0x0da
+#define EE_AUDIO_TDMIN_B_MUTE3             0x0db
+#define EE_AUDIO_TDMIN_B_MUTE4             0x275
+#define EE_AUDIO_TDMIN_B_MUTE5             0x276
+#define EE_AUDIO_TDMIN_B_MUTE6             0x277
+#define EE_AUDIO_TDMIN_B_MUTE7             0x278
+
+#define EE_AUDIO_TDMIN_C_CTRL              0x0e0
+#define EE_AUDIO_TDMIN_C_SWAP0             0x0e1
+#define EE_AUDIO_TDMIN_C_SWAP1             0x280
+#define EE_AUDIO_TDMIN_C_SWAP              0x0e1
+#define EE_AUDIO_TDMIN_C_MASK0             0x0e2
+#define EE_AUDIO_TDMIN_C_MASK1             0x0e3
+#define EE_AUDIO_TDMIN_C_MASK2             0x0e4
+#define EE_AUDIO_TDMIN_C_MASK3             0x0e5
+#define EE_AUDIO_TDMIN_C_MASK4             0x281
+#define EE_AUDIO_TDMIN_C_MASK5             0x282
+#define EE_AUDIO_TDMIN_C_MASK6             0x283
+#define EE_AUDIO_TDMIN_C_MASK7             0x284
+#define EE_AUDIO_TDMIN_C_STAT              0x0e6
+#define EE_AUDIO_TDMIN_C_MUTE_VAL          0x0e7
+#define EE_AUDIO_TDMIN_C_MUTE0             0x0e8
+#define EE_AUDIO_TDMIN_C_MUTE1             0x0e9
+#define EE_AUDIO_TDMIN_C_MUTE2             0x0ea
+#define EE_AUDIO_TDMIN_C_MUTE3             0x0eb
+#define EE_AUDIO_TDMIN_C_MUTE4             0x285
+#define EE_AUDIO_TDMIN_C_MUTE5             0x286
+#define EE_AUDIO_TDMIN_C_MUTE6             0x287
+#define EE_AUDIO_TDMIN_C_MUTE7             0x288
+
+#define EE_AUDIO_TDMIN_LB_CTRL             0x0f0
+#define EE_AUDIO_TDMIN_LB_SWAP0            0x0f1
+#define EE_AUDIO_TDMIN_LB_SWAP1            0x290
+#define EE_AUDIO_TDMIN_LB_MASK0            0x0f2
+#define EE_AUDIO_TDMIN_LB_MASK1            0x0f3
+#define EE_AUDIO_TDMIN_LB_MASK2            0x0f4
+#define EE_AUDIO_TDMIN_LB_MASK3            0x0f5
+#define EE_AUDIO_TDMIN_LB_MASK4            0x291
+#define EE_AUDIO_TDMIN_LB_MASK5            0x292
+#define EE_AUDIO_TDMIN_LB_MASK6            0x293
+#define EE_AUDIO_TDMIN_LB_MASK7            0x294
+#define EE_AUDIO_TDMIN_LB_STAT             0x0f6
+#define EE_AUDIO_TDMIN_LB_MUTE_VAL         0x0f7
+#define EE_AUDIO_TDMIN_LB_MUTE0            0x0f8
+#define EE_AUDIO_TDMIN_LB_MUTE1            0x0f9
+#define EE_AUDIO_TDMIN_LB_MUTE2            0x0fa
+#define EE_AUDIO_TDMIN_LB_MUTE3            0x0fb
+#define EE_AUDIO_TDMIN_LB_MUTE4            0x295
+#define EE_AUDIO_TDMIN_LB_MUTE5            0x296
+#define EE_AUDIO_TDMIN_LB_MUTE6            0x297
+#define EE_AUDIO_TDMIN_LB_MUTE7            0x298
+
+/*
+ *	AUDIO OUTPUT
+ */
+#define EE_AUDIO_SPDIFIN_CTRL0             0x100
+#define EE_AUDIO_SPDIFIN_CTRL1             0x101
+#define EE_AUDIO_SPDIFIN_CTRL2             0x102
+#define EE_AUDIO_SPDIFIN_CTRL3             0x103
+#define EE_AUDIO_SPDIFIN_CTRL4             0x104
+#define EE_AUDIO_SPDIFIN_CTRL5             0x105
+#define EE_AUDIO_SPDIFIN_CTRL6             0x106
+#define EE_AUDIO_SPDIFIN_STAT0             0x107
+#define EE_AUDIO_SPDIFIN_STAT1             0x108
+#define EE_AUDIO_SPDIFIN_STAT2             0x109
+#define EE_AUDIO_SPDIFIN_MUTE_VAL          0x10a
+
+#define EE_AUDIO_RESAMPLEA_CTRL0           0x110
+#define EE_AUDIO_RESAMPLEA_CTRL1           0x111
+#define EE_AUDIO_RESAMPLEA_CTRL2           0x112
+#define EE_AUDIO_RESAMPLEA_CTRL3           0x113
+#define EE_AUDIO_RESAMPLEA_COEF0           0x114
+#define EE_AUDIO_RESAMPLEA_COEF1           0x115
+#define EE_AUDIO_RESAMPLEA_COEF2           0x116
+#define EE_AUDIO_RESAMPLEA_COEF3           0x117
+#define EE_AUDIO_RESAMPLEA_COEF4           0x118
+#define EE_AUDIO_RESAMPLEA_STATUS1         0x119
+
+#define EE_AUDIO_RESAMPLEB_CTRL0           0x1e0
+#define EE_AUDIO_RESAMPLEB_CTRL1           0x1e1
+#define EE_AUDIO_RESAMPLEB_CTRL2           0x1e2
+#define EE_AUDIO_RESAMPLEB_CTRL3           0x1e3
+#define EE_AUDIO_RESAMPLEB_COEF0           0x1e4
+#define EE_AUDIO_RESAMPLEB_COEF1           0x1e5
+#define EE_AUDIO_RESAMPLEB_COEF2           0x1e6
+#define EE_AUDIO_RESAMPLEB_COEF3           0x1e7
+#define EE_AUDIO_RESAMPLEB_COEF4           0x1e8
+#define EE_AUDIO_RESAMPLEB_STATUS1         0x1e9
+
+#define EE_AUDIO_SPDIFOUT_STAT             0x120
+#define EE_AUDIO_SPDIFOUT_GAIN0            0x121
+#define EE_AUDIO_SPDIFOUT_GAIN1            0x122
+#define EE_AUDIO_SPDIFOUT_CTRL0            0x123
+#define EE_AUDIO_SPDIFOUT_CTRL1            0x124
+#define EE_AUDIO_SPDIFOUT_PREAMB           0x125
+#define EE_AUDIO_SPDIFOUT_SWAP             0x126
+#define EE_AUDIO_SPDIFOUT_CHSTS0           0x127
+#define EE_AUDIO_SPDIFOUT_CHSTS1           0x128
+#define EE_AUDIO_SPDIFOUT_CHSTS2           0x129
+#define EE_AUDIO_SPDIFOUT_CHSTS3           0x12a
+#define EE_AUDIO_SPDIFOUT_CHSTS4           0x12b
+#define EE_AUDIO_SPDIFOUT_CHSTS5           0x12c
+#define EE_AUDIO_SPDIFOUT_CHSTS6           0x12d
+#define EE_AUDIO_SPDIFOUT_CHSTS7           0x12e
+#define EE_AUDIO_SPDIFOUT_CHSTS8           0x12f
+#define EE_AUDIO_SPDIFOUT_CHSTS9           0x130
+#define EE_AUDIO_SPDIFOUT_CHSTSA           0x131
+#define EE_AUDIO_SPDIFOUT_CHSTSB           0x132
+#define EE_AUDIO_SPDIFOUT_MUTE_VAL         0x133
+
+#define EE_AUDIO_TDMOUT_A_CTRL0            0x140
+#define EE_AUDIO_TDMOUT_A_CTRL1            0x141
+#define EE_AUDIO_TDMOUT_A_CTRL2            0x2a0
+#define EE_AUDIO_TDMOUT_A_SWAP0            0x142
+#define EE_AUDIO_TDMOUT_A_SWAP1            0x2a1
+#define EE_AUDIO_TDMOUT_A_MASK0            0x143
+#define EE_AUDIO_TDMOUT_A_MASK1            0x144
+#define EE_AUDIO_TDMOUT_A_MASK2            0x145
+#define EE_AUDIO_TDMOUT_A_MASK3            0x146
+#define EE_AUDIO_TDMOUT_A_MASK4            0x2a4
+#define EE_AUDIO_TDMOUT_A_MASK5            0x2a5
+#define EE_AUDIO_TDMOUT_A_MASK6            0x2a6
+#define EE_AUDIO_TDMOUT_A_MASK7            0x2a7
+#define EE_AUDIO_TDMOUT_A_STAT             0x147
+#define EE_AUDIO_TDMOUT_A_GAIN0            0x148
+#define EE_AUDIO_TDMOUT_A_GAIN1            0x149
+#define EE_AUDIO_TDMOUT_A_GAIN2            0x2a2
+#define EE_AUDIO_TDMOUT_A_GAIN3            0x2a3
+#define EE_AUDIO_TDMOUT_A_MUTE_VAL         0x14a
+#define EE_AUDIO_TDMOUT_A_MUTE0            0x14b
+#define EE_AUDIO_TDMOUT_A_MUTE1            0x14c
+#define EE_AUDIO_TDMOUT_A_MUTE2            0x14d
+#define EE_AUDIO_TDMOUT_A_MUTE3            0x14e
+#define EE_AUDIO_TDMOUT_A_MUTE4            0x2a8
+#define EE_AUDIO_TDMOUT_A_MUTE5            0x2a9
+#define EE_AUDIO_TDMOUT_A_MUTE6            0x2aa
+#define EE_AUDIO_TDMOUT_A_MUTE7            0x2ab
+#define EE_AUDIO_TDMOUT_A_MASK_VAL         0x14f
+
+#define EE_AUDIO_TDMOUT_B_CTRL0            0x150
+#define EE_AUDIO_TDMOUT_B_CTRL1            0x151
+#define EE_AUDIO_TDMOUT_B_CTRL2            0x2b0
+#define EE_AUDIO_TDMOUT_B_SWAP0            0x152
+#define EE_AUDIO_TDMOUT_B_SWAP1            0x2b1
+#define EE_AUDIO_TDMOUT_B_MASK0            0x153
+#define EE_AUDIO_TDMOUT_B_MASK1            0x154
+#define EE_AUDIO_TDMOUT_B_MASK2            0x155
+#define EE_AUDIO_TDMOUT_B_MASK3            0x156
+#define EE_AUDIO_TDMOUT_B_MASK4            0x2b4
+#define EE_AUDIO_TDMOUT_B_MASK5            0x2b5
+#define EE_AUDIO_TDMOUT_B_MASK6            0x2b6
+#define EE_AUDIO_TDMOUT_B_MASK7            0x2b7
+#define EE_AUDIO_TDMOUT_B_STAT             0x157
+#define EE_AUDIO_TDMOUT_B_GAIN0            0x158
+#define EE_AUDIO_TDMOUT_B_GAIN1            0x159
+#define EE_AUDIO_TDMOUT_B_GAIN2            0x2b2
+#define EE_AUDIO_TDMOUT_B_GAIN3            0x2b3
+#define EE_AUDIO_TDMOUT_B_MUTE_VAL         0x15a
+#define EE_AUDIO_TDMOUT_B_MUTE0            0x15b
+#define EE_AUDIO_TDMOUT_B_MUTE1            0x15c
+#define EE_AUDIO_TDMOUT_B_MUTE2            0x15d
+#define EE_AUDIO_TDMOUT_B_MUTE3            0x15e
+#define EE_AUDIO_TDMOUT_B_MUTE4            0x2b8
+#define EE_AUDIO_TDMOUT_B_MUTE5            0x2b9
+#define EE_AUDIO_TDMOUT_B_MUTE6            0x2ba
+#define EE_AUDIO_TDMOUT_B_MUTE7            0x2bb
+#define EE_AUDIO_TDMOUT_B_MASK_VAL         0x15f
+
+#define EE_AUDIO_TDMOUT_C_CTRL0            0x160
+#define EE_AUDIO_TDMOUT_C_CTRL1            0x161
+#define EE_AUDIO_TDMOUT_C_CTRL2            0x2c0
+#define EE_AUDIO_TDMOUT_C_SWAP0            0x162
+#define EE_AUDIO_TDMOUT_C_SWAP1            0x2c1
+#define EE_AUDIO_TDMOUT_C_MASK0            0x163
+#define EE_AUDIO_TDMOUT_C_MASK1            0x164
+#define EE_AUDIO_TDMOUT_C_MASK2            0x165
+#define EE_AUDIO_TDMOUT_C_MASK3            0x166
+#define EE_AUDIO_TDMOUT_C_MASK4            0x2c4
+#define EE_AUDIO_TDMOUT_C_MASK5            0x2c5
+#define EE_AUDIO_TDMOUT_C_MASK6            0x2c6
+#define EE_AUDIO_TDMOUT_C_MASK7            0x2c7
+#define EE_AUDIO_TDMOUT_C_STAT             0x167
+#define EE_AUDIO_TDMOUT_C_GAIN0            0x168
+#define EE_AUDIO_TDMOUT_C_GAIN1            0x169
+#define EE_AUDIO_TDMOUT_C_GAIN2            0x2c2
+#define EE_AUDIO_TDMOUT_C_GAIN3            0x2c3
+#define EE_AUDIO_TDMOUT_C_MUTE_VAL         0x16a
+#define EE_AUDIO_TDMOUT_C_MUTE0            0x16b
+#define EE_AUDIO_TDMOUT_C_MUTE1            0x16c
+#define EE_AUDIO_TDMOUT_C_MUTE2            0x16d
+#define EE_AUDIO_TDMOUT_C_MUTE3            0x16e
+#define EE_AUDIO_TDMOUT_C_MUTE4            0x2c8
+#define EE_AUDIO_TDMOUT_C_MUTE5            0x2c9
+#define EE_AUDIO_TDMOUT_C_MUTE6            0x2ca
+#define EE_AUDIO_TDMOUT_C_MUTE7            0x2cb
+#define EE_AUDIO_TDMOUT_C_MASK_VAL         0x16f
+
+/*
+ *	AUDIO POWER DETECT
+ */
+#define EE_AUDIO_POW_DET_CTRL0             0x180
+#define EE_AUDIO_POW_DET_TH_HI             0x181
+#define EE_AUDIO_POW_DET_TH_LO             0x182
+#define EE_AUDIO_POW_DET_VALUE             0x183
+#define EE_AUDIO_SECURITY_CTRL             0x193
+
+/*
+ *	AUDIO SPDIF_B
+ */
+#define EE_AUDIO_SPDIFOUT_B_STAT           0x1a0
+#define EE_AUDIO_SPDIFOUT_B_GAIN0          0x1a1
+#define EE_AUDIO_SPDIFOUT_B_GAIN1          0x1a2
+#define EE_AUDIO_SPDIFOUT_B_CTRL0          0x1a3
+#define EE_AUDIO_SPDIFOUT_B_CTRL1          0x1a4
+#define EE_AUDIO_SPDIFOUT_B_PREAMB         0x1a5
+#define EE_AUDIO_SPDIFOUT_B_SWAP           0x1a6
+#define EE_AUDIO_SPDIFOUT_B_CHSTS0         0x1a7
+#define EE_AUDIO_SPDIFOUT_B_CHSTS1         0x1a8
+#define EE_AUDIO_SPDIFOUT_B_CHSTS2         0x1a9
+#define EE_AUDIO_SPDIFOUT_B_CHSTS3         0x1aa
+#define EE_AUDIO_SPDIFOUT_B_CHSTS4         0x1ab
+#define EE_AUDIO_SPDIFOUT_B_CHSTS5         0x1ac
+#define EE_AUDIO_SPDIFOUT_B_CHSTS6         0x1ad
+#define EE_AUDIO_SPDIFOUT_B_CHSTS7         0x1ae
+#define EE_AUDIO_SPDIFOUT_B_CHSTS8         0x1af
+#define EE_AUDIO_SPDIFOUT_B_CHSTS9         0x1b0
+#define EE_AUDIO_SPDIFOUT_B_CHSTSA         0x1b1
+#define EE_AUDIO_SPDIFOUT_B_CHSTSB         0x1b2
+#define EE_AUDIO_SPDIFOUT_B_MUTE_VAL       0x1b3
+
+/*
+ *	AUDIO LOCKER
+ */
+#define EE_AUDIO_TORAM_CTRL0               0x1c0
+#define EE_AUDIO_TORAM_CTRL1               0x1c1
+#define EE_AUDIO_TORAM_START_ADDR          0x1c2
+#define EE_AUDIO_TORAM_FINISH_ADDR         0x1c3
+#define EE_AUDIO_TORAM_INT_ADDR            0x1c4
+#define EE_AUDIO_TORAM_STATUS1             0x1c5
+#define EE_AUDIO_TORAM_STATUS2             0x1c6
+#define EE_AUDIO_TORAM_INIT_ADDR           0x1c7
+
+/*
+ *	HIU, AUDIO CODEC RESET
+ */
+#define EE_RESET1                          0x002
+
+/*
+ *	HIU, ARC
+ */
+#define HHI_HDMIRX_ARC_CNTL                0xe8
+
+/*
+ *	AUDIO MUX CONTROLS
+ */
+#define EE_AUDIO_TOACODEC_CTRL0            0x1d0
+#define EE_AUDIO_TOHDMITX_CTRL0            0x1d1
+#define EE_AUDIO_TOVAD_CTRL0               0x1d2
+#define EE_AUDIO_FRATV_CTRL0               0x1d3
+
+#define EE_AUDIO_SPDIFIN_LB_CTRL0          0x1f0
+#define EE_AUDIO_SPDIFIN_LB_CTRL1          0x1f1
+#define EE_AUDIO_SPDIFIN_LB_CTRL6          0x1f6
+#define EE_AUDIO_SPDIFIN_LB_STAT0          0x1f7
+#define EE_AUDIO_SPDIFIN_LB_STAT1          0x1f8
+#define EE_AUDIO_SPDIFIN_LB_MUTE_VAL       0x1fa
+
+#define EE_AUDIO_FRHDMIRX_CTRL0            0x200
+#define EE_AUDIO_FRHDMIRX_CTRL1            0x201
+#define EE_AUDIO_FRHDMIRX_CTRL2            0x202
+#define EE_AUDIO_FRHDMIRX_CTRL3            0x203
+#define EE_AUDIO_FRHDMIRX_CTRL4            0x204
+#define EE_AUDIO_FRHDMIRX_CTRL5            0x205
+#define EE_AUDIO_FRHDMIRX_STAT0            0x20a
+#define EE_AUDIO_FRHDMIRX_STAT1            0x20b
+
+#define EE_AUDIO_TODDR_D_CTRL0             0x210
+#define EE_AUDIO_TODDR_D_CTRL1             0x211
+#define EE_AUDIO_TODDR_D_START_ADDR        0x212
+#define EE_AUDIO_TODDR_D_FINISH_ADDR       0x213
+#define EE_AUDIO_TODDR_D_INT_ADDR          0x214
+#define EE_AUDIO_TODDR_D_STATUS1           0x215
+#define EE_AUDIO_TODDR_D_STATUS2           0x216
+#define EE_AUDIO_TODDR_D_START_ADDRB       0x217
+#define EE_AUDIO_TODDR_D_FINISH_ADDRB      0x218
+#define EE_AUDIO_TODDR_D_INIT_ADDR         0x219
+#define EE_AUDIO_TODDR_D_CTRL2             0x21a
+
+#define EE_AUDIO_FRDDR_D_CTRL0             0x220
+#define EE_AUDIO_FRDDR_D_CTRL1             0x221
+#define EE_AUDIO_FRDDR_D_START_ADDR        0x222
+#define EE_AUDIO_FRDDR_D_FINISH_ADDR       0x223
+#define EE_AUDIO_FRDDR_D_INT_ADDR          0x224
+#define EE_AUDIO_FRDDR_D_STATUS1           0x225
+#define EE_AUDIO_FRDDR_D_STATUS2           0x226
+#define EE_AUDIO_FRDDR_D_START_ADDRB       0x227
+#define EE_AUDIO_FRDDR_D_FINISH_ADDRB      0x228
+#define EE_AUDIO_FRDDR_D_INIT_ADDR         0x229
+#define EE_AUDIO_FRDDR_D_CTRL2             0x22a
+
+/*
+ *	AUDIO LOCKER
+ */
+#define AUD_LOCK_EN                        0x000
+#define AUD_LOCK_SW_RESET                  0x001
+#define AUD_LOCK_SW_LATCH                  0x002
+#define AUD_LOCK_HW_LATCH                  0x003
+#define AUD_LOCK_REFCLK_SRC                0x004
+#define AUD_LOCK_REFCLK_LAT_INT            0x005
+#define AUD_LOCK_IMCLK_LAT_INT             0x006
+#define AUD_LOCK_OMCLK_LAT_INT             0x007
+#define AUD_LOCK_REFCLK_DS_INT             0x008
+#define AUD_LOCK_IMCLK_DS_INT              0x009
+#define AUD_LOCK_OMCLK_DS_INT              0x00a
+#define AUD_LOCK_INT_CLR                   0x00b
+#define AUD_LOCK_GCLK_CTRL                 0x00c
+#define AUD_LOCK_INT_CTRL                  0x00d
+#define RO_REF2IMCLK_CNT_L                 0x010
+#define RO_REF2IMCLK_CNT_H                 0x011
+#define RO_REF2OMCLK_CNT_L                 0x012
+#define RO_REF2OMCLK_CNT_H                 0x013
+#define RO_IMCLK2REF_CNT_L                 0x014
+#define RO_IMCLK2REF_CNT_H                 0x015
+#define RO_OMCLK2REF_CNT_L                 0x016
+#define RO_OMCLK2REF_CNT_H                 0x017
+#define RO_REFCLK_PKG_CNT                  0x018
+#define RO_IMCLK_PKG_CNT                   0x019
+#define RO_OMCLK_PKG_CNT                   0x01a
+#define RO_AUD_LOCK_INT_STATUS             0x01b
+
+/*
+ * EQ DRC, G12X means g12a, g12b
+ */
+#define AED_EQ_CH1_COEF00                  0x00
+#define AED_EQ_CH1_COEF01                  0x01
+#define AED_EQ_CH1_COEF02                  0x02
+#define AED_EQ_CH1_COEF03                  0x03
+#define AED_EQ_CH1_COEF04                  0x04
+#define AED_EQ_CH1_COEF10                  0x05
+#define AED_EQ_CH1_COEF11                  0x06
+#define AED_EQ_CH1_COEF12                  0x07
+#define AED_EQ_CH1_COEF13                  0x08
+#define AED_EQ_CH1_COEF14                  0x09
+#define AED_EQ_CH1_COEF20                  0x0a
+#define AED_EQ_CH1_COEF21                  0x0b
+#define AED_EQ_CH1_COEF22                  0x0c
+#define AED_EQ_CH1_COEF23                  0x0d
+#define AED_EQ_CH1_COEF24                  0x0e
+#define AED_EQ_CH1_COEF30                  0x0f
+#define AED_EQ_CH1_COEF31                  0x10
+#define AED_EQ_CH1_COEF32                  0x11
+#define AED_EQ_CH1_COEF33                  0x12
+#define AED_EQ_CH1_COEF34                  0x13
+#define AED_EQ_CH1_COEF40                  0x14
+#define AED_EQ_CH1_COEF41                  0x15
+#define AED_EQ_CH1_COEF42                  0x16
+#define AED_EQ_CH1_COEF43                  0x17
+#define AED_EQ_CH1_COEF44                  0x18
+#define AED_EQ_CH1_COEF50                  0x19
+#define AED_EQ_CH1_COEF51                  0x1a
+#define AED_EQ_CH1_COEF52                  0x1b
+#define AED_EQ_CH1_COEF53                  0x1c
+#define AED_EQ_CH1_COEF54                  0x1d
+#define AED_EQ_CH1_COEF60                  0x1e
+#define AED_EQ_CH1_COEF61                  0x1f
+#define AED_EQ_CH1_COEF62                  0x20
+#define AED_EQ_CH1_COEF63                  0x21
+#define AED_EQ_CH1_COEF64                  0x22
+#define AED_EQ_CH1_COEF70                  0x23
+#define AED_EQ_CH1_COEF71                  0x24
+#define AED_EQ_CH1_COEF72                  0x25
+#define AED_EQ_CH1_COEF73                  0x26
+#define AED_EQ_CH1_COEF74                  0x27
+#define AED_EQ_CH1_COEF80                  0x28
+#define AED_EQ_CH1_COEF81                  0x29
+#define AED_EQ_CH1_COEF82                  0x2a
+#define AED_EQ_CH1_COEF83                  0x2b
+#define AED_EQ_CH1_COEF84                  0x2c
+#define AED_EQ_CH1_COEF90                  0x2d
+#define AED_EQ_CH1_COEF91                  0x2e
+#define AED_EQ_CH1_COEF92                  0x2f
+#define AED_EQ_CH1_COEF93                  0x30
+#define AED_EQ_CH1_COEF94                  0x31
+#define AED_EQ_CH2_COEF00                  0x32
+#define AED_EQ_CH2_COEF01                  0x33
+#define AED_EQ_CH2_COEF02                  0x34
+#define AED_EQ_CH2_COEF03                  0x35
+#define AED_EQ_CH2_COEF04                  0x36
+#define AED_EQ_CH2_COEF10                  0x37
+#define AED_EQ_CH2_COEF11                  0x38
+#define AED_EQ_CH2_COEF12                  0x39
+#define AED_EQ_CH2_COEF13                  0x3a
+#define AED_EQ_CH2_COEF14                  0x3b
+#define AED_EQ_CH2_COEF20                  0x3c
+#define AED_EQ_CH2_COEF21                  0x3d
+#define AED_EQ_CH2_COEF22                  0x3e
+#define AED_EQ_CH2_COEF23                  0x3f
+#define AED_EQ_CH2_COEF24                  0x40
+#define AED_EQ_CH2_COEF30                  0x41
+#define AED_EQ_CH2_COEF31                  0x42
+#define AED_EQ_CH2_COEF32                  0x43
+#define AED_EQ_CH2_COEF33                  0x44
+#define AED_EQ_CH2_COEF34                  0x45
+#define AED_EQ_CH2_COEF40                  0x46
+#define AED_EQ_CH2_COEF41                  0x47
+#define AED_EQ_CH2_COEF42                  0x48
+#define AED_EQ_CH2_COEF43                  0x49
+#define AED_EQ_CH2_COEF44                  0x4a
+#define AED_EQ_CH2_COEF50                  0x4b
+#define AED_EQ_CH2_COEF51                  0x4c
+#define AED_EQ_CH2_COEF52                  0x4d
+#define AED_EQ_CH2_COEF53                  0x4e
+#define AED_EQ_CH2_COEF54                  0x4f
+#define AED_EQ_CH2_COEF60                  0x50
+#define AED_EQ_CH2_COEF61                  0x51
+#define AED_EQ_CH2_COEF62                  0x52
+#define AED_EQ_CH2_COEF63                  0x53
+#define AED_EQ_CH2_COEF64                  0x54
+#define AED_EQ_CH2_COEF70                  0x55
+#define AED_EQ_CH2_COEF71                  0x56
+#define AED_EQ_CH2_COEF72                  0x57
+#define AED_EQ_CH2_COEF73                  0x58
+#define AED_EQ_CH2_COEF74                  0x59
+#define AED_EQ_CH2_COEF80                  0x5a
+#define AED_EQ_CH2_COEF81                  0x5b
+#define AED_EQ_CH2_COEF82                  0x5c
+#define AED_EQ_CH2_COEF83                  0x5d
+#define AED_EQ_CH2_COEF84                  0x5e
+#define AED_EQ_CH2_COEF90                  0x5f
+#define AED_EQ_CH2_COEF91                  0x60
+#define AED_EQ_CH2_COEF92                  0x61
+#define AED_EQ_CH2_COEF93                  0x62
+#define AED_EQ_CH2_COEF94                  0x63
+#define AED_EQ_EN_G12X                     0x64
+#define AED_EQ_VOLUME_G12X                 0x65
+#define AED_EQ_VOLUME_SLEW_CNT_G12X        0x66
+#define AED_MUTE_G12X                      0x67
+#define AED_DRC_EN                         0x68
+#define AED_DRC_AE                         0x69
+#define AED_DRC_AA                         0x6a
+#define AED_DRC_AD                         0x6b
+#define AED_DRC_AE_1M                      0x6c
+#define AED_DRC_AA_1M                      0x6d
+#define AED_DRC_AD_1M                      0x6e
+#define AED_DRC_OFFSET0                    0x6f
+#define AED_DRC_OFFSET1                    0x70
+#define AED_DRC_THD0_G12X                  0x71
+#define AED_DRC_THD1_G12X                  0x72
+#define AED_DRC_K0_G12X                    0x73
+#define AED_DRC_K1_G12X                    0x74
+#define AED_CLIP_THD_G12X                  0x75
+#define AED_NG_THD0                        0x76
+#define AED_NG_THD1                        0x77
+#define AED_NG_CNT_THD                     0x78
+#define AED_NG_CTL                         0x79
+#define AED_ED_CTL                         0x7a
+#define AED_DEBUG0                         0x7b
+#define AED_DEBUG1                         0x7c
+#define AED_DEBUG2                         0x7d
+#define AED_DEBUG3                         0x7e
+#define AED_DEBUG4                         0x7f
+#define AED_DEBUG5                         0x80
+#define AED_DEBUG6                         0x81
+#define AED_DRC_AA_H                       0x82
+#define AED_DRC_AD_H                       0x83
+#define AED_DRC_AA_1M_H                    0x84
+#define AED_DRC_AD_1M_H                    0x85
+#define AED_NG_CNT                         0x86
+#define AED_NG_STEP                        0x87
+
+#define AED_TOP_CTL_G12X                   0x88
+#define AED_TOP_REQ_CTL_G12X               0x89
+
+/*
+ * EQ DRC, New ARCH, from tl1
+ */
+#define AED_COEF_RAM_CNTL                  0x00
+#define AED_COEF_RAM_DATA                  0x01
+#define AED_EQ_EN                          0x02
+#define AED_EQ_TAP_CNTL                    0x03
+#define AED_EQ_VOLUME                      0x04
+#define AED_EQ_VOLUME_SLEW_CNT             0x05
+#define AED_MUTE                           0x06
+#define AED_DRC_CNTL                       0x07
+#define AED_DRC_RMS_COEF0                  0x08
+#define AED_DRC_RMS_COEF1                  0x09
+#define AED_DRC_THD0                       0x0a
+#define AED_DRC_THD1                       0x0b
+#define AED_DRC_THD2                       0x0c
+#define AED_DRC_THD3                       0x0d
+#define AED_DRC_THD4                       0x0e
+#define AED_DRC_K0                         0x0f
+#define AED_DRC_K1                         0x10
+#define AED_DRC_K2                         0x11
+#define AED_DRC_K3                         0x12
+#define AED_DRC_K4                         0x13
+#define AED_DRC_K5                         0x14
+#define AED_DRC_THD_OUT0                   0x15
+#define AED_DRC_THD_OUT1                   0x16
+#define AED_DRC_THD_OUT2                   0x17
+#define AED_DRC_THD_OUT3                   0x18
+#define AED_DRC_OFFSET                     0x19
+#define AED_DRC_RELEASE_COEF00             0x1a
+#define AED_DRC_RELEASE_COEF01             0x1b
+#define AED_DRC_RELEASE_COEF10             0x1c
+#define AED_DRC_RELEASE_COEF11             0x1d
+#define AED_DRC_RELEASE_COEF20             0x1e
+#define AED_DRC_RELEASE_COEF21             0x1f
+#define AED_DRC_RELEASE_COEF30             0x20
+#define AED_DRC_RELEASE_COEF31             0x21
+#define AED_DRC_RELEASE_COEF40             0x22
+#define AED_DRC_RELEASE_COEF41             0x23
+#define AED_DRC_RELEASE_COEF50             0x24
+#define AED_DRC_RELEASE_COEF51             0x25
+#define AED_DRC_ATTACK_COEF00              0x26
+#define AED_DRC_ATTACK_COEF01              0x27
+#define AED_DRC_ATTACK_COEF10              0x28
+#define AED_DRC_ATTACK_COEF11              0x29
+#define AED_DRC_ATTACK_COEF20              0x2a
+#define AED_DRC_ATTACK_COEF21              0x2b
+#define AED_DRC_ATTACK_COEF30              0x2c
+#define AED_DRC_ATTACK_COEF31              0x2d
+#define AED_DRC_ATTACK_COEF40              0x2e
+#define AED_DRC_ATTACK_COEF41              0x2f
+#define AED_DRC_ATTACK_COEF50              0x30
+#define AED_DRC_ATTACK_COEF51              0x31
+#define AED_DRC_LOOPBACK_CNTL              0x32
+#define AED_MDRC_CNTL                      0x33
+#define AED_MDRC_RMS_COEF00                0x34
+#define AED_MDRC_RMS_COEF01                0x35
+#define AED_MDRC_RELEASE_COEF00            0x36
+#define AED_MDRC_RELEASE_COEF01            0x37
+#define AED_MDRC_ATTACK_COEF00             0x38
+#define AED_MDRC_ATTACK_COEF01             0x39
+#define AED_MDRC_THD0                      0x3a
+#define AED_MDRC_K0                        0x3b
+#define AED_MDRC_LOW_GAIN                  0x3c
+#define AED_MDRC_OFFSET0                   0x3d
+#define AED_MDRC_RMS_COEF10                0x3e
+#define AED_MDRC_RMS_COEF11                0x3f
+#define AED_MDRC_RELEASE_COEF10            0x40
+#define AED_MDRC_RELEASE_COEF11            0x41
+#define AED_MDRC_ATTACK_COEF10             0x42
+#define AED_MDRC_ATTACK_COEF11             0x43
+#define AED_MDRC_THD1                      0x44
+#define AED_MDRC_K1                        0x45
+#define AED_MDRC_OFFSET1                   0x46
+#define AED_MDRC_MID_GAIN                  0x47
+#define AED_MDRC_RMS_COEF20                0x48
+#define AED_MDRC_RMS_COEF21                0x49
+#define AED_MDRC_RELEASE_COEF20            0x4a
+#define AED_MDRC_RELEASE_COEF21            0x4b
+#define AED_MDRC_ATTACK_COEF20             0x4c
+#define AED_MDRC_ATTACK_COEF21             0x4d
+#define AED_MDRC_THD2                      0x4e
+#define AED_MDRC_K2                        0x4f
+#define AED_MDRC_OFFSET2                   0x50
+#define AED_MDRC_HIGH_GAIN                 0x51
+#define AED_ED_CNTL                        0x52
+#define AED_DC_EN                          0x53
+#define AED_ND_LOW_THD                     0x54
+#define AED_ND_HIGH_THD                    0x55
+#define AED_ND_CNT_THD                     0x56
+#define AED_ND_SUM_NUM                     0x57
+#define AED_ND_CZ_NUM                      0x58
+#define AED_ND_SUM_THD0                    0x59
+#define AED_ND_SUM_THD1                    0x5a
+#define AED_ND_CZ_THD0                     0x5b
+#define AED_ND_CZ_THD1                     0x5c
+#define AED_ND_COND_CNTL                   0x5d
+#define AED_ND_RELEASE_COEF0               0x5e
+#define AED_ND_RELEASE_COEF1               0x5f
+#define AED_ND_ATTACK_COEF0                0x60
+#define AED_ND_ATTACK_COEF1                0x61
+#define AED_ND_CNTL                        0x62
+#define AED_MIX0_LL                        0x63
+#define AED_MIX0_RL                        0x64
+#define AED_MIX0_LR                        0x65
+#define AED_MIX0_RR                        0x66
+#define AED_CLIP_THD                       0x67
+#define AED_CH1_ND_SUM_OUT                 0x68
+#define AED_CH2_ND_SUM_OUT                 0x69
+#define AED_CH1_ND_CZ_OUT                  0x6a
+#define AED_CH2_ND_CZ_OUT                  0x6b
+#define AED_NOISE_STATUS                   0x6c
+#define AED_POW_CURRENT_S0                 0x6d
+#define AED_POW_CURRENT_S1                 0x6e
+#define AED_POW_CURRENT_S2                 0x6f
+#define AED_POW_OUT0                       0x70
+#define AED_POW_OUT1                       0x71
+#define AED_POW_OUT2                       0x72
+#define AED_POW_ADJ_INDEX0                 0x73
+#define AED_POW_ADJ_INDEX1                 0x74
+#define AED_POW_ADJ_INDEX2                 0x75
+#define AED_DRC_GAIN_INDEX0                0x76
+#define AED_DRC_GAIN_INDEX1                0x77
+#define AED_DRC_GAIN_INDEX2                0x78
+#define AED_CH1_VOLUME_STATE               0x79
+#define AED_CH2_VOLUME_STATE               0x7a
+#define AED_CH1_VOLUME_GAIN                0x7b
+#define AED_CH2_VOLUME_GAIN                0x7c
+#define AED_FULL_POW_CURRENT               0x7d
+#define AED_FULL_POW_OUT                   0x7e
+#define AED_FULL_POW_ADJ                   0x7f
+#define AED_FULL_DRC_GAIN                  0x80
+#define AED_MASTER_VOLUME_STATE            0x81
+#define AED_MASTER_VOLUME_GAIN             0x82
+
+#define AED_TOP_CTL                        0x83
+#define AED_TOP_REQ_CTL                    0x84
+
+#define AED_TOP_CTL0                       0x83
+#define AED_TOP_CTL1                       0x84
+#define AED_TOP_CTL2                       0x85
+
+/*
+ * VAD, Voice activity detection
+ */
+#define VAD_TOP_CTRL0                      0x000
+#define VAD_TOP_CTRL1                      0x001
+#define VAD_TOP_CTRL2                      0x002
+#define VAD_FIR_CTRL	                   0x003
+#define VAD_FIR_EMP                        0x004
+#define VAD_FIR_COEF0                      0x005
+#define VAD_FIR_COEF1                      0x006
+#define VAD_FIR_COEF2                      0x007
+#define VAD_FIR_COEF3                      0x008
+#define VAD_FIR_COEF4                      0x009
+#define VAD_FIR_COEF5                      0x00a
+#define VAD_FIR_COEF6                      0x00b
+#define VAD_FIR_COEF7                      0x00c
+#define VAD_FIR_COEF8                      0x00d
+#define VAD_FIR_COEF9                      0x00e
+#define VAD_FIR_COEF10                     0x00f
+#define VAD_FIR_COEF11                     0x010
+#define VAD_FIR_COEF12                     0x011
+#define VAD_FRAME_CTRL0                    0x012
+#define VAD_FRAME_CTRL1                    0x013
+#define VAD_FRAME_CTRL2                    0x014
+#define VAD_CEP_CTRL0                      0x015
+#define VAD_CEP_CTRL1                      0x016
+#define VAD_CEP_CTRL2                      0x017
+#define VAD_CEP_CTRL3                      0x018
+#define VAD_CEP_CTRL4                      0x019
+#define VAD_CEP_CTRL5                      0x01a
+#define VAD_DEC_CTRL                       0x01b
+#define VAD_TOP_STS0                       0x01c
+#define VAD_TOP_STS1                       0x01d
+#define VAD_TOP_STS2                       0x01e
+#define VAD_FIR_STS0                       0x01f
+#define VAD_FIR_STS1                       0x020
+#define VAD_POW_STS0                       0x021
+#define VAD_POW_STS1                       0x022
+#define VAD_POW_STS2                       0x023
+#define VAD_FFT_STS0                       0x024
+#define VAD_FFT_STS1                       0x025
+#define VAD_SPE_STS0                       0x026
+#define VAD_SPE_STS1                       0x027
+#define VAD_SPE_STS2                       0x028
+#define VAD_SPE_STS3                       0x029
+#define VAD_DEC_STS0                       0x02a
+#define VAD_DEC_STS1                       0x02b
+#define VAD_LUT_CTRL                       0x02c
+#define VAD_LUT_WR                         0x02d
+#define VAD_LUT_RD                         0x02e
+#define VAD_IN_SEL0                        0x02f
+#define VAD_IN_SEL1                        0x030
+#define VAD_TO_DDR                         0x031
+
+/*
+ * eARC
+ */
+/* eARC RX CMDC */
+#define EARC_RX_CMDC_TOP_CTRL0             0x000
+#define EARC_RX_CMDC_TOP_CTRL1             0x001
+#define EARC_RX_CMDC_TOP_CTRL2             0x002
+#define EARC_RX_CMDC_TIMER_CTRL0           0x003
+#define EARC_RX_CMDC_TIMER_CTRL1           0x004
+#define EARC_RX_CMDC_TIMER_CTRL2           0x005
+#define EARC_RX_CMDC_TIMER_CTRL3           0x006
+#define EARC_RX_CMDC_VSM_CTRL0             0x007
+#define EARC_RX_CMDC_VSM_CTRL1             0x008
+#define EARC_RX_CMDC_VSM_CTRL2             0x009
+#define EARC_RX_CMDC_VSM_CTRL3             0x00a
+#define EARC_RX_CMDC_VSM_CTRL4             0x00b
+#define EARC_RX_CMDC_VSM_CTRL5             0x00c
+#define EARC_RX_CMDC_VSM_CTRL6             0x00d
+#define EARC_RX_CMDC_VSM_CTRL7             0x00e
+#define EARC_RX_CMDC_VSM_CTRL8             0x00f
+#define EARC_RX_CMDC_VSM_CTRL9             0x010
+#define EARC_RX_CMDC_SENDER_CTRL0          0x011
+#define EARC_RX_CMDC_PACKET_CTRL0          0x012
+#define EARC_RX_CMDC_PACKET_CTRL1          0x013
+#define EARC_RX_CMDC_PACKET_CTRL2          0x014
+#define EARC_RX_CMDC_PACKET_CTRL3          0x015
+#define EARC_RX_CMDC_PACKET_CTRL4          0x016
+#define EARC_RX_CMDC_PACKET_CTRL5          0x017
+#define EARC_RX_CMDC_PACKET_CTRL6          0x018
+#define EARC_RX_CMDC_BIPHASE_CTRL0         0x019
+#define EARC_RX_CMDC_BIPHASE_CTRL1         0x01a
+#define EARC_RX_CMDC_BIPHASE_CTRL2         0x01b
+#define EARC_RX_CMDC_BIPHASE_CTRL3         0x01c
+#define EARC_RX_CMDC_DEVICE_ID_CTRL        0x01d
+#define EARC_RX_CMDC_DEVICE_WDATA          0x01e
+#define EARC_RX_CMDC_DEVICE_RDATA          0x01f
+#define EARC_RX_ANA_CTRL0                  0x020
+#define EARC_RX_ANA_CTRL1                  0x021
+#define EARC_RX_ANA_CTRL2                  0x022
+#define EARC_RX_ANA_CTRL3                  0x023
+#define EARC_RX_ANA_CTRL4                  0x024
+#define EARC_RX_ANA_CTRL5                  0x025
+#define EARC_RX_ANA_STAT0                  0x026
+#define EARC_RX_CMDC_STATUS0               0x027
+#define EARC_RX_CMDC_STATUS1               0x028
+#define EARC_RX_CMDC_STATUS2               0x029
+#define EARC_RX_CMDC_STATUS3               0x02a
+#define EARC_RX_CMDC_STATUS4               0x02b
+#define EARC_RX_CMDC_STATUS5               0x02c
+#define EARC_RX_CMDC_STATUS6               0x02d
+/* eARC TX CMDC */
+#define EARC_TX_CMDC_TOP_CTRL0             0x030
+#define EARC_TX_CMDC_TOP_CTRL1             0x031
+#define EARC_TX_CMDC_TOP_CTRL2             0x032
+#define EARC_TX_CMDC_TIMER_CTRL0           0x033
+#define EARC_TX_CMDC_TIMER_CTRL1           0x034
+#define EARC_TX_CMDC_TIMER_CTRL2           0x035
+#define EARC_TX_CMDC_TIMER_CTRL3           0x036
+#define EARC_TX_CMDC_VSM_CTRL0             0x037
+#define EARC_TX_CMDC_VSM_CTRL1             0x038
+#define EARC_TX_CMDC_VSM_CTRL2             0x039
+#define EARC_TX_CMDC_VSM_CTRL3             0x03a
+#define EARC_TX_CMDC_VSM_CTRL4             0x03b
+#define EARC_TX_CMDC_VSM_CTRL5             0x03c
+#define EARC_TX_CMDC_VSM_CTRL6             0x03d
+#define EARC_TX_CMDC_VSM_CTRL7             0x03e
+#define EARC_TX_CMDC_VSM_CTRL8             0x03f
+#define EARC_TX_CMDC_VSM_CTRL9             0x041
+#define EARC_TX_CMDC_SENDER_CTRL0          0x042
+#define EARC_TX_CMDC_PACKET_CTRL0          0x043
+#define EARC_TX_CMDC_PACKET_CTRL1          0x044
+#define EARC_TX_CMDC_PACKET_CTRL2          0x045
+#define EARC_TX_CMDC_PACKET_CTRL3          0x046
+#define EARC_TX_CMDC_PACKET_CTRL4          0x047
+#define EARC_TX_CMDC_PACKET_CTRL5          0x048
+#define EARC_TX_CMDC_PACKET_CTRL6          0x049
+#define EARC_TX_CMDC_BIPHASE_CTRL0         0x04a
+#define EARC_TX_CMDC_BIPHASE_CTRL1         0x04b
+#define EARC_TX_CMDC_BIPHASE_CTRL2         0x04c
+#define EARC_TX_CMDC_BIPHASE_CTRL3         0x04d
+#define EARC_TX_CMDC_DEVICE_ID_CTRL        0x04e
+#define EARC_TX_CMDC_DEVICE_WDATA          0x04f
+#define EARC_TX_CMDC_DEVICE_RDATA          0x050
+#define EARC_TX_CMDC_MASTER_CTRL           0x051
+#define EARC_TX_ANA_CTRL0                  0x052
+#define EARC_TX_ANA_CTRL1                  0x053
+#define EARC_TX_ANA_CTRL2                  0x054
+#define EARC_TX_ANA_CTRL3                  0x055
+#define EARC_TX_ANA_CTRL4                  0x056
+#define EARC_TX_ANA_CTRL5                  0x057
+#define EARC_TX_ANA_STAT0                  0x058
+#define EARC_TX_CMDC_STATUS0               0x059
+#define EARC_TX_CMDC_STATUS1               0x05a
+#define EARC_TX_CMDC_STATUS2               0x05b
+#define EARC_TX_CMDC_STATUS3               0x05c
+#define EARC_TX_CMDC_STATUS4               0x05d
+#define EARC_TX_CMDC_STATUS5               0x05e
+#define EARC_TX_CMDC_STATUS6               0x05f
+/* eARC RX DMAC */
+#define EARCRX_DMAC_TOP_CTRL0              0x000
+#define EARCRX_DMAC_SYNC_CTRL0             0x001
+#define EARCRX_DMAC_SYNC_STAT0             0x002
+#define EARCRX_SPDIFIN_SAMPLE_CTRL0        0x003
+#define EARCRX_SPDIFIN_SAMPLE_CTRL1        0x004
+#define EARCRX_SPDIFIN_SAMPLE_CTRL2        0x005
+#define EARCRX_SPDIFIN_SAMPLE_CTRL3        0x006
+#define EARCRX_SPDIFIN_SAMPLE_CTRL4        0x007
+#define EARCRX_SPDIFIN_SAMPLE_CTRL5        0x008
+#define EARCRX_SPDIFIN_SAMPLE_STAT0        0x009
+#define EARCRX_SPDIFIN_SAMPLE_STAT1        0x00a
+#define EARCRX_SPDIFIN_MUTE_VAL            0x00b
+#define EARCRX_SPDIFIN_CTRL0               0x00c
+#define EARCRX_SPDIFIN_CTRL1               0x00d
+#define EARCRX_SPDIFIN_CTRL2               0x00e
+#define EARCRX_SPDIFIN_CTRL3               0x00f
+#define EARCRX_SPDIFIN_STAT0               0x010
+#define EARCRX_SPDIFIN_STAT1               0x011
+#define EARCRX_SPDIFIN_STAT2               0x012
+#define EARCRX_DMAC_UBIT_CTRL0             0x013
+#define EARCRX_IU_RDATA                    0x014
+#define EARCRX_DMAC_UBIT_STAT0             0x015
+#define EARCRX_ERR_CORRECT_CTRL0           0x016
+#define EARCRX_ERR_CORRECT_STAT0           0x017
+#define EARCRX_ANA_RST_CTRL0               0x018
+#define EARCRX_ANA_RST_CTRL1               0x019
+/* eARC TX DMAC */
+#define EARCTX_DMAC_TOP_CTRL0              0x000
+#define EARCTX_MUTE_VAL                    0x001
+#define EARCTX_SPDIFOUT_GAIN0              0x002
+#define EARCTX_SPDIFOUT_GAIN1              0x003
+#define EARCTX_SPDIFOUT_CTRL0              0x004
+#define EARCTX_SPDIFOUT_CTRL1              0x005
+#define EARCTX_SPDIFOUT_PREAMB             0x006
+#define EARCTX_SPDIFOUT_SWAP               0x007
+#define EARCTX_ERR_CORRT_CTRL0             0x008
+#define EARCTX_ERR_CORRT_CTRL1             0x009
+#define EARCTX_ERR_CORRT_CTRL2             0x00a
+#define EARCTX_ERR_CORRT_CTRL3             0x00b
+#define EARCTX_ERR_CORRT_CTRL4             0x00c
+#define EARCTX_ERR_CORRT_STAT0             0x00d
+#define EARCTX_SPDIFOUT_CHSTS0             0x00e
+#define EARCTX_SPDIFOUT_CHSTS1             0x00f
+#define EARCTX_SPDIFOUT_CHSTS2             0x010
+#define EARCTX_SPDIFOUT_CHSTS3             0x011
+#define EARCTX_SPDIFOUT_CHSTS4             0x012
+#define EARCTX_SPDIFOUT_CHSTS5             0x013
+#define EARCTX_SPDIFOUT_CHSTS6             0x014
+#define EARCTX_SPDIFOUT_CHSTS7             0x015
+#define EARCTX_SPDIFOUT_CHSTS8             0x016
+#define EARCTX_SPDIFOUT_CHSTS9             0x017
+#define EARCTX_SPDIFOUT_CHSTSA             0x018
+#define EARCTX_SPDIFOUT_CHSTSB             0x019
+#define EARCTX_FE_CTRL0                    0x01a
+#define EARCTX_FE_STAT0                    0x01b
+#define EARCTX_SPDIFOUT_STAT               0x01c
+/* eARC RX */
+#define EARCRX_TOP_CTRL0                   0x000
+#define EARCRX_DMAC_INT_MASK               0x001
+#define EARCRX_DMAC_INT_PENDING            0x002
+#define EARCRX_CMDC_INT_MASK               0x003
+#define EARCRX_CMDC_INT_PENDING            0x004
+#define EARCRX_ANA_CTRL0                   0x005
+#define EARCRX_ANA_CTRL1                   0x006
+#define EARCRX_ANA_STAT0                   0x007
+#define EARCRX_PLL_CTRL0                   0x008
+#define EARCRX_PLL_CTRL1                   0x009
+#define EARCRX_PLL_CTRL2                   0x00a
+#define EARCRX_PLL_CTRL3                   0x00b
+#define EARCRX_PLL_STAT0                   0x00c
+/* eARC TX */
+#define EARCTX_TOP_CTRL0                   0x000
+#define EARCTX_DMAC_INT_MASK               0x001
+#define EARCTX_DMAC_INT_PENDING            0x002
+#define EARCTX_CMDC_INT_MASK               0x003
+#define EARCTX_CMDC_INT_PENDING            0x004
+#define EARCTX_ANA_CTRL0                   0x005
+#define EARCTX_ANA_CTRL1                   0x006
+#define EARCTX_ANA_CTRL2                   0x007
+#define EARCTX_ANA_STAT0                   0x008
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/rpi-audio-rtdm.c b/evl/sound/evl-amlogic/rpi-audio-rtdm.c
--- a/drivers/evl/sound/evl-amlogic/rpi-audio-rtdm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/rpi-audio-rtdm.c	2022-01-05 10:56:14.752832074 +0300
@@ -0,0 +1,365 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @brief Initial version of real-time audio driver for rpi
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/printk.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+
+/* RTDM headers */
+#include <rtdm/driver.h>
+#include <rtdm/rtdm.h>
+
+#include "rpi-audio-rtdm.h"
+#include "elk-pi-config.h"
+#include "hifi-berry-config.h"
+#include "hifi-berry-pro-config.h"
+#include "pcm3168a-elk.h"
+#include "pcm5122-elk.h"
+#include "pcm1863-elk.h"
+#include "bcm2835-i2s-elk.h"
+
+MODULE_AUTHOR("Nitin Kulkarni (nitin@elk.audio)");
+MODULE_DESCRIPTION("RTDM audio driver for RPi");
+MODULE_LICENSE("GPL");
+
+#define DEFAULT_AUDIO_SAMPLING_RATE			48000
+#define DEFAULT_AUDIO_NUM_INPUT_CHANNELS		8
+#define DEFAULT_AUDIO_NUM_OUTPUT_CHANNELS		8
+#define DEFAULT_AUDIO_NUM_CODEC_CHANNELS		8
+#define DEFAULT_AUDIO_N_FRAMES_PER_BUFFER		64
+#define DEFAULT_AUDIO_CODEC_FORMAT			INT24_LJ
+#define DEFAULT_AUDIO_LOW_LATENCY_VAL			1
+#define PLATFORM_TYPE					NATIVE_AUDIO
+#define SUPPORTED_BUFFER_SIZES 16, 32, 64, 128
+
+static uint audio_rtdm_ver_maj = AUDIO_RTDM_VERSION_MAJ;
+static uint audio_rtdm_ver_min = AUDIO_RTDM_VERSION_MIN;
+static uint audio_rtdm_ver_rev = AUDIO_RTDM_VERSION_VER;
+static uint audio_input_channels = DEFAULT_AUDIO_NUM_INPUT_CHANNELS;
+static uint audio_output_channels = DEFAULT_AUDIO_NUM_OUTPUT_CHANNELS;
+static uint audio_sampling_rate = DEFAULT_AUDIO_SAMPLING_RATE;
+static uint audio_format = DEFAULT_AUDIO_CODEC_FORMAT;
+static uint platform_type = PLATFORM_TYPE;
+
+static uint audio_buffer_size = DEFAULT_AUDIO_N_FRAMES_PER_BUFFER;
+module_param(audio_buffer_size, uint, 0644);
+static char *audio_hat = "elk-pi";
+module_param(audio_hat, charp, 0644);
+static uint audio_enable_low_latency = DEFAULT_AUDIO_LOW_LATENCY_VAL;
+module_param(audio_enable_low_latency, uint, 0644);
+static const int supported_buffer_sizes[] = {SUPPORTED_BUFFER_SIZES};
+
+struct audio_dev_context {
+	struct audio_rtdm_dev *i2s_dev;
+	uint64_t user_proc_calls;
+};
+
+static ssize_t audio_buffer_size_show(struct class *cls,
+                                      struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", audio_buffer_size);
+}
+
+static ssize_t audio_buffer_size_store(struct class *class,
+		struct class_attribute *attr, const char *buf, size_t size)
+{
+	unsigned long bs;
+	ssize_t result;
+	result = sscanf(buf, "%lu", &bs);
+	if (result != 1)
+		return -EINVAL;
+	audio_buffer_size = bs;
+	return size;
+}
+
+
+static ssize_t audio_sampling_rate_show(struct class *cls,
+                                        struct class_attribute *attr,
+                                        char *buf) {
+  return sprintf(buf, "%lu\n", audio_sampling_rate);
+}
+
+static ssize_t audio_rtdm_ver_maj_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_maj);
+}
+
+static ssize_t audio_rtdm_ver_min_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_min);
+}
+
+static ssize_t audio_rtdm_ver_rev_show(struct class *cls,
+                                       struct class_attribute *attr,
+                                       char *buf) {
+  return sprintf(buf, "%d\n", audio_rtdm_ver_rev);
+}
+
+static ssize_t audio_input_channels_show(struct class *cls,
+                                         struct class_attribute *attr,
+                                         char *buf) {
+  return sprintf(buf, "%d\n", audio_input_channels);
+}
+
+static ssize_t audio_output_channels_show(struct class *cls,
+                                          struct class_attribute *attr,
+                                          char *buf) {
+  return sprintf(buf, "%d\n", audio_output_channels);
+}
+
+static ssize_t audio_format_show(struct class *cls,
+                                 struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", audio_format);
+}
+
+static ssize_t platform_type_show(struct class *cls,
+                                  struct class_attribute *attr, char *buf) {
+  return sprintf(buf, "%d\n", platform_type);
+}
+
+static CLASS_ATTR_RW(audio_buffer_size);
+static CLASS_ATTR_RO(audio_hat);
+static CLASS_ATTR_RO(audio_sampling_rate);
+static CLASS_ATTR_RO(audio_rtdm_ver_maj);
+static CLASS_ATTR_RO(audio_rtdm_ver_min);
+static CLASS_ATTR_RO(audio_rtdm_ver_rev);
+static CLASS_ATTR_RO(audio_input_channels);
+static CLASS_ATTR_RO(audio_output_channels);
+static CLASS_ATTR_RO(audio_format);
+static CLASS_ATTR_RO(platform_type);
+
+static struct attribute *audio_rtdm_class_attrs[] = {
+	&class_attr_audio_buffer_size.attr,
+	&class_attr_audio_hat.attr,
+	&class_attr_audio_sampling_rate.attr,
+	&class_attr_audio_rtdm_ver_maj.attr,
+	&class_attr_audio_rtdm_ver_min.attr,
+	&class_attr_audio_rtdm_ver_rev.attr,
+	&class_attr_audio_input_channels.attr,
+	&class_attr_audio_output_channels.attr,
+	&class_attr_audio_format.attr,
+	&class_attr_platform_type.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(audio_rtdm_class);
+
+struct class audio_rtdm_class = {
+    .name = "audio_rtdm",
+    .class_groups = audio_rtdm_class_groups,
+};
+
+static int audio_driver_open(struct rtdm_fd *fd, int oflags)
+{
+	struct audio_dev_context *dev_context;
+	printk(KERN_INFO "audio_rtdm: audio_open.\n");
+	dev_context = (struct audio_dev_context *)rtdm_fd_to_private(fd);
+	dev_context->i2s_dev = bcm2835_get_i2s_dev();
+	dev_context->i2s_dev->wait_flag = 0;
+	dev_context->user_proc_calls = 0;
+	dev_context->i2s_dev->kinterrupts = 0;
+	dev_context->i2s_dev->buffer_idx = 0;
+	rtdm_event_init(&dev_context->i2s_dev->irq_event, 0);
+	bcm2835_i2s_buffers_setup(audio_buffer_size, audio_output_channels);
+	return 0;
+}
+
+static void audio_driver_close(struct rtdm_fd *fd)
+{
+	int i;
+	struct audio_dev_context *dev_context = (struct audio_dev_context *)
+							rtdm_fd_to_private(fd);
+	struct audio_rtdm_buffers *i2s_buffer = dev_context->i2s_dev->buffer;
+	int *tx = i2s_buffer->tx_buf;
+
+	printk(KERN_INFO "audio_rtdm: audio_close.\n");
+	rtdm_event_destroy(&dev_context->i2s_dev->irq_event);
+	if (dev_context->i2s_dev->wait_flag) {
+		for (i = 0; i < i2s_buffer->buffer_len/4; i++) {
+			tx[i] = 0;
+		}
+		dev_context->i2s_dev->wait_flag = 0;
+	}
+	bcm2835_i2s_exit();
+}
+
+static int audio_driver_mmap_nrt(struct rtdm_fd *fd, struct vm_area_struct *vma)
+{
+	struct audio_dev_context *dev_context = (struct audio_dev_context *)
+							rtdm_fd_to_private(fd);
+	struct audio_rtdm_buffers *i2s_buffer = dev_context->i2s_dev->buffer;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	return dma_mmap_coherent(dev_context->i2s_dev->dma_rx->device->dev,
+		vma,
+		i2s_buffer->rx_buf, i2s_buffer->rx_phys_addr,
+		RESERVED_BUFFER_SIZE_IN_PAGES * PAGE_SIZE);
+}
+
+static int audio_driver_ioctl_rt(struct rtdm_fd *fd, unsigned int request,
+								void __user *arg)
+{
+	int result;
+	struct audio_dev_context *dev_context = (struct audio_dev_context *)
+					rtdm_fd_to_private(fd);
+	struct audio_rtdm_dev *dev = dev_context->i2s_dev;
+
+	switch (request) {
+
+	case AUDIO_IRQ_WAIT:
+	{
+		result = rtdm_event_wait(&dev->irq_event);
+		if (result < 0) {
+			printk(KERN_ERR "rtdm_event_wait failed\n");
+			return result;
+		}
+		dev_context->user_proc_calls = dev->kinterrupts;
+		result = dev->buffer_idx;
+		return !result;
+	}
+
+	case AUDIO_PROC_START:
+	{
+		bcm2835_i2s_start_stop(dev, BCM2835_I2S_START_CMD);
+		return 0;
+	}
+
+	case AUDIO_PROC_STOP:
+	{
+		bcm2835_i2s_start_stop(dev, BCM2835_I2S_STOP_CMD);
+		return 0;
+	}
+
+	case AUDIO_USERPROC_FINISHED:
+	{
+		result = (dev->kinterrupts -
+				dev_context->user_proc_calls);
+		return result;
+	}
+
+	default:
+		printk(KERN_WARNING "audio_rtdm : audio_ioctl_rt: invalid value"
+							" %d\n", request);
+		return -EINVAL;
+	}
+}
+
+static struct rtdm_driver audio_driver = {
+	.profile_info		= RTDM_PROFILE_INFO(gpio,
+						RTDM_CLASS_EXPERIMENTAL,
+						RTDM_SUBCLASS_GENERIC,
+						RTAUDIO_PROFILE_VER),
+	.device_flags		= RTDM_NAMED_DEVICE | RTDM_EXCLUSIVE,
+	.device_count		= 1,
+	.context_size		= sizeof(struct audio_dev_context),
+	.ops = {
+		.open		= audio_driver_open,
+		.close		= audio_driver_close,
+		.mmap		= audio_driver_mmap_nrt,
+		.ioctl_rt	= audio_driver_ioctl_rt,
+	},
+};
+
+static struct rtdm_device rtdm_audio_device = {
+	.driver = &audio_driver,
+	.label = DEVICE_NAME,
+};
+
+
+int audio_rtdm_init(void)
+{
+	int ret, num_codec_channels = DEFAULT_AUDIO_NUM_CODEC_CHANNELS;
+
+	ret = class_register(&audio_rtdm_class);
+	if (ret < 0)
+		return ret;
+
+	if (!realtime_core_enabled()) {
+		printk(KERN_ERR "audio_rtdm: rt core not enabled\n");
+		return -ENODEV;
+	}
+
+	if (!strcmp(audio_hat, "hifi-berry")) {
+		printk(KERN_INFO "audio_rtdm: hifi-berry hat\n");
+		if (pcm5122_codec_init(HIFI_BERRY_DAC_MODE,
+				HIFI_BERRY_SAMPLING_RATE,
+				audio_enable_low_latency)) {
+			printk(KERN_ERR "audio_rtdm: codec init failed\n");
+			return -1;
+		}
+		audio_input_channels = HIFI_BERRY_NUM_INPUT_CHANNELS;
+		audio_output_channels = HIFI_BERRY_NUM_OUTPUT_CHANNELS;
+		num_codec_channels = HIFI_BERRY_NUM_CODEC_CHANNELS;
+		audio_format = HIFI_BERRY_CODEC_FORMAT;
+		audio_sampling_rate = HIFI_BERRY_SAMPLING_RATE;
+	} else if (!strcmp(audio_hat, "hifi-berry-pro")) {
+		printk(KERN_INFO "audio_rtdm: hifi-berry-pro hat\n");
+		if (pcm1863_codec_init(audio_enable_low_latency)) {
+			printk(KERN_ERR "audio_rtdm: pcm3168 codec failed\n");
+			return -1;
+		}
+		if (pcm5122_codec_init(HIFI_BERRY_PRO_DAC_MODE,
+					HIFI_BERRY_PRO_SAMPLING_RATE,
+					audio_enable_low_latency)) {
+			printk(KERN_ERR "audio_rtdm: pcm5122 codec failed\n");
+			return -1;
+		}
+		audio_input_channels = HIFI_BERRY_PRO_NUM_INPUT_CHANNELS;
+		audio_output_channels = HIFI_BERRY_PRO_NUM_OUTPUT_CHANNELS;
+		num_codec_channels = HIFI_BERRY_PRO_NUM_CODEC_CHANNELS;
+		audio_format = HIFI_BERRY_PRO_CODEC_FORMAT;
+		audio_sampling_rate = HIFI_BERRY_PRO_SAMPLING_RATE;
+	} else if (!strcmp(audio_hat, "elk-pi")) {
+		printk(KERN_INFO "audio_rtdm: elk-pi hat\n");
+		if (pcm3168a_codec_init()) {
+			printk(KERN_ERR "audio_rtdm: codec init failed\n");
+			return -1;
+		}
+		audio_input_channels = ELK_PI_NUM_INPUT_CHANNELS;
+		audio_output_channels = ELK_PI_NUM_OUTPUT_CHANNELS;
+		num_codec_channels = ELK_PI_NUM_CODEC_CHANNELS;
+		audio_format = ELK_PI_CODEC_FORMAT;
+		audio_sampling_rate = ELK_PI_SAMPLING_RATE;
+	} else {
+		printk(KERN_ERR "audio_rtdm: Unsupported hat\n");
+	}
+
+	if (bcm2835_i2s_init(audio_hat)) {
+		printk(KERN_ERR "audio_rtdm: i2s init failed\n");
+		return -1;
+	}
+	ret = rtdm_dev_register(&rtdm_audio_device);
+	if (ret) {
+		rtdm_dev_unregister(&rtdm_audio_device);
+		printk(KERN_ERR "audio_rtdm:driver init failed\n");
+		return ret;
+	}
+
+	printk(KERN_INFO "audio_rtdm: driver initialized\n");
+	return 0;
+}
+
+void audio_rtdm_exit(void)
+{
+	printk(KERN_INFO "audio_rtdm: driver exiting...\n");
+	if (!strcmp(audio_hat, "hifi-berry")) {
+		pcm5122_codec_exit();
+	} else if (!strcmp(audio_hat, "elk-pi")) {
+		pcm3168a_codec_exit();
+	}
+	class_unregister(&audio_rtdm_class);
+	rtdm_dev_unregister(&rtdm_audio_device);
+}
+
+module_init(audio_rtdm_init)
+module_exit(audio_rtdm_exit)
diff -ruN a/drivers/evl/sound/evl-amlogic/rpi-audio-rtdm.h b/evl/sound/evl-amlogic/rpi-audio-rtdm.h
--- a/drivers/evl/sound/evl-amlogic/rpi-audio-rtdm.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/rpi-audio-rtdm.h	2021-12-16 16:27:41.009132721 +0300
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * @copyright 2017-2019 Modern Ancient Instruments Networked AB, dba Elk,
+ * Stockholm
+ */
+#ifndef AUDIO_RTDM_H
+#define AUDIO_RTDM_H
+
+#include <linux/io.h>
+#include <linux/ioctl.h>
+
+#define RTDM_SUBCLASS_GPIO	0
+#define DEVICE_NAME		"audio_rtdm"
+#define RTAUDIO_PROFILE_VER	1
+#define AUDIO_RTDM_VERSION_MAJ	0
+#define AUDIO_RTDM_VERSION_MIN	3
+#define AUDIO_RTDM_VERSION_VER	0
+
+#define AUDIO_IOC_MAGIC		'r'
+
+/* ioctl request to wait on dma callback */
+#define AUDIO_IRQ_WAIT			_IO(AUDIO_IOC_MAGIC, 1)
+/* This ioctl not used anymore but kept for backwards compatibility */
+#define AUDIO_IMMEDIATE_SEND		_IOW(AUDIO_IOC_MAGIC, 2, int)
+/* ioctl request to start receiving audio callbacks */
+#define AUDIO_PROC_START		_IO(AUDIO_IOC_MAGIC, 3)
+/* ioctl to inform the driver the user space process has completed */
+#define AUDIO_USERPROC_FINISHED		_IOW(AUDIO_IOC_MAGIC, 4, int)
+/* ioctl to stop receiving audio callbacks */
+#define AUDIO_PROC_STOP			_IO(AUDIO_IOC_MAGIC, 5)
+
+enum codec_sample_format {
+	INT24_LJ = 1,
+	INT24_I2S,
+	INT24_RJ,
+	INT32_RJ
+};
+
+enum platform_type {
+	NATIVE_AUDIO = 1,
+	SYNC_WITH_UC_AUDIO,
+	ASYNC_WITH_UC_AUDIO,
+};
+
+struct audio_rtdm_buffers {
+	uint32_t 	 	*cv_gate_out;
+	uint32_t 	 	*cv_gate_in;
+	void			*tx_buf;
+	void			*rx_buf;
+	size_t			buffer_len;
+	size_t			period_len;
+	dma_addr_t		tx_phys_addr;
+	dma_addr_t		rx_phys_addr;
+};
+
+/* General audio rtdm device struct */
+struct audio_rtdm_dev {
+	struct device			*dev;
+	void __iomem			*i2s_base_addr;
+	struct dma_chan			*dma_tx;
+	struct dma_chan			*dma_rx;
+	struct dma_async_tx_descriptor 	*tx_desc;
+	struct dma_async_tx_descriptor	*rx_desc;
+	dma_addr_t			fifo_dma_addr;
+	unsigned			addr_width;
+	unsigned			dma_burst_size;
+	struct audio_rtdm_buffers	*buffer;
+	rtdm_event_t 			irq_event;
+	unsigned			wait_flag;
+	unsigned			buffer_idx;
+	uint64_t			kinterrupts;
+	struct clk			*clk;
+	bool				cv_gate_enabled;
+	int				clk_rate;
+	char 				*audio_hat;
+};
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/sharebuffer.c b/evl/sound/evl-amlogic/sharebuffer.c
--- a/drivers/evl/sound/evl-amlogic/sharebuffer.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/sharebuffer.c	2022-01-11 13:08:14.433690391 +0300
@@ -0,0 +1,167 @@
+/*
+ * sound/soc/amlogic/auge/sharebuffer.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+// #include <sound/pcm.h>
+
+// #include <linux/amlogic/media/sound/aout_notify.h>
+
+#include "sharebuffer.h"
+#include "ddr_mngr.h"
+#include "evl-audio.h"
+#include "spdif_hw.h"
+#include "evl-audio.h"
+#include "tdm_hw.h"
+
+static int sharebuffer_spdifout_prepare(
+	struct frddr *fr, int spdif_id, int lane_i2s, int rate)
+{
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	int bit_depth;
+	struct iec958_chsts chsts;
+
+	// Hack fixed bit depth
+	bit_depth = 32;
+
+	spdifout_samesource_set(spdif_id,
+		aml_frddr_get_fifo_id(fr),
+		bit_depth,
+		2,
+		true,
+		lane_i2s);
+
+	/* spdif to hdmitx */
+	spdifout_to_hdmitx_ctrl(spdif_id);
+	/* check and set channel status */
+	spdif_get_channel_status_info(&chsts, rate);
+	spdif_set_channel_status_info(&chsts, spdif_id);
+	/* notify hdmitx audio */
+	// aout_notifier_call_chain(0x1, substream);
+
+	return 0;
+}
+
+static int sharebuffer_spdifout_free(
+	struct frddr *fr, int spdif_id)
+{
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	int bit_depth;
+
+	// Fix me - hacl
+	bit_depth = 32;
+
+	/* spdif b is always on */
+	if (spdif_id != 1)
+		spdifout_samesource_set(spdif_id,
+			aml_frddr_get_fifo_id(fr),
+			bit_depth,
+			2,
+			false, 0);
+
+	return 0;
+}
+
+void sharebuffer_enable(int sel, bool enable, bool reenable)
+{
+	if (sel < 0) {
+		pr_err("Not support same source\n");
+		return;
+	} else if (sel < 3) {
+		// TODO: same with tdm
+	} else if (sel < 5) {
+		/* same source with spdif a/b */
+		spdifout_enable(sel - 3, enable, reenable);
+	}
+}
+
+int sharebuffer_prepare(
+	void *pfrddr, int samesource_sel, int lane_i2s, int offset, int rate)
+{
+	struct frddr *fr = (struct frddr *)pfrddr;
+
+	/* each module prepare, clocks and controls */
+	if (samesource_sel < 0) {
+		pr_err("Not support same source\n");
+		return -EINVAL;
+	} else if (samesource_sel < 3) {
+		// TODO: same with tdm
+	} else if (samesource_sel < 5) {
+		/* same source with spdif a/b */
+		sharebuffer_spdifout_prepare(
+			fr, samesource_sel - 3, lane_i2s,rate);
+	}
+
+	/* frddr, share buffer, src_sel1 */
+	aml_frddr_select_dst_ss(fr, samesource_sel, 1, true);
+
+	return 0;
+}
+
+int sharebuffer_free(
+	void *pfrddr, int samesource_sel)
+{
+	struct frddr *fr = (struct frddr *)pfrddr;
+
+	/* each module prepare, clocks and controls */
+	if (samesource_sel < 0) {
+		pr_err("Not support same source\n");
+		return -EINVAL;
+	} else if (samesource_sel < 3) {
+		// TODO: same with tdm
+	} else if (samesource_sel < 5) {
+		/* same source with spdif a/b */
+		sharebuffer_spdifout_free(fr, samesource_sel - 3);
+	}
+
+	/* frddr, share buffer, src_sel1 */
+	aml_frddr_select_dst_ss(fr, samesource_sel, 1, false);
+
+	return 0;
+}
+
+
+int sharebuffer_trigger(int cmd, int samesource_sel, int reenable)
+{
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sharebuffer_enable(samesource_sel, true, reenable);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sharebuffer_enable(samesource_sel, false, reenable);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void sharebuffer_get_mclk_fs_ratio(int samesource_sel,
+	int *pll_mclk_ratio, int *mclk_fs_ratio)
+{
+	if (samesource_sel < 0) {
+		pr_err("Not support same source\n");
+	} else if (samesource_sel < 3) {
+		// TODO: same with tdm
+	} else if (samesource_sel < 5) {
+		/* spdif a/b */
+		*pll_mclk_ratio = 4;
+		*mclk_fs_ratio = 128;
+	}
+}
diff -ruN a/drivers/evl/sound/evl-amlogic/sharebuffer.h b/evl/sound/evl-amlogic/sharebuffer.h
--- a/drivers/evl/sound/evl-amlogic/sharebuffer.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/sharebuffer.h	2022-01-10 12:11:06.948906676 +0300
@@ -0,0 +1,28 @@
+/*
+ * sound/soc/amlogic/auge/sharebuffer.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef __AML_AUDIO_SHAREBUFFER_H__
+#define __AML_AUDIO_SHAREBUFFER_H__
+
+extern int sharebuffer_prepare(
+	void *pfrddr, int samesource_sel, int lane_i2s, int offset, int rate);
+extern int sharebuffer_free(
+		void *pfrddr, int samesource_sel);
+extern int sharebuffer_trigger(int cmd, int samesource_sel, int reenable);
+
+extern void sharebuffer_get_mclk_fs_ratio(int samesource_sel,
+	int *pll_mclk_ratio, int *mclk_fs_ratio);
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/sm1,clocks.c b/evl/sound/evl-amlogic/sm1,clocks.c
--- a/drivers/evl/sound/evl-amlogic/sm1,clocks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/sm1,clocks.c	2021-12-24 10:32:04.398782567 +0300
@@ -0,0 +1,403 @@
+/*
+ * sound/soc/amlogic/auge/sm1,clocks.c
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "sm1_audio_clocks: " fmt
+
+#include "dt-bindings/amlogic,sm1-audio-clk.h"
+
+#include "audio_clks.h"
+#include "regs.h"
+
+static spinlock_t aclk_lock;
+
+static const char *const mclk_parent_names[] = {
+	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
+	"fclk_div3", "fclk_div4", "fclk_div5"};
+
+static const char *const audioclk_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c", "mclk_d", "mclk_e",
+	"mclk_f", "i_slv_sclk_a", "i_slv_sclk_b", "i_slv_sclk_c",
+	"i_slv_sclk_d", "i_slv_sclk_e", "i_slv_sclk_f", "i_slv_sclk_g",
+	"i_slv_sclk_h", "i_slv_sclk_i", "i_slv_sclk_j"};
+
+static const char *const mclk_pad_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c",
+	"mclk_d", "mclk_e", "mclk_f"
+};
+
+CLOCK_GATE(audio_ddr_arb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 0);
+CLOCK_GATE(audio_pdm, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 1);
+CLOCK_GATE(audio_tdmina, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 2);
+CLOCK_GATE(audio_tdminb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 3);
+CLOCK_GATE(audio_tdminc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 4);
+CLOCK_GATE(audio_tdminlb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 5);
+CLOCK_GATE(audio_tdmouta, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 6);
+CLOCK_GATE(audio_tdmoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 7);
+CLOCK_GATE(audio_tdmoutc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 8);
+CLOCK_GATE(audio_frddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 9);
+CLOCK_GATE(audio_frddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 10);
+CLOCK_GATE(audio_frddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 11);
+CLOCK_GATE(audio_toddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 12);
+CLOCK_GATE(audio_toddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 13);
+CLOCK_GATE(audio_toddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 14);
+CLOCK_GATE(audio_loopbacka, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 15);
+CLOCK_GATE(audio_spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 16);
+CLOCK_GATE(audio_spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 17);
+CLOCK_GATE(audio_resamplea, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 18);
+CLOCK_GATE(audio_reserved0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 19);
+CLOCK_GATE(audio_toram, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 20);
+CLOCK_GATE(audio_spdifoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 21);
+CLOCK_GATE(audio_eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 22);
+CLOCK_GATE(audio_reserved1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 23);
+CLOCK_GATE(audio_reserved2, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 24);
+CLOCK_GATE(audio_reserved3, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 25);
+CLOCK_GATE(audio_resampleb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 26);
+CLOCK_GATE(audio_tovad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 27);
+CLOCK_GATE(audio_audiolocker, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 28);
+CLOCK_GATE(audio_spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 29);
+CLOCK_GATE(audio_reserved4, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 30);
+CLOCK_GATE(audio_reserved5, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 31);
+
+CLOCK_GATE(audio_frddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 0);
+CLOCK_GATE(audio_toddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 1);
+CLOCK_GATE(audio_loopbackb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 2);
+CLOCK_GATE(audio_earcrx, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 6);
+
+static struct clk_gate *sm1_audio_clk_gates[] = {
+	&audio_ddr_arb,
+	&audio_pdm,
+	&audio_tdmina,
+	&audio_tdminb,
+	&audio_tdminc,
+	&audio_tdminlb,
+	&audio_tdmouta,
+	&audio_tdmoutb,
+	&audio_tdmoutc,
+	&audio_frddra,
+	&audio_frddrb,
+	&audio_frddrc,
+	&audio_toddra,
+	&audio_toddrb,
+	&audio_toddrc,
+	&audio_loopbacka,
+	&audio_spdifin,
+	&audio_spdifout,
+	&audio_resamplea,
+	&audio_reserved0,
+	&audio_toram,
+	&audio_spdifoutb,
+	&audio_eqdrc,
+	&audio_reserved1,
+	&audio_reserved2,
+	&audio_reserved3,
+	&audio_resampleb,
+	&audio_tovad,
+	&audio_audiolocker,
+	&audio_spdifin_lb,
+	&audio_reserved4,
+	&audio_reserved5,
+
+	&audio_frddrd,
+	&audio_toddrd,
+	&audio_loopbackb,
+	&audio_earcrx,
+};
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw *sm1_audio_clk_hws[] = {
+	[CLKID_AUDIO_GATE_DDR_ARB]     = &audio_ddr_arb.hw,
+	[CLKID_AUDIO_GATE_PDM]         = &audio_pdm.hw,
+	[CLKID_AUDIO_GATE_TDMINA]      = &audio_tdmina.hw,
+	[CLKID_AUDIO_GATE_TDMINB]      = &audio_tdminb.hw,
+	[CLKID_AUDIO_GATE_TDMINC]      = &audio_tdminc.hw,
+	[CLKID_AUDIO_GATE_TDMINLB]     = &audio_tdminlb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTA]     = &audio_tdmouta.hw,
+	[CLKID_AUDIO_GATE_TDMOUTB]     = &audio_tdmoutb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTC]     = &audio_tdmoutc.hw,
+	[CLKID_AUDIO_GATE_FRDDRA]      = &audio_frddra.hw,
+	[CLKID_AUDIO_GATE_FRDDRB]      = &audio_frddrb.hw,
+	[CLKID_AUDIO_GATE_FRDDRC]      = &audio_frddrc.hw,
+	[CLKID_AUDIO_GATE_TODDRA]      = &audio_toddra.hw,
+	[CLKID_AUDIO_GATE_TODDRB]      = &audio_toddrb.hw,
+	[CLKID_AUDIO_GATE_TODDRC]      = &audio_toddrc.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKA]   = &audio_loopbacka.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN]     = &audio_spdifin.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_A]  = &audio_spdifout.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEA]   = &audio_resamplea.hw,
+	[CLKID_AUDIO_GATE_RESERVED0]   = &audio_reserved0.hw,
+	[CLKID_AUDIO_GATE_TORAM]       = &audio_toram.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_B]  = &audio_spdifoutb.hw,
+	[CLKID_AUDIO_GATE_EQDRC]       = &audio_eqdrc.hw,
+	[CLKID_AUDIO_GATE_RESERVED1]   = &audio_reserved1.hw,
+	[CLKID_AUDIO_GATE_RESERVED2]   = &audio_reserved2.hw,
+	[CLKID_AUDIO_GATE_RESERVED3]   = &audio_reserved3.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEB]   = &audio_resampleb.hw,
+	[CLKID_AUDIO_GATE_TOVAD]       = &audio_tovad.hw,
+	[CLKID_AUDIO_GATE_AUDIOLOCKER] = &audio_audiolocker.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN_LB]  = &audio_spdifin_lb.hw,
+	[CLKID_AUDIO_GATE_RESERVED4]   = &audio_reserved4.hw,
+	[CLKID_AUDIO_GATE_RESERVED5]   = &audio_reserved5.hw,
+
+	[CLKID_AUDIO_GATE_FRDDRD]      = &audio_frddrd.hw,
+	[CLKID_AUDIO_GATE_TODDRD]      = &audio_toddrd.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKB]   = &audio_loopbackb.hw,
+	[CLKID_AUDIO_GATE_EARCRX]      = &audio_earcrx.hw,
+};
+
+static int sm1_clk_gates_init(struct clk **clks, void __iomem *iobase)
+{
+	int clkid;
+
+	if (ARRAY_SIZE(sm1_audio_clk_gates) != MCLK_BASE) {
+		pr_err("check clk gates number\n");
+		return -EINVAL;
+	}
+
+	for (clkid = 0; clkid < MCLK_BASE; clkid++) {
+		unsigned long offset =
+			(unsigned long)sm1_audio_clk_gates[clkid]->reg;
+		sm1_audio_clk_gates[clkid]->reg =
+			(void __iomem *)((unsigned long)iobase + offset);
+		clks[clkid] = clk_register(NULL, sm1_audio_clk_hws[clkid]);
+		WARN_ON(IS_ERR_OR_NULL(clks[clkid]));
+	}
+
+	return 0;
+}
+
+/* mclk_a */
+CLOCK_COM_MUX(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 31);
+/* mclk_b */
+CLOCK_COM_MUX(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 31);
+/* mclk_c */
+CLOCK_COM_MUX(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 31);
+/* mclk_d */
+CLOCK_COM_MUX(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 31);
+/* mclk_e */
+CLOCK_COM_MUX(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 31);
+/* mclk_pad0 */
+CLOCK_COM_MUX(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0x7, 8);
+CLOCK_COM_DIV(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0, 8);
+CLOCK_COM_GATE(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 15);
+/* mclk_pad1 */
+CLOCK_COM_MUX(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 16, 8);
+CLOCK_COM_GATE(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 31);
+
+/* mclk_f */
+CLOCK_COM_MUX(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 31);
+/* spdifin */
+CLOCK_COM_MUX(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0, 8);
+CLOCK_COM_GATE(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 31);
+/* spdifout */
+CLOCK_COM_MUX(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 31);
+/* audio resample_a */
+CLOCK_COM_MUX(resample_a,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 31);
+/* audio locker_out */
+CLOCK_COM_MUX(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 24);
+CLOCK_COM_DIV(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 16, 8);
+CLOCK_COM_GATE(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 31);
+/* audio locker_in */
+CLOCK_COM_MUX(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 8);
+CLOCK_COM_DIV(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0, 8);
+CLOCK_COM_GATE(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 15);
+/* pdmin0 */
+CLOCK_COM_MUX(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0, 16);
+CLOCK_COM_GATE(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 31);
+/* pdmin1 */
+CLOCK_COM_MUX(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0x7, 24);
+CLOCK_COM_DIV(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0, 16);
+CLOCK_COM_GATE(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 31);
+/* spdifout b*/
+CLOCK_COM_MUX(spdifout_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio resample_b */
+CLOCK_COM_MUX(resample_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 31);
+/* spdifin_lb, div is a fake */
+CLOCK_COM_MUX(spdifin_lb,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x1, 30);
+CLOCK_COM_DIV(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 29);
+CLOCK_COM_GATE(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio eqdrc  */
+CLOCK_COM_MUX(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0, 16);
+CLOCK_COM_GATE(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 31);
+/* audio vad  */
+CLOCK_COM_MUX(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0x7, 24);
+CLOCK_COM_DIV(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0, 16);
+CLOCK_COM_GATE(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 31);
+/* EARC TX CMDC */
+CLOCK_COM_MUX(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 31);
+/* EARC TX DMAC */
+CLOCK_COM_MUX(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 31);
+/* EARC RX CMDC */
+CLOCK_COM_MUX(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 31);
+/* EARC RX DMAC */
+CLOCK_COM_MUX(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 31);
+
+static int sm1_clks_init(struct clk **clks, void __iomem *iobase)
+{
+	IOMAP_COM_CLK(mclk_a, iobase);
+	clks[CLKID_AUDIO_MCLK_A] = REGISTER_CLK_COM(mclk_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_A]));
+
+	IOMAP_COM_CLK(mclk_b, iobase);
+	clks[CLKID_AUDIO_MCLK_B] = REGISTER_CLK_COM(mclk_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_B]));
+
+	IOMAP_COM_CLK(mclk_c, iobase);
+	clks[CLKID_AUDIO_MCLK_C] = REGISTER_CLK_COM(mclk_c);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_C]));
+
+	IOMAP_COM_CLK(mclk_d, iobase);
+	clks[CLKID_AUDIO_MCLK_D] = REGISTER_CLK_COM(mclk_d);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_D]));
+
+	IOMAP_COM_CLK(mclk_e, iobase);
+	clks[CLKID_AUDIO_MCLK_E] = REGISTER_CLK_COM(mclk_e);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_E]));
+
+	IOMAP_COM_CLK(mclk_f, iobase);
+	clks[CLKID_AUDIO_MCLK_F] = REGISTER_CLK_COM(mclk_f);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_F]));
+
+	IOMAP_COM_CLK(spdifin, iobase);
+	clks[CLKID_AUDIO_SPDIFIN] = REGISTER_CLK_COM(spdifin);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN]));
+
+	IOMAP_COM_CLK(spdifout, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_A] = REGISTER_CLK_COM(spdifout);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_A]));
+
+	IOMAP_COM_CLK(resample_a, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_A] = REGISTER_AUDIOCLK_COM(resample_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_A]));
+
+	IOMAP_COM_CLK(locker_out, iobase);
+	clks[CLKID_AUDIO_LOCKER_OUT] = REGISTER_AUDIOCLK_COM(locker_out);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_OUT]));
+
+	IOMAP_COM_CLK(locker_in, iobase);
+	clks[CLKID_AUDIO_LOCKER_IN] = REGISTER_AUDIOCLK_COM(locker_in);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_IN]));
+
+	IOMAP_COM_CLK(pdmin0, iobase);
+	clks[CLKID_AUDIO_PDMIN0] = REGISTER_CLK_COM(pdmin0);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN0]));
+
+	IOMAP_COM_CLK(pdmin1, iobase);
+	clks[CLKID_AUDIO_PDMIN1] = REGISTER_CLK_COM(pdmin1);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN1]));
+
+	IOMAP_COM_CLK(spdifout_b, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_B] = REGISTER_CLK_COM(spdifout_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_B]));
+
+	IOMAP_COM_CLK(resample_b, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_B] = REGISTER_AUDIOCLK_COM(resample_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_B]));
+
+	IOMAP_COM_CLK(spdifin_lb, iobase);
+	clks[CLKID_AUDIO_SPDIFIN_LB] = REGISTER_CLK_COM(spdifin_lb);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN_LB]));
+
+	IOMAP_COM_CLK(eqdrc, iobase);
+	clks[CLKID_AUDIO_EQDRC] = REGISTER_CLK_COM(eqdrc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_EQDRC]));
+
+	IOMAP_COM_CLK(vad, iobase);
+	clks[CLKID_AUDIO_VAD] = REGISTER_CLK_COM(vad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_VAD]));
+
+	IOMAP_COM_CLK(earctx_cmdc, iobase);
+	clks[CLKID_EARCTX_CMDC] = REGISTER_CLK_COM(earctx_cmdc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCTX_CMDC]));
+
+	IOMAP_COM_CLK(earctx_dmac, iobase);
+	clks[CLKID_EARCTX_DMAC] = REGISTER_CLK_COM(earctx_dmac);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCTX_DMAC]));
+
+	IOMAP_COM_CLK(earcrx_cmdc, iobase);
+	clks[CLKID_EARCRX_CMDC] = REGISTER_CLK_COM(earcrx_cmdc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCRX_CMDC]));
+
+	IOMAP_COM_CLK(earcrx_dmac, iobase);
+	clks[CLKID_EARCRX_DMAC] = REGISTER_CLK_COM(earcrx_dmac);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCRX_DMAC]));
+
+	IOMAP_COM_CLK(mclk_pad0, iobase);
+	clks[CLKID_AUDIO_MCLK_PAD0] =
+			REGISTER_CLK_COM_PARENTS(mclk_pad0, mclk_pad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_PAD0]));
+
+	IOMAP_COM_CLK(mclk_pad1, iobase);
+	clks[CLKID_AUDIO_MCLK_PAD1] =
+			REGISTER_CLK_COM_PARENTS(mclk_pad1, mclk_pad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_PAD1]));
+
+	return 0;
+}
+
+struct audio_clk_init sm1_audio_clks_init = {
+	.clk_num   = NUM_AUDIO_CLKS,
+	.clk_gates = sm1_clk_gates_init,
+	.clks      = sm1_clks_init,
+};
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif.c b/evl/sound/evl-amlogic/spdif.c
--- a/drivers/evl/sound/evl-amlogic/spdif.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif.c	2022-01-10 16:03:22.738879541 +0300
@@ -0,0 +1,1477 @@
+/*
+ * sound/soc/amlogic/auge/spdif.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define  DEBUG
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+// #include <linux/extcon.h>
+// #include <sound/core.h>
+// #include <sound/pcm.h>
+// #include <sound/initval.h>
+// #include <sound/control.h>
+// #include <sound/soc.h>
+// #include <sound/pcm_params.h>
+#include <linux/pinctrl/pinctrl.h>
+
+#include "ddr_mngr.h"
+#include "spdif_hw.h"
+#include "spdif_match_table.c"
+// #include "resample.h"
+// #include "resample_hw.h"
+#include "spdif.h"
+#include "evl-audio.h"
+#define DRV_NAME "snd_spdif"
+
+/* Debug by PTM when bringup */
+/*#define __PTM_SPDIF_CLK__*/
+
+/* for debug */
+/*#define __SPDIFIN_INSERT_CHNUM__*/
+enum samplerate_index {
+	RATE_OFF,
+	RATE_32K,
+	RATE_44K,
+	RATE_48K,
+	RATE_88K,
+	RATE_96K,
+	RATE_176K,
+	RATE_192K,
+};
+/*#define __SPDIFIN_AUDIO_TYPE_HW__*/
+struct aml_spdif *spdif_priv[2];
+
+static int aml_dai_set_spdif_sysclk(struct aml_spdif *p_spdif,
+				int clk_id, unsigned int freq, int dir);
+
+enum SPDIF_SRC {
+	SPDIFIN_PAD = 0,
+	SPDIFOUT,
+	NOAP,
+	HDMIRX
+};
+
+struct aml_spdif {
+	struct pinctrl *pin_ctl;
+	struct aml_audio_controller *actrl;
+	struct device *dev;
+	struct clk *gate_spdifin;
+	struct clk *gate_spdifout;
+	struct clk *sysclk;
+	struct clk *fixed_clk;
+	struct clk *clk_spdifin;
+	struct clk *clk_spdifout;
+	unsigned int sysclk_freq;
+	/* bclk src selection */
+	int irq_spdifin;
+	struct toddr *tddr;
+	struct frddr *fddr;
+
+	/* external connect */
+	struct extcon_dev *edev;
+
+	unsigned int id;
+	struct spdif_chipinfo *chipinfo;
+	unsigned int clk_cont; /* CONTINUOUS CLOCK */
+
+	/*
+	 * resample a/b do asrc for spdif in
+	 */
+	enum resample_idx asrc_id;
+	/* spdif in do asrc for pcm,
+	 * if raw data, disable it automatically.
+	 */
+	enum samplerate_index auto_asrc;
+
+	/* check spdifin channel status for pcm or nonpcm */
+	struct timer_list timer;
+	struct work_struct work;
+
+	/* spdif in reset for l/r channel swap when plug/unplug */
+	struct timer_list reset_timer;
+	/* timer is used */
+	int is_reset_timer_used;
+	/* reset timer counter */
+	int timer_counter;
+	/* 0: default, 1: spdif in firstly enable, 2: spdif in could be reset */
+	int sample_rate_detect_start;
+	/* is spdif in reset */
+	int is_reset;
+	int last_sample_rate_mode;
+
+	/* last value for pc, pd */
+	int pc_last;
+	int pd_last;
+
+	/* mixer control vals */
+	bool mute;
+	enum SPDIF_SRC spdifin_src;
+	int clk_tuning_enable;
+	bool on;
+};
+
+
+
+// static const unsigned int spdifin_extcon[] = {
+// 	EXTCON_SPDIFIN_SAMPLERATE,
+// 	EXTCON_SPDIFIN_AUDIOTYPE,
+// 	EXTCON_NONE,
+// };
+
+/* current sample mode and its sample rate */
+static const char *const spdifin_samplerate[] = {
+	"N/A",
+	"32000",
+	"44100",
+	"48000",
+	"88200",
+	"96000",
+	"176400",
+	"192000"
+};
+
+// static int spdifin_samplerate_get_enum(struct snd_kcontrol *kcontrol,
+// 			struct snd_ctl_elem_value *ucontrol)
+// {
+// 	int val = spdifin_get_sample_rate();
+
+// 	if (val == 0x7)
+// 		val = 0;
+// 	else
+// 		val += 1;
+
+// 	ucontrol->value.integer.value[0] = val;
+
+// 	return 0;
+// }
+
+// static const struct soc_enum spdifin_sample_rate_enum[] = {
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdifin_samplerate),
+// 			spdifin_samplerate),
+// };
+
+/* spdif in audio format detect: LPCM or NONE-LPCM */
+struct sppdif_audio_info {
+	unsigned char aud_type;
+	/*IEC61937 package presamble Pc value*/
+	short pc;
+	char *aud_type_str;
+};
+
+static const char *const spdif_audio_type_texts[] = {
+	"LPCM",
+	"AC3",
+	"EAC3",
+	"DTS",
+	"DTS-HD",
+	"TRUEHD",
+	"PAUSE"
+};
+
+static const struct sppdif_audio_info type_texts[] = {
+	{0, 0, "LPCM"},
+	{1, 0x1, "AC3"},
+	{2, 0x15, "EAC3"},
+	{3, 0xb, "DTS-I"},
+	{3, 0x0c, "DTS-II"},
+	{3, 0x0d, "DTS-III"},
+	{3, 0x11, "DTS-IV"},
+	{4, 0, "DTS-HD"},
+	{5, 0x16, "TRUEHD"},
+	{6, 0x103, "PAUSE"},
+	{6, 0x003, "PAUSE"},
+	{6, 0x100, "PAUSE"},
+};
+
+// static const struct soc_enum spdif_audio_type_enum =
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdif_audio_type_texts),
+// 			spdif_audio_type_texts);
+
+// static int spdifin_check_audio_type(void)
+// {
+// 	int total_num = sizeof(type_texts)/sizeof(struct sppdif_audio_info);
+// 	int pc = spdifin_get_audio_type();
+// 	int audio_type = 0;
+// 	int i;
+
+// 	for (i = 0; i < total_num; i++) {
+// 		if (pc == type_texts[i].pc) {
+// 			audio_type = type_texts[i].aud_type;
+// 			break;
+// 		}
+// 	}
+
+// 	/*pr_debug("%s audio type:%d\n", __func__, audio_type);*/
+
+// 	return audio_type;
+// }
+
+
+// static int aml_audio_set_spdif_mute(struct snd_kcontrol *kcontrol,
+// 					struct snd_ctl_elem_value *ucontrol)
+// {
+// 	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(dai);
+// 	struct pinctrl_state *state = NULL;
+// 	bool mute = !!ucontrol->value.integer.value[0];
+
+// 	if (IS_ERR_OR_NULL(p_spdif->pin_ctl)) {
+// 		pr_err("%s(), no pinctrl", __func__);
+// 		return 0;
+// 	}
+// 	if (mute) {
+// 		state = pinctrl_lookup_state
+// 			(p_spdif->pin_ctl, "spdif_pins_mute");
+
+// 		if (!IS_ERR_OR_NULL(state))
+// 			pinctrl_select_state(p_spdif->pin_ctl, state);
+// 	} else {
+// 		state = pinctrl_lookup_state
+// 			(p_spdif->pin_ctl, "spdif_pins");
+
+// 		if (!IS_ERR_OR_NULL(state))
+// 			pinctrl_select_state(p_spdif->pin_ctl, state);
+// 	}
+
+// 	p_spdif->mute = mute;
+
+// 	return 0;
+// }
+
+// static int aml_audio_get_spdif_mute(struct snd_kcontrol *kcontrol,
+// 					struct snd_ctl_elem_value *ucontrol)
+// {
+// 	struct snd_soc_dai *dai = snd_kcontrol_chip(kcontrol);
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(dai);
+
+// 	ucontrol->value.integer.value[0] = p_spdif->mute;
+
+// 	return 0;
+// }
+// static const char *const spdifin_src_texts[] = {
+// 	"spdifin pad", "spdifout", "N/A", "HDMIRX"
+// };
+
+// const struct soc_enum spdifin_src_enum =
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(spdifin_src_texts),
+// 	spdifin_src_texts);
+
+
+
+
+int spdif_set_audio_clk(int id,
+		struct clk *clk_src, int rate, int same)
+{
+	int ret = 0;
+
+	if (spdif_priv[id]->on && same) {
+		pr_debug("spdif priority");
+		return 0;
+	}
+
+	if (rate == 0)
+		return 0;
+
+	clk_set_parent(spdif_priv[id]->clk_spdifout, clk_src);
+	clk_set_rate(spdif_priv[id]->clk_spdifout, rate);
+	ret = clk_prepare_enable(spdif_priv[id]->clk_spdifout);
+	if (ret) {
+		pr_err("%s Can't enable clk_spdifout clock, ret %d\n",
+		__func__, ret);
+	}
+	return 0;
+}
+
+
+// static bool spdifin_check_audiotype_by_sw(struct aml_spdif *p_spdif)
+// {
+// 	if (p_spdif
+// 		&& p_spdif->chipinfo
+// 		&& p_spdif->chipinfo->irq_no_papb)
+// 		return true;
+
+// 	return false;
+// }
+
+// static void spdifin_audio_type_start_timer(
+// 	struct aml_spdif *p_spdif)
+// {
+// 	p_spdif->timer.expires = jiffies + 1;
+// 	add_timer(&p_spdif->timer);
+// }
+
+// static void spdifin_audio_type_stop_timer(
+// 	struct aml_spdif *p_spdif)
+// {
+// 	del_timer(&p_spdif->timer);
+// }
+
+// static void spdifin_audio_type_timer_func(unsigned long data)
+// {
+// 	struct aml_spdif *p_spdif = (struct aml_spdif *)data;
+// 	unsigned long delay = msecs_to_jiffies(1);
+
+// 	schedule_work(&p_spdif->work);
+// 	mod_timer(&p_spdif->timer, jiffies + delay);
+// }
+
+// static void spdifin_audio_type_work_func(struct work_struct *work)
+// {
+// 	struct aml_spdif *p_spdif = container_of(
+// 		work, struct aml_spdif, work);
+
+// 	int val = spdifin_get_ch_status0to31();
+
+// 	/* auto resample ? */
+// 	if (!p_spdif->auto_asrc)
+// 		return;
+
+// #ifdef __PTM_SPDIF_CLK__
+// 	return;
+// #endif
+
+// 	if (val & 0x2)
+// 		/* nonpcm, resample disable */
+// 		resample_set(p_spdif->asrc_id, RATE_OFF, false);
+// 	else
+// 		/* pcm, resample which rate ? */
+// 		resample_set(p_spdif->asrc_id, p_spdif->auto_asrc, false);
+// }
+
+// static void spdifin_audio_type_detect_init(struct aml_spdif *p_spdif)
+// {
+// 	init_timer(&p_spdif->timer);
+// 	p_spdif->timer.function = spdifin_audio_type_timer_func;
+// 	p_spdif->timer.data = (unsigned long)p_spdif;
+
+// 	INIT_WORK(&p_spdif->work, spdifin_audio_type_work_func);
+// }
+
+// static void spdifin_audio_type_detect_deinit(struct aml_spdif *p_spdif)
+// {
+// 	cancel_work_sync(&p_spdif->work);
+// }
+
+// static void spdifin_fast_reset(struct aml_spdif *p_spdif)
+// {
+// 	struct aml_audio_controller *actrl = p_spdif->actrl;
+// 	unsigned int tddr_val = aml_toddr_read(p_spdif->tddr);
+// 	unsigned int spdifin_ctrl_val = aml_spdif_ctrl_read(actrl,
+// 					SNDRV_PCM_STREAM_CAPTURE, p_spdif->id);
+// 	unsigned int asr_ctrl_val = 0;
+
+// 	pr_info("%s\n", __func__);
+
+// 	/* toddr disable */
+// 	tddr_val &= ~(1 << 31);
+// 	aml_toddr_write(p_spdif->tddr, tddr_val);
+
+// 	/* resample disable and reset */
+// 	if (p_spdif->auto_asrc) {
+// 		asr_ctrl_val = resample_ctrl_read(p_spdif->asrc_id);
+// 		asr_ctrl_val &= ~(1 << 28);
+// 		resample_ctrl_write(p_spdif->asrc_id, asr_ctrl_val);
+// 		asr_ctrl_val |= (1 << 31);
+// 		resample_ctrl_write(p_spdif->asrc_id, asr_ctrl_val);
+// 		asr_ctrl_val &= ~(1 << 31);
+// 		resample_ctrl_write(p_spdif->asrc_id, asr_ctrl_val);
+// 	}
+
+// 	/* spdif in disable and reset */
+// 	spdifin_ctrl_val &= ~(0x1 << 31);
+// 	aml_spdif_ctrl_write(actrl,
+// 		SNDRV_PCM_STREAM_CAPTURE, p_spdif->id, spdifin_ctrl_val);
+// 	spdifin_ctrl_val &= ~(0x3 << 28);
+// 	aml_spdif_ctrl_write(actrl,
+// 		SNDRV_PCM_STREAM_CAPTURE, p_spdif->id, spdifin_ctrl_val);
+// 	spdifin_ctrl_val |= (0x1 << 29);
+// 	aml_spdif_ctrl_write(actrl,
+// 		SNDRV_PCM_STREAM_CAPTURE, p_spdif->id, spdifin_ctrl_val);
+// 	spdifin_ctrl_val |= (0x1 << 28);
+// 	aml_spdif_ctrl_write(actrl,
+// 		SNDRV_PCM_STREAM_CAPTURE, p_spdif->id, spdifin_ctrl_val);
+
+// 	/* toddr enable */
+// 	tddr_val |= (1 << 31);
+// 	aml_toddr_write(p_spdif->tddr, tddr_val);
+
+// 	/* resample enable */
+// 	if (p_spdif->auto_asrc) {
+// 		asr_ctrl_val |= (1 << 28);
+// 		resample_ctrl_write(p_spdif->asrc_id, asr_ctrl_val);
+// 	}
+
+// 	/* spdif in enable */
+// 	spdifin_ctrl_val |= (0x1 << 31);
+// 	aml_spdif_ctrl_write(actrl,
+// 		SNDRV_PCM_STREAM_CAPTURE, p_spdif->id, spdifin_ctrl_val);
+// }
+
+// #define MAX_TIMER_COUNTER 30
+// #define FIRST_DELAY       20
+
+// static void spdifin_reset_timer(unsigned long data)
+// {
+// 	struct aml_spdif *p_spdif = (struct aml_spdif *)data;
+// 	unsigned long delay = msecs_to_jiffies(1);
+// 	int intrpt_status = aml_spdifin_status_check(p_spdif->actrl);
+// 	int mode = (intrpt_status >> 28) & 0x7;
+
+// 	if ((p_spdif->last_sample_rate_mode != mode) ||
+// 			(p_spdif->last_sample_rate_mode == 0x7)) {
+
+// 		p_spdif->last_sample_rate_mode = mode;
+// 		p_spdif->timer_counter = 0;
+// 		mod_timer(&p_spdif->reset_timer, jiffies + delay);
+// 	} else if ((p_spdif->last_sample_rate_mode == mode) &&
+// 				(mode != 0x7)) {
+
+// 		if (p_spdif->timer_counter > MAX_TIMER_COUNTER) {
+// 			p_spdif->timer_counter = 0;
+
+// 			if (p_spdif->is_reset ||
+// 				(p_spdif->sample_rate_detect_start == 1)) {
+// 				p_spdif->is_reset = 0;
+// 				p_spdif->sample_rate_detect_start = 2;
+// 				if (p_spdif->is_reset_timer_used) {
+// 					p_spdif->is_reset_timer_used = 0;
+// 					del_timer(&p_spdif->reset_timer);
+// 				}
+// 				pr_debug("%s,last sample mode:0x%x, stop timer\n",
+// 					__func__,
+// 					p_spdif->last_sample_rate_mode);
+// 			} else {
+// 				p_spdif->last_sample_rate_mode = 0;
+
+// 				p_spdif->is_reset = 1;
+// 				spdifin_fast_reset(p_spdif);
+
+// 				delay = msecs_to_jiffies(FIRST_DELAY);
+// 				mod_timer(&p_spdif->reset_timer,
+// 					jiffies + delay);
+// 			}
+// 		} else {
+// 			p_spdif->timer_counter++;
+// 			mod_timer(&p_spdif->reset_timer, jiffies + delay);
+// 		}
+// 	}
+// }
+
+// static void spdifin_status_event(struct aml_spdif *p_spdif)
+// {
+// 	int intrpt_status;
+
+// 	if (!p_spdif)
+// 		return;
+
+// 	/* interrupt status, check and clear by reg_clk_interrupt */
+// 	intrpt_status = aml_spdifin_status_check(p_spdif->actrl);
+
+// 	/* clear irq bits immediametely */
+// 	if (p_spdif->chipinfo)
+// 		aml_spdifin_clr_irq(p_spdif->actrl,
+// 			p_spdif->chipinfo->clr_irq_all_bits,
+// 			intrpt_status & 0xff);
+
+// 	if (intrpt_status & 0x1)
+// 		pr_info("over flow!!\n");
+// 	if (intrpt_status & 0x2)
+// 		pr_info("parity error\n");
+
+// 	if (intrpt_status & 0x4) {
+// 		int mode = (intrpt_status >> 28) & 0x7;
+
+// 		pr_debug("sample rate, mode:%x\n", mode);
+// 		if (/*(mode == 0x7) && */(!p_spdif->sample_rate_detect_start)) {
+// 			p_spdif->sample_rate_detect_start = 1;
+// 			pr_debug("spdif in sample rate started\n");
+// 		}
+
+// 		if (p_spdif->sample_rate_detect_start) {
+
+// 			p_spdif->last_sample_rate_mode = mode;
+
+// 			if (!p_spdif->is_reset_timer_used) {
+// 				unsigned long delay = msecs_to_jiffies(1);
+
+// 				if (p_spdif->sample_rate_detect_start == 1)
+// 					delay = msecs_to_jiffies(FIRST_DELAY);
+
+// 				setup_timer(&p_spdif->reset_timer,
+// 						spdifin_reset_timer,
+// 						(unsigned long)p_spdif);
+// 				mod_timer(&p_spdif->reset_timer,
+// 					jiffies + delay);
+// 			}
+// 			p_spdif->is_reset_timer_used++;
+// 			p_spdif->timer_counter = 0;
+// 		}
+
+// 		if ((mode == 0x7) ||
+// 			(((intrpt_status >> 18) & 0x3ff) == 0x3ff)) {
+// 			pr_info("Default value, not detect sample rate\n");
+// 			// extcon_set_state(p_spdif->edev,
+// 			// 	EXTCON_SPDIFIN_SAMPLERATE, 0);
+// 		} else if (mode >= 0) {
+// 			if (p_spdif->last_sample_rate_mode != mode) {
+// 				pr_info("Event: EXTCON_SPDIFIN_SAMPLERATE, new sample rate:%s\n",
+// 					spdifin_samplerate[mode + 1]);
+
+// #ifdef __SPDIFIN_AUDIO_TYPE_HW__
+// 				/* resample enable, by hw */
+// 				if (!spdifin_check_audiotype_by_sw(p_spdif))
+// 					resample_set(p_spdif->asrc_id,
+// 						p_spdif->auto_asrc, false);
+// #endif
+// 				// extcon_set_state(p_spdif->edev,
+// 				// 	EXTCON_SPDIFIN_SAMPLERATE, 1);
+// 			}
+// 		}
+// 		p_spdif->last_sample_rate_mode = mode;
+
+// 	}
+
+// 	if (p_spdif->chipinfo
+// 		&& p_spdif->chipinfo->pcpd_separated) {
+// 		if (intrpt_status & 0x8) {
+// 			pr_info("Pc changed, try to read spdifin audio type\n");
+
+// 			extcon_set_state(p_spdif->edev,
+// 				EXTCON_SPDIFIN_AUDIOTYPE, 1);
+
+// #ifdef __PTM_SPDIF_CLK__
+// #ifdef __SPDIFIN_AUDIO_TYPE_HW__
+// 			/* resample disable, by hw */
+// 			if (!spdifin_check_audiotype_by_sw(p_spdif))
+// 				resample_set(p_spdif->asrc_id, RATE_OFF, false);
+// #endif
+// #endif
+// 		}
+// 		if (intrpt_status & 0x10)
+// 			pr_info("Pd changed\n");
+// 	} else {
+// 		if (intrpt_status & 0x8)
+// 			pr_debug("CH status changed\n");
+
+// 		if (intrpt_status & 0x10) {
+// 			int val = spdifin_get_ch_status0to31();
+// 			int pc_v = (val >> 16) & 0xffff;
+// 			int pd_v = val & 0xffff;
+
+// 			if (pc_v != p_spdif->pc_last) {
+// 				p_spdif->pc_last = pc_v;
+// 				pr_info("Pc changed\n");
+// 			}
+// 			if (pd_v != p_spdif->pd_last) {
+// 				p_spdif->pd_last = pd_v;
+// 				pr_info("Pd changed\n");
+// 			}
+// 		}
+// 	}
+
+// 	if (intrpt_status & 0x20) {
+// 		pr_info("nonpcm to pcm\n");
+// 		extcon_set_state(p_spdif->edev,
+// 			EXTCON_SPDIFIN_AUDIOTYPE, 0);
+
+// #ifdef __SPDIFIN_AUDIO_TYPE_HW__
+// 		/* resample to 48k, by hw */
+// 		if (!spdifin_check_audiotype_by_sw(p_spdif))
+// 			resample_set(p_spdif->asrc_id,
+// 				p_spdif->auto_asrc, false);
+// #endif
+// 	}
+// 	if (intrpt_status & 0x40)
+// 		pr_info("valid changed\n");
+// }
+
+// static irqreturn_t aml_spdif_ddr_isr(int irq, void *devid)
+// {
+// 	struct snd_pcm_substream *substream =
+// 		(struct snd_pcm_substream *)devid;
+
+// 	if (!snd_pcm_running(substream))
+// 		return IRQ_HANDLED;
+
+// 	snd_pcm_period_elapsed(substream);
+
+// 	return IRQ_HANDLED;
+// }
+
+// /* detect PCM/RAW and sample changes by the source */
+// static irqreturn_t aml_spdifin_status_isr(int irq, void *devid)
+// {
+// 	struct aml_spdif *p_spdif = (struct aml_spdif *)devid;
+
+// 	spdifin_status_event(p_spdif);
+
+// 	return IRQ_HANDLED;
+// }
+
+// static int aml_spdif_open(struct snd_pcm_substream *substream)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+// 	struct device *dev = rtd->platform->dev;
+// 	struct aml_spdif *p_spdif;
+// 	int ret = 0;
+
+// 	pr_info("%s\n", __func__);
+
+// 	p_spdif = (struct aml_spdif *)dev_get_drvdata(dev);
+
+// 	snd_soc_set_runtime_hwparams(substream, &aml_spdif_hardware);
+
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 		p_spdif->on = true;
+// 		p_spdif->fddr = aml_audio_register_frddr(dev,
+// 			p_spdif->actrl,
+// 			aml_spdif_ddr_isr, substream, false);
+// 		if (p_spdif->fddr == NULL) {
+// 			dev_err(dev, "failed to claim from ddr\n");
+// 			return -ENXIO;
+// 		}
+// 	} else {
+// 		p_spdif->tddr = aml_audio_register_toddr(dev,
+// 			p_spdif->actrl,
+// 			aml_spdif_ddr_isr, substream);
+// 		if (p_spdif->tddr == NULL) {
+// 			dev_err(dev, "failed to claim to ddr\n");
+// 			return -ENXIO;
+// 		}
+
+// 		ret = request_irq(p_spdif->irq_spdifin,
+// 				aml_spdifin_status_isr, 0, "irq_spdifin",
+// 				p_spdif);
+// 		if (ret) {
+// 			dev_err(p_spdif->dev, "failed to claim irq_spdifin %u\n",
+// 						p_spdif->irq_spdifin);
+// 			return ret;
+// 		}
+// 		if (spdifin_check_audiotype_by_sw(p_spdif))
+// 			spdifin_audio_type_detect_init(p_spdif);
+
+// 		p_spdif->sample_rate_detect_start = 0;
+// 	}
+
+// 	runtime->private_data = p_spdif;
+
+// 	return 0;
+// }
+
+
+
+// static int aml_spdif_trigger(struct snd_pcm_substream *substream, int cmd)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	struct aml_spdif *p_spdif = runtime->private_data;
+// 	int ret = 0;
+
+// 	switch (cmd) {
+// 	case SNDRV_PCM_TRIGGER_START:
+// 	case SNDRV_PCM_TRIGGER_RESUME:
+// 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+// 		if ((spdifin_check_audiotype_by_sw(p_spdif))
+// 			&& (substream->stream == SNDRV_PCM_STREAM_CAPTURE))
+// 			spdifin_audio_type_start_timer(p_spdif);
+// 		break;
+// 	case SNDRV_PCM_TRIGGER_SUSPEND:
+// 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+// 	case SNDRV_PCM_TRIGGER_STOP:
+// 		if ((spdifin_check_audiotype_by_sw(p_spdif))
+// 			&& (substream->stream == SNDRV_PCM_STREAM_CAPTURE))
+// 			spdifin_audio_type_stop_timer(p_spdif);
+// 		break;
+// 	default:
+// 		ret = -EINVAL;
+// 	}
+
+// 	return ret;
+// }
+
+// static int aml_spdif_prepare(struct snd_pcm_substream *substream)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	struct aml_spdif *p_spdif = runtime->private_data;
+// 	unsigned int start_addr, end_addr, int_addr;
+
+// 	start_addr = runtime->dma_addr;
+// 	end_addr = start_addr + runtime->dma_bytes - 8;
+// 	int_addr = frames_to_bytes(runtime, runtime->period_size) / 8;
+
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 		struct frddr *fr = p_spdif->fddr;
+
+// 		aml_frddr_set_buf(fr, start_addr, end_addr);
+// 		aml_frddr_set_intrpt(fr, int_addr);
+// 	} else {
+// 		struct toddr *to = p_spdif->tddr;
+
+// 		aml_toddr_set_buf(to, start_addr, end_addr);
+// 		aml_toddr_set_intrpt(to, int_addr);
+// 	}
+
+// 	return 0;
+// }
+
+// static snd_pcm_uframes_t aml_spdif_pointer(struct snd_pcm_substream *substream)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	struct aml_spdif *p_spdif = runtime->private_data;
+// 	unsigned int addr, start_addr;
+// 	snd_pcm_uframes_t frames;
+
+// 	start_addr = runtime->dma_addr;
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+// 		addr = aml_frddr_get_position(p_spdif->fddr);
+// 	else
+// 		addr = aml_toddr_get_position(p_spdif->tddr);
+
+// 	frames = bytes_to_frames(runtime, addr - start_addr);
+// 	if (frames > runtime->buffer_size)
+// 		frames = 0;
+
+// 	return frames;
+// }
+
+// int aml_spdif_silence(struct snd_pcm_substream *substream, int channel,
+// 		    snd_pcm_uframes_t pos, snd_pcm_uframes_t count)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	char *ppos;
+// 	int n;
+
+// 	n = frames_to_bytes(runtime, count);
+// 	ppos = runtime->dma_area + frames_to_bytes(runtime, pos);
+// 	memset(ppos, 0, n);
+
+// 	return 0;
+// }
+
+// static int aml_spdif_mmap(struct snd_pcm_substream *substream,
+// 			struct vm_area_struct *vma)
+// {
+// 	return snd_pcm_lib_default_mmap(substream, vma);
+// }
+
+// static struct snd_pcm_ops aml_spdif_ops = {
+// 	.open      = aml_spdif_open,
+// 	.close     = aml_spdif_close,
+// 	.ioctl     = snd_pcm_lib_ioctl,
+// 	.hw_params = aml_spdif_hw_params,
+// 	.hw_free   = aml_spdif_hw_free,
+// 	.prepare   = aml_spdif_prepare,
+// 	.trigger   = aml_spdif_trigger,
+// 	.pointer   = aml_spdif_pointer,
+// 	.silence   = aml_spdif_silence,
+// 	.mmap      = aml_spdif_mmap,
+// };
+
+#define PREALLOC_BUFFER		(256 * 1024)
+#define PREALLOC_BUFFER_MAX	(256 * 1024)
+// static int aml_spdif_new(struct snd_soc_pcm_runtime *rtd)
+// {
+// 	struct device *dev = rtd->platform->dev;
+// 	struct aml_spdif *p_spdif;
+
+// 	p_spdif = (struct aml_spdif *)dev_get_drvdata(dev);
+
+// 	pr_debug("%s spdif_%s, clk continuous:%d\n",
+// 		__func__,
+// 		(p_spdif->id == 0) ? "a":"b",
+// 		p_spdif->clk_cont);
+
+// 	/* keep frddr when probe, after spdif_frddr_init done
+// 	 * frddr can be released, and spdif outputs zero data
+// 	 * without frddr used.
+// 	 */
+// 	if (p_spdif->clk_cont)
+// 		spdifout_play_with_zerodata_free(p_spdif->id);
+
+// 	return snd_pcm_lib_preallocate_pages_for_all(
+// 			rtd->pcm, SNDRV_DMA_TYPE_DEV,
+// 			rtd->card->snd_card->dev,
+// 			PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+// }
+
+// struct snd_soc_platform_driver aml_spdif_platform = {
+// 	.ops = &aml_spdif_ops,
+// 	.pcm_new = aml_spdif_new,
+// };
+
+// static int aml_dai_spdif_probe(struct snd_soc_dai *cpu_dai)
+// {
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+// 	int ret = 0;
+
+// 	pr_info("%s\n", __func__);
+
+// 	// if (p_spdif->id == SPDIF_A) {
+// 	// 	ret = snd_soc_add_dai_controls(cpu_dai, snd_spdif_controls,
+// 	// 				ARRAY_SIZE(snd_spdif_controls));
+// 	// 	if (ret < 0)
+// 	// 		pr_err("%s, failed add snd spdif controls\n", __func__);
+// 	// }
+
+// 	// if (p_spdif->clk_tuning_enable == 1) {
+// 	// 	ret = snd_soc_add_dai_controls(cpu_dai,
+// 	// 			snd_spdif_clk_controls,
+// 	// 			ARRAY_SIZE(snd_spdif_clk_controls));
+// 	// 	if (ret < 0)
+// 	// 		pr_err("%s, failed add snd spdif clk controls\n",
+// 	// 			__func__);
+// 	// }
+
+// 	return 0;
+// }
+
+// static int aml_dai_spdif_remove(struct snd_soc_dai *cpu_dai)
+// {
+// 	pr_info("%s\n", __func__);
+
+// 	return 0;
+// }
+
+// static int aml_dai_spdif_startup(
+// 	struct snd_pcm_substream *substream,
+// 	struct snd_soc_dai *cpu_dai)
+// {
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+// 	int ret;
+
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+// 		if (0/*p_spdif->clk_cont*/) {
+// 			pr_info("spdif_%s keep clk continuous\n",
+// 				(p_spdif->id == 0) ? "a":"b");
+// 			return 0;
+// 		}
+// 		/* enable clock gate */
+// 		ret = clk_prepare_enable(p_spdif->gate_spdifout);
+
+// 		/* clock parent */
+// 		ret = clk_set_parent(p_spdif->clk_spdifout, p_spdif->sysclk);
+// 		if (ret) {
+// 			pr_err("Can't set clk_spdifout parent clock\n");
+// 			ret = PTR_ERR(p_spdif->clk_spdifout);
+// 			goto err;
+// 		}
+
+// 		/* enable clock */
+// 		ret = clk_prepare_enable(p_spdif->sysclk);
+// 		if (ret) {
+// 			pr_err("Can't enable pcm sysclk clock: %d\n", ret);
+// 			goto err;
+// 		}
+// 		ret = clk_prepare_enable(p_spdif->clk_spdifout);
+// 		if (ret) {
+// 			pr_err("Can't enable pcm clk_spdifout clock: %d\n",
+// 				ret);
+// 			goto err;
+// 		}
+// 	} else {
+// 		/* enable clock gate */
+// 		ret = clk_prepare_enable(p_spdif->gate_spdifin);
+
+// 		/* clock parent */
+// 		ret = clk_set_parent(p_spdif->clk_spdifin, p_spdif->fixed_clk);
+// 		if (ret) {
+// 			pr_err("Can't set clk_spdifin parent clock\n");
+// 			ret = PTR_ERR(p_spdif->clk_spdifin);
+// 			goto err;
+// 		}
+
+// 		/* enable clock */
+// 		ret = clk_prepare_enable(p_spdif->fixed_clk);
+// 		if (ret) {
+// 			pr_err("Can't enable pcm fixed_clk clock: %d\n", ret);
+// 			goto err;
+// 		}
+// 		ret = clk_prepare_enable(p_spdif->clk_spdifin);
+// 		if (ret) {
+// 			pr_err("Can't enable pcm clk_spdifin clock: %d\n", ret);
+// 			goto err;
+// 		}
+
+// #ifdef __SPDIFIN_AUDIO_TYPE_HW__
+// 		/* resample to 48k in default, by hw */
+// 		if (!spdifin_check_audiotype_by_sw(p_spdif))
+// 			resample_set(p_spdif->asrc_id,
+// 				p_spdif->auto_asrc, false);
+// #endif
+// 	}
+
+// 	return 0;
+// err:
+// 	pr_err("failed enable clock\n");
+// 	return -EINVAL;
+// }
+
+// static void aml_dai_spdif_shutdown(
+// 	struct snd_pcm_substream *substream,
+// 	struct snd_soc_dai *cpu_dai)
+// {
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+// 	/* disable clock and gate */
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 		if (p_spdif->clk_cont) {
+// 			pr_info("spdif_%s keep clk continuous\n",
+// 				(p_spdif->id == 0) ? "a":"b");
+// 			return;
+// 		}
+
+// 		clk_disable_unprepare(p_spdif->clk_spdifout);
+// 		clk_disable_unprepare(p_spdif->sysclk);
+// 		clk_disable_unprepare(p_spdif->gate_spdifout);
+// 	} else {
+// #ifdef __SPDIFIN_AUDIO_TYPE_HW__
+// 		/* resample disabled, by hw */
+// 		if (!spdifin_check_audiotype_by_sw(p_spdif))
+// 			resample_set(p_spdif->asrc_id, RATE_OFF, false);
+// #endif
+// 		clk_disable_unprepare(p_spdif->clk_spdifin);
+// 		clk_disable_unprepare(p_spdif->fixed_clk);
+// 		clk_disable_unprepare(p_spdif->gate_spdifin);
+// 	}
+// }
+
+
+// static int aml_dai_spdif_prepare(
+// 	struct snd_pcm_substream *substream,
+// 	struct snd_soc_dai *cpu_dai)
+// {
+// 	struct snd_pcm_runtime *runtime = substream->runtime;
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+// 	unsigned int bit_depth = 0;
+// 	unsigned int fifo_id = 0;
+
+// 	bit_depth = snd_pcm_format_width(runtime->format);
+
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 		struct frddr *fr = p_spdif->fddr;
+// 		enum frddr_dest dst;
+// 		struct iec958_chsts chsts;
+
+// 		switch (p_spdif->id) {
+// 		case 0:
+// 			dst = SPDIFOUT_A;
+// 			break;
+// 		case 1:
+// 			dst = SPDIFOUT_B;
+// 			break;
+// 		default:
+// 			dev_err(p_spdif->dev, "invalid id: %d\n", p_spdif->id);
+// 			return -EINVAL;
+// 		}
+
+// 		fifo_id = aml_frddr_get_fifo_id(fr);
+// 		aml_frddr_set_format(fr,
+// 			runtime->channels,
+// 			bit_depth - 1,
+// 			spdifout_get_frddr_type(bit_depth));
+// 		aml_frddr_select_dst(fr, dst);
+// 		aml_frddr_set_fifos(fr, 0x40, 0x20);
+
+// 		/* check channel status info, and set them */
+// 		spdif_get_channel_status_info(&chsts, runtime->rate);
+// 		spdif_set_channel_status_info(&chsts, p_spdif->id);
+
+// 		/* TOHDMITX_CTRL0
+// 		 * Both spdif_a/spdif_b would notify to hdmitx
+// 		 */
+// 		spdifout_to_hdmitx_ctrl(p_spdif->id);
+// 		/* notify to hdmitx */
+// 		spdif_notify_to_hdmitx(substream);
+
+// 	} else {
+// 		struct toddr *to = p_spdif->tddr;
+// 		struct toddr_fmt fmt;
+// 		unsigned int msb, lsb, toddr_type;
+
+// 		switch (bit_depth) {
+// 		case 8:
+// 		case 16:
+// 			toddr_type = 0;
+// 			break;
+// 		case 24:
+// 			toddr_type = 4;
+// 			break;
+// 		case 32:
+// 			toddr_type = 3;
+// 			break;
+// 		default:
+// 			dev_err(p_spdif->dev,
+// 				"runtime format invalid bit_depth: %d\n",
+// 				bit_depth);
+// 			return -EINVAL;
+// 		}
+
+// 		msb = 28 - 1;
+// 		if (bit_depth <= 24)
+// 			lsb = 28 - bit_depth;
+// 		else
+// 			lsb = 4;
+
+// 		// to ddr spdifin
+// 		fmt.type       = toddr_type;
+// 		fmt.msb        = msb;
+// 		fmt.lsb        = lsb;
+// 		fmt.endian     = 0;
+// 		fmt.bit_depth  = bit_depth;
+// 		fmt.ch_num     = runtime->channels;
+// 		fmt.rate       = runtime->rate;
+// 		aml_toddr_select_src(to, SPDIFIN);
+// 		aml_toddr_set_format(to, &fmt);
+// 		aml_toddr_set_fifos(to, 0x40);
+// #ifdef __SPDIFIN_INSERT_CHNUM__
+// 		aml_toddr_insert_chanum(to);
+// #endif
+// 	}
+
+// 	aml_spdif_fifo_ctrl(p_spdif->actrl, bit_depth,
+// 			substream->stream, p_spdif->id, fifo_id);
+
+// #ifdef __SPDIFIN_INSERT_CHNUM__
+// 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+// 		aml_spdifin_chnum_en(p_spdif->actrl,
+// 			p_spdif->id, true);
+// #endif
+
+// 	return 0;
+// }
+
+// static int aml_dai_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+// 			       struct snd_soc_dai *cpu_dai)
+// {
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+// 	switch (cmd) {
+// 	case SNDRV_PCM_TRIGGER_START:
+// 	case SNDRV_PCM_TRIGGER_RESUME:
+// 	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+// 		/* reset fifo */
+// 		aml_spdif_fifo_reset(p_spdif->actrl,
+// 			substream->stream,
+// 			p_spdif->id);
+
+// 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 			dev_info(substream->pcm->card->dev, "S/PDIF Playback enable\n");
+// 			aml_spdif_enable(p_spdif->actrl,
+// 			    substream->stream, p_spdif->id, true);
+// 			aml_frddr_enable(p_spdif->fddr, 1);
+// 			udelay(100);
+// 			aml_spdif_mute(p_spdif->actrl,
+// 				substream->stream, p_spdif->id, false);
+// 		} else {
+// 			dev_info(substream->pcm->card->dev, "S/PDIF Capture enable\n");
+// 			aml_toddr_enable(p_spdif->tddr, 1);
+// 			aml_spdif_enable(p_spdif->actrl,
+// 			    substream->stream, p_spdif->id, true);
+// 		}
+
+// 		break;
+// 	case SNDRV_PCM_TRIGGER_STOP:
+// 	case SNDRV_PCM_TRIGGER_SUSPEND:
+// 	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+// 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 			dev_info(substream->pcm->card->dev, "S/PDIF Playback disable\n");
+// 			/* continuous-clock, spdif out is not disable,
+// 			 * only mute, ensure spdif outputs zero data.
+// 			 */
+// 			if (p_spdif->clk_cont) {
+// 				aml_spdif_mute(p_spdif->actrl,
+// 					substream->stream, p_spdif->id, true);
+// 			} else {
+// 				aml_spdif_enable(p_spdif->actrl,
+// 					substream->stream, p_spdif->id, false);
+// 			}
+
+// 			if (p_spdif->chipinfo &&
+// 				p_spdif->chipinfo->async_fifo)
+// 				aml_frddr_check(p_spdif->fddr);
+// 			aml_frddr_enable(p_spdif->fddr, 0);
+// 		} else {
+// 			bool toddr_stopped = false;
+
+// 			aml_spdif_enable(p_spdif->actrl,
+// 					substream->stream, p_spdif->id, false);
+// 			dev_info(substream->pcm->card->dev, "S/PDIF Capture disable\n");
+
+// 			toddr_stopped = aml_toddr_burst_finished(p_spdif->tddr);
+// 			if (toddr_stopped)
+// 				aml_toddr_enable(p_spdif->tddr, false);
+// 			else
+// 				pr_err("%s(), toddr may be stuck\n", __func__);
+// 		}
+
+// 		break;
+// 	default:
+// 		return -EINVAL;
+// 	}
+
+// 	return 0;
+// }
+// static int aml_dai_spdif_hw_params(struct snd_pcm_substream *substream,
+// 				struct snd_pcm_hw_params *params,
+// 				struct snd_soc_dai *cpu_dai)
+// {
+// 	struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+// 	unsigned int rate = params_rate(params);
+// 	int ret = 0;
+
+// 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+// 		rate *= 128;
+
+// 		snd_soc_dai_set_sysclk(cpu_dai,
+// 				0, rate, SND_SOC_CLOCK_OUT);
+// 	} else {
+// 		clk_set_rate(p_spdif->clk_spdifin, 500000000);
+// 	}
+
+// 	return ret;
+// }
+
+// static int aml_dai_set_spdif_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+// {
+// 	pr_debug("%s , fmt %#x\n", __func__, fmt);
+
+// 	return 0;
+// }
+
+static void aml_set_spdifclk(struct aml_spdif *p_spdif)
+{
+	unsigned int mpll_freq = 0;
+
+	if (p_spdif->sysclk_freq) {
+		unsigned int mul = 4;
+		int ret;
+
+		if (spdif_is_4x_clk()) {
+			pr_debug("set 4x audio clk for 958\n");
+			p_spdif->sysclk_freq *= 4;
+		} else {
+			pr_debug("set normal 512 fs /4 fs\n");
+		}
+		mpll_freq = p_spdif->sysclk_freq * mul;
+
+#ifdef __PTM_SPDIF_CLK__
+		/* mpll_freq = p_spdif->sysclk_freq * 58; */ /* 48k */
+		mpll_freq = p_spdif->sysclk_freq * 58 / 2; /* 96k */
+#endif
+		clk_set_rate(p_spdif->sysclk, mpll_freq);
+		/*
+		clk_set_rate(p_spdif->clk_spdifout,
+			p_spdif->sysclk_freq);
+		*/
+		spdif_set_audio_clk(p_spdif->id,
+			p_spdif->sysclk,
+			p_spdif->sysclk_freq, 0);
+
+		ret = clk_prepare_enable(p_spdif->sysclk);
+		if (ret) {
+			pr_err("Can't enable pcm sysclk clock: %d\n", ret);
+			return;
+		}
+		ret = clk_prepare_enable(p_spdif->clk_spdifout);
+		if (ret) {
+			pr_err("Can't enable clk_spdifout clock: %d\n", ret);
+			return;
+		}
+		pr_debug("\t set spdifout clk:%d, mpll:%d\n",
+			p_spdif->sysclk_freq,
+			mpll_freq);
+		pr_debug("\t get spdifout clk:%lu, mpll:%lu\n",
+			clk_get_rate(p_spdif->clk_spdifout),
+			clk_get_rate(p_spdif->sysclk));
+	}
+}
+
+static int aml_dai_set_spdif_sysclk(struct aml_spdif *p_spdif,
+				int clk_id, unsigned int freq, int dir)
+{
+	if (clk_id == 0) {
+		// struct aml_spdif *p_spdif = snd_soc_dai_get_drvdata(cpu_dai);
+
+		p_spdif->sysclk_freq = freq;
+		aml_set_spdifclk(p_spdif);
+	}
+
+	return 0;
+}
+
+// static struct snd_soc_dai_ops aml_dai_spdif_ops = {
+// 	.startup = aml_dai_spdif_startup,
+// 	.shutdown = aml_dai_spdif_shutdown,
+// 	.prepare = aml_dai_spdif_prepare,
+// 	.trigger = aml_dai_spdif_trigger,
+// 	.hw_params = aml_dai_spdif_hw_params,
+// 	.set_fmt = aml_dai_set_spdif_fmt,
+// 	.set_sysclk = aml_dai_set_spdif_sysclk,
+// };
+
+// #define AML_DAI_SPDIF_RATES		(SNDRV_PCM_RATE_8000_192000)
+// #define AML_DAI_SPDIF_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+// 		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+// static struct snd_soc_dai_driver aml_spdif_dai[] = {
+// 	{
+// 		.name = "SPDIF",
+// 		.id = 1,
+// 		.probe = aml_dai_spdif_probe,
+// 		.remove = aml_dai_spdif_remove,
+// 		.playback = {
+// 		      .channels_min = 1,
+// 		      .channels_max = 2,
+// 		      .rates = AML_DAI_SPDIF_RATES,
+// 		      .formats = AML_DAI_SPDIF_FORMATS,
+// 		},
+// 		.capture = {
+// 		     .channels_min = 1,
+// 			 /* spdif 2ch + tdmin_lb 8ch(fake for loopback) */
+// 		     .channels_max = 10,
+// 		     .rates = AML_DAI_SPDIF_RATES,
+// 		     .formats = AML_DAI_SPDIF_FORMATS,
+// 		},
+// 		.ops = &aml_dai_spdif_ops,
+// 	},
+// 	{
+// 		.name = "SPDIF-B",
+// 		.id = 2,
+// 		.probe = aml_dai_spdif_probe,
+// 		.remove = aml_dai_spdif_remove,
+// 		.playback = {
+// 			  .channels_min = 1,
+// 			  .channels_max = 8,
+// 			  .rates = AML_DAI_SPDIF_RATES,
+// 			  .formats = AML_DAI_SPDIF_FORMATS,
+// 		},
+// 		.ops = &aml_dai_spdif_ops,
+// 	}
+// };
+
+// static const struct snd_soc_component_driver aml_spdif_component = {
+// 	.name		= DRV_NAME,
+// };
+
+static int aml_spdif_parse_of(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct aml_spdif *p_spdif = dev_get_drvdata(dev);
+	int ret = 0;
+
+	/* clock for spdif in */
+	if (p_spdif->id == 0) {
+		/* clock gate */
+		p_spdif->gate_spdifin = devm_clk_get(dev, "gate_spdifin");
+		if (IS_ERR(p_spdif->gate_spdifin)) {
+			dev_err(dev, "Can't get spdifin gate\n");
+			return PTR_ERR(p_spdif->gate_spdifin);
+		}
+		/* pll */
+		p_spdif->fixed_clk = devm_clk_get(dev, "fixed_clk");
+		if (IS_ERR(p_spdif->fixed_clk)) {
+			dev_err(dev, "Can't retrieve fixed_clk\n");
+			return PTR_ERR(p_spdif->fixed_clk);
+		}
+		/* spdif in clk */
+		p_spdif->clk_spdifin = devm_clk_get(dev, "clk_spdifin");
+		if (IS_ERR(p_spdif->clk_spdifin)) {
+			dev_err(dev, "Can't retrieve spdifin clock\n");
+			return PTR_ERR(p_spdif->clk_spdifin);
+		}
+		ret = clk_set_parent(p_spdif->clk_spdifin, p_spdif->fixed_clk);
+		if (ret) {
+			dev_err(dev,
+				"Can't set clk_spdifin parent clock\n");
+			ret = PTR_ERR(p_spdif->clk_spdifin);
+			return ret;
+		}
+
+		/* irqs */
+		p_spdif->irq_spdifin =
+			platform_get_irq_byname(pdev, "irq_spdifin");
+		if (p_spdif->irq_spdifin < 0)
+			dev_err(dev, "platform_get_irq_byname failed\n");
+
+		/* spdif pinmux
+		 * only for spdif_a
+		 * spdif_b has no pin to output yet
+		 */
+		p_spdif->pin_ctl = devm_pinctrl_get_select(dev, "spdif_pins");
+		if (IS_ERR(p_spdif->pin_ctl)) {
+			dev_info(dev, "aml_spdif_get_pins error!\n");
+			return PTR_ERR(p_spdif->pin_ctl);
+		}
+
+		/* spdifin sample rate change event */
+		// p_spdif->edev = devm_extcon_dev_allocate(dev, spdifin_extcon);
+		// if (IS_ERR(p_spdif->edev)) {
+		// 	pr_err("failed to allocate spdifin extcon!!!\n");
+		// 	ret = -ENOMEM;
+		// 	return ret;
+		// }
+		// p_spdif->edev->dev.parent  = dev;
+		// p_spdif->edev->name = "spdifin_event";
+
+		// dev_set_name(&p_spdif->edev->dev, "spdifin_event");
+		// ret = extcon_dev_register(p_spdif->edev);
+		// if (ret < 0)
+		// 	pr_err("SPDIF IN extcon failed to register!!, ignore it\n");
+
+		ret = of_property_read_u32(pdev->dev.of_node,
+					"asrc_id", &p_spdif->asrc_id);
+		if (ret < 0)
+			p_spdif->asrc_id = 0;
+
+		// ret = of_property_read_u32(pdev->dev.of_node,
+		// 			"auto_asrc", &p_spdif->auto_asrc);
+		// if (ret < 0)
+			p_spdif->auto_asrc = 0;
+
+		// if (p_spdif->auto_asrc < RATE_OFF ||
+		// 		p_spdif->auto_asrc > RATE_192K) {
+		// 	pr_info("%s(), inval asrc setting %d\n",
+		// 		__func__, p_spdif->auto_asrc);
+		// 	p_spdif->auto_asrc = RATE_OFF;
+		// }
+		pr_debug("SPDIF id %d asrc_id:%d auto_asrc:%d\n",
+			p_spdif->id,
+			p_spdif->asrc_id,
+			p_spdif->auto_asrc);
+	}
+
+	/* clock for spdif out */
+	/* clock gate */
+	p_spdif->gate_spdifout = devm_clk_get(dev, "gate_spdifout");
+	if (IS_ERR(p_spdif->gate_spdifout)) {
+		dev_err(dev, "Can't get spdifout gate\n");
+		return PTR_ERR(p_spdif->gate_spdifout);
+	}
+	/* pll */
+	p_spdif->sysclk = devm_clk_get(dev, "sysclk");
+	if (IS_ERR(p_spdif->sysclk)) {
+		dev_err(dev, "Can't retrieve sysclk clock\n");
+		return PTR_ERR(p_spdif->sysclk);
+	}
+	/* spdif out clock */
+	p_spdif->clk_spdifout = devm_clk_get(dev, "clk_spdifout");
+	if (IS_ERR(p_spdif->clk_spdifout)) {
+		dev_err(dev, "Can't retrieve spdifout clock\n");
+		return PTR_ERR(p_spdif->clk_spdifout);
+	}
+
+	ret = of_property_read_u32(pdev->dev.of_node,
+				"clk_tuning_enable",
+				&p_spdif->clk_tuning_enable);
+	if (ret < 0)
+		p_spdif->clk_tuning_enable = 0;
+	else
+		pr_info("Spdif id %d tuning clk enable:%d\n",
+			p_spdif->id, p_spdif->clk_tuning_enable);
+
+	return 0;
+}
+
+int aml_spdif_platform_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node_prt = NULL;
+	struct platform_device *pdev_parent;
+	struct device *dev = &pdev->dev;
+	struct aml_audio_controller *actrl = NULL;
+	struct aml_spdif *aml_spdif = NULL;
+	struct spdif_chipinfo *p_spdif_chipinfo;
+	const struct of_device_id *di;
+	struct audio_dev_context * ctx = platform_get_drvdata(pdev);
+
+	int ret = 0;
+	bool spdif_reenable = false;
+
+	dev_info(&pdev->dev,"Registering SPDIF manager");
+	node  = of_find_node_by_name(pdev->dev.of_node, "spdif");
+
+	aml_spdif = devm_kzalloc(dev, sizeof(struct aml_spdif), GFP_KERNEL);
+	if (!aml_spdif)
+		return -ENOMEM;
+
+	aml_spdif->dev = dev;
+	// dev_set_drvdata(dev, aml_spdif);
+
+	/* match data */
+	di = of_match_node(aml_spdif_device_id,node);
+	if(di)
+		p_spdif_chipinfo = (struct spdif_chipinfo *)di->data;
+	if (!p_spdif_chipinfo) {
+		dev_warn_once(dev, "check whether to update tdm chipinfo\n");
+		return -ENOMEM;
+	}
+
+	// p_spdif_chipinfo = (struct spdif_chipinfo *)
+	// 	of_device_get_match_data(dev);
+	if (p_spdif_chipinfo) {
+		aml_spdif->id = p_spdif_chipinfo->id;
+		/* for spdif output zero data, clk be continuous,
+		 * and keep silence when no valid data
+		 */
+		aml_spdif->clk_cont = 1;
+
+		aml_spdif->chipinfo = p_spdif_chipinfo;
+
+		spdif_reenable = p_spdif_chipinfo->same_src_spdif_reen;
+	} else
+		dev_warn_once(dev,
+			"check whether to update spdif chipinfo\n");
+
+	pr_debug("%s, spdif ID = %u\n", __func__, aml_spdif->id);
+
+	/* get audio controller */
+	// node_prt = of_get_parent(node);
+	// if (node_prt == NULL)
+	// 	return -ENXIO;
+
+	// pdev_parent = of_find_device_by_node(node_prt);
+	// of_node_put(node_prt);
+	// actrl = (struct aml_audio_controller *)
+	// 			platform_get_drvdata(pdev_parent);
+	actrl = ctx->actrl;
+	aml_spdif->actrl = actrl;
+
+	ret = aml_spdif_parse_of(pdev);
+	if (ret)
+		return -EINVAL;
+	// if (aml_spdif->clk_cont)
+	// 	spdifout_play_with_zerodata(aml_spdif->id, spdif_reenable);
+
+	// ret = devm_snd_soc_register_component(dev, &aml_spdif_component,
+	// 	&aml_spdif_dai[aml_spdif->id], 1);
+	// if (ret) {
+	// 	dev_err(dev, "devm_snd_soc_register_component failed\n");
+	// 	return ret;
+	// }
+	ctx->spdif = aml_spdif;
+	spdif_priv[aml_spdif->id] = aml_spdif;
+	pr_info("%s, register soc platform\n", __func__);
+	return ret;
+	// return devm_snd_soc_register_platform(dev, &aml_spdif_platform);
+}
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif.h b/evl/sound/evl-amlogic/spdif.h
--- a/drivers/evl/sound/evl-amlogic/spdif.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif.h	2022-01-10 16:02:47.538879610 +0300
@@ -0,0 +1,32 @@
+/*
+ * sound/soc/amlogic/auge/spdif.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SPDIF_H__
+#define __AML_SPDIF_H__
+#include <linux/clk.h>
+#if 0
+enum SPDIF_ID {
+	SPDIF_A,
+	SPDIF_B,
+	SPDIF_ID_CNT
+};
+#endif
+
+extern int spdif_set_audio_clk(int id,
+		struct clk *clk_src, int rate, int same);
+extern int aml_spdif_platform_probe(struct platform_device *pdev);
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif_hw.c b/evl/sound/evl-amlogic/spdif_hw.c
--- a/drivers/evl/sound/evl-amlogic/spdif_hw.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif_hw.c	2022-01-10 12:20:14.848905609 +0300
@@ -0,0 +1,721 @@
+/*
+ * sound/soc/amlogic/auge/spdif_hw.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG
+#include <sound/soc.h>
+
+#include "iomap.h"
+#include "spdif_hw.h"
+#include "ddr_mngr.h"
+
+// #include <linux/amlogic/media/sound/aout_notify.h>
+
+/*#define G12A_PTM*/
+/*#define __PTM_SPDIF_INTERNAL_LB__*/
+
+unsigned int aml_spdif_ctrl_read(struct aml_audio_controller *actrl,
+	int stream, int index)
+{
+	unsigned int offset, reg;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+	} else {
+		reg = EE_AUDIO_SPDIFIN_CTRL0;
+	}
+
+	return aml_audiobus_read(actrl, reg);
+}
+
+void aml_spdif_ctrl_write(struct aml_audio_controller *actrl,
+	int stream, int index, int val)
+{
+	unsigned int offset, reg;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+	} else {
+		reg = EE_AUDIO_SPDIFIN_CTRL0;
+	}
+
+	aml_audiobus_write(actrl, reg, val);
+}
+
+void aml_spdifin_chnum_en(struct aml_audio_controller *actrl,
+	int index, bool is_enable)
+{
+	unsigned int reg;
+
+	reg = EE_AUDIO_SPDIFIN_CTRL0;
+	aml_audiobus_update_bits(actrl, reg, 1 << 26, is_enable << 26);
+
+	pr_debug("%s spdifin ctrl0:0x%x\n",
+		__func__,
+		aml_audiobus_read(actrl, reg));
+}
+
+void aml_spdif_enable(
+	struct aml_audio_controller *actrl,
+	int stream,
+	int index,
+	bool is_enable)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		unsigned int offset, reg;
+
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+		aml_audiobus_update_bits(actrl,
+			reg, 1<<31, is_enable<<31);
+	} else {
+		aml_audiobus_update_bits(actrl,
+			EE_AUDIO_SPDIFIN_CTRL0, 1<<31, is_enable<<31);
+#ifdef __PTM_SPDIF_INTERNAL_LB__
+		if (index == 0)
+		aml_audiobus_update_bits(actrl,
+			EE_AUDIO_SPDIFIN_CTRL0, 0x3<<4, 0x1<<4);
+#endif
+	}
+}
+
+void aml_spdif_mute(
+	struct aml_audio_controller *actrl,
+	int stream,
+	int index,
+	bool is_mute)
+{
+	int mute_lr = 0;
+
+	if (is_mute)
+		mute_lr = 0x3;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		unsigned int offset, reg;
+
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+		aml_audiobus_update_bits(actrl,
+			reg, 0x3 << 21, mute_lr << 21);
+	} else {
+		aml_audiobus_update_bits(actrl,
+			EE_AUDIO_SPDIFIN_CTRL0, 0x3 << 6, mute_lr << 6);
+	}
+}
+
+void aml_spdifout_mute_without_actrl(
+		int index,
+		bool is_mute)
+{
+	unsigned int offset, reg;
+	int mute_lr = 0;
+
+	if (is_mute)
+		mute_lr = 0x3;
+
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+	reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+
+	audiobus_update_bits(reg, 0x3 << 21, mute_lr << 21);
+}
+
+void aml_spdif_arb_config(struct aml_audio_controller *actrl)
+{
+	/* config ddr arb */
+	aml_audiobus_write(actrl, EE_AUDIO_ARB_CTRL, 1<<31|0xff<<0);
+}
+
+int aml_spdifin_status_check(struct aml_audio_controller *actrl)
+{
+	unsigned int val;
+
+	val = aml_audiobus_read(actrl, EE_AUDIO_SPDIFIN_STAT0);
+
+	/* pr_info("\t--- spdif handles status0 %#x\n", val); */
+	return val;
+}
+
+void aml_spdifin_clr_irq(struct aml_audio_controller *actrl,
+	bool is_all_bits, int clr_bits_val)
+{
+	if (is_all_bits) {
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL0,
+				1 << 26,
+				1 << 26);
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL0,
+				1 << 26,
+				0);
+	} else
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL6,
+				0xff << 16,
+				clr_bits_val << 16);
+}
+
+void aml_spdif_fifo_reset(
+	struct aml_audio_controller *actrl,
+	int stream, int index)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* reset afifo */
+		unsigned int offset, reg;
+
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+		aml_audiobus_update_bits(actrl,
+				reg, 3<<28, 0);
+		aml_audiobus_update_bits(actrl,
+				reg, 1<<29, 1<<29);
+		aml_audiobus_update_bits(actrl,
+				reg, 1<<28, 1<<28);
+	} else {
+		/* reset afifo */
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL0, 3<<28, 0);
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL0, 1<<29, 1<<29);
+		aml_audiobus_update_bits(actrl,
+				EE_AUDIO_SPDIFIN_CTRL0, 1<<28, 1<<28);
+	}
+}
+
+int spdifout_get_frddr_type(int bitwidth)
+{
+	unsigned int frddr_type = 0;
+
+	switch (bitwidth) {
+	case 8:
+		frddr_type = 0;
+		break;
+	case 16:
+		frddr_type = 1;
+		break;
+	case 24:
+		frddr_type = 4;
+		break;
+	case 32:
+		frddr_type = 3;
+		break;
+	default:
+		pr_err("runtime format invalid bitwidth: %d\n",
+			bitwidth);
+		break;
+	}
+
+	return frddr_type;
+}
+
+void aml_spdif_fifo_ctrl(
+	struct aml_audio_controller *actrl,
+	int bitwidth,
+	int stream,
+	int index,
+	unsigned int fifo_id)
+{
+	unsigned int toddr_type;
+	unsigned int frddr_type = spdifout_get_frddr_type(bitwidth);
+
+	switch (bitwidth) {
+	case 8:
+		toddr_type = 0;
+		break;
+	case 16:
+		toddr_type = 1;
+		break;
+	case 24:
+		toddr_type = 4;
+		break;
+	case 32:
+		toddr_type = 3;
+		break;
+	default:
+		pr_err("runtime format invalid bitwidth: %d\n",
+			bitwidth);
+		return;
+	}
+
+	pr_debug("%s, bit depth:%d, frddr type:%d, toddr:type:%d\n",
+		__func__,
+		bitwidth,
+		frddr_type,
+		toddr_type);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		unsigned int offset, reg;
+
+		/* mask lane 0 L/R channels */
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+		reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * index;
+		aml_audiobus_update_bits(actrl,
+			reg,
+			0x1<<29|0x1<<28|0x1<<20|0x1<<19|0xff<<4,
+			1<<29|1<<28|0<<20|0<<19|0x3<<4);
+
+		offset = EE_AUDIO_SPDIFOUT_B_CTRL1 - EE_AUDIO_SPDIFOUT_CTRL1;
+		reg = EE_AUDIO_SPDIFOUT_CTRL1 + offset * index;
+		aml_audiobus_update_bits(actrl,
+			reg,
+			0x3 << 24 | 0x1f << 8 | 0x7 << 4,
+			fifo_id << 24 | (bitwidth - 1) << 8 | frddr_type<<4);
+
+		offset = EE_AUDIO_SPDIFOUT_B_SWAP - EE_AUDIO_SPDIFOUT_SWAP;
+		reg = EE_AUDIO_SPDIFOUT_SWAP + offset * index;
+		aml_audiobus_write(actrl,
+			reg,
+			1<<4);
+	} else {
+		unsigned int spdifin_clk = 500000000;
+
+		/* sysclk/rate/32(bit)/2(ch)/2(bmc) */
+		unsigned int counter_32k  = (spdifin_clk / (32000  * 64));
+		unsigned int counter_44k  = (spdifin_clk / (44100  * 64));
+		unsigned int counter_48k  = (spdifin_clk / (48000  * 64));
+		unsigned int counter_88k  = (spdifin_clk / (88200  * 64));
+		unsigned int counter_96k  = (spdifin_clk / (96000  * 64));
+		unsigned int counter_176k = (spdifin_clk / (176400 * 64));
+		unsigned int counter_192k = (spdifin_clk / (192000 * 64));
+		unsigned int mode0_th = 3 * (counter_32k + counter_44k) >> 1;
+		unsigned int mode1_th = 3 * (counter_44k + counter_48k) >> 1;
+		unsigned int mode2_th = 3 * (counter_48k + counter_88k) >> 1;
+		unsigned int mode3_th = 3 * (counter_88k + counter_96k) >> 1;
+		unsigned int mode4_th = 3 * (counter_96k + counter_176k) >> 1;
+		unsigned int mode5_th = 3 * (counter_176k + counter_192k) >> 1;
+		unsigned int mode0_timer = counter_32k >> 1;
+		unsigned int mode1_timer = counter_44k >> 1;
+		unsigned int mode2_timer = counter_48k >> 1;
+		unsigned int mode3_timer = counter_88k >> 1;
+		unsigned int mode4_timer = counter_96k >> 1;
+		unsigned int mode5_timer = (counter_176k >> 1);
+		unsigned int mode6_timer = (counter_192k >> 1);
+
+		aml_audiobus_write(actrl,
+			EE_AUDIO_SPDIFIN_CTRL1,
+			0xff << 20 | (spdifin_clk / 10000) << 0);
+
+		aml_audiobus_write(actrl,
+			EE_AUDIO_SPDIFIN_CTRL2,
+			mode0_th << 20 |
+			mode1_th << 10 |
+			mode2_th << 0);
+
+		aml_audiobus_write(actrl,
+			EE_AUDIO_SPDIFIN_CTRL3,
+			mode3_th << 20 |
+			mode4_th << 10 |
+			mode5_th << 0);
+
+		aml_audiobus_write(actrl,
+			EE_AUDIO_SPDIFIN_CTRL4,
+			(mode0_timer << 24) |
+			(mode1_timer << 16) |
+			(mode2_timer << 8)  |
+			(mode3_timer << 0)
+			);
+
+		aml_audiobus_write(actrl,
+			EE_AUDIO_SPDIFIN_CTRL5,
+			(mode4_timer << 24) |
+			(mode5_timer << 16) |
+			(mode6_timer << 8)
+			);
+
+		aml_audiobus_update_bits(actrl,
+			EE_AUDIO_SPDIFIN_CTRL0,
+			0x1 << 25 | 0x1 << 24 | 0xfff << 12,
+			0x1 << 25 | 0x0 << 24 | 0xff << 12);
+	}
+
+}
+
+int spdifin_get_mode(void)
+{
+	int mode_val = audiobus_read(EE_AUDIO_SPDIFIN_STAT0);
+
+	mode_val >>= 28;
+	mode_val &= 0x7;
+
+	return mode_val;
+}
+
+int spdif_get_channel_status(int reg)
+{
+	return audiobus_read(reg);
+}
+
+void spdifin_set_channel_status(int ch, int bits)
+{
+	int ch_status_sel = (ch << 3 | bits) & 0xf;
+
+	/*which channel status would be got*/
+	audiobus_update_bits(EE_AUDIO_SPDIFIN_CTRL0,
+		0xf << 8,
+		ch_status_sel << 8);
+}
+
+void aml_spdifout_select_aed(bool enable, int spdifout_id)
+{
+	unsigned int offset, reg;
+
+	/* select eq_drc output */
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL1 - EE_AUDIO_SPDIFOUT_CTRL1;
+	reg = EE_AUDIO_SPDIFOUT_CTRL1 + offset * spdifout_id;
+	audiobus_update_bits(reg, 0x1 << 31, enable << 31);
+}
+
+void aml_spdifout_get_aed_info(int spdifout_id,
+	int *bitwidth, int *frddrtype)
+{
+	unsigned int reg, offset, val;
+
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL1
+			- EE_AUDIO_SPDIFOUT_CTRL1;
+	reg = EE_AUDIO_SPDIFOUT_CTRL1 + offset * spdifout_id;
+
+	val = audiobus_read(reg);
+	if (bitwidth)
+		*bitwidth = (val >> 8) & 0x1f;
+	if (frddrtype)
+		*frddrtype = (val >> 4) & 0x7;
+}
+
+/* spdifout to hdmix ctrl
+ * allow spdif out data to hdmitx
+ */
+void spdifout_to_hdmitx_ctrl(int spdif_index)
+{
+	audiobus_write(EE_AUDIO_TOHDMITX_CTRL0,
+		1 << 31
+		| 1 << 3 /* spdif_clk_cap_inv */
+		| 0 << 2 /* spdif_clk_inv */
+		| spdif_index << 1 /* spdif_out */
+		| spdif_index << 0 /* spdif_clk */
+	);
+}
+#if 0
+static void spdifout_clk_ctrl(int spdif_id, bool is_enable)
+{
+	unsigned int offset, reg;
+
+	offset = EE_AUDIO_CLK_SPDIFOUT_B_CTRL - EE_AUDIO_CLK_SPDIFOUT_CTRL;
+	reg = EE_AUDIO_CLK_SPDIFOUT_CTRL + offset * spdif_id;
+
+	/* select : mpll 0, 24m, so spdif clk:6m */
+	audiobus_write(reg, is_enable << 31 | 0x0 << 24 | 0x3 << 0);
+}
+#endif
+static void spdifout_fifo_ctrl(int spdif_id,
+	int fifo_id, int bitwidth, int channels, int lane_i2s)
+{
+	unsigned int frddr_type = spdifout_get_frddr_type(bitwidth);
+	unsigned int offset, reg, i, chmask = 0;
+	unsigned int swap_masks = 0;
+
+	/* spdif always masks two channel */
+	if (lane_i2s * 2 >= channels) {
+		pr_err("invalid lane(%d) and channels(%d)\n",
+				lane_i2s, channels);
+		return;
+	}
+
+	for (i = 0; i < channels; i++)
+		chmask |= (1 << i);
+
+	swap_masks = (2 * lane_i2s) |
+		(2 * lane_i2s + 1) << 4;
+	pr_debug("spdif_%s fifo ctrl, frddr:%d type:%d, %d bits, chmask %#x, swap %#x\n",
+		(spdif_id == 0) ? "a":"b",
+		fifo_id,
+		frddr_type,
+		bitwidth,
+		chmask,
+		swap_masks);
+
+	/* mask lane 0 L/R channels */
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+	reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * spdif_id;
+	audiobus_update_bits(reg,
+		0x1<<20|0x1<<19|0xff<<4,
+		0<<20|0<<19|chmask<<4);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL1 - EE_AUDIO_SPDIFOUT_CTRL1;
+	reg = EE_AUDIO_SPDIFOUT_CTRL1 + offset * spdif_id;
+	audiobus_update_bits(reg,
+		0x3 << 24 | 0x1f << 8 | 0x7 << 4,
+		fifo_id << 24 | (bitwidth - 1) << 8 | frddr_type<<4);
+
+	offset = EE_AUDIO_SPDIFOUT_B_SWAP - EE_AUDIO_SPDIFOUT_SWAP;
+	reg = EE_AUDIO_SPDIFOUT_SWAP + offset * spdif_id;
+	audiobus_write(reg, swap_masks);
+}
+
+static bool spdifout_is_enable(int spdif_id)
+{
+	unsigned int offset, reg, val;
+
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+	reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * spdif_id;
+	val = audiobus_read(reg);
+
+	return ((val >> 31) == 1);
+}
+
+void spdifout_enable(int spdif_id, bool is_enable, bool reenable)
+{
+	unsigned int offset, reg;
+
+	pr_debug("spdif_%s is set to %s\n",
+		(spdif_id == 0) ? "a":"b",
+		is_enable ? "enable":"disable");
+
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+	reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * spdif_id;
+
+	if (!is_enable) {
+		/* share buffer, spdif should be active, so mute it */
+		/*audiobus_update_bits(reg, 0x3 << 21, 0x3 << 21);*/
+		return;
+	}
+
+	/* disable then for reset, to correct channel map */
+	if (reenable)
+		audiobus_update_bits(reg, 1<<31, 0x0<<31);
+
+	/* reset afifo */
+	audiobus_update_bits(reg, 3<<28, 0);
+	audiobus_update_bits(reg, 1<<29, 1<<29);
+	audiobus_update_bits(reg, 1<<28, 1<<28);
+
+	audiobus_update_bits(reg, 1<<31, is_enable<<31);
+}
+
+void spdifout_samesource_set(int spdif_index, int fifo_id,
+	int bitwidth, int channels, bool is_enable, int lane_i2s)
+{
+	int spdif_id;
+
+	if (spdif_index == 1)
+		spdif_id = 1;
+	else
+		spdif_id = 0;
+
+	if (is_enable)
+		spdifout_fifo_ctrl(spdif_id,
+			fifo_id, bitwidth, channels, lane_i2s);
+}
+
+int spdifin_get_sample_rate(void)
+{
+	unsigned int val;
+	/*EE_AUDIO_SPDIFIN_STAT0*/
+	/*r_width_max bit17:8 (the max width of two edge;)*/
+	unsigned int max_width = 0;
+
+	val = audiobus_read(EE_AUDIO_SPDIFIN_STAT0);
+
+	/* NA when check min width of two edges */
+	if (((val >> 18) & 0x3ff) == 0x3ff)
+		return 7;
+
+	/*check the max width of two edge when spdifin sr=32kHz*/
+	/*if max_width is more than 0x2f0(magic number),*/
+	/*sr(32kHz) is unavailable*/
+	max_width = ((val >> 8) & 0x3ff);
+
+	if ((((val >> 28) & 0x7) == 0) && (max_width == 0x3ff))
+		return 7;
+
+	return (val >> 28) & 0x7;
+}
+
+
+static int spdifin_get_channel_status(int sel)
+{
+	unsigned int val;
+
+	/* set ch_status_sel to channel status */
+	audiobus_update_bits(EE_AUDIO_SPDIFIN_CTRL0, 0xf << 8, sel << 8);
+
+	val = audiobus_read(EE_AUDIO_SPDIFIN_STAT1);
+
+	return val;
+}
+
+int spdifin_get_ch_status0to31(void)
+{
+	return spdifin_get_channel_status(0x0);
+}
+
+int spdifin_get_audio_type(void)
+{
+	unsigned int val;
+
+	/* set ch_status_sel to read Pc */
+	val = spdifin_get_channel_status(0x6);
+
+	return (val >> 16) & 0xff;
+}
+
+void spdifin_set_src(int src)
+{
+	audiobus_update_bits(EE_AUDIO_SPDIFIN_CTRL0, 0x3 << 4, src << 4);
+}
+
+void spdif_set_channel_status_info(
+	struct iec958_chsts *chsts, int spdif_id)
+{
+	unsigned int offset, reg;
+
+	/* "ch status" = reg_chsts0~B */
+	offset = EE_AUDIO_SPDIFOUT_B_CTRL0 - EE_AUDIO_SPDIFOUT_CTRL0;
+	reg = EE_AUDIO_SPDIFOUT_CTRL0 + offset * spdif_id;
+	audiobus_update_bits(reg, 0x1 << 24, 0x0 << 24);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS0 - EE_AUDIO_SPDIFOUT_CHSTS0;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS0 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS1 - EE_AUDIO_SPDIFOUT_CHSTS1;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS1 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS2 - EE_AUDIO_SPDIFOUT_CHSTS2;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS2 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS3 - EE_AUDIO_SPDIFOUT_CHSTS3;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS3 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS4 - EE_AUDIO_SPDIFOUT_CHSTS4;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS4 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS5 - EE_AUDIO_SPDIFOUT_CHSTS5;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS5 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_l << 16 | chsts->chstat0_l);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS6 - EE_AUDIO_SPDIFOUT_CHSTS6;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS6 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS7 - EE_AUDIO_SPDIFOUT_CHSTS7;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS7 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS8 - EE_AUDIO_SPDIFOUT_CHSTS8;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS8 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTS9 - EE_AUDIO_SPDIFOUT_CHSTS9;
+	reg = EE_AUDIO_SPDIFOUT_CHSTS9 + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTSA - EE_AUDIO_SPDIFOUT_CHSTSA;
+	reg = EE_AUDIO_SPDIFOUT_CHSTSA + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+
+	offset = EE_AUDIO_SPDIFOUT_B_CHSTSB - EE_AUDIO_SPDIFOUT_CHSTSB;
+	reg = EE_AUDIO_SPDIFOUT_CHSTSB + offset * spdif_id;
+	audiobus_write(reg, chsts->chstat1_r << 16 | chsts->chstat0_r);
+}
+
+// void spdifout_play_with_zerodata(unsigned int spdif_id, bool reenable)
+// {
+// 	pr_debug("%s, spdif id:%d enable:%d\n",
+// 		__func__,
+// 		spdif_id,
+// 		spdifout_is_enable(spdif_id));
+
+// 	if (!spdifout_is_enable(spdif_id)) {
+// 		unsigned int frddr_index = 0;
+// 		unsigned int bitwidth = 32;
+// 		unsigned int sample_rate = 48000;
+// 		unsigned int src0_sel = 4; /* spdif b */
+// 		struct iec958_chsts chsts;
+// 		struct snd_pcm_substream substream;
+// 		struct snd_pcm_runtime runtime;
+
+// 		substream.runtime = &runtime;
+// 		runtime.rate = sample_rate;
+// 		runtime.format = SNDRV_PCM_FORMAT_S16_LE;
+// 		runtime.channels = 2;
+// 		runtime.sample_bits = 16;
+
+// 		/* check whether fix to spdif a */
+// 		if (spdif_id == 0)
+// 			src0_sel = 3;
+
+// 		/* spdif clk */
+// 		//spdifout_clk_ctrl(spdif_id, true);
+// 		/* spdif to hdmitx */
+// 		spdifout_to_hdmitx_ctrl(spdif_id);
+
+// 		/* spdif ctrl */
+// 		spdifout_fifo_ctrl(spdif_id,
+// 			frddr_index, bitwidth, runtime.channels, 0);
+
+// 		/* channel status info */
+// 		spdif_get_channel_status_info(&chsts, sample_rate);
+// 		spdif_set_channel_status_info(&chsts, spdif_id);
+
+// 		/* notify hdmitx audio */
+// 		// aout_notifier_call_chain(0x1, &substream);
+
+// 		/* init frddr to output zero data. */
+// 		frddr_init_without_mngr(frddr_index, src0_sel);
+
+// 		/* spdif enable */
+// 		spdifout_enable(spdif_id, true, reenable);
+// 	}
+// }
+
+// void spdifout_play_with_zerodata_free(unsigned int spdif_id)
+// {
+// 	pr_debug("%s, spdif id:%d\n",
+// 		__func__,
+// 		spdif_id);
+
+// 	/* free frddr, then frddr in mngr */
+// 	frddr_deinit_without_mngr(spdif_id);
+// }
+
+void aml_spdif_out_reset(unsigned int spdif_id, int offset)
+{
+	unsigned int reg = 0, val = 0;
+
+	if ((offset != 0) && (offset != 1)) {
+		pr_err("%s(), invalid offset = %d\n", __func__, offset);
+		return;
+	}
+
+	if (spdif_id == 0) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_SPDIFOUTA;
+	} else if (spdif_id == 1) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_SPDIFOUTB;
+	} else {
+		pr_err("invalid spdif id %d\n", spdif_id);
+		return;
+	}
+
+	audiobus_update_bits(reg, val, val);
+	audiobus_update_bits(reg, val, 0);
+}
+
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif_hw.h b/evl/sound/evl-amlogic/spdif_hw.h
--- a/drivers/evl/sound/evl-amlogic/spdif_hw.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif_hw.h	2022-01-10 13:37:55.188896535 +0300
@@ -0,0 +1,98 @@
+/*
+ * sound/soc/amlogic/auge/spdif_hw.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_SPDIF_HW_H__
+#define __AML_SPDIF_HW_H__
+#include "audio_io.h"
+#include "regs.h"
+
+#include "spdif_info.h"
+
+extern unsigned int aml_spdif_ctrl_read(struct aml_audio_controller *actrl,
+	int stream, int index);
+extern void aml_spdif_ctrl_write(struct aml_audio_controller *actrl,
+	int stream, int index, int val);
+extern void aml_spdifin_chnum_en(struct aml_audio_controller *actrl,
+	int index, bool is_enable);
+extern void aml_spdif_enable(
+	struct aml_audio_controller *actrl,
+	int stream,
+	int index,
+	bool is_enable);
+
+extern void aml_spdif_mute(
+	struct aml_audio_controller *actrl,
+	int stream,
+	int index,
+	bool is_mute);
+
+extern void aml_spdifout_mute_without_actrl(
+	int index,
+	bool is_mute);
+
+extern void aml_spdif_arb_config(struct aml_audio_controller *actrl);
+
+extern int aml_spdifin_status_check(
+	struct aml_audio_controller *actrl);
+extern void aml_spdifin_clr_irq(struct aml_audio_controller *actrl,
+	bool is_all_bits, int clr_bits_val);
+
+extern void aml_spdif_fifo_reset(
+	struct aml_audio_controller *actrl,
+	int stream, int index);
+
+extern int spdifout_get_frddr_type(int bitwidth);
+
+extern void aml_spdif_fifo_ctrl(
+	struct aml_audio_controller *actrl,
+	int bitwidth,
+	int stream,
+	int index,
+	unsigned int fifo_id);
+
+extern int spdifin_get_mode(void);
+
+extern int spdif_get_channel_status(int reg);
+
+extern void spdifin_set_channel_status(int ch, int bits);
+
+extern void aml_spdifout_select_aed(bool enable, int spdifout_id);
+
+extern void aml_spdifout_get_aed_info(int spdifout_id,
+	int *bitwidth, int *frddrtype);
+
+extern void spdifout_to_hdmitx_ctrl(int spdif_index);
+
+extern void spdifout_samesource_set(int spdif_index, int fifo_id,
+	int bitwidth, int channels, bool is_enable, int lane_i2s);
+extern void spdifout_enable(int spdif_id, bool is_enable, bool reenable);
+
+extern int spdifin_get_sample_rate(void);
+
+extern int spdifin_get_ch_status0to31(void);
+
+extern int spdifin_get_audio_type(void);
+
+extern void spdif_set_channel_status_info(
+	struct iec958_chsts *chsts, int spdif_id);
+
+// extern void spdifout_play_with_zerodata(unsigned int spdif_id, bool reenable);
+// extern void spdifout_play_with_zerodata_free(unsigned int spdif_id);
+extern void spdifin_set_src(int src);
+void aml_spdif_out_reset(unsigned int spdif_id, int offset);
+
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif_info.c b/evl/sound/evl-amlogic/spdif_info.c
--- a/drivers/evl/sound/evl-amlogic/spdif_info.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif_info.c	2022-01-10 11:57:24.508908277 +0300
@@ -0,0 +1,175 @@
+/*
+ * sound/soc/amlogic/common/spdif_info.c
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG
+#undef pr_fmt
+#define pr_fmt(fmt) "spdif_info: " fmt
+
+// #include <linux/amlogic/media/sound/aout_notify.h>
+#include "spdif_info.h"
+#include "evl-audio.h"
+#ifdef CONFIG_AMLOGIC_HDMITX
+#include <linux/amlogic/media/vout/hdmi_tx/hdmi_tx_ext.h>
+#endif
+
+/*
+ * 0 --  other formats except(DD,DD+,DTS)
+ * 1 --  DTS
+ * 2 --  DD
+ * 3 -- DTS with 958 PCM RAW package mode
+ * 4 -- DD+
+ */
+unsigned int IEC958_mode_codec;
+EXPORT_SYMBOL(IEC958_mode_codec);
+
+int spdif_is_4x_clk(void)
+{
+	int is_4x = 0;
+
+	if (IEC958_mode_codec == 7 || IEC958_mode_codec == 8) {
+		is_4x = 1;
+	}
+
+	return is_4x;
+}
+
+
+static int pcm_rate_to_rate_bit(int rate) {
+	switch (rate)
+	{
+	case 5512:
+		return SNDRV_PCM_RATE_5512;
+		break;
+	case 8000:
+		return SNDRV_PCM_RATE_8000;
+		break;
+	case 11025:
+		return SNDRV_PCM_RATE_11025;
+		break;
+	case 16000:
+		return SNDRV_PCM_RATE_16000;
+		break;
+	case 22050:
+		return SNDRV_PCM_RATE_22050;
+		break;
+	case 32000:
+		return SNDRV_PCM_RATE_32000;
+		break;
+	case 44100:
+		return SNDRV_PCM_RATE_44100;
+		break;
+	case 48000:
+		return SNDRV_PCM_RATE_48000;
+		break;
+	case 64000:
+		return SNDRV_PCM_RATE_64000;
+		break;
+	case 88200:
+		return SNDRV_PCM_RATE_88200;
+		break;
+	case 96000:
+		return SNDRV_PCM_RATE_96000;
+		break;
+	default:
+		break;
+	}
+
+	return SNDRV_PCM_RATE_KNOT;
+}
+
+
+void spdif_get_channel_status_info(
+	struct iec958_chsts *chsts,
+	unsigned int rate)
+{
+	int rate_bit = pcm_rate_to_rate_bit(rate);
+
+	if (rate_bit == SNDRV_PCM_RATE_KNOT) {
+		pr_err("Unsupport sample rate\n");
+		return;
+	}
+	if (IEC958_mode_codec && IEC958_mode_codec != 9) {
+		if (IEC958_mode_codec == 1) {
+			/* dts, use raw sync-word mode */
+			pr_info("iec958 mode RAW\n");
+		} else {
+			/* ac3,use the same pcm mode as i2s */
+		}
+
+		chsts->chstat0_l = 0x1902;
+		chsts->chstat0_r = 0x1902;
+		if (IEC958_mode_codec == 4 || IEC958_mode_codec == 5) {
+			/* DD+ */
+			if (rate_bit == SNDRV_PCM_RATE_32000) {
+				chsts->chstat1_l = 0x300;
+				chsts->chstat1_r = 0x300;
+			} else if (rate_bit == SNDRV_PCM_RATE_44100) {
+				chsts->chstat1_l = 0xc00;
+				chsts->chstat1_r = 0xc00;
+			} else {
+				chsts->chstat1_l = 0Xe00;
+				chsts->chstat1_r = 0Xe00;
+			}
+		} else if (IEC958_mode_codec == 8 || IEC958_mode_codec == 7) {
+			/* DTS-HD MA, TrueHD */
+				chsts->chstat1_l = 0x900;
+				chsts->chstat1_r = 0x900;
+		} else {
+			/* DTS,DD */
+			if (rate_bit == SNDRV_PCM_RATE_32000) {
+				chsts->chstat1_l = 0x300;
+				chsts->chstat1_r = 0x300;
+			} else if (rate_bit == SNDRV_PCM_RATE_44100) {
+				chsts->chstat1_l = 0;
+				chsts->chstat1_r = 0;
+			} else {
+				chsts->chstat1_l = 0x200;
+				chsts->chstat1_r = 0x200;
+			}
+		}
+	} else {
+		chsts->chstat0_l = 0x0100;
+		chsts->chstat0_r = 0x0100;
+		chsts->chstat1_l = 0x200;
+		chsts->chstat1_r = 0x200;
+
+		if (rate_bit == SNDRV_PCM_RATE_44100) {
+			chsts->chstat1_l = 0;
+			chsts->chstat1_r = 0;
+		} else if (rate_bit == SNDRV_PCM_RATE_88200) {
+			chsts->chstat1_l = 0x800;
+			chsts->chstat1_r = 0x800;
+		} else if (rate_bit == SNDRV_PCM_RATE_96000) {
+			chsts->chstat1_l = 0xa00;
+			chsts->chstat1_r = 0xa00;
+		} else if (rate_bit == SNDRV_PCM_RATE_176400) {
+			chsts->chstat1_l = 0xc00;
+			chsts->chstat1_r = 0xc00;
+		} else if (rate_bit == SNDRV_PCM_RATE_192000) {
+			chsts->chstat1_l = 0xe00;
+			chsts->chstat1_r = 0xe00;
+		}
+	}
+	pr_debug("rate: %d, channel status ch0_l:0x%x, ch0_r:0x%x, ch1_l:0x%x, ch1_r:0x%x\n",
+		rate,
+		chsts->chstat0_l,
+		chsts->chstat0_r,
+		chsts->chstat1_l,
+		chsts->chstat1_r);
+}
+
+
+
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif_info.h b/evl/sound/evl-amlogic/spdif_info.h
--- a/drivers/evl/sound/evl-amlogic/spdif_info.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif_info.h	2022-01-10 11:57:28.038908271 +0300
@@ -0,0 +1,54 @@
+/*
+ * include/linux/amlogic/media/sound/spdif_info.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SPDIF_INFO_H__
+#define __SPDIF_INFO_H__
+
+// #include <sound/soc.h>
+// #include <sound/pcm.h>
+// #include <sound/control.h>
+
+struct iec958_chsts {
+	unsigned short chstat0_l;
+	unsigned short chstat1_l;
+	unsigned short chstat0_r;
+	unsigned short chstat1_r;
+};
+
+extern int spdif_is_4x_clk(void);
+
+extern void spdif_get_channel_status_info(struct iec958_chsts *chsts,
+	unsigned int rate);
+
+// extern void spdif_notify_to_hdmitx(struct snd_pcm_substream *substream);
+
+// extern const struct soc_enum spdif_format_enum;
+
+// extern int spdif_format_get_enum(
+// 	struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol);
+
+// extern int spdif_format_set_enum(
+// 	struct snd_kcontrol *kcontrol,
+// 	struct snd_ctl_elem_value *ucontrol);
+#ifdef CONFIG_AMLOGIC_HDMITX
+int aml_get_hdmi_out_audio(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+int aml_set_hdmi_out_audio(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol);
+#endif
+#endif
diff -ruN a/drivers/evl/sound/evl-amlogic/spdif_match_table.c b/evl/sound/evl-amlogic/spdif_match_table.c
--- a/drivers/evl/sound/evl-amlogic/spdif_match_table.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/spdif_match_table.c	2022-01-10 11:16:39.928913037 +0300
@@ -0,0 +1,156 @@
+/*
+ * sound/soc/amlogic/auge/spdif_match_table.c
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#define SPDIF_A	0
+#define SPDIF_B	1
+
+struct spdif_chipinfo {
+	unsigned int id;
+
+	/* add ch_cnt to ch_num */
+	bool chnum_en;
+	/*
+	 * axg, clear all irq bits
+	 * after axg, such as g12a, clear each bits
+	 * Reg_clr_interrupt[7:0] for each bit of irq_status[7:0];
+	 */
+	bool clr_irq_all_bits;
+	/* no PaPb irq */
+	bool irq_no_papb;
+	/* reg_hold_start_en; 1: add delay to match TDM out when share buff; */
+	bool hold_start;
+	/* eq/drc */
+	bool eq_drc_en;
+	/* pc, pd interrupt is separated. */
+	bool pcpd_separated;
+	/* same source, spdif re-enable */
+	bool same_src_spdif_reen;
+	/* async fifo */
+	bool async_fifo;
+};
+
+struct spdif_chipinfo axg_spdif_chipinfo = {
+	.id               = SPDIF_A,
+	.irq_no_papb      = true,
+	.clr_irq_all_bits = true,
+	.pcpd_separated   = true,
+};
+
+struct spdif_chipinfo g12a_spdif_a_chipinfo = {
+	.id             = SPDIF_A,
+	.chnum_en       = true,
+	.hold_start     = true,
+	.eq_drc_en      = true,
+	.pcpd_separated = true,
+};
+
+struct spdif_chipinfo g12a_spdif_b_chipinfo = {
+	.id             = SPDIF_B,
+	.chnum_en       = true,
+	.hold_start     = true,
+	.eq_drc_en      = true,
+	.pcpd_separated = true,
+};
+
+struct spdif_chipinfo tl1_spdif_a_chipinfo = {
+	.id           = SPDIF_A,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+struct spdif_chipinfo tl1_spdif_b_chipinfo = {
+	.id           = SPDIF_B,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+struct spdif_chipinfo sm1_spdif_a_chipinfo = {
+	.id           = SPDIF_A,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+struct spdif_chipinfo sm1_spdif_b_chipinfo = {
+	.id           = SPDIF_B,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+struct spdif_chipinfo tm2_spdif_a_chipinfo = {
+	.id           = SPDIF_A,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+struct spdif_chipinfo tm2_spdif_b_chipinfo = {
+	.id           = SPDIF_B,
+	.chnum_en     = true,
+	.hold_start   = true,
+	.eq_drc_en    = true,
+	.async_fifo   = true,
+};
+
+static const struct of_device_id aml_spdif_device_id[] = {
+	{
+		.compatible = "amlogic, axg-snd-spdif",
+		.data       = &axg_spdif_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-spdif-a",
+		.data       = &g12a_spdif_a_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-spdif-b",
+		.data       = &g12a_spdif_b_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-spdif-a",
+		.data       = &tl1_spdif_a_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-spdif-b",
+		.data       = &tl1_spdif_b_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-spdif-a",
+		.data		= &sm1_spdif_a_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-spdif-b",
+		.data		= &sm1_spdif_b_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-spdif-a",
+		.data		= &tm2_spdif_a_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-spdif-b",
+		.data		= &tm2_spdif_b_chipinfo,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, aml_spdif_device_id);
diff -ruN a/drivers/evl/sound/evl-amlogic/tdm.c b/evl/sound/evl-amlogic/tdm.c
--- a/drivers/evl/sound/evl-amlogic/tdm.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tdm.c	2022-01-10 21:12:51.811476253 +0300
@@ -0,0 +1,1903 @@
+/*
+ * sound/soc/amlogic/auge/tdm.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#define DEBUG
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/ioctl.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+// #include <sound/core.h>
+// #include <sound/pcm.h>
+// #include <sound/initval.h>
+// #include <sound/control.h>
+// #include <sound/soc.h>
+// #include <sound/pcm_params.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/delay.h>
+#include "clk_measure.h"
+#include "cpu_version.h"
+
+// #include "aout_notify.h"
+
+#include "ddr_mngr.h"
+#include "tdm_hw.h"
+#include "sharebuffer.h"
+// #include "vad.h"
+#include "spdif_hw.h"
+#include "tdm_match_table.c"
+// #include "effects_v2.h"
+#include "spdif.h"
+#include "evl-audio.h"
+
+/*#define __PTM_TDM_CLK__*/
+
+
+#define DRV_NAME "snd_tdm"
+
+static int aml_dai_set_tdm_sysclk(struct aml_tdm *p_tdm,
+				int clk_id, unsigned int freq, int dir);
+static int aml_dai_set_clkdiv(struct aml_tdm *p_tdm,
+						int div_id, int div);
+static int aml_dai_set_bclk_ratio(struct aml_tdm *p_tdm,
+						unsigned int ratio);
+
+static void dump_pcm_setting(struct pcm_setting *setting)
+{
+	if (setting == NULL)
+		return;
+
+	pr_debug("dump_pcm_setting(%p)\n", setting);
+	pr_debug("\tpcm_mode(%d)\n", setting->pcm_mode);
+	pr_debug("\tsysclk(%d)\n", setting->sysclk);
+	pr_debug("\tsysclk_bclk_ratio(%d)\n", setting->sysclk_bclk_ratio);
+	pr_debug("\tbclk(%d)\n", setting->bclk);
+	pr_debug("\tbclk_lrclk_ratio(%d)\n", setting->bclk_lrclk_ratio);
+	pr_debug("\tlrclk(%d)\n", setting->lrclk);
+	pr_debug("\ttx_mask(%#x)\n", setting->tx_mask);
+	pr_debug("\trx_mask(%#x)\n", setting->rx_mask);
+	pr_debug("\tslots(%d)\n", setting->slots);
+	pr_debug("\tslot_width(%d)\n", setting->slot_width);
+	pr_debug("\tlane_mask_in(%#x)\n", setting->lane_mask_in);
+	pr_debug("\tlane_mask_out(%#x)\n", setting->lane_mask_out);
+	pr_debug("\tlane_oe_mask_in(%#x)\n", setting->lane_oe_mask_in);
+	pr_debug("\tlane_oe_mask_out(%#x)\n", setting->lane_oe_mask_out);
+	pr_debug("\tlane_lb_mask_in(%#x)\n", setting->lane_lb_mask_in);
+}
+
+
+
+// static const struct snd_pcm_hardware aml_tdm_hardware = {
+// 	.info =
+// 	SNDRV_PCM_INFO_MMAP |
+// 	SNDRV_PCM_INFO_MMAP_VALID |
+// 	SNDRV_PCM_INFO_INTERLEAVED |
+// 	    SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_PAUSE,
+// 	.formats =
+// 	    SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE |
+// 	    SNDRV_PCM_FMTBIT_S32_LE,
+
+// 	.period_bytes_min = 64,
+// 	.period_bytes_max = 256 * 1024,
+// 	.periods_min = 2,
+// 	.periods_max = 1024,
+// 	.buffer_bytes_max = 1024 * 1024,
+
+// 	.rate_min = 8000,
+// 	.rate_max = 192000,
+// 	.channels_min = 1,
+// 	.channels_max = 32,
+// };
+
+// static int tdm_clk_get(struct snd_kcontrol *kcontrol,
+// 					struct snd_ctl_elem_value *ucontrol)
+// {
+// 	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+// 	struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+
+// 	ucontrol->value.enumerated.item[0] = clk_get_rate(p_tdm->mclk);
+// 	return 0;
+// }
+
+// static int tdm_clk_set(struct snd_kcontrol *kcontrol,
+// 					struct snd_ctl_elem_value *ucontrol)
+// {
+// 	struct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);
+// 	struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+
+// 	int mclk_rate = p_tdm->last_mclk_freq;
+// 	int value = ucontrol->value.enumerated.item[0];
+
+// 	if (value > 2000000 || value < 0) {
+// 		pr_err("Fine tdm clk setting range (0~2000000), %d\n", value);
+// 		return 0;
+// 	}
+// 	mclk_rate += (value - 1000000);
+
+// 	mclk_rate >>= 1;
+// 	mclk_rate <<= 1;
+
+// 	aml_dai_set_tdm_sysclk(cpu_dai, 0, mclk_rate, 0);
+
+// 	return 0;
+// }
+
+// static int tdmin_clk_get(struct snd_kcontrol *kcontrol,
+// 			struct snd_ctl_elem_value *ucontrol)
+// {
+// 	int clk;
+// 	int value;
+
+// 	clk = meson_clk_measure(70);
+// 	if (clk >= 11000000)
+// 		value = 3;
+// 	else if (clk >= 6000000)
+// 		value = 2;
+// 	else if (clk >= 2000000)
+// 		value = 1;
+// 	else
+// 		value = 0;
+
+
+// 	ucontrol->value.integer.value[0] = value;
+
+// 	return 0;
+// }
+
+/* current sample mode and its sample rate */
+// static const char *const i2sin_clk[] = {
+// 	"0",
+// 	"3000000",
+// 	"6000000",
+// 	"12000000"
+// };
+
+// static const struct soc_enum i2sin_clk_enum[] = {
+// 	SOC_ENUM_SINGLE(SND_SOC_NOPM, 0, ARRAY_SIZE(i2sin_clk),
+// 			i2sin_clk),
+// };
+
+// static const struct snd_kcontrol_new snd_tdm_controls[] = {
+// 	SOC_ENUM_EXT("I2SIn CLK", i2sin_clk_enum,
+// 				tdmin_clk_get,
+// 				NULL),
+// };
+
+// static const struct snd_kcontrol_new snd_tdm_clk_controls[] = {
+// 	SOC_SINGLE_EXT("TDM MCLK Fine Setting",
+// 				0, 0, 2000000, 0,
+// 				tdm_clk_get,
+// 				tdm_clk_set),
+// };
+// static bool dump_ss = true;
+static irqreturn_t aml_tdm_to_ddr_isr(int irq, void *devid)
+{
+	struct audio_dev_context *dev_context = devid;
+	struct audio_rtdm_dev *audio_dev = dev_context->i2s_dev;
+	audio_dev->nsecs = ktime_get_raw_fast_ns();
+	audio_dev->kinterrupts++;
+	audio_dev->buffer_idx = ~(audio_dev->buffer_idx) & 0x1;
+	// if(dump_ss)
+	// 	dump_stack();
+	// dump_ss = false;
+	// Debug
+	// aml_toddr_get_position(dev_context->tdm->tddr);
+	// aml_toddr_ack_irq(dev_context->tdm->tddr,0);
+	evl_raise_flag(&audio_dev->irq_event);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t aml_tdm_from_ddr_isr(int irq, void *devid)
+{
+	//  struct audio_dev_context *dev_context = devid;
+	// struct audio_rtdm_dev *dev = dev_context->i2s_dev;
+
+	// evl_raise_flag(&dev->irq_event);
+	// aml_frddr_ack_irq(dev_context->tdm->fddr,0);
+
+	return IRQ_HANDLED;
+}
+
+/* get counts of '1's in val */
+static unsigned int pop_count(unsigned int val)
+{
+	unsigned int count = 0;
+
+	while (val) {
+		count++;
+		val = val & (val - 1);
+	}
+
+	return count;
+}
+
+// static int snd_soc_of_get_slot_mask(struct device_node *np,
+// 				    const char *prop_name,
+// 				    unsigned int *mask)
+// {
+// 	u32 val;
+// 	const __be32 *of_slot_mask = of_get_property(np, prop_name, &val);
+// 	int i;
+
+// 	if (!of_slot_mask)
+// 		return -EINVAL;
+
+// 	val /= sizeof(u32);
+// 	for (i = 0; i < val; i++)
+// 		if (be32_to_cpup(&of_slot_mask[i]))
+// 			*mask |= (1 << i);
+
+// 	return val;
+// }
+
+int snd_soc_of_get_slot_mask(struct device_node *np,
+			     const char *prop_name,
+			     unsigned int *mask)
+{
+	u32 val;
+	const __be32 *of_slot_mask = of_get_property(np, prop_name, &val);
+	int i;
+
+	if (!of_slot_mask)
+		return 0;
+	val /= sizeof(u32);
+	for (i = 0; i < val; i++)
+		if (be32_to_cpup(&of_slot_mask[i]))
+			*mask |= (1 << i);
+
+	return val;
+}
+
+static int of_parse_tdm_lane_slot_in(struct device_node *np,
+			      unsigned int *lane_mask)
+{
+	if (lane_mask)
+		return snd_soc_of_get_slot_mask(np,
+			"dai-tdm-lane-slot-mask-in", lane_mask);
+
+	return -EINVAL;
+}
+
+static int of_parse_tdm_lane_slot_out(struct device_node *np,
+			      unsigned int *lane_mask)
+{
+	if (lane_mask)
+		return snd_soc_of_get_slot_mask(np,
+			"dai-tdm-lane-slot-mask-out", lane_mask);
+
+	return -EINVAL;
+}
+
+static int of_parse_tdm_lane_oe_slot_in(struct device_node *np,
+			      unsigned int *lane_mask)
+{
+	if (lane_mask)
+		return snd_soc_of_get_slot_mask(np,
+			"dai-tdm-lane-oe-slot-mask-in", lane_mask);
+
+	return -EINVAL;
+}
+
+static int of_parse_tdm_lane_oe_slot_out(struct device_node *np,
+			      unsigned int *lane_mask)
+{
+	if (lane_mask)
+		return snd_soc_of_get_slot_mask(np,
+			"dai-tdm-lane-oe-slot-mask-out", lane_mask);
+
+	return -EINVAL;
+}
+
+static int of_parse_tdm_lane_lb_slot_in(struct device_node *np,
+			      unsigned int *lane_mask)
+{
+	if (lane_mask)
+		return snd_soc_of_get_slot_mask(np,
+			"dai-tdm-lane-lb-slot-mask-in", lane_mask);
+
+	return -EINVAL;
+}
+
+int aml_tdm_open(struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	// struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct device *dev = &dev_context->pdev->dev;
+	struct aml_tdm *p_tdm;
+	int aed_dst_status = 0;
+	pr_info("%s\n", __func__);
+	p_tdm = dev_context->tdm;
+
+	// snd_soc_set_runtime_hwparams(substream, &aml_tdm_hardware);
+
+
+		// int dst_id = get_aed_dst();
+
+
+		// if (dst_id == p_tdm->id)
+		// 	aed_dst_status = true;
+		p_tdm->fddr = aml_audio_register_frddr(dev,
+			p_tdm->actrl, aml_tdm_from_ddr_isr,
+			dev_context, aed_dst_status);
+		if (p_tdm->fddr == NULL) {
+			dev_err(dev, "failed to claim from ddr\n");
+			return -ENXIO;
+		}
+	
+	
+
+		p_tdm->tddr = aml_audio_register_toddr(dev,
+			p_tdm->actrl, aml_tdm_to_ddr_isr, dev_context);
+		if (p_tdm->tddr == NULL) {
+			dev_err(dev, "failed to claim to ddr\n");
+			return -ENXIO;
+		}
+	
+
+	return 0;
+}
+
+int aml_tdm_close(struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	// struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	// struct device *dev = &dev_context->pdev->dev;
+	struct aml_tdm *p_tdm;
+
+	pr_info("%s\n", __func__);
+	p_tdm = dev_context->tdm;
+
+
+
+		aml_audio_unregister_frddr(p_tdm->dev,
+				dev_context);
+	
+		aml_audio_unregister_toddr(p_tdm->dev,
+				dev_context);
+
+	return 0;
+}
+
+// static int aml_tdm_hw_params(struct snd_pcm_substream *substream,
+// 			 struct snd_pcm_hw_params *hw_params)
+// {
+// 	return snd_pcm_lib_malloc_pages(substream,
+// 					params_buffer_bytes(hw_params));
+// }
+
+// static int aml_tdm_hw_free(struct snd_pcm_substream *substream)
+// {
+// 	return snd_pcm_lib_free_pages(substream);
+// }
+
+#define BUFF_SIZE 32
+
+int aml_tdm_prepare(struct file* fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+	struct audio_rtdm_dev * dev = dev_context->i2s_dev;
+	struct audio_rtdm_buffer *i2s_buffer = dev_context->i2s_dev->buffer;
+	struct frddr *fr = p_tdm->fddr;
+	struct toddr *to = p_tdm->tddr;
+
+	unsigned int start_addr_a, end_addr_a, start_addr_b,end_addr_b, int_addr=0;
+	unsigned int rec_start_addr_a, rec_end_addr_a, rec_start_addr_b,rec_end_addr_b, rec_int_addr=0;
+
+	start_addr_a = i2s_buffer->dma;
+	end_addr_a = start_addr_a + (dev->buffer_frame_size*8) - 8;
+	start_addr_b = end_addr_a + 8;
+	end_addr_b = start_addr_b + (dev->buffer_frame_size*8) - 8;
+
+	rec_start_addr_a = i2s_buffer->dma+PAGE_SIZE;
+	rec_end_addr_a = rec_start_addr_a + (dev->buffer_frame_size*8) - 8;
+	// int_addr = rec_start_addr_a + (256*8) - 8;
+	rec_start_addr_b = rec_end_addr_a + 8;
+	rec_end_addr_b = rec_start_addr_b + (dev->buffer_frame_size*8) - 8;
+
+	// int_addr = frames_to_bytes(runtime, runtime->period_size)/8;
+	pr_debug("%s() - Playback Address of A buffer, start = 0x%08x, end = 0x%08x\n",__func__,start_addr_a,end_addr_a);
+	pr_debug("%s() - Playback Address of B buffer, start = 0x%08x, end = 0x%08x\n",__func__,start_addr_b,end_addr_b);
+	pr_debug("%s() - Capture Address of A buffer, start = 0x%08x, end = 0x%08x\n",__func__,rec_start_addr_a,rec_end_addr_a);
+	pr_debug("%s() - Capture Address of B buffer, start = 0x%08x, end = 0x%08x\n",__func__,rec_start_addr_b,rec_end_addr_b);
+
+		if (p_tdm->chipinfo && p_tdm->chipinfo->async_fifo) {
+			int offset = p_tdm->chipinfo->reset_reg_offset;
+
+			pr_debug("%s(), reset fddr\n", __func__);
+			aml_frddr_reset(p_tdm->fddr, offset);
+			aml_tdm_out_reset(p_tdm->id, offset);
+
+			if (p_tdm->chipinfo->same_src_fn
+				&& (p_tdm->samesource_sel >= 0)
+				&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+					p_tdm->samesource_sel))
+				&& p_tdm->en_share)
+				aml_spdif_out_reset(p_tdm->samesource_sel - 3,
+						offset);
+		}
+		aml_frddr_set_buf(fr, start_addr_a, end_addr_a,start_addr_b, end_addr_b);
+		aml_frddr_set_intrpt(fr, int_addr);
+	
+		// Capture
+
+
+		aml_toddr_set_buf(to, rec_start_addr_a, rec_end_addr_a,rec_start_addr_b,rec_end_addr_b);
+		aml_toddr_set_intrpt(to, rec_int_addr);
+	
+
+	return 0;
+}
+
+unsigned int  aml_tdm_pointer(struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+
+
+		return aml_frddr_get_position(p_tdm->fddr);
+
+}
+
+unsigned int  aml_tdm_pointer_tddr(struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+
+
+		return aml_toddr_get_position(p_tdm->tddr);
+
+}
+
+// static int aml_tdm_mmap(struct snd_pcm_substream *substream,
+// 			struct vm_area_struct *vma)
+// {
+// 	return snd_pcm_lib_default_mmap(substream, vma);
+// }
+
+// static struct snd_pcm_ops aml_tdm_ops = {
+// 	.open = aml_tdm_open,
+// 	.close = aml_tdm_close,
+// 	.ioctl = snd_pcm_lib_ioctl,
+// 	.hw_params = aml_tdm_hw_params,
+// 	.hw_free = aml_tdm_hw_free,
+// 	.prepare = aml_tdm_prepare,
+// 	.pointer = aml_tdm_pointer,
+// 	.mmap = aml_tdm_mmap,
+// };
+
+// #define PREALLOC_BUFFER		(256 * 1024)
+// #define PREALLOC_BUFFER_MAX	(256 * 1024)
+// static int aml_tdm_new(struct snd_soc_pcm_runtime *rtd)
+// {
+// 	snd_pcm_lib_preallocate_pages_for_all(
+// 		rtd->pcm, SNDRV_DMA_TYPE_DEV,
+// 		rtd->card->snd_card->dev, PREALLOC_BUFFER, PREALLOC_BUFFER_MAX);
+// 	return 0;
+// }
+
+// struct snd_soc_platform_driver aml_tdm_platform = {
+// 	.ops = &aml_tdm_ops,
+// 	.pcm_new = aml_tdm_new,
+// };
+
+
+
+int aml_dai_tdm_prepare(struct file *fd )
+{
+	// struct snd_pcm_runtime *runtime = substream->runtime;
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+	int bit_depth = 32;
+	struct frddr *fr = p_tdm->fddr;
+	enum frddr_dest dst;
+	unsigned int fifo_id;
+	struct toddr *to = p_tdm->tddr;
+	enum toddr_src src;
+	unsigned int lsb = 32 - bit_depth;
+	unsigned int toddr_type;
+	struct toddr_fmt fmt;
+	// bit_depth = snd_pcm_format_width(runtime->format);
+
+	// if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+
+		/* share buffer prepare */
+		if (p_tdm->chipinfo &&
+			p_tdm->chipinfo->same_src_fn
+			&& (p_tdm->samesource_sel >= 0)
+			&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+				p_tdm->samesource_sel))
+			&& p_tdm->en_share) {
+				sharebuffer_prepare(
+					fr, p_tdm->samesource_sel,
+					p_tdm->lane_ss,
+					p_tdm->chipinfo->reset_reg_offset, p_tdm->setting.lrclk);
+		// 			/* sharebuffer default uses spdif_a */
+				// spdif_set_audio_clk(p_tdm->samesource_sel - 3,
+				// 	p_tdm->clk,
+				// 	(p_tdm->last_mclk_freq >> 1), 1);
+		}
+
+		/* i2s source to hdmix */
+		if (p_tdm->i2s2hdmitx) {
+		 	i2s_to_hdmitx_ctrl(p_tdm->id);
+		// 	aout_notifier_call_chain(AOUT_EVENT_IEC_60958_PCM,
+		// 		substream);
+		}
+
+		fifo_id = aml_frddr_get_fifo_id(fr);
+		aml_tdm_fifo_ctrl(p_tdm->actrl,
+			bit_depth,
+			p_tdm->id,
+			fifo_id);
+
+		switch (p_tdm->id) {
+		case 0:
+			dst = TDMOUT_A;
+			break;
+		case 1:
+			dst = TDMOUT_B;
+			break;
+		case 2:
+			dst = TDMOUT_C;
+			break;
+		default:
+			dev_err(p_tdm->dev,	"invalid id: %d\n",
+					p_tdm->id);
+			return -EINVAL;
+		}
+		aml_frddr_set_format(fr,
+			0,
+			bit_depth - 1,
+			tdmout_get_frddr_type(bit_depth));
+		aml_frddr_select_dst(fr, dst);
+		aml_frddr_set_fifos(fr, 0x20, 0x10);
+
+	// } else {
+
+
+		// if (vad_tdm_is_running(p_tdm->id)
+		// 	&& pm_audio_is_suspend())
+		// 	return 0;
+
+		switch (bit_depth) {
+		case 8:
+		case 16:
+		case 32:
+			toddr_type = 0;
+			break;
+		case 24:
+			toddr_type = 4;
+			break;
+		default:
+			dev_err(p_tdm->dev, "invalid bit_depth: %d\n",
+					bit_depth);
+			return -EINVAL;
+		}
+
+		dev_info(p_tdm->dev, "tdm prepare capture\n");
+		switch (p_tdm->id) {
+		case 0:
+			src = TDMIN_A;
+		break;
+		case 1:
+			src = TDMIN_B;
+		break;
+		case 2:
+			src = TDMIN_C;
+		break;
+		case 3:
+			src = TDMIN_LB;
+		break;
+		default:
+			dev_err(p_tdm->dev, "invalid id: %d\n",
+					p_tdm->id);
+			return -EINVAL;
+		}
+
+		// if (toddr_src_get() == FRHDMIRX) {
+		// 	src = FRHDMIRX;
+
+		// 	aml_update_tdmin_src(p_tdm->actrl,
+		// 		p_tdm->id,
+		// 		HDMIRX_I2S);
+		// }  else if (p_tdm->chipinfo
+		// 	&& p_tdm->chipinfo->adc_fn
+		// 	&& p_tdm->acodec_adc)
+		// 	aml_update_tdmin_src(p_tdm->actrl,
+		// 		p_tdm->id,
+		// 		ACODEC_ADC);
+
+		// pr_info("%s Expected toddr src:%s\n",
+		// 	__func__,
+		// 	toddr_src_get_str(src));
+
+		fmt.type      = toddr_type;
+		fmt.msb       = 31;
+		fmt.lsb       = lsb;
+		fmt.endian    = 0;
+		fmt.bit_depth = bit_depth;
+		fmt.ch_num    = 0;
+		fmt.rate      = DEFAULT_AUDIO_SAMPLING_RATE;
+		aml_toddr_select_src(to, src);
+		aml_toddr_set_format(to, &fmt);
+		aml_toddr_set_fifos(to, 0x3);
+	// }
+
+	return 0;
+}
+
+int aml_dai_tdm_trigger(struct file* fd, int cmd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+	bool toddr_stopped = false;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+
+		// if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		// 	&& vad_tdm_is_running(p_tdm->id)
+		// 	&& pm_audio_is_suspend()) {
+		// 	pm_audio_set_suspend(false);
+		// 	/* VAD switch to alsa buffer */
+		// 	// vad_update_buffer(0);
+		// 	break;
+		// }
+
+		/* reset fifo here.
+		 * If not, xrun will cause channel mapping mismatch
+		 */
+		aml_tdm_fifo_reset(p_tdm->actrl, p_tdm->id);
+
+		// if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* output START sequence:
+			 * 1. Frddr/TDMOUT/SPDIF reset(may cause the AVR mute)
+			 * 2. ctrl0 set to 0
+			 * 3. TDMOUT enable
+			 * 4. SPDIFOUT enable
+			 * 5. FRDDR enable
+			 */
+			dev_info(&dev_context->pdev->dev, "tdm playback enable\n");
+			/*don't change this flow*/
+			// aml_aed_top_enable(p_tdm->fddr, true);
+			aml_tdm_enable(p_tdm->actrl, SNDRV_PCM_STREAM_PLAYBACK,
+				 p_tdm->id, true);
+			if (p_tdm->chipinfo
+				&& p_tdm->chipinfo->same_src_fn
+				&& (p_tdm->samesource_sel >= 0)
+				&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+						p_tdm->samesource_sel))
+				&& p_tdm->en_share)
+				sharebuffer_trigger(cmd,
+					p_tdm->samesource_sel,
+					p_tdm->chipinfo->same_src_spdif_reen);
+
+			aml_frddr_enable(p_tdm->fddr, true);
+			udelay(100);
+			aml_tdmout_enable_gain(p_tdm->id, false);
+			if (p_tdm->chipinfo
+				&& p_tdm->chipinfo->same_src_fn
+				&& (p_tdm->samesource_sel >= 0)
+				&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+						p_tdm->samesource_sel))
+				&& p_tdm->en_share) {
+				aml_spdifout_mute_without_actrl(0, false);
+			}
+
+		// } else {
+			// Temporary debug
+			dev_info(&dev_context->pdev->dev, "tdm capture enable\n");
+			aml_toddr_enable(p_tdm->tddr, true);
+			aml_tdm_enable(p_tdm->actrl, SNDRV_PCM_STREAM_CAPTURE,
+				 p_tdm->id, true);
+		
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		// if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		// 	&& vad_tdm_is_running(p_tdm->id)
+		// 	&& pm_audio_is_suspend()) {
+		// 	/* switch to VAD buffer */
+		// 	// vad_update_buffer(1);
+		// 	break;
+		// }
+
+		// if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			/* output STOP sequence:
+			 * 1. TDMOUT->muteval
+			 * 2. SPDIFOUT->muteval
+			 * 3. TDMOUT/SPDIF Disable
+			 * 4. FRDDR Disable
+			 */
+			dev_info(&dev_context->pdev->dev, "tdm playback stop\n");
+			/*don't change this flow*/
+			aml_tdmout_enable_gain(p_tdm->id, true);
+			if (p_tdm->chipinfo
+				&& p_tdm->chipinfo->same_src_fn
+				&& (p_tdm->samesource_sel >= 0)
+				&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+						p_tdm->samesource_sel))
+				&& p_tdm->en_share) {
+				aml_spdifout_mute_without_actrl(0, true);
+			}
+//			aml_aed_top_enable(p_tdm->fddr, false);
+			aml_tdm_enable(p_tdm->actrl,SNDRV_PCM_STREAM_PLAYBACK,
+				 p_tdm->id, false);
+			if (p_tdm->chipinfo	&& p_tdm->chipinfo->same_src_fn
+				&& (p_tdm->samesource_sel >= 0)
+				&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+						p_tdm->samesource_sel))
+				&& p_tdm->en_share)
+				sharebuffer_trigger(cmd,
+					p_tdm->samesource_sel,
+					p_tdm->chipinfo->same_src_spdif_reen);
+
+			if (p_tdm->chipinfo	&&
+				p_tdm->chipinfo->async_fifo)
+				aml_frddr_check(p_tdm->fddr);
+
+			aml_frddr_enable(p_tdm->fddr, false);
+		// } else {
+
+			aml_tdm_enable(p_tdm->actrl,SNDRV_PCM_STREAM_CAPTURE,
+				 p_tdm->id, false);
+			dev_info(&dev_context->pdev->dev, "tdm capture stop\n");
+
+			toddr_stopped = aml_toddr_burst_finished(p_tdm->tddr);
+			if (toddr_stopped)
+				aml_toddr_enable(p_tdm->tddr, false);
+			else
+				pr_err("%s(), toddr may be stuck\n", __func__);
+		// }
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int pcm_setting_init(struct pcm_setting *setting, unsigned int rate,
+			unsigned int channels)
+{
+	unsigned int ratio = 0;
+
+	setting->lrclk = rate;
+	setting->bclk_lrclk_ratio = setting->slots * setting->slot_width;
+	setting->bclk = setting->lrclk * setting->bclk_lrclk_ratio;
+
+	/* calculate mclk */
+	if (setting->pcm_mode == SND_SOC_DAIFMT_DSP_A ||
+		setting->pcm_mode == SND_SOC_DAIFMT_DSP_B) {
+		/* for some TDM codec, mclk limites */
+		ratio = 2;
+	}
+	else
+	{
+		ratio = 4;
+	}
+	setting->sysclk_bclk_ratio = ratio;
+	setting->sysclk = ratio * setting->bclk;
+
+	return 0;
+}
+static int aml_tdm_set_lanes(struct aml_tdm *p_tdm,
+				unsigned int channels, int stream)
+{
+	struct pcm_setting *setting = &p_tdm->setting;
+	unsigned int lanes, swap_val = 0, swap_val1 = 0;
+	unsigned int lane_mask;
+	unsigned int set_num = 0;
+	unsigned int i;
+
+	/* calc lanes by channels and slots */
+	lanes = (channels - 1) / setting->slots + 1;
+	if (lanes > p_tdm->lane_cnt) {
+		pr_err("set lane error! asoc channels:%d, slots:%d, lane_cnt:%d\n",
+		channels, setting->slots, p_tdm->lane_cnt);
+		return -EINVAL;
+	}
+
+#if 1
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* set lanes mask acordingly */
+		lane_mask = setting->lane_mask_out;
+		/* compatible using oe masks */
+		if (!lane_mask && setting->lane_oe_mask_out)
+			lane_mask = setting->lane_oe_mask_out;
+
+		for (i = 0; i < p_tdm->lane_cnt; i++) {
+			if (((1 << i) & lane_mask) && lanes) {
+				aml_tdm_set_channel_mask(p_tdm->actrl,
+					stream, p_tdm->id, i, setting->tx_mask);
+				lanes--;
+			}
+		}
+		swap_val = 0x76543210;
+		if (p_tdm->lane_cnt > LANE_MAX1)
+			swap_val1 = 0xfedcba98;
+		aml_tdm_set_lane_channel_swap(p_tdm->actrl,
+			stream, p_tdm->id, swap_val, swap_val1);
+	} else {
+		if (p_tdm->chipinfo
+			&& p_tdm->chipinfo->oe_fn
+			&& p_tdm->setting.lane_oe_mask_in)
+			lane_mask = setting->lane_oe_mask_in;
+		else
+			lane_mask = setting->lane_mask_in;
+
+		for (i = 0; i < p_tdm->lane_cnt; i++) {
+			if (i < lanes)
+				aml_tdm_set_channel_mask(p_tdm->actrl,
+					stream, p_tdm->id, i, setting->rx_mask);
+			if (((1 << i) & lane_mask) && (i < LANE_MAX1)) {
+				/* each lane only L/R masked */
+				pr_debug("tdmin set lane %d\n", i);
+				swap_val |= (i * 2) <<
+						(set_num++ * LANE_MAX1);
+				swap_val |= (i * 2 + 1) <<
+						(set_num++ * LANE_MAX1);
+			}
+			if (((1 << i) & lane_mask) && (i >= LANE_MAX1)
+					&& (i < LANE_MAX3)) {
+				/* each lane only L/R masked */
+				pr_debug("tdmin set lane %d\n", i);
+				swap_val1 |= (i * 2) <<
+						(set_num++ * LANE_MAX1);
+				swap_val1 |= (i * 2 + 1) <<
+						(set_num++ * LANE_MAX1);
+			}
+		}
+
+		aml_tdm_set_lane_channel_swap(p_tdm->actrl,
+			stream, p_tdm->id, swap_val, swap_val1);
+	}
+
+#else
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (p_tdm->chipinfo
+			&& p_tdm->chipinfo->oe_fn
+			&& p_tdm->setting.lane_oe_mask_out)
+			lane_mask = setting->lane_oe_mask_out;
+		else
+			lane_mask = setting->lane_mask_out;
+	} else {
+		if (p_tdm->chipinfo
+			&& p_tdm->chipinfo->oe_fn
+			&& p_tdm->setting.lane_oe_mask_in)
+			lane_mask = setting->lane_oe_mask_in;
+		else
+			lane_mask = setting->lane_mask_in;
+	}
+
+	/* lane mask */
+	for (i = 0; i < 4; i++) {
+		if (((1 << i) & lane_mask) && lanes) {
+			aml_tdm_set_channel_mask(p_tdm->actrl,
+				stream, p_tdm->id, i, setting->tx_mask);
+			lanes--;
+		}
+	}
+
+	/* channel swap */
+	for (i = 0; i < p_tdm->lane_cnt; i++) {
+		if ((1 << i) & lane_mask) {
+			swap0_val |= (1 << (2 * i)) - 1;
+			lane_chs += 1;
+			if (lane_chs >= channels)
+				break;
+			swap0_val |= (1 << (2 * i + 1)) - 1;
+			lane_chs += 1;
+			if (lane_chs >= channels)
+				break;
+
+			if (i >= LANE_MAX1) {
+				swap1_val |= (1 << (2 * (i - LANE_MAX1))) - 1;
+				lane_chs += 1;
+				if (lane_chs >= channels)
+					break;
+				swap1_val |= (1 << (2 * (i - LANE_MAX1) + 1))
+								- 1;
+				lane_chs += 1;
+				if (lane_chs >= channels)
+					break;
+			}
+		}
+	}
+	aml_tdm_set_lane_channel_swap(p_tdm->actrl,
+		stream, p_tdm->id, swap0_val, swap1_val);
+#endif
+	return 0;
+}
+
+static int aml_tdm_set_clk_pad(struct aml_tdm *p_tdm)
+{
+	int mpad_offset = 0;
+	/* mclk pad
+	 * does mclk need?
+	 * mclk from which mclk source,  mclk_a/b/c/d/e/f
+	 * mclk pad controlled by dts, mclk source according to id
+	 */
+	if (p_tdm->chipinfo && (!p_tdm->chipinfo->mclkpad_no_offset))
+		mpad_offset = 1;
+
+	if (p_tdm->mclk_pad >= 0) {
+		aml_tdm_mclk_pad_select(p_tdm->actrl,
+					p_tdm->mclk_pad,
+					mpad_offset,
+					p_tdm->clk_sel);
+	}
+
+	aml_tdm_sclk_pad_select(p_tdm->actrl,
+				mpad_offset,
+				p_tdm->id,
+				p_tdm->id);
+
+	return 0;
+}
+
+int aml_dai_tdm_hw_params(struct file *fd,
+				unsigned int rate
+				)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+	struct pcm_setting *setting = &p_tdm->setting;
+	unsigned int channels = 2;
+	int ret;
+
+	ret = pcm_setting_init(setting, rate, channels);
+	if (ret)
+		return ret;
+
+	dump_pcm_setting(setting);
+
+	/* set pcm dai hw params */
+	// TODO: add clk_id
+	aml_dai_set_tdm_sysclk(p_tdm,
+		0, setting->sysclk, SND_SOC_CLOCK_OUT);
+	ret = aml_dai_set_clkdiv(p_tdm, 0, setting->sysclk_bclk_ratio);
+	if (ret)
+		return ret;
+
+	ret = aml_dai_set_bclk_ratio(p_tdm, setting->bclk_lrclk_ratio);
+	if (ret)
+		return ret;
+
+	ret = aml_tdm_set_lanes(p_tdm, channels, 0);
+	if (ret)
+		return ret;
+	ret = aml_tdm_set_lanes(p_tdm, channels, 1);
+	if (ret)
+		return ret;
+	if (p_tdm->chipinfo && (!p_tdm->chipinfo->no_mclkpad_ctrl)) {
+		ret = aml_tdm_set_clk_pad(p_tdm);
+		if (ret)
+			return ret;
+	}
+
+	// /* Must enabe channel number for VAD */
+	// if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	// 	&& (vad_tdm_is_running(p_tdm->id)))
+	// 	tdmin_set_chnum_en(p_tdm->actrl, p_tdm->id, true);
+
+	/* share buffer trigger */
+	if (
+		 p_tdm->chipinfo
+		&& (p_tdm->chipinfo->same_src_fn)
+		&& (p_tdm->samesource_sel >= 0)
+		&& (aml_check_sharebuffer_valid(p_tdm->fddr,
+				p_tdm->samesource_sel))
+		&& p_tdm->en_share) {
+#if 1
+		int mux = 0, ratio = 0;
+
+			sharebuffer_get_mclk_fs_ratio(p_tdm->samesource_sel,
+				&mux, &ratio);
+			pr_info("samesource sysclk:%d\n", rate * ratio * mux);
+			if (!IS_ERR(p_tdm->samesrc_srcpll)) {
+				clk_set_rate(p_tdm->samesrc_srcpll,
+					rate * ratio * mux);
+				clk_prepare_enable(p_tdm->samesrc_srcpll);
+			}
+			if (!IS_ERR(p_tdm->samesrc_clk)) {
+				clk_set_rate(p_tdm->samesrc_clk,
+					rate * ratio);
+				clk_prepare_enable(p_tdm->samesrc_clk);
+			}
+#endif
+	}
+
+	if (!p_tdm->contns_clk && !IS_ERR(p_tdm->mclk)) {
+		pr_debug("%s(), enable mclk for\n", __func__);
+		ret = clk_prepare_enable(p_tdm->mclk);
+		if (ret) {
+			pr_err("Can't enable mclk: %d\n", ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+int aml_dai_tdm_hw_free(
+				struct file *fd)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+	struct frddr *fr = p_tdm->fddr;
+	int i;
+
+	for (i = 0; i < p_tdm->lane_cnt; i++)
+		aml_tdm_set_channel_mask(p_tdm->actrl,
+			0, p_tdm->id, i, 0);
+
+	// /* Disable channel number for VAD */
+	// if ((substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	// 	&& (vad_tdm_is_running(p_tdm->id)))
+	// 	tdmin_set_chnum_en(p_tdm->actrl, p_tdm->id, false);
+
+	/* share buffer free */
+	if (
+		p_tdm->chipinfo
+		&& p_tdm->chipinfo->same_src_fn
+		&& (p_tdm->samesource_sel >= 0)
+		&& fr
+		&& (aml_check_sharebuffer_valid(fr, p_tdm->samesource_sel))
+		&& p_tdm->en_share) {
+			sharebuffer_free(
+				fr, p_tdm->samesource_sel);
+	}
+
+	/* disable clock and gate */
+	if (!p_tdm->contns_clk && !IS_ERR(p_tdm->mclk)) {
+		pr_info("%s(), disable mclk for", __func__);
+		clk_disable_unprepare(p_tdm->mclk);
+	}
+
+	return 0;
+}
+
+int aml_dai_set_tdm_fmt(struct file *fd, unsigned int fmt)
+{
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+
+	pr_debug("asoc aml_dai_set_tdm_fmt, %#x, %p, id(%d), clksel(%d)\n",
+		fmt, p_tdm, p_tdm->id, p_tdm->clk_sel);
+	if (p_tdm->last_fmt == fmt) {
+		pr_debug("%s(), fmt not change\n", __func__);
+		goto capture;
+	} else
+		p_tdm->last_fmt = fmt;
+
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SND_SOC_DAIFMT_CONT:
+		p_tdm->contns_clk = true;
+		break;
+	case SND_SOC_DAIFMT_GATED:
+		p_tdm->contns_clk = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (p_tdm->chipinfo)
+		p_tdm->setting.sclk_ws_inv = p_tdm->chipinfo->sclk_ws_inv;
+
+	aml_tdm_set_format(p_tdm->actrl,
+		&(p_tdm->setting), p_tdm->clk_sel, p_tdm->id, fmt,
+		1, 1);
+	if (p_tdm->contns_clk && !IS_ERR(p_tdm->mclk)) {
+		int ret = clk_prepare_enable(p_tdm->mclk);
+
+		if (ret) {
+			pr_err("Can't enable mclk: %d\n", ret);
+			return ret;
+		}
+	}
+
+capture:
+	/* update skew for ACODEC_ADC */
+	// if (cpu_dai->capture_active
+	// 	&& p_tdm->chipinfo
+	// 	&& p_tdm->chipinfo->adc_fn
+	// 	&& p_tdm->acodec_adc){
+		// aml_update_tdmin_skew(p_tdm->actrl, p_tdm->id, 4);
+		// aml_update_tdmin_rev_ws(p_tdm->actrl, p_tdm->id, 0);
+	// }
+
+	return 0;
+}
+
+/* mpll clk range from 5M to 500M */
+#define AML_MPLL_FREQ_MIN	5000000
+static unsigned int aml_mpll_mclk_ratio(unsigned int freq)
+{
+	unsigned int i, ratio = 2;
+	unsigned int mpll_freq = 0;
+
+	for (i = 1; i < 15; i++) {
+		ratio = 1 << i;
+		mpll_freq = freq * ratio;
+
+		if (mpll_freq > AML_MPLL_FREQ_MIN)
+			break;
+	}
+
+	return ratio;
+}
+
+static int aml_dai_set_tdm_sysclk(struct aml_tdm *p_tdm,
+				int clk_id, unsigned int freq, int dir)
+{
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned int ratio = aml_mpll_mclk_ratio(freq);
+	unsigned int mpll_freq = 0;
+
+	p_tdm->setting.sysclk = freq;
+
+#ifdef __PTM_TDM_CLK__
+	if (p_tdm->id == 0)
+		ratio = 14;
+	else if (p_tdm->id == 1)
+		ratio = 18 * 2;
+	else if (p_tdm->id == 2)
+		ratio = 20;
+#endif
+
+	mpll_freq = freq * ratio;
+	if (mpll_freq != p_tdm->last_mpll_freq) {
+		clk_set_rate(p_tdm->clk, mpll_freq);
+		p_tdm->last_mpll_freq = mpll_freq;
+	} else {
+		pr_debug("%s(), mpll no change, keep clk\n", __func__);
+	}
+
+	if (freq != p_tdm->last_mclk_freq) {
+		clk_set_rate(p_tdm->mclk, freq);
+		p_tdm->last_mclk_freq = freq;
+	} else {
+		pr_debug("%s(), mclk no change, keep clk\n", __func__);
+	}
+
+	pr_debug("set mclk:%d, mpll:%d, get mclk:%lu, mpll:%lu\n",
+		freq,
+		freq * ratio,
+		clk_get_rate(p_tdm->mclk),
+		clk_get_rate(p_tdm->clk));
+
+	return 0;
+}
+
+static int aml_dai_set_bclk_ratio(struct aml_tdm *p_tdm,
+						unsigned int ratio)
+{
+	unsigned int bclk_ratio, lrclk_hi;
+
+	p_tdm->setting.bclk_lrclk_ratio = ratio;
+	bclk_ratio = ratio - 1;
+	lrclk_hi = 0;
+
+	if (p_tdm->setting.pcm_mode == SND_SOC_DAIFMT_I2S ||
+		p_tdm->setting.pcm_mode == SND_SOC_DAIFMT_LEFT_J) {
+		pr_debug("aml_dai_set_bclk_ratio, select I2S mode\n");
+		lrclk_hi = bclk_ratio / 2;
+	} else {
+		pr_debug("aml_dai_set_bclk_ratio, select TDM mode\n");
+	}
+	aml_tdm_set_bclk_ratio(p_tdm->actrl,
+		p_tdm->clk_sel, lrclk_hi, bclk_ratio);
+
+	return 0;
+}
+
+static int aml_dai_set_clkdiv(struct aml_tdm *p_tdm,
+						int div_id, int div)
+{
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+	unsigned int mclk_ratio;
+
+	pr_debug("aml_dai_set_clkdiv, div %d, clksel(%d)\n",
+			div, p_tdm->clk_sel);
+
+	p_tdm->setting.sysclk_bclk_ratio = div;
+	mclk_ratio = div - 1;
+	aml_tdm_set_lrclkdiv(p_tdm->actrl, p_tdm->clk_sel, mclk_ratio);
+
+	return 0;
+}
+
+int aml_dai_set_tdm_slot(struct aml_tdm *p_tdm,
+				unsigned int tx_mask, unsigned int rx_mask,
+				int slots, int slot_width)
+{
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+	// struct snd_soc_dai_driver *drv = cpu_dai->driver;
+	unsigned int lanes_out_cnt = 0, lanes_in_cnt = 0;
+	unsigned int lanes_oe_out_cnt = 0, lanes_oe_in_cnt = 0;
+	unsigned int force_oe = 0, oe_val = 0;
+	unsigned int lanes_lb_cnt = 0;
+	int out_lanes = 0, in_lanes = 0;
+	int in_src = -1;
+
+	lanes_out_cnt = pop_count(p_tdm->setting.lane_mask_out);
+	lanes_in_cnt = pop_count(p_tdm->setting.lane_mask_in);
+	lanes_lb_cnt = pop_count(p_tdm->setting.lane_lb_mask_in);
+
+	pr_debug("%s(), txmask(%#x), rxmask(%#x)\n",
+		__func__, tx_mask, rx_mask);
+	pr_debug("\tlanes_out_cnt(%d), lanes_in_cnt(%d)\n",
+		lanes_out_cnt, lanes_in_cnt);
+	pr_debug("\tlanes_lb_cnt(%d)\n",
+		lanes_lb_cnt);
+	pr_debug("\tslots(%d), slot_width(%d)\n",
+		slots, slot_width);
+
+	p_tdm->setting.tx_mask = tx_mask;
+	p_tdm->setting.rx_mask = rx_mask;
+	p_tdm->setting.slots = slots;
+	p_tdm->setting.slot_width = slot_width;
+
+	if (p_tdm->setting.lane_mask_in
+			& p_tdm->setting.lane_lb_mask_in)
+		pr_err("pin(%x) should be selected for only one usage\n",
+			p_tdm->setting.lane_mask_in
+				& p_tdm->setting.lane_lb_mask_in);
+
+	if (p_tdm->chipinfo && p_tdm->chipinfo->oe_fn) {
+		if (p_tdm->setting.lane_mask_out
+				& p_tdm->setting.lane_oe_mask_out)
+			pr_err("pin(%x) should be selected for only one usage\n",
+				p_tdm->setting.lane_mask_out
+					& p_tdm->setting.lane_oe_mask_out);
+
+		if ((p_tdm->setting.lane_mask_in
+				& p_tdm->setting.lane_oe_mask_in)
+			|| (p_tdm->setting.lane_lb_mask_in
+				& p_tdm->setting.lane_oe_mask_in))
+			pr_err("pin(%x:%x) should be selected for only one usage\n",
+				p_tdm->setting.lane_mask_in
+					& p_tdm->setting.lane_oe_mask_in,
+				p_tdm->setting.lane_lb_mask_in
+					& p_tdm->setting.lane_oe_mask_in);
+
+		lanes_oe_out_cnt = pop_count(p_tdm->setting.lane_oe_mask_out);
+		lanes_oe_in_cnt = pop_count(p_tdm->setting.lane_oe_mask_in);
+		pr_debug
+			("\tlanes_oe_out_cnt(%d), lanes_oe_in_cnt(%d)\n",
+			lanes_oe_out_cnt, lanes_oe_in_cnt);
+
+		if (lanes_oe_out_cnt) {
+			unsigned int oe_fn_version = p_tdm->chipinfo->oe_fn;
+
+			force_oe = (1 << p_tdm->chipinfo->lane_cnt) - 1;
+			oe_val = p_tdm->setting.lane_oe_mask_out;
+			if (oe_fn_version == OE_FUNCTION_V1) {
+				aml_tdm_set_oe_v1
+					(p_tdm->actrl, p_tdm->id,
+					force_oe, oe_val);
+			} else if (oe_fn_version == OE_FUNCTION_V2) {
+				aml_tdm_set_oe_v2
+					(p_tdm->actrl, p_tdm->id,
+					force_oe, oe_val);
+			} else {
+				pr_err
+					("%s(), oe version(%d) not support\n",
+					__func__, oe_fn_version);
+			}
+		}
+
+		if (lanes_lb_cnt)
+			in_src = p_tdm->tdmin_lb_src;
+		if (lanes_oe_in_cnt)
+			in_src = p_tdm->id + 3;
+		if (lanes_in_cnt)
+			in_src = p_tdm->id;
+	} else {
+		if (lanes_lb_cnt)
+			in_src = p_tdm->tdmin_lb_src;
+		if (lanes_in_cnt && lanes_in_cnt <= 4)
+			in_src = p_tdm->id;
+		if (in_src > 5) {
+			pr_err("unknown src(%d) for tdmin\n", in_src);
+			return -EINVAL;
+		}
+	}
+
+	out_lanes = lanes_out_cnt;
+	in_lanes = lanes_in_cnt + lanes_oe_in_cnt + lanes_lb_cnt;
+
+	if (p_tdm->chipinfo
+		&& p_tdm->chipinfo->adc_fn
+		&& p_tdm->acodec_adc) {
+		in_src = ACODEC_ADC;
+	}
+
+	if (in_lanes > 0 && in_lanes <= LANE_MAX3)
+		aml_tdm_set_slot_in(p_tdm->actrl,
+			p_tdm->id, in_src, slot_width);
+
+	if (out_lanes > 0 && out_lanes <= LANE_MAX3)
+		aml_tdm_set_slot_out(p_tdm->actrl,
+			p_tdm->id, slots, slot_width);
+
+	/* constrains hw channels_max by DTS configs */
+	// drv->playback.channels_max = slots * out_lanes;
+	// drv->capture.channels_max = slots * in_lanes;
+
+	return 0;
+}
+
+int aml_dai_tdm_probe(struct aml_tdm *p_tdm)
+{
+	// int ret = 0;
+	// struct aml_tdm *p_tdm = snd_soc_dai_get_drvdata(cpu_dai);
+
+	// ret = snd_soc_add_dai_controls(cpu_dai, snd_tdm_controls,
+	// // 				ARRAY_SIZE(snd_tdm_controls));
+	// if (ret < 0)
+	// 	pr_err("%s, failed add snd tdm controls\n", __func__);
+
+	// if (p_tdm->clk_tuning_enable == 1) {
+	// 	ret = snd_soc_add_dai_controls(cpu_dai,
+	// 			snd_tdm_clk_controls,
+	// 			ARRAY_SIZE(snd_tdm_clk_controls));
+	// 	if (ret < 0)
+	// 		pr_err("%s, failed add snd tdm clk controls\n",
+	// 			__func__);
+	// }
+
+	/* config ddr arb */
+	aml_tdm_arb_config(p_tdm->actrl);
+
+	return 0;
+}
+
+// static int aml_dai_tdm_remove(struct snd_soc_dai *cpu_dai)
+// {
+
+// 	return 0;
+// }
+
+ int aml_dai_tdm_mute_stream(struct file *fd,
+				int mute, int stream)
+{
+	struct audio_dev_context *dev_context = get_audio_dev_context(fd);
+	struct aml_tdm *p_tdm = dev_context->tdm;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_debug("tdm playback mute: %d, lane_cnt = %d\n",
+				mute, p_tdm->lane_cnt);
+		//aml_tdm_mute_playback(p_tdm->actrl, p_tdm->id,
+		//		mute, p_tdm->lane_cnt);
+	} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+		pr_debug("tdm capture mute: %d\n", mute);
+		aml_tdm_mute_capture(p_tdm->actrl, p_tdm->id,
+				mute, p_tdm->lane_cnt);
+	}
+	return 0;
+}
+
+static int aml_set_default_tdm_clk(struct aml_tdm *tdm)
+{
+	unsigned int mclk = 12288000;
+	unsigned int ratio = aml_mpll_mclk_ratio(mclk);
+	unsigned int lrclk_hi;
+	unsigned int pll = mclk * ratio;
+
+	/*set default i2s clk for codec sequence*/
+	tdm->setting.bclk_lrclk_ratio = 64;
+	tdm->setting.sysclk_bclk_ratio = 128;
+	lrclk_hi = tdm->setting.bclk_lrclk_ratio - 1;
+
+	aml_tdm_set_lrclkdiv(tdm->actrl, tdm->clk_sel,
+		tdm->setting.sysclk_bclk_ratio - 1);
+
+	aml_tdm_set_bclk_ratio(tdm->actrl,
+		tdm->clk_sel, lrclk_hi/2, lrclk_hi);
+
+	clk_prepare_enable(tdm->mclk);
+	clk_set_rate(tdm->clk, pll);
+	clk_set_rate(tdm->mclk, mclk);
+
+	tdm->last_mclk_freq = mclk;
+	tdm->last_mpll_freq = pll;
+
+	return 0;
+}
+
+
+// static struct snd_soc_dai_ops aml_dai_tdm_ops = {
+// 	.prepare = aml_dai_tdm_prepare,
+// 	.trigger = aml_dai_tdm_trigger,
+// 	.hw_params = aml_dai_tdm_hw_params,
+// 	.hw_free = aml_dai_tdm_hw_free,
+// 	.set_fmt = aml_dai_set_tdm_fmt,
+// 	.set_sysclk = aml_dai_set_tdm_sysclk,
+// 	.set_bclk_ratio = aml_dai_set_bclk_ratio,
+// 	.set_clkdiv = aml_dai_set_clkdiv,
+// 	.set_tdm_slot = aml_dai_set_tdm_slot,
+// 	.mute_stream = aml_dai_tdm_mute_stream,
+// };
+
+#define AML_DAI_TDM_RATES		(SNDRV_PCM_RATE_8000_192000)
+#define AML_DAI_TDM_FORMATS		(SNDRV_PCM_FMTBIT_S16_LE |\
+		SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+// static struct snd_soc_dai_driver aml_tdm_dai[] = {
+// 	{
+// 		.name = "TDM-A",
+// 		.id = 1,
+// 		.probe = aml_dai_tdm_probe,
+// 		.remove = aml_dai_tdm_remove,
+// 		.playback = {
+// 		      .channels_min = 1,
+// 		      .channels_max = 32,
+// 		      .rates = AML_DAI_TDM_RATES,
+// 		      .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.capture = {
+// 		     .channels_min = 1,
+// 		     .channels_max = 32,
+// 		     .rates = AML_DAI_TDM_RATES,
+// 		     .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.ops = &aml_dai_tdm_ops,
+// 		// .symmetric_rates = 1,
+// 	},
+// 	{
+
+// 		.name = "TDM-B",
+// 		.id = 2,
+// 		.probe = aml_dai_tdm_probe,
+// 		.remove = aml_dai_tdm_remove,
+// 		.playback = {
+// 		      .channels_min = 1,
+// 		      .channels_max = 32,
+// 		      .rates = AML_DAI_TDM_RATES,
+// 		      .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.capture = {
+// 		     .channels_min = 1,
+// 		     .channels_max = 32,
+// 		     .rates = AML_DAI_TDM_RATES,
+// 		     .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.ops = &aml_dai_tdm_ops,
+// 		// .symmetric_rates = 1,
+// 	},
+// 	{
+// 		.name = "TDM-C",
+// 		.id = 3,
+// 		.probe = aml_dai_tdm_probe,
+// 		.remove = aml_dai_tdm_remove,
+// 		.playback = {
+// 		      .channels_min = 1,
+// 		      .channels_max = 32,
+// 		      .rates = AML_DAI_TDM_RATES,
+// 		      .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.capture = {
+// 		     .channels_min = 1,
+// 		     .channels_max = 32,
+// 		     .rates = AML_DAI_TDM_RATES,
+// 		     .formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.ops = &aml_dai_tdm_ops,
+// 		// .symmetric_rates = 1,
+// 	},
+// 	{
+// 		.name = "TDMIN-LB",
+// 		.id = 4,
+// 		.probe = aml_dai_tdm_probe,
+// 		.remove = aml_dai_tdm_remove,
+
+// 		.capture = {
+// 			.channels_min = 1,
+// 			.channels_max = 32,
+// 			.rates = AML_DAI_TDM_RATES,
+// 			.formats = AML_DAI_TDM_FORMATS,
+// 		},
+// 		.ops = &aml_dai_tdm_ops,
+// 		// .symmetric_rates = 1,
+// 	}
+// };
+
+// static const struct snd_soc_component_driver aml_tdm_component = {
+// 	.name		= DRV_NAME,
+// };
+
+static int check_channel_mask(const char *str)
+{
+	int ret = -1;
+
+	if (!strncmp(str, "i2s_0/1", 7))
+		ret = 0;
+	else if (!strncmp(str, "i2s_2/3", 7))
+		ret = 1;
+	else if (!strncmp(str, "i2s_4/5", 7))
+		ret = 2;
+	else if (!strncmp(str, "i2s_6/7", 7))
+		ret = 3;
+	return ret;
+}
+
+/* spdif same source with i2s */
+static void parse_samesrc_channel_mask(struct aml_tdm *p_tdm)
+{
+	struct device_node *node = p_tdm->dev->of_node;
+	struct device_node *np = NULL;
+	const char *str = NULL;
+	int ret = 0;
+
+	/* channel mask */
+	np = of_get_child_by_name(node, "Channel_Mask");
+	if (np == NULL) {
+		pr_info("No channel mask node %s\n",
+				"Channel_Mask");
+		return;
+	}
+
+	/* If spdif is same source to i2s,
+	 * it can be muxed to i2s 2 channels
+	 */
+	ret = of_property_read_string(np,
+			"Spdif_samesource_Channel_Mask", &str);
+	if (ret) {
+		pr_err("error:read Spdif_samesource_Channel_Mask\n");
+		return;
+	}
+	p_tdm->lane_ss = check_channel_mask(str);
+
+	pr_info("Channel_Mask: lane_ss = %d\n", p_tdm->lane_ss);
+}
+
+int aml_tdm_platform_setup(struct platform_device *pdev)
+{
+	// struct device_node *node = pdev->dev.of_node;
+	// struct device_node *node_prt = NULL;
+	// struct platform_device *pdev_parent;
+	struct audio_dev_context * ctx = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	struct aml_audio_controller *actrl = NULL;
+	struct aml_tdm *p_tdm = NULL;
+	struct tdm_chipinfo *p_chipinfo;
+	struct device_node *np;
+	const struct of_device_id *di;
+	int ret = 0;
+
+	dev_info(&pdev->dev,"Registering TDM manager");
+	np  = of_find_node_by_name(pdev->dev.of_node, "tdm");
+
+	dev_info(&pdev->dev, "tdm node at  = %pm", np);
+	dev_info(&pdev->dev, "parent node at  = %pm", pdev->dev.of_node);
+
+	if(np == NULL)
+		return -ENOENT;
+	
+
+	p_tdm = devm_kzalloc(dev, sizeof(struct aml_tdm), GFP_KERNEL);
+	if (!p_tdm)
+		return -ENOMEM;
+	/* match data */
+	di = of_match_node(aml_tdm_device_id,np);
+	if(di)
+		p_chipinfo = (struct tdm_chipinfo *)di->data;
+	if (!p_chipinfo) {
+		dev_warn_once(dev, "check whether to update tdm chipinfo\n");
+		return -ENOMEM;
+	}
+	p_tdm->chipinfo = p_chipinfo;
+	p_tdm->id = p_chipinfo->id;
+	if (!p_chipinfo->lane_cnt)
+		p_chipinfo->lane_cnt = LANE_MAX1;
+
+	p_tdm->lane_cnt = p_chipinfo->lane_cnt;
+	pr_info("%s, tdm ID = %u, lane_cnt = %d\n", __func__,
+			p_tdm->id, p_tdm->lane_cnt);
+
+	/* get audio controller */
+	// node_prt = of_get_parent(node);
+	// if (node_prt == NULL)
+	// 	return -ENXIO;
+
+	// pdev_parent = of_find_device_by_node(node_prt);
+	// of_node_put(node_prt);
+
+	actrl = ((struct audio_dev_context *)
+				platform_get_drvdata(pdev))->actrl;
+	p_tdm->actrl = actrl;
+	/* get tdm mclk sel configs */
+	ret = of_property_read_u32(np, "dai-tdm-clk-sel",
+			&p_tdm->clk_sel);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Can't retrieve dai-tdm-clk-sel\n");
+		return -ENXIO;
+	}
+
+	/* default no same source */
+	if (p_tdm->chipinfo &&
+		p_tdm->chipinfo->same_src_fn) {
+
+		ret = of_property_read_u32(np, "samesource_sel",
+				&p_tdm->samesource_sel);
+		if (ret < 0)
+			p_tdm->samesource_sel = -1;
+		else {
+			p_tdm->samesrc_srcpll = devm_clk_get(&pdev->dev,
+				"samesource_srcpll");
+			if (IS_ERR(p_tdm->samesrc_srcpll)) {
+				dev_err(&pdev->dev,
+					"Can't retrieve samesrc_srcpll clock\n");
+				return PTR_ERR(p_tdm->samesrc_srcpll);
+			}
+			p_tdm->samesrc_clk = devm_clk_get(&pdev->dev,
+				"samesource_clk");
+			if (IS_ERR(p_tdm->samesrc_clk)) {
+				dev_err(&pdev->dev,
+					"Can't retrieve samesrc_clk clock\n");
+				return PTR_ERR(p_tdm->samesrc_clk);
+			}
+			ret = clk_set_parent(p_tdm->samesrc_clk,
+				p_tdm->samesrc_srcpll);
+			if (ret) {
+				dev_err(dev, "can't set samesource clock\n");
+				return ret;
+			}
+			pr_info("TDM id %d samesource_sel:%d\n",
+				p_tdm->id,
+				p_tdm->samesource_sel);
+		}
+	}
+	/* default no acodec_adc */
+	if (p_tdm->chipinfo &&
+		p_tdm->chipinfo->adc_fn) {
+
+		ret = of_property_read_u32(np, "acodec_adc",
+				&p_tdm->acodec_adc);
+		if (ret < 0)
+			p_tdm->acodec_adc = 0;
+		else
+			pr_info("TDM id %d supports ACODEC_ADC\n", p_tdm->id);
+	}
+
+	ret = of_property_read_u32(np, "i2s2hdmi",
+			&p_tdm->i2s2hdmitx);
+	if (ret < 0)
+		p_tdm->i2s2hdmitx = 0;
+	else
+		pr_info("TDM id %d i2s2hdmi:%d\n",
+			p_tdm->id,
+			p_tdm->i2s2hdmitx);
+
+	if (p_tdm->id == TDM_LB) {
+		ret = of_property_read_u32(np, "lb-src-sel",
+				&p_tdm->tdmin_lb_src);
+		if (ret < 0 || (p_tdm->tdmin_lb_src > 7)) {
+			dev_err(&pdev->dev, "invalid lb-src-sel:%d\n",
+				p_tdm->tdmin_lb_src);
+			return -EINVAL;
+		}
+		pr_info("TDM id %d lb-src-sel:%d\n",
+			p_tdm->id,
+			p_tdm->tdmin_lb_src);
+	}
+
+	/* get tdm lanes info. if not, set to default 0 */
+	ret = of_parse_tdm_lane_slot_in(np,
+			&p_tdm->setting.lane_mask_in);
+	if (ret < 0)
+		p_tdm->setting.lane_mask_in = 0x0;
+
+	ret = of_parse_tdm_lane_slot_out(np,
+			&p_tdm->setting.lane_mask_out);
+	if (ret < 0)
+		p_tdm->setting.lane_mask_out = 0x1;
+
+	/* get tdm lanes oe info. if not, set to default 0 */
+	ret = of_parse_tdm_lane_oe_slot_in(np,
+			&p_tdm->setting.lane_oe_mask_in);
+	if (ret < 0)
+		p_tdm->setting.lane_oe_mask_in = 0x0;
+
+	ret = of_parse_tdm_lane_oe_slot_out(np,
+			&p_tdm->setting.lane_oe_mask_out);
+	if (ret < 0)
+		p_tdm->setting.lane_oe_mask_out = 0x0;
+
+	/* get tdm lanes lb info. if not, set to default 0 */
+	ret = of_parse_tdm_lane_lb_slot_in(np,
+			&p_tdm->setting.lane_lb_mask_in);
+	if (ret < 0)
+		p_tdm->setting.lane_lb_mask_in = 0x0;
+
+	dev_info(&pdev->dev,
+	    "lane_mask_out = %x, lane_oe_mask_out = %x\n",
+	    p_tdm->setting.lane_mask_out,
+	    p_tdm->setting.lane_oe_mask_out);
+
+	p_tdm->clk = devm_clk_get(&pdev->dev, "clk_srcpll");
+	if (IS_ERR(p_tdm->clk)) {
+		dev_err(&pdev->dev, "Can't retrieve mpll2 clock\n");
+		return PTR_ERR(p_tdm->clk);
+	}
+
+	p_tdm->mclk = devm_clk_get(&pdev->dev, "mclk");
+	if (IS_ERR(p_tdm->mclk)) {
+		dev_err(&pdev->dev, "Can't retrieve mclk\n");
+		return PTR_ERR(p_tdm->mclk);
+	}
+
+	ret = clk_set_parent(p_tdm->mclk, p_tdm->clk);
+	if (ret) {
+		dev_err(dev, "can't set tdm parent clock\n");
+		return ret;
+	}
+
+	/* clk tree style after SM1, instead of legacy prop */
+	p_tdm->mclk2pad = devm_clk_get(&pdev->dev, "mclk_pad");
+	if (!IS_ERR(p_tdm->mclk2pad)) {
+		ret = clk_set_parent(p_tdm->mclk2pad, p_tdm->mclk);
+		if (ret) {
+			dev_err(&pdev->dev, "Can't set tdm mclk_pad parent\n");
+			return -EINVAL;
+		}
+		clk_prepare_enable(p_tdm->mclk2pad);
+		p_tdm->mclk_pad = -1;
+	} else {
+		/* mclk pad ctrl */
+		ret = of_property_read_u32(np, "mclk_pad",
+					   &p_tdm->mclk_pad);
+		if (ret < 0) {
+			/* No mclk in defalut if chip needs mclk pad mux. */
+			p_tdm->mclk_pad = -1;
+			dev_warn_once(&pdev->dev,
+				      "neither mclk_pad nor mclk2pad set\n");
+		}
+	}
+
+	/* complete mclk for tdm */
+	if (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xa)
+		meson_clk_measure((1<<16) | 0x67);
+
+	p_tdm->pin_ctl = devm_pinctrl_get_select(dev, "tdm_pins");
+	if (IS_ERR(p_tdm->pin_ctl)) {
+		dev_info(dev, "aml_tdm_get_pins error!\n");
+		/*return PTR_ERR(p_tdm->pin_ctl);*/
+	}
+
+	ret = of_property_read_u32(np, "start_clk_enable",
+				&p_tdm->start_clk_enable);
+	if (ret < 0)
+		p_tdm->start_clk_enable = 0;
+	else
+		pr_info("TDM id %d output clk enable:%d\n",
+			p_tdm->id, p_tdm->start_clk_enable);
+
+	/*set default clk for output*/
+	if (p_tdm->start_clk_enable == 1)
+		aml_set_default_tdm_clk(p_tdm);
+
+	p_tdm->dev = dev;
+	/* For debug to disable share buffer */
+	p_tdm->en_share = 1;
+	pr_info("%s(), share en = %d", __func__, p_tdm->en_share);
+	// dev_set_drvdata(dev, p_tdm);
+	ctx->tdm = p_tdm;
+	/* spdif same source with i2s */
+	parse_samesrc_channel_mask(p_tdm);
+
+	// ret = devm_snd_soc_register_component(dev, &aml_tdm_component,
+	// 				 &aml_tdm_dai[p_tdm->id], 1);
+	// if (ret) {
+	// 	dev_err(dev, "devm_snd_soc_register_component failed\n");
+	// 	return ret;
+	// }
+
+	ret = of_property_read_u32(np, "clk_tuning_enable",
+				&p_tdm->clk_tuning_enable);
+	if (ret < 0)
+		p_tdm->clk_tuning_enable = 0;
+	else
+		pr_info("TDM id %d tuning clk enable:%d\n",
+			p_tdm->id, p_tdm->clk_tuning_enable);
+	aml_dai_tdm_probe(p_tdm);
+
+	// return devm_snd_soc_register_platform(dev, &aml_tdm_platform);
+	return ret;
+}
+
+// static int aml_tdm_platform_suspend(struct platform_device *pdev,
+// 	pm_message_t state)
+// {
+// 	struct aml_tdm *p_tdm = dev_get_drvdata(&pdev->dev);
+
+// 	/*mute default clk */
+// 	if (p_tdm->start_clk_enable == 1 && p_tdm->pin_ctl) {
+// 		struct pinctrl_state *state = NULL;
+
+// 		state = pinctrl_lookup_state(p_tdm->pin_ctl, "tdmout_a_gpio");
+// 		if (!IS_ERR_OR_NULL(state)) {
+// 			pinctrl_select_state(p_tdm->pin_ctl, state);
+// 			pr_info("%s tdm pins disable!\n", __func__);
+// 		}
+// 	}
+
+// 	pr_info("%s tdm:(%d)\n", __func__, p_tdm->id);
+// 	return 0;
+// }
+
+// static int aml_tdm_platform_resume(struct platform_device *pdev)
+// {
+// 	struct aml_tdm *p_tdm = dev_get_drvdata(&pdev->dev);
+
+// 	/* complete mclk for tdm */
+// 	if (get_meson_cpu_version(MESON_CPU_VERSION_LVL_MINOR) == 0xa)
+// 		meson_clk_measure((1<<16) | 0x67);
+
+// 	/*set default clk for output*/
+// 	if (p_tdm->start_clk_enable == 1 && p_tdm->pin_ctl) {
+// 		struct pinctrl_state *state = NULL;
+
+// 		aml_set_default_tdm_clk(p_tdm);
+// 		state = pinctrl_lookup_state(p_tdm->pin_ctl, "tdm_pins");
+// 		if (!IS_ERR_OR_NULL(state)) {
+// 			pinctrl_select_state(p_tdm->pin_ctl, state);
+// 			pr_info("%s tdm pins enable!\n", __func__);
+// 		}
+// 	}
+
+// 	pr_info("%s tdm:(%d)\n", __func__, p_tdm->id);
+// 	return 0;
+// }
+
+// static void aml_tdm_platform_shutdown(struct platform_device *pdev)
+// {
+// }
+
+// struct platform_driver aml_tdm_driver = {
+// 	.driver = {
+// 		.name = DRV_NAME,
+// 		.of_match_table = aml_tdm_device_id,
+// 	},
+// 	.probe	 = aml_tdm_platform_probe,
+// 	.suspend = aml_tdm_platform_suspend,
+// 	.resume  = aml_tdm_platform_resume,
+// 	.shutdown = aml_tdm_platform_shutdown,
+// };
+// module_platform_driver(aml_tdm_driver);
+
+// MODULE_AUTHOR("Amlogic, Inc.");
+// MODULE_DESCRIPTION("Amlogic TDM ASoc driver");
+// MODULE_LICENSE("GPL");
+// MODULE_ALIAS("platform:" DRV_NAME);
+// MODULE_DEVICE_TABLE(of, aml_tdm_device_id);
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/tdm_hw.c b/evl/sound/evl-amlogic/tdm_hw.c
--- a/drivers/evl/sound/evl-amlogic/tdm_hw.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tdm_hw.c	2022-01-06 13:49:35.932506920 +0300
@@ -0,0 +1,874 @@
+/*
+ * sound/soc/amlogic/auge/tdm_hw.c
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <sound/soc.h>
+
+#include "tdm_hw.h"
+#include "iomap.h"
+
+#define MST_CLK_INVERT_PH0_PAD_BCLK       (1 << 0)
+#define MST_CLK_INVERT_PH0_PAD_FCLK       (1 << 1)
+#define MST_CLK_INVERT_PH1_TDMIN_BCLK     (1 << 2)
+#define MST_CLK_INVERT_PH1_TDMIN_FCLK     (1 << 3)
+#define MST_CLK_INVERT_PH2_TDMOUT_BCLK    (1 << 4)
+#define MST_CLK_INVERT_PH2_TDMOUT_FCLK    (1 << 5)
+
+/*#define G12A_PTM_LB_INTERNAL*/
+/*#define TL1_PTM_LB_INTERNAL*/
+
+/* without audio handler, it should be improved */
+void aml_tdm_enable(
+	struct aml_audio_controller *actrl,
+	int stream, int index,
+	bool is_enable)
+{
+	unsigned int offset, reg;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_info("tdm playback enabled\n");
+
+
+		offset = EE_AUDIO_TDMOUT_B_CTRL0
+				- EE_AUDIO_TDMOUT_A_CTRL0;
+		reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
+
+		aml_audiobus_update_bits(actrl, reg, 1<<31, is_enable<<31);
+						// Debug...
+		pr_info("TDM playback debug, TDMOUT CTRL0 = 0x%08x\n", aml_audiobus_read(actrl,reg));
+	} else {
+		pr_info("tdm capture enabled\n");
+
+		offset = EE_AUDIO_TDMIN_B_CTRL
+				- EE_AUDIO_TDMIN_A_CTRL;
+		reg = EE_AUDIO_TDMIN_A_CTRL + offset * index;
+		aml_audiobus_update_bits(actrl, reg, 1<<31, is_enable<<31);
+		pr_info("TDM capture debug, TDMIN CTRL0 = 0x%08x\n", aml_audiobus_read(actrl,reg));
+
+	}
+
+}
+
+void aml_tdm_arb_config(struct aml_audio_controller *actrl)
+{
+	/* config ddr arb */
+	aml_audiobus_write(actrl, EE_AUDIO_ARB_CTRL, 1<<31|0xff<<0);
+}
+
+void aml_tdm_fifo_reset(
+	struct aml_audio_controller *actrl,
+	int index)
+{
+	unsigned int reg, offset;
+
+	// if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		offset = EE_AUDIO_TDMOUT_B_CTRL0
+				- EE_AUDIO_TDMOUT_A_CTRL0;
+		reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
+		/* reset afifo */
+		aml_audiobus_update_bits(actrl, reg, 3<<28, 0);
+		aml_audiobus_update_bits(actrl, reg, 1<<29, 1<<29);
+		aml_audiobus_update_bits(actrl, reg, 1<<28, 1<<28);
+	// } else {
+		offset = EE_AUDIO_TDMIN_B_CTRL
+				- EE_AUDIO_TDMIN_A_CTRL;
+		reg = EE_AUDIO_TDMIN_A_CTRL + offset * index;
+		/* reset afifo */
+		aml_audiobus_update_bits(actrl, reg, 3<<28, 0);
+		aml_audiobus_update_bits(actrl, reg, 1<<29, 1<<29);
+		aml_audiobus_update_bits(actrl, reg, 1<<28, 1<<28);
+	// }
+
+}
+
+
+void tdm_enable(int tdm_index, int is_enable)
+{
+	unsigned int offset, reg;
+
+	if (tdm_index < 3) {
+		pr_info("tdmout is_enable:%d\n", is_enable);
+
+		offset = EE_AUDIO_TDMOUT_B_CTRL0
+			- EE_AUDIO_TDMOUT_A_CTRL0;
+		reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * tdm_index;
+
+		audiobus_update_bits(reg, 1<<31, is_enable<<31);
+	} else if (tdm_index < 6) {
+		pr_info("tdmin is_enable:%d\n", is_enable);
+
+		tdm_index -= 3;
+		offset = EE_AUDIO_TDMIN_B_CTRL
+			- EE_AUDIO_TDMIN_A_CTRL;
+		reg = EE_AUDIO_TDMIN_A_CTRL + offset * tdm_index;
+
+		audiobus_update_bits(reg, 1<<31, is_enable<<31);
+	}
+}
+
+void tdm_fifo_enable(int tdm_index, int is_enable)
+{
+	unsigned int reg, offset;
+
+	if (tdm_index < 3) {
+		offset = EE_AUDIO_TDMOUT_B_CTRL0
+			- EE_AUDIO_TDMOUT_A_CTRL0;
+		reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * tdm_index;
+
+		if (is_enable) {
+			audiobus_update_bits(reg, 1<<29, 1<<29);
+			audiobus_update_bits(reg, 1<<28, 1<<28);
+		} else
+			audiobus_update_bits(reg, 3<<28, 0);
+
+	} else if (tdm_index < 6) {
+		tdm_index -= 3;
+		offset = EE_AUDIO_TDMIN_B_CTRL
+				- EE_AUDIO_TDMIN_A_CTRL;
+		reg = EE_AUDIO_TDMIN_A_CTRL + offset * tdm_index;
+
+		if (is_enable) {
+			audiobus_update_bits(reg, 1<<29, 1<<29);
+			audiobus_update_bits(reg, 1<<28, 1<<28);
+		} else
+			audiobus_update_bits(reg, 3<<28, 0);
+	}
+}
+
+int tdmout_get_frddr_type(int bitwidth)
+{
+	unsigned int frddr_type = 0;
+
+	switch (bitwidth) {
+	case 8:
+		frddr_type = 0;
+		break;
+	case 16:
+		frddr_type = 2;
+		break;
+	case 24:
+	case 32:
+		frddr_type = 4;
+		break;
+	default:
+		pr_err("invalid bit_depth: %d\n",
+			bitwidth);
+		break;
+	}
+
+	return frddr_type;
+}
+
+void aml_tdm_fifo_ctrl(
+	struct aml_audio_controller *actrl,
+	int bitwidth, 
+	int index, unsigned int fifo_id)
+{
+	unsigned int frddr_type = tdmout_get_frddr_type(bitwidth);
+	unsigned int reg, offset;
+
+	// if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_debug("tdm prepare----playback\n");
+		// from ddr, 63bit split into 2 samples
+		offset = EE_AUDIO_TDMOUT_B_CTRL1
+				- EE_AUDIO_TDMOUT_A_CTRL1;
+		reg = EE_AUDIO_TDMOUT_A_CTRL1 + offset * index;
+		aml_audiobus_update_bits(actrl, reg,
+				0x3<<24|0x1f<<8|0x7<<4,
+				fifo_id<<24|(bitwidth-1)<<8|frddr_type<<4);
+	// } else {
+		pr_debug("tdm prepare----capture\n");
+	// }
+
+}
+
+static void aml_clk_set_tdmout_by_id(
+		struct aml_audio_controller *actrl,
+		unsigned int tdm_index,
+		unsigned int sclk_sel,
+		unsigned int lrclk_sel,
+		bool sclk_ws_inv,
+		bool is_master,
+		bool binv)
+{
+	unsigned int val_sclk_ws_inv = 0;
+	unsigned int reg = EE_AUDIO_CLK_TDMOUT_A_CTRL + tdm_index;
+
+	/* This is just a copy from previous setting. WHY??? */
+	val_sclk_ws_inv = sclk_ws_inv && is_master;
+	if (val_sclk_ws_inv)
+		aml_audiobus_update_bits(actrl, reg,
+			0x3<<30|1<<28|0xf<<24|0xf<<20,
+			0x3<<30|val_sclk_ws_inv<<28|
+			sclk_sel<<24|lrclk_sel<<20);
+	else
+		aml_audiobus_update_bits(actrl, reg,
+			0x3<<30|1<<29|0xf<<24|0xf<<20,
+			0x3<<30|binv<<29|
+			sclk_sel<<24|lrclk_sel<<20);
+}
+
+static void aml_clk_set_tdmin_by_id(
+		struct aml_audio_controller *actrl,
+		unsigned int tdm_index,
+		unsigned int sclk_sel,
+		unsigned int lrclk_sel)
+{
+	unsigned int reg =
+		EE_AUDIO_CLK_TDMIN_A_CTRL + tdm_index;
+	aml_audiobus_update_bits(actrl,
+		reg,
+		0xff<<20,
+		sclk_sel<<24|lrclk_sel<<20);
+}
+
+static void aml_tdmout_invert_lrclk(
+		struct aml_audio_controller *actrl,
+		unsigned int tdm_index,
+		bool finv)
+{
+	unsigned int off_set =
+		EE_AUDIO_TDMOUT_B_CTRL1 - EE_AUDIO_TDMOUT_A_CTRL1;
+	unsigned int reg_out =
+		EE_AUDIO_TDMOUT_A_CTRL1 + off_set * tdm_index;
+	aml_audiobus_update_bits(actrl,
+		reg_out, 0x1<<28, finv<<28);
+}
+
+static void aml_tdmout_bclk_skew(
+		struct aml_audio_controller *actrl,
+		unsigned int tdm_index,
+		unsigned int bclkout_skew)
+{
+	unsigned int off_set =
+		EE_AUDIO_TDMOUT_B_CTRL0 - EE_AUDIO_TDMOUT_A_CTRL0;
+	unsigned int reg_out =
+		EE_AUDIO_TDMOUT_A_CTRL0 + off_set * tdm_index;
+	aml_audiobus_update_bits(actrl,
+		reg_out, 0x1f<<15, bclkout_skew<<15);
+}
+
+void aml_tdm_set_format(
+	struct aml_audio_controller *actrl,
+	struct pcm_setting *p_config,
+	unsigned int clk_sel,
+	unsigned int index,
+	unsigned int fmt,
+	unsigned int capture_active,
+	unsigned int playback_active)
+{
+	unsigned int binv, finv, id;
+	unsigned int valb, valf;
+	unsigned int reg_in, reg_out, off_set;
+	int bclkin_skew, bclkout_skew;
+	int master_mode;
+	unsigned int clkctl = 0;
+
+	id = index;
+
+	binv = 0;
+	finv = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		valb = SLAVE_A + id;
+		valf = SLAVE_A + id;
+		master_mode = 0;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		valb = MASTER_A + clk_sel;
+		valf = MASTER_A + clk_sel;
+		master_mode = 1;
+		break;
+	default:
+		return;
+	}
+	aml_clk_set_tdmin_by_id(actrl, id, valb, valf);
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		if (p_config->sclk_ws_inv) {
+			if (master_mode)
+				bclkout_skew = 2;
+			else
+				bclkout_skew = 3;
+		} else
+			bclkout_skew = 1;
+		bclkin_skew = 3;
+
+		clkctl |= MST_CLK_INVERT_PH0_PAD_FCLK
+			| MST_CLK_INVERT_PH2_TDMOUT_FCLK;
+		finv = 1;
+
+		if (master_mode) {
+			clkctl |= MST_CLK_INVERT_PH0_PAD_BCLK;
+			if (capture_active)
+				binv |= 1;
+		} else {
+			if (playback_active)
+				binv |= 1;
+		}
+
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		/*
+		 * Frame high, 1clk before data, one bit for frame sync,
+		 * frame sync starts one serial clock cycle earlier,
+		 * that is, together with the last bit of the previous
+		 * data word.
+		 */
+		if (p_config->sclk_ws_inv) {
+			if (master_mode)
+				bclkout_skew = 2;
+			else
+				bclkout_skew = 3;
+		} else
+			bclkout_skew = 1;
+		bclkin_skew = 3;
+
+		if (capture_active)
+			binv |= 1;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+	case SND_SOC_DAIFMT_DSP_B:
+		/*
+		 * Frame high, one bit for frame sync,
+		 * frame sync asserts with the first bit of the frame.
+		 */
+		if (p_config->sclk_ws_inv) {
+			if (master_mode)
+				bclkout_skew = 3;
+			else
+				bclkout_skew = 4;
+		} else
+			bclkout_skew = 2;
+		bclkin_skew = 2;
+
+		if (capture_active)
+			binv |= 1;
+		break;
+	default:
+		return;
+	}
+
+	p_config->pcm_mode = fmt & SND_SOC_DAIFMT_FORMAT_MASK;
+
+	pr_debug("pad clk ctl value:%x\n", clkctl);
+	/* set lrclk/bclk invertion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_IB_IF:
+		/* Invert both clocks */
+		if (!master_mode)
+			binv ^= 1;
+
+		finv |= 1;
+		clkctl ^= MST_CLK_INVERT_PH0_PAD_BCLK;
+		clkctl ^= MST_CLK_INVERT_PH0_PAD_FCLK;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		/* Invert bit clock */
+		if (!master_mode)
+			binv ^= 1;
+		clkctl ^= MST_CLK_INVERT_PH0_PAD_BCLK;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		/* Invert frame clock */
+		finv ^= 1;
+		clkctl ^= MST_CLK_INVERT_PH0_PAD_FCLK;
+		break;
+	case SND_SOC_DAIFMT_NB_NF:
+		/* normal cases */
+		break;
+	default:
+		return;
+	}
+	pr_debug("sclk_ph0 (pad) clk ctl set:%x\n", clkctl);
+	/* clk ctrl: delay line and invert clk */
+	/*clkctl |= 0x88880000;*/
+
+	if (master_mode) {
+		off_set = EE_AUDIO_MST_B_SCLK_CTRL1 - EE_AUDIO_MST_A_SCLK_CTRL1;
+		reg_out = EE_AUDIO_MST_A_SCLK_CTRL1 + off_set * id;
+
+		aml_audiobus_update_bits(actrl, reg_out, 0x3f, clkctl);
+	}
+
+	pr_info("master_mode(%d), binv(%d), finv(%d) out_skew(%d), in_skew(%d)\n",
+			master_mode, binv, finv, bclkout_skew, bclkin_skew);
+
+	/* TDM out */
+	if (playback_active) {
+		aml_clk_set_tdmout_by_id(actrl,
+			id, valb, valf,
+			p_config->sclk_ws_inv, master_mode, binv);
+		aml_tdmout_invert_lrclk(actrl, id, finv);
+		aml_tdmout_bclk_skew(actrl, id, bclkout_skew);
+	}
+
+	/* TDM in */
+	if (capture_active) {
+		reg_in = EE_AUDIO_CLK_TDMIN_A_CTRL + id;
+		aml_audiobus_update_bits(actrl, reg_in,
+			0x3<<30, 0x3<<30);
+
+		if (master_mode)
+			aml_audiobus_update_bits(actrl, reg_in,
+				0x1<<29, binv<<29);
+
+		off_set = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+		reg_in = EE_AUDIO_TDMIN_A_CTRL + off_set * id;
+		// DEbugging ???
+		aml_audiobus_update_bits(actrl, reg_in,
+			3<<26|0x7<<16, 3<<26|bclkin_skew<<16);
+			// 0x7<<16, bclkin_skew<<16);
+
+		aml_audiobus_update_bits(actrl, reg_in,
+			0x1<<25, finv<<25);
+
+		if (p_config->pcm_mode == SND_SOC_DAIFMT_I2S)
+			aml_audiobus_update_bits(actrl, reg_in,
+				1<<30,
+				1<<30);
+	}
+}
+
+void aml_update_tdmin_skew(struct aml_audio_controller *actrl,
+	 int idx, int skew)
+{
+	unsigned int reg_in, off_set;
+
+	off_set = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+	reg_in = EE_AUDIO_TDMIN_A_CTRL + off_set * idx;
+	aml_audiobus_update_bits(actrl, reg_in,
+		0x7 << 16, skew << 16);
+}
+
+void aml_update_tdmin_rev_ws(struct aml_audio_controller *actrl,
+	 int idx, int is_rev)
+{
+	unsigned int reg_in, off_set;
+
+	off_set = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+	reg_in = EE_AUDIO_TDMIN_A_CTRL + off_set * idx;
+	aml_audiobus_update_bits
+		(actrl, reg_in,
+		0x1 << 25, is_rev << 25);
+}
+
+void aml_tdm_set_oe_v1(
+	struct aml_audio_controller *actrl,
+	int index, int force_oe, int oe_val)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMOUT_B_CTRL0 - EE_AUDIO_TDMOUT_A_CTRL0;
+	reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
+
+	if (force_oe) {
+		offset = EE_AUDIO_TDMOUT_B_CTRL2 - EE_AUDIO_TDMOUT_A_CTRL2;
+		reg = EE_AUDIO_TDMOUT_A_CTRL2 + offset * index;
+
+		aml_audiobus_update_bits(actrl, reg, 0xf << 24, force_oe << 24);
+
+		/* force oe val, in or out */
+		reg = EE_AUDIO_TDMOUT_A_CTRL1 + offset * index;
+		aml_audiobus_update_bits(actrl, reg, 0xf, oe_val);
+	}
+}
+
+void aml_tdm_set_oe_v2(
+	struct aml_audio_controller *actrl,
+	int index, int force_oe, int oe_val)
+{
+	unsigned int reg, offset;
+
+	if (force_oe) {
+		offset = EE_AUDIO_TDMOUT_B_CTRL2 - EE_AUDIO_TDMOUT_A_CTRL2;
+		reg = EE_AUDIO_TDMOUT_A_CTRL2 + offset * index;
+
+		aml_audiobus_update_bits(actrl, reg, 0xff << 8, force_oe << 8);
+
+		/* force oe val, in or out */
+		if (oe_val) {
+			aml_audiobus_update_bits
+				(actrl, reg, 0xff << 16, oe_val << 16);
+		}
+	}
+}
+
+void aml_tdm_set_slot_out(
+	struct aml_audio_controller *actrl,
+	int index, int slots, int slot_width)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMOUT_B_CTRL0 - EE_AUDIO_TDMOUT_A_CTRL0;
+	reg = EE_AUDIO_TDMOUT_A_CTRL0 + offset * index;
+	aml_audiobus_update_bits
+		(actrl, reg, 0x3ff, ((slots - 1) << 5) | (slot_width - 1));
+}
+
+void aml_tdm_set_slot_in(
+	struct aml_audio_controller *actrl,
+	int index, int in_src, int slot_width)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+	reg = EE_AUDIO_TDMIN_A_CTRL + offset * index;
+
+#if defined(G12A_PTM_LB_INTERNAL)
+	if (index == 0) /*TODO: ptm, tdma dsp_a lb*/
+		aml_audiobus_update_bits(actrl, reg,
+			0xf<<20|0x1f, 6<<20|(slot_width-1));
+	if (index == 1) /*TODO: ptm, tdmb i2s lb*/
+		aml_audiobus_update_bits(actrl, reg,
+			0xf<<20|0x1f, 7<<20|(slot_width-1));
+	else
+#elif defined(TL1_PTM_LB_INTERNAL)
+if (index == 0) /*TODO: ptm, tdma dsp_a lb*/
+	aml_audiobus_update_bits(actrl, reg,
+		0xf<<20|0x1f, 13<<20|(slot_width-1));
+else if (index == 1) /*TODO: ptm, tdmb i2s lb*/
+	aml_audiobus_update_bits(actrl, reg,
+		0xf<<20|0x1f, 14<<20|(slot_width-1));
+else
+#endif
+	aml_audiobus_update_bits(actrl, reg,
+		0xf << 20 | 0x1f, in_src << 20 | (slot_width-1));
+}
+
+void aml_update_tdmin_src(
+	struct aml_audio_controller *actrl,
+	int index, int in_src)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+	reg = EE_AUDIO_TDMIN_A_CTRL + offset * index;
+
+	aml_audiobus_update_bits(actrl, reg,
+		0xf << 20, in_src << 20);
+}
+
+void tdmin_set_chnum_en(
+	struct aml_audio_controller *actrl,
+	int index, bool enable)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMIN_B_CTRL - EE_AUDIO_TDMIN_A_CTRL;
+	reg = EE_AUDIO_TDMIN_A_CTRL + offset * index;
+
+	aml_audiobus_update_bits(actrl, reg,
+		0x1 << 6, enable << 6);
+}
+
+void aml_tdm_set_channel_mask(
+	struct aml_audio_controller *actrl,
+	int stream, int index, int lane, int mask)
+{
+	unsigned int offset, reg;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (lane >= LANE_MAX1) {
+			offset = EE_AUDIO_TDMOUT_B_MASK4
+				- EE_AUDIO_TDMOUT_A_MASK4;
+			reg = EE_AUDIO_TDMOUT_A_MASK4 + offset * index;
+			lane -= LANE_MAX1;
+		} else {
+			offset = EE_AUDIO_TDMOUT_B_MASK0
+				- EE_AUDIO_TDMOUT_A_MASK0;
+			reg = EE_AUDIO_TDMOUT_A_MASK0 + offset * index;
+		}
+	} else {
+		if (lane >= LANE_MAX1) {
+			offset = EE_AUDIO_TDMIN_B_MASK4
+				- EE_AUDIO_TDMIN_A_MASK4;
+			reg = EE_AUDIO_TDMIN_A_MASK4 + offset * index;
+			lane -= LANE_MAX1;
+		} else {
+			offset = EE_AUDIO_TDMIN_B_MASK0
+				- EE_AUDIO_TDMIN_A_MASK0;
+			reg = EE_AUDIO_TDMIN_A_MASK0 + offset * index;
+		}
+	}
+
+	aml_audiobus_write(actrl, reg + lane, mask);
+}
+
+void aml_tdm_set_lane_channel_swap(
+	struct aml_audio_controller *actrl,
+	int stream, int index, int swap0, int swap1)
+{
+	unsigned int offset, reg;
+
+	pr_debug("\t %s swap0 = %#x, swap1 = %#x\n",
+		(stream == SNDRV_PCM_STREAM_PLAYBACK) ? "tdmout" : "tdmin",
+		swap0,
+		swap1);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		offset = EE_AUDIO_TDMOUT_B_SWAP0
+			- EE_AUDIO_TDMOUT_A_SWAP0;
+		reg = EE_AUDIO_TDMOUT_A_SWAP0 + offset * index;
+		aml_audiobus_write(actrl, reg, swap0);
+
+		if (swap1) {
+			offset = EE_AUDIO_TDMOUT_B_SWAP1
+				- EE_AUDIO_TDMOUT_A_SWAP1;
+			reg = EE_AUDIO_TDMOUT_A_SWAP1 + offset * index;
+			aml_audiobus_write(actrl, reg, swap1);
+		}
+	} else {
+		offset = EE_AUDIO_TDMIN_B_SWAP0
+			- EE_AUDIO_TDMIN_A_SWAP0;
+		reg = EE_AUDIO_TDMIN_A_SWAP0 + offset * index;
+		aml_audiobus_write(actrl, reg, swap0);
+
+		if (swap1) {
+			offset = EE_AUDIO_TDMIN_B_SWAP1
+				- EE_AUDIO_TDMIN_A_SWAP1;
+			reg = EE_AUDIO_TDMIN_A_SWAP1 + offset * index;
+			aml_audiobus_write(actrl, reg, swap1);
+		}
+	}
+}
+
+void aml_tdm_set_bclk_ratio(
+	struct aml_audio_controller *actrl,
+	int clk_sel, int lrclk_hi, int bclk_ratio)
+{
+	unsigned int reg, reg_step = 2;
+
+	reg = EE_AUDIO_MST_A_SCLK_CTRL0 + reg_step * clk_sel;
+
+	aml_audiobus_update_bits(actrl, reg,
+				(3 << 30)|0x3ff<<10|0x3ff,
+				(3 << 30)|lrclk_hi<<10|bclk_ratio);
+}
+
+void aml_tdm_set_lrclkdiv(
+	struct aml_audio_controller *actrl,
+	int clk_sel, int ratio)
+{
+	unsigned int reg, reg_step = 2;
+
+	pr_debug("aml_dai_set_clkdiv, clksel(%d), ratio(%d)\n",
+			clk_sel, ratio);
+
+	reg = EE_AUDIO_MST_A_SCLK_CTRL0 + reg_step * clk_sel;
+
+	aml_audiobus_update_bits(actrl, reg,
+		(3 << 30)|(0x3ff << 20),
+		(3 << 30)|(ratio << 20));
+}
+
+void aml_tdmout_select_aed(bool enable, int tdmout_id)
+{
+	unsigned int reg, offset;
+
+	/* select eq_drc output */
+	offset = EE_AUDIO_TDMOUT_B_CTRL1
+			- EE_AUDIO_TDMOUT_A_CTRL1;
+	reg = EE_AUDIO_TDMOUT_A_CTRL1 + offset * tdmout_id;
+	audiobus_update_bits(reg, 0x1 << 31, enable << 31);
+}
+
+void aml_tdmout_get_aed_info(int tdmout_id,
+	int *bitwidth, int *frddrtype)
+{
+	unsigned int reg, offset, val;
+
+	offset = EE_AUDIO_TDMOUT_B_CTRL1
+			- EE_AUDIO_TDMOUT_A_CTRL1;
+	reg = EE_AUDIO_TDMOUT_A_CTRL1 + offset * tdmout_id;
+
+	val = audiobus_read(reg);
+	if (bitwidth)
+		*bitwidth = (val >> 8) & 0x1f;
+	if (frddrtype)
+		*frddrtype = (val >> 4) & 0x7;
+}
+
+void aml_tdmout_enable_gain(int tdmout_id, int en)
+{
+	unsigned int reg, offset;
+
+	offset = EE_AUDIO_TDMOUT_B_CTRL1
+			- EE_AUDIO_TDMOUT_A_CTRL1;
+	reg = EE_AUDIO_TDMOUT_A_CTRL1 + offset * tdmout_id;
+	audiobus_update_bits(reg, 0x1 << 26, !!en << 26);
+}
+
+void aml_tdm_mclk_pad_select(struct aml_audio_controller *actrl,
+			     int mpad, int mpad_offset, int mclk_sel)
+{
+	unsigned int reg, mask_offset, val_offset;
+
+	switch (mpad) {
+	case 0:
+		mask_offset = 0x7 << 0;
+		val_offset = mclk_sel << 0;
+		break;
+	case 1:
+		mask_offset = 0x7 << 4;
+		val_offset = mclk_sel << 4;
+		break;
+	default:
+		mask_offset = 0x7 << 4;
+		val_offset = 0;
+		pr_info("unknown tdm mpad:%d\n", mpad);
+		break;
+	}
+
+	reg = EE_AUDIO_MST_PAD_CTRL0(mpad_offset);
+	if (actrl)
+		aml_audiobus_update_bits(actrl, reg,
+					 mask_offset, val_offset);
+	else
+		audiobus_update_bits(reg,
+				     mask_offset, val_offset);
+}
+
+void aml_tdm_sclk_pad_select(struct aml_audio_controller *actrl,
+			     int mpad_offset, int tdm_index, int clk_sel)
+{
+	unsigned int reg, mask_offset, val_offset;
+
+	reg = EE_AUDIO_MST_PAD_CTRL1(mpad_offset);
+	switch (tdm_index) {
+	case 0:
+		mask_offset = 0x7 << 16 | 0x7 << 0;
+		val_offset = clk_sel << 16 | clk_sel << 0;
+		break;
+	case 1:
+		mask_offset = 0x7 << 20 | 0x7 << 4;
+		val_offset = clk_sel << 20 | clk_sel << 4;
+		break;
+	case 2:
+		mask_offset = 0x7 << 24 | 0x7 << 8;
+		val_offset = clk_sel << 24 | clk_sel << 8;
+		break;
+	default:
+		pr_err("unknown mclk pad, tdm index:%d\n", tdm_index);
+		return;
+	}
+	if (actrl)
+		aml_audiobus_update_bits(actrl, reg,
+			mask_offset, val_offset);
+	else
+		audiobus_update_bits(reg,
+			mask_offset, val_offset);
+}
+
+void i2s_to_hdmitx_ctrl(int tdm_index)
+{
+	audiobus_write(EE_AUDIO_TOHDMITX_CTRL0,
+		1 << 31
+		| tdm_index << 12 /* dat_sel */
+		| tdm_index << 8 /* lrclk_sel */
+		| 1 << 7 /* Bclk_cap_inv */
+		| 0 << 6 /* Bclk_o_inv */
+		| tdm_index << 4 /* Bclk_sel */
+	);
+}
+
+void aml_tdm_mute_playback(
+		struct aml_audio_controller *actrl,
+		int tdm_index,
+		bool mute,
+		int lane_cnt)
+{
+	unsigned int offset, reg;
+	unsigned int mute_mask = 0xffffffff;
+	unsigned int mute_val = 0;
+	int i = 0;
+
+	if (mute)
+		mute_val = 0xffffffff;
+
+	offset = EE_AUDIO_TDMOUT_B_MUTE0
+			- EE_AUDIO_TDMOUT_A_MUTE0;
+	reg = EE_AUDIO_TDMOUT_A_MUTE0 + offset * tdm_index;
+	for (i = 0; i < LANE_MAX1; i++)
+		aml_audiobus_update_bits(actrl, reg + i, mute_mask, mute_val);
+
+	if (lane_cnt > LANE_MAX1) {
+		offset = EE_AUDIO_TDMOUT_B_MUTE4
+				- EE_AUDIO_TDMOUT_A_MUTE4;
+		reg = EE_AUDIO_TDMOUT_A_MUTE4 + offset * tdm_index;
+		for (i = 0; i < LANE_MAX1; i++)
+			aml_audiobus_update_bits(actrl, reg + i,
+					mute_mask, mute_val);
+	}
+}
+
+void aml_tdm_mute_capture(
+		struct aml_audio_controller *actrl,
+		int tdm_index,
+		bool mute,
+		int lane_cnt)
+{
+	unsigned int offset, reg;
+	unsigned int mute_mask = 0xffffffff;
+	unsigned int mute_val = 0;
+	int i = 0;
+
+	if (mute)
+		mute_val = 0xffffffff;
+
+	offset = EE_AUDIO_TDMIN_B_MUTE0
+			- EE_AUDIO_TDMIN_A_MUTE0;
+	reg = EE_AUDIO_TDMIN_A_MUTE0 + offset * tdm_index;
+	for (i = 0; i < LANE_MAX1; i++)
+		aml_audiobus_update_bits(actrl, reg + i,
+				mute_mask, mute_val);
+
+	if (lane_cnt > LANE_MAX1) {
+		offset = EE_AUDIO_TDMIN_B_MUTE4
+				- EE_AUDIO_TDMIN_A_MUTE4;
+		reg = EE_AUDIO_TDMIN_A_MUTE4 + offset * tdm_index;
+		for (i = 0; i < LANE_MAX1; i++)
+			aml_audiobus_update_bits(actrl, reg + i,
+					mute_mask, mute_val);
+	}
+}
+
+void aml_tdm_out_reset(unsigned int tdm_id, int offset)
+{
+	unsigned int reg = 0, val = 0;
+
+	if ((offset != 0) && (offset != 1)) {
+		pr_err("%s(), invalid offset = %d\n", __func__, offset);
+		return;
+	}
+
+	if (tdm_id == 0) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_TDMOUTA;
+	} else if (tdm_id == 1) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_TDMOUTB;
+	} else if (tdm_id == 2) {
+		reg = EE_AUDIO_SW_RESET0(offset);
+		val = REG_BIT_RESET_TDMOUTC;
+	} else {
+		pr_err("invalid tdmout id %d\n", tdm_id);
+		return;
+	}
+	audiobus_update_bits(reg, val, val);
+	audiobus_update_bits(reg, val, 0);
+}
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/tdm_hw.h b/evl/sound/evl-amlogic/tdm_hw.h
--- a/drivers/evl/sound/evl-amlogic/tdm_hw.h	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tdm_hw.h	2022-01-10 12:06:42.108907192 +0300
@@ -0,0 +1,219 @@
+/*
+ * sound/soc/amlogic/auge/tdm_hw.h
+ *
+ * Copyright (C) 2017 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __AML_TDM_HW_H__
+#define __AML_TDM_HW_H__
+
+#include "audio_io.h"
+#include "regs.h"
+
+#define TDM_A	0
+#define TDM_B	1
+#define TDM_C	2
+#define TDM_LB	3
+
+#define LANE_MAX0 2
+#define LANE_MAX1 4
+#define LANE_MAX2 6
+#define LANE_MAX3 8
+
+//	TODO: fix me, now based by tl1
+enum tdmin_src {
+	PAD_TDMINA_DIN = 0,
+	PAD_TDMINB_DIN = 1,
+	PAD_TDMINC_DIN = 2,
+	PAD_TDMINA_D = 3,
+	PAD_TDMINB_D = 4,
+	PAD_TDMINC_D = 5,
+	HDMIRX_I2S = 6,
+	ACODEC_ADC = 7,
+	TDMOUTA = 13,
+	TDMOUTB = 14,
+	TDMOUTC = 15,
+};
+
+struct pcm_setting {
+	unsigned int pcm_mode;
+	unsigned int sysclk;
+	unsigned int sysclk_bclk_ratio;
+	unsigned int bclk;
+	unsigned int bclk_lrclk_ratio;
+	unsigned int lrclk;
+	unsigned int tx_mask;
+	unsigned int rx_mask;
+	unsigned int slots;
+	unsigned int slot_width;
+	unsigned int pcm_width;
+	unsigned int lane_mask_out;
+	unsigned int lane_mask_in;
+	/* lane oe (out pad) mask */
+	unsigned int lane_oe_mask_out;
+	unsigned int lane_oe_mask_in;
+	/* lane in selected from out, for intrenal loopback */
+	unsigned int lane_lb_mask_in;
+
+	/* eco or sclk_ws_inv */
+	bool sclk_ws_inv;
+};
+
+struct aml_tdm {
+	struct pcm_setting setting;
+	struct pinctrl *pin_ctl;
+	struct aml_audio_controller *actrl;
+	struct device *dev;
+	struct clk *clk;
+	struct clk *clk_gate;
+	struct clk *mclk;
+	/* mclk mux out to pad */
+	struct clk *mclk2pad;
+	struct clk *samesrc_srcpll;
+	struct clk *samesrc_clk;
+	bool contns_clk;
+	unsigned int id;
+	/* bclk src selection */
+	unsigned int clk_sel;
+	struct toddr *tddr;
+	struct frddr *fddr;
+
+	struct tdm_chipinfo *chipinfo;
+	/* share buffer with module */
+	int samesource_sel;
+	/* share buffer lane setting from DTS */
+	int lane_ss;
+	int mclk_pad;
+	/* virtual link for i2s to hdmitx */
+	int i2s2hdmitx;
+	int acodec_adc;
+	uint last_mpll_freq;
+	uint last_mclk_freq;
+	uint last_fmt;
+
+	bool en_share;
+	unsigned int lane_cnt;
+
+	/* tdmin_lb src sel */
+	int tdmin_lb_src;
+	int start_clk_enable;
+	int clk_tuning_enable;
+	int last_rate;
+};
+
+extern void aml_tdm_enable(
+	struct aml_audio_controller *actrl,int stream,
+	 int index,
+	bool is_enable);
+
+extern void aml_tdm_arb_config(
+	struct aml_audio_controller *actrl);
+
+extern void aml_tdm_fifo_reset(
+	struct aml_audio_controller *actrl,
+	int index);
+void aml_tdmout_enable_gain(int tdmout_id, int en);
+
+extern int tdmout_get_frddr_type(int bitwidth);
+
+extern void aml_tdm_fifo_ctrl(
+	struct aml_audio_controller *actrl,
+	int bitwidth, 
+	int index, unsigned int fifo_id);
+
+extern void aml_tdm_set_format(
+	struct aml_audio_controller *actrl,
+	struct pcm_setting *p_config,
+	unsigned int clk_sel,
+	unsigned int index,
+	unsigned int fmt,
+	unsigned int capture_active,
+	unsigned int playback_active);
+
+extern void aml_update_tdmin_skew(struct aml_audio_controller *actrl,
+	int idx, int skew);
+
+extern void aml_update_tdmin_rev_ws(struct aml_audio_controller *actrl,
+	int idx, int is_rev);
+
+extern void aml_tdm_set_slot_out(
+	struct aml_audio_controller *actrl,
+	int index, int slots, int slot_width);
+
+extern void aml_tdm_set_slot_in(
+	struct aml_audio_controller *actrl,
+	int index, int in_src, int slot_width);
+
+extern void aml_update_tdmin_src(
+	struct aml_audio_controller *actrl,
+	int index, int in_src);
+
+extern void tdmin_set_chnum_en(
+	struct aml_audio_controller *actrl,
+	int index, bool enable);
+
+extern void aml_tdm_set_channel_mask(
+	struct aml_audio_controller *actrl,
+	int stream, int index, int lanes, int mask);
+
+extern void aml_tdm_set_lane_channel_swap(
+	struct aml_audio_controller *actrl,
+	int stream, int index, int swap0, int swap1);
+
+extern void aml_tdm_set_bclk_ratio(
+	struct aml_audio_controller *actrl,
+	int clk_sel, int lrclk_hi, int bclk_ratio);
+
+extern void aml_tdm_set_lrclkdiv(
+	struct aml_audio_controller *actrl,
+	int clk_sel, int ratio);
+
+extern void tdm_enable(int tdm_index, int is_enable);
+
+extern void tdm_fifo_enable(int tdm_index, int is_enable);
+
+extern void aml_tdmout_select_aed(bool enable, int tdmout_id);
+
+extern void aml_tdmout_get_aed_info(int tdmout_id,
+	int *bitwidth, int *frddrtype);
+
+extern void aml_tdm_clk_pad_select(
+	struct aml_audio_controller *actrl,
+	int mpad, int mpad_offset, int mclk_sel,
+	int tdm_index, int clk_sel);
+void aml_tdm_mclk_pad_select(struct aml_audio_controller *actrl,
+			     int mpad, int mpad_offset, int mclk_sel);
+void aml_tdm_sclk_pad_select(struct aml_audio_controller *actrl,
+			     int mpad_offset, int tdm_index, int clk_sel);
+
+extern void i2s_to_hdmitx_ctrl(int tdm_index);
+void aml_tdm_mute_playback(
+		struct aml_audio_controller *actrl,
+		int index,
+		bool mute,
+		int lane_cnt);
+void aml_tdm_mute_capture(
+		struct aml_audio_controller *actrl,
+		int tdm_index,
+		bool mute,
+		int lane_cnt);
+void aml_tdm_out_reset(unsigned int tdm_id, int offset);
+void aml_tdm_set_oe_v1(
+	struct aml_audio_controller *actrl,
+	int index, int force_oe, int oe_val);
+void aml_tdm_set_oe_v2(
+	struct aml_audio_controller *actrl,
+	int index, int force_oe, int oe_val);
+
+#endif
\ No newline at end of file
diff -ruN a/drivers/evl/sound/evl-amlogic/tdm_match_table.c b/evl/sound/evl-amlogic/tdm_match_table.c
--- a/drivers/evl/sound/evl-amlogic/tdm_match_table.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tdm_match_table.c	2021-12-24 09:27:12.698739646 +0300
@@ -0,0 +1,318 @@
+/*
+ * sound/soc/amlogic/auge/tdm_match_table.c
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+/* For OE function V1:
+ * OE is set by EE_AUDIO_TDMOUT_A_CTRL0 & EE_AUDIO_TDMOUT_A_CTRL1
+ */
+#define OE_FUNCTION_V1 1
+/* For OE function V2:
+ * OE is set by EE_AUDIO_TDMOUT_A_CTRL2
+ */
+#define OE_FUNCTION_V2 2
+
+struct tdm_chipinfo {
+	/* device id */
+	unsigned int id;
+
+	/* lane max count */
+	unsigned int lane_cnt;
+
+	/* no eco, sclk_ws_inv for out */
+	bool sclk_ws_inv;
+
+	/* output en (oe) for pinmux */
+	unsigned int oe_fn;
+
+	/* clk pad */
+	bool no_mclkpad_ctrl;
+
+	/* same source */
+	bool same_src_fn;
+
+	/* same source, spdif re-enable */
+	bool same_src_spdif_reen;
+
+	/* ACODEC_ADC function */
+	bool adc_fn;
+
+	/* mclk pad offset */
+	bool mclkpad_no_offset;
+
+	/* offset config for SW_RESET in reg.h */
+	int reset_reg_offset;
+
+	/* async fifo */
+	bool async_fifo;
+};
+
+
+struct tdm_chipinfo axg_tdma_chipinfo = {
+	.id          = TDM_A,
+	.no_mclkpad_ctrl = true,
+};
+
+struct tdm_chipinfo axg_tdmb_chipinfo = {
+	.id          = TDM_B,
+	.no_mclkpad_ctrl = true,
+};
+
+struct tdm_chipinfo axg_tdmc_chipinfo = {
+	.id          = TDM_C,
+	.no_mclkpad_ctrl = true,
+};
+
+struct tdm_chipinfo axg_tdminlb_chipinfo = {
+	.id          = TDM_LB,
+	.no_mclkpad_ctrl = true,
+};
+
+struct tdm_chipinfo g12a_tdma_chipinfo = {
+	.id          = TDM_A,
+	.sclk_ws_inv = true,
+	.oe_fn       = true,
+	.same_src_fn = true,
+	.mclkpad_no_offset = true,
+};
+
+struct tdm_chipinfo g12a_tdmb_chipinfo = {
+	.id          = TDM_B,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.mclkpad_no_offset = true,
+};
+
+struct tdm_chipinfo g12a_tdmc_chipinfo = {
+	.id          = TDM_C,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.mclkpad_no_offset = true,
+};
+
+struct tdm_chipinfo g12a_tdminlb_chipinfo = {
+	.id          = TDM_LB,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.mclkpad_no_offset = true,
+};
+
+struct tdm_chipinfo tl1_tdma_chipinfo = {
+	.id          = TDM_A,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tl1_tdmb_chipinfo = {
+	.id          = TDM_B,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tl1_tdmc_chipinfo = {
+	.id          = TDM_C,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tl1_tdminlb_chipinfo = {
+	.id          = TDM_LB,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V1,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo sm1_tdma_chipinfo = {
+	.id          = TDM_A,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.lane_cnt    = LANE_MAX0,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo sm1_tdmb_chipinfo = {
+	.id          = TDM_B,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.lane_cnt    = LANE_MAX3,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo sm1_tdmc_chipinfo = {
+	.id          = TDM_C,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.lane_cnt    = LANE_MAX1,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo sm1_tdminlb_chipinfo = {
+	.id          = TDM_LB,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.lane_cnt    = LANE_MAX3,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tm2_tdma_chipinfo = {
+	.id          = TDM_A,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.lane_cnt    = LANE_MAX3,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tm2_tdmb_chipinfo = {
+	.id          = TDM_B,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.lane_cnt    = LANE_MAX1,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tm2_tdmc_chipinfo = {
+	.id          = TDM_C,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.adc_fn      = true,
+	.lane_cnt    = LANE_MAX1,
+	.reset_reg_offset = 1,
+	.async_fifo  = true,
+};
+
+struct tdm_chipinfo tm2_tdminlb_chipinfo = {
+	.id          = TDM_LB,
+	.sclk_ws_inv = true,
+	.oe_fn       = OE_FUNCTION_V2,
+	.same_src_fn = true,
+	.lane_cnt    = LANE_MAX3,
+	.async_fifo  = true,
+};
+
+static const struct of_device_id aml_tdm_device_id[] = {
+	{
+		.compatible = "amlogic, axg-snd-tdma",
+		.data       = &axg_tdma_chipinfo,
+	},
+	{
+		.compatible = "amlogic, axg-snd-tdmb",
+		.data       = &axg_tdmb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, axg-snd-tdmc",
+		.data       = &axg_tdmc_chipinfo,
+	},
+	{
+		.compatible = "amlogic, axg-snd-tdmlb",
+		.data       = &axg_tdminlb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-tdma",
+		.data       = &g12a_tdma_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-tdmb",
+		.data       = &g12a_tdmb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-tdmc",
+		.data       = &g12a_tdmc_chipinfo,
+	},
+	{
+		.compatible = "amlogic, g12a-snd-tdmlb",
+		.data       = &g12a_tdminlb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-tdma",
+		.data       = &tl1_tdma_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-tdmb",
+		.data       = &tl1_tdmb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-tdmc",
+		.data       = &tl1_tdmc_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tl1-snd-tdmlb",
+		.data       = &tl1_tdminlb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-tdma",
+		.data       = &sm1_tdma_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-tdmb",
+		.data       = &sm1_tdmb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-tdmc",
+		.data       = &sm1_tdmc_chipinfo,
+	},
+	{
+		.compatible = "amlogic, sm1-snd-tdmlb",
+		.data       = &sm1_tdminlb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-tdma",
+		.data       = &tm2_tdma_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-tdmb",
+		.data       = &tm2_tdmb_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-tdmc",
+		.data       = &tm2_tdmc_chipinfo,
+	},
+	{
+		.compatible = "amlogic, tm2-snd-tdmlb",
+		.data       = &tm2_tdminlb_chipinfo,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, aml_tdm_device_id);
diff -ruN a/drivers/evl/sound/evl-amlogic/tl1,clocks.c b/evl/sound/evl-amlogic/tl1,clocks.c
--- a/drivers/evl/sound/evl-amlogic/tl1,clocks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tl1,clocks.c	2021-12-23 13:28:10.966157511 +0300
@@ -0,0 +1,319 @@
+/*
+ * sound/soc/amlogic/auge/tl1,clocks.c
+ *
+ * Copyright (C) 2018 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "tl1_clocks: " fmt
+
+#include "dt-bindings/amlogic,tl1-audio-clk.h"
+
+#include "audio_clks.h"
+#include "regs.h"
+
+static spinlock_t aclk_lock;
+
+static const char *const mclk_parent_names[] = {
+	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
+	"fclk_div3", "fclk_div4", "fclk_div5"};
+
+static const char *const audioclk_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c", "mclk_d", "mclk_e",
+	"mclk_f", "i_slv_sclk_a", "i_slv_sclk_b", "i_slv_sclk_c",
+	"i_slv_sclk_d", "i_slv_sclk_e", "i_slv_sclk_f", "i_slv_sclk_g",
+	"i_slv_sclk_h", "i_slv_sclk_i", "i_slv_sclk_j"};
+
+CLOCK_GATE(audio_ddr_arb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 0);
+CLOCK_GATE(audio_pdm, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 1);
+CLOCK_GATE(audio_tdmina, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 2);
+CLOCK_GATE(audio_tdminb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 3);
+CLOCK_GATE(audio_tdminc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 4);
+CLOCK_GATE(audio_tdminlb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 5);
+CLOCK_GATE(audio_tdmouta, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 6);
+CLOCK_GATE(audio_tdmoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 7);
+CLOCK_GATE(audio_tdmoutc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 8);
+CLOCK_GATE(audio_frddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 9);
+CLOCK_GATE(audio_frddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 10);
+CLOCK_GATE(audio_frddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 11);
+CLOCK_GATE(audio_toddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 12);
+CLOCK_GATE(audio_toddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 13);
+CLOCK_GATE(audio_toddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 14);
+CLOCK_GATE(audio_loopbacka, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 15);
+CLOCK_GATE(audio_spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 16);
+CLOCK_GATE(audio_spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 17);
+CLOCK_GATE(audio_resamplea, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 18);
+CLOCK_GATE(audio_reserved0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 19);
+CLOCK_GATE(audio_reserved1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 20);
+CLOCK_GATE(audio_spdifoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 21);
+CLOCK_GATE(audio_eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 22);
+CLOCK_GATE(audio_resampleb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 26);
+CLOCK_GATE(audio_tovad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 27);
+CLOCK_GATE(audio_audiolocker, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 28);
+CLOCK_GATE(audio_spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 29);
+CLOCK_GATE(audio_fratv, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 30);
+CLOCK_GATE(audio_frhdmirx, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 31);
+
+CLOCK_GATE(audio_frddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 0);
+CLOCK_GATE(audio_toddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 1);
+CLOCK_GATE(audio_loopbackb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 2);
+
+static struct clk_gate *tl1_audio_clk_gates[] = {
+	&audio_ddr_arb,
+	&audio_pdm,
+	&audio_tdmina,
+	&audio_tdminb,
+	&audio_tdminc,
+	&audio_tdminlb,
+	&audio_tdmouta,
+	&audio_tdmoutb,
+	&audio_tdmoutc,
+	&audio_frddra,
+	&audio_frddrb,
+	&audio_frddrc,
+	&audio_toddra,
+	&audio_toddrb,
+	&audio_toddrc,
+	&audio_loopbacka,
+	&audio_spdifin,
+	&audio_spdifout,
+	&audio_resamplea,
+	&audio_reserved0,
+	&audio_reserved1,
+	&audio_spdifoutb,
+	&audio_eqdrc,
+	&audio_resampleb,
+	&audio_tovad,
+	&audio_audiolocker,
+	&audio_spdifin_lb,
+	&audio_fratv,
+	&audio_frhdmirx,
+
+	&audio_frddrd,
+	&audio_toddrd,
+	&audio_loopbackb,
+};
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw *tl1_audio_clk_hws[] = {
+	[CLKID_AUDIO_GATE_DDR_ARB]     = &audio_ddr_arb.hw,
+	[CLKID_AUDIO_GATE_PDM]         = &audio_pdm.hw,
+	[CLKID_AUDIO_GATE_TDMINA]      = &audio_tdmina.hw,
+	[CLKID_AUDIO_GATE_TDMINB]      = &audio_tdminb.hw,
+	[CLKID_AUDIO_GATE_TDMINC]      = &audio_tdminc.hw,
+	[CLKID_AUDIO_GATE_TDMINLB]     = &audio_tdminlb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTA]     = &audio_tdmouta.hw,
+	[CLKID_AUDIO_GATE_TDMOUTB]     = &audio_tdmoutb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTC]     = &audio_tdmoutc.hw,
+	[CLKID_AUDIO_GATE_FRDDRA]      = &audio_frddra.hw,
+	[CLKID_AUDIO_GATE_FRDDRB]      = &audio_frddrb.hw,
+	[CLKID_AUDIO_GATE_FRDDRC]      = &audio_frddrc.hw,
+	[CLKID_AUDIO_GATE_TODDRA]      = &audio_toddra.hw,
+	[CLKID_AUDIO_GATE_TODDRB]      = &audio_toddrb.hw,
+	[CLKID_AUDIO_GATE_TODDRC]      = &audio_toddrc.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKA]   = &audio_loopbacka.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN]     = &audio_spdifin.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_A]  = &audio_spdifout.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEA]   = &audio_resamplea.hw,
+	[CLKID_AUDIO_GATE_RESERVED0]   = &audio_reserved0.hw,
+	[CLKID_AUDIO_GATE_RESERVED1]   = &audio_reserved1.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_B]  = &audio_spdifoutb.hw,
+	[CLKID_AUDIO_GATE_EQDRC]       = &audio_eqdrc.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEB]   = &audio_resampleb.hw,
+	[CLKID_AUDIO_GATE_TOVAD]       = &audio_tovad.hw,
+	[CLKID_AUDIO_GATE_AUDIOLOCKER] = &audio_audiolocker.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN_LB]  = &audio_spdifin_lb.hw,
+	[CLKID_AUDIO_GATE_FRATV]       = &audio_fratv.hw,
+	[CLKID_AUDIO_GATE_FRHDMIRX]    = &audio_frhdmirx.hw,
+	[CLKID_AUDIO_GATE_FRDDRD]      = &audio_frddrd.hw,
+	[CLKID_AUDIO_GATE_TODDRD]      = &audio_toddrd.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKB]   = &audio_loopbackb.hw,
+};
+
+static int tl1_clk_gates_init(struct clk **clks, void __iomem *iobase)
+{
+	int clkid;
+
+	if (ARRAY_SIZE(tl1_audio_clk_gates) != MCLK_BASE) {
+		pr_err("check clk gates number\n");
+		return -EINVAL;
+	}
+
+	for (clkid = 0; clkid < MCLK_BASE; clkid++) {
+		tl1_audio_clk_gates[clkid]->reg = iobase;
+		clks[clkid] = clk_register(NULL, tl1_audio_clk_hws[clkid]);
+		WARN_ON(IS_ERR_OR_NULL(clks[clkid]));
+	}
+
+	return 0;
+}
+
+/* mclk_a */
+CLOCK_COM_MUX(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 31);
+/* mclk_b */
+CLOCK_COM_MUX(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 31);
+/* mclk_c */
+CLOCK_COM_MUX(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 31);
+/* mclk_d */
+CLOCK_COM_MUX(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 31);
+/* mclk_e */
+CLOCK_COM_MUX(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 31);
+/* mclk_f */
+CLOCK_COM_MUX(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 31);
+/* spdifin */
+CLOCK_COM_MUX(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0, 8);
+CLOCK_COM_GATE(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 31);
+/* spdifout */
+CLOCK_COM_MUX(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 31);
+/* audio resample_a */
+CLOCK_COM_MUX(resample_a,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 31);
+/* audio locker_out */
+CLOCK_COM_MUX(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 24);
+CLOCK_COM_DIV(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 16, 8);
+CLOCK_COM_GATE(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 31);
+/* audio locker_in */
+CLOCK_COM_MUX(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 8);
+CLOCK_COM_DIV(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0, 8);
+CLOCK_COM_GATE(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 15);
+/* pdmin0 */
+CLOCK_COM_MUX(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0, 16);
+CLOCK_COM_GATE(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 31);
+/* pdmin1 */
+CLOCK_COM_MUX(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0x7, 24);
+CLOCK_COM_DIV(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0, 16);
+CLOCK_COM_GATE(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 31);
+/* spdifout b*/
+CLOCK_COM_MUX(spdifout_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio resample_b */
+CLOCK_COM_MUX(resample_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 31);
+/* spdifin_lb, div is a fake */
+CLOCK_COM_MUX(spdifin_lb,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x1, 30);
+CLOCK_COM_DIV(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 29);
+CLOCK_COM_GATE(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio eqdrc  */
+CLOCK_COM_MUX(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0, 16);
+CLOCK_COM_GATE(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 31);
+/* audio vad  */
+CLOCK_COM_MUX(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0x7, 24);
+CLOCK_COM_DIV(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0, 16);
+CLOCK_COM_GATE(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 31);
+
+static int tl1_clks_init(struct clk **clks, void __iomem *iobase)
+{
+	IOMAP_COM_CLK(mclk_a, iobase);
+	clks[CLKID_AUDIO_MCLK_A] = REGISTER_CLK_COM(mclk_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_A]));
+
+	IOMAP_COM_CLK(mclk_b, iobase);
+	clks[CLKID_AUDIO_MCLK_B] = REGISTER_CLK_COM(mclk_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_B]));
+
+	IOMAP_COM_CLK(mclk_c, iobase);
+	clks[CLKID_AUDIO_MCLK_C] = REGISTER_CLK_COM(mclk_c);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_C]));
+
+	IOMAP_COM_CLK(mclk_d, iobase);
+	clks[CLKID_AUDIO_MCLK_D] = REGISTER_CLK_COM(mclk_d);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_D]));
+
+	IOMAP_COM_CLK(mclk_e, iobase);
+	clks[CLKID_AUDIO_MCLK_E] = REGISTER_CLK_COM(mclk_e);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_E]));
+
+	IOMAP_COM_CLK(mclk_f, iobase);
+	clks[CLKID_AUDIO_MCLK_F] = REGISTER_CLK_COM(mclk_f);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_F]));
+
+	IOMAP_COM_CLK(spdifin, iobase);
+	clks[CLKID_AUDIO_SPDIFIN] = REGISTER_CLK_COM(spdifin);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN]));
+
+	IOMAP_COM_CLK(spdifout, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_A] = REGISTER_CLK_COM(spdifout);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_A]));
+
+	IOMAP_COM_CLK(resample_a, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_A] = REGISTER_AUDIOCLK_COM(resample_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_A]));
+
+	IOMAP_COM_CLK(locker_out, iobase);
+	clks[CLKID_AUDIO_LOCKER_OUT] = REGISTER_AUDIOCLK_COM(locker_out);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_OUT]));
+
+	IOMAP_COM_CLK(locker_in, iobase);
+	clks[CLKID_AUDIO_LOCKER_IN] = REGISTER_AUDIOCLK_COM(locker_in);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_IN]));
+
+	IOMAP_COM_CLK(pdmin0, iobase);
+	clks[CLKID_AUDIO_PDMIN0] = REGISTER_CLK_COM(pdmin0);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN0]));
+
+	IOMAP_COM_CLK(pdmin1, iobase);
+	clks[CLKID_AUDIO_PDMIN1] = REGISTER_CLK_COM(pdmin1);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN1]));
+
+	IOMAP_COM_CLK(spdifout_b, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_B] = REGISTER_CLK_COM(spdifout_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_B]));
+
+	IOMAP_COM_CLK(resample_b, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_B] = REGISTER_AUDIOCLK_COM(resample_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_B]));
+
+	IOMAP_COM_CLK(spdifin_lb, iobase);
+	clks[CLKID_AUDIO_SPDIFIN_LB] = REGISTER_CLK_COM(spdifin_lb);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN_LB]));
+
+	IOMAP_COM_CLK(eqdrc, iobase);
+	clks[CLKID_AUDIO_EQDRC] = REGISTER_CLK_COM(eqdrc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_EQDRC]));
+
+	IOMAP_COM_CLK(vad, iobase);
+	clks[CLKID_AUDIO_VAD] = REGISTER_CLK_COM(vad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_VAD]));
+
+	return 0;
+}
+
+struct audio_clk_init tl1_audio_clks_init = {
+	.clk_num   = NUM_AUDIO_CLKS,
+	.clk_gates = tl1_clk_gates_init,
+	.clks      = tl1_clks_init,
+};
diff -ruN a/drivers/evl/sound/evl-amlogic/tm2,clocks.c b/evl/sound/evl-amlogic/tm2,clocks.c
--- a/drivers/evl/sound/evl-amlogic/tm2,clocks.c	1970-01-01 03:00:00.000000000 +0300
+++ b/evl/sound/evl-amlogic/tm2,clocks.c	2021-12-23 13:28:20.486157616 +0300
@@ -0,0 +1,419 @@
+/*
+ * sound/soc/amlogic/auge/tm2_clocks.c
+ *
+ * Copyright (C) 2019 Amlogic, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#undef pr_fmt
+#define pr_fmt(fmt) "tm2_audio_clocks: " fmt
+
+#include "dt-bindings/amlogic,tm2-audio-clk.h"
+
+#include "audio_clks.h"
+#include "regs.h"
+
+static spinlock_t aclk_lock;
+
+static const char *const mclk_parent_names[] = {
+	"mpll0", "mpll1", "mpll2", "mpll3", "hifi_pll",
+	"fclk_div3", "fclk_div4", "fclk_div5"};
+
+static const char *const audioclk_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c", "mclk_d", "mclk_e",
+	"mclk_f", "i_slv_sclk_a", "i_slv_sclk_b", "i_slv_sclk_c",
+	"i_slv_sclk_d", "i_slv_sclk_e", "i_slv_sclk_f", "i_slv_sclk_g",
+	"i_slv_sclk_h", "i_slv_sclk_i", "i_slv_sclk_j"};
+
+static const char *const mclk_pad_parent_names[] = {
+	"mclk_a", "mclk_b", "mclk_c",
+	"mclk_d", "mclk_e", "mclk_f"
+};
+
+CLOCK_GATE(audio_ddr_arb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 0);
+CLOCK_GATE(audio_pdm, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 1);
+CLOCK_GATE(audio_tdmina, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 2);
+CLOCK_GATE(audio_tdminb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 3);
+CLOCK_GATE(audio_tdminc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 4);
+CLOCK_GATE(audio_tdminlb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 5);
+CLOCK_GATE(audio_tdmouta, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 6);
+CLOCK_GATE(audio_tdmoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 7);
+CLOCK_GATE(audio_tdmoutc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 8);
+CLOCK_GATE(audio_frddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 9);
+CLOCK_GATE(audio_frddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 10);
+CLOCK_GATE(audio_frddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 11);
+CLOCK_GATE(audio_toddra, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 12);
+CLOCK_GATE(audio_toddrb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 13);
+CLOCK_GATE(audio_toddrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 14);
+CLOCK_GATE(audio_loopbacka, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 15);
+CLOCK_GATE(audio_spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 16);
+CLOCK_GATE(audio_spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 17);
+CLOCK_GATE(audio_resamplea, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 18);
+CLOCK_GATE(audio_reserved0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 19);
+CLOCK_GATE(audio_reserved1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 20);
+CLOCK_GATE(audio_spdifoutb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 21);
+CLOCK_GATE(audio_eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 22);
+CLOCK_GATE(audio_reserved2, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 23);
+CLOCK_GATE(audio_reserved3, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 24);
+CLOCK_GATE(audio_reserved4, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 25);
+CLOCK_GATE(audio_resampleb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 26);
+CLOCK_GATE(audio_tovad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 27);
+CLOCK_GATE(audio_audiolocker, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 28);
+CLOCK_GATE(audio_spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 29);
+CLOCK_GATE(audio_fratv, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 30);
+CLOCK_GATE(audio_frhdmirx, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN0), 31);
+
+CLOCK_GATE(audio_frddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 0);
+CLOCK_GATE(audio_toddrd, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 1);
+CLOCK_GATE(audio_loopbackb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 2);
+CLOCK_GATE(audio_frddre, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 3);
+CLOCK_GATE(audio_toddre, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 4);
+CLOCK_GATE(audio_earctx, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 5);
+CLOCK_GATE(audio_earcrx, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 6);
+CLOCK_GATE(audio_resampleb_old, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 7);
+CLOCK_GATE(audio_locker, AUD_ADDR_OFFSET(EE_AUDIO_CLK_GATE_EN1), 8);
+
+
+static struct clk_gate *tm2_audio_clk_gates[] = {
+	&audio_ddr_arb,
+	&audio_pdm,
+	&audio_tdmina,
+	&audio_tdminb,
+	&audio_tdminc,
+	&audio_tdminlb,
+	&audio_tdmouta,
+	&audio_tdmoutb,
+	&audio_tdmoutc,
+	&audio_frddra,
+	&audio_frddrb,
+	&audio_frddrc,
+	&audio_toddra,
+	&audio_toddrb,
+	&audio_toddrc,
+	&audio_loopbacka,
+	&audio_spdifin,
+	&audio_spdifout,
+	&audio_resamplea,
+	&audio_reserved0,
+	&audio_reserved1,
+	&audio_spdifoutb,
+	&audio_eqdrc,
+	&audio_reserved2,
+	&audio_reserved3,
+	&audio_reserved4,
+	&audio_resampleb,
+	&audio_tovad,
+	&audio_audiolocker,
+	&audio_spdifin_lb,
+	&audio_fratv,
+	&audio_frhdmirx,
+
+	&audio_frddrd,
+	&audio_toddrd,
+	&audio_loopbackb,
+	&audio_frddre,
+	&audio_toddre,
+	&audio_earctx,
+	&audio_earcrx,
+	&audio_resampleb_old,
+	&audio_locker,
+};
+
+/* Array of all clocks provided by this provider */
+static struct clk_hw *tm2_audio_clk_hws[] = {
+	[CLKID_AUDIO_GATE_DDR_ARB]     = &audio_ddr_arb.hw,
+	[CLKID_AUDIO_GATE_PDM]         = &audio_pdm.hw,
+	[CLKID_AUDIO_GATE_TDMINA]      = &audio_tdmina.hw,
+	[CLKID_AUDIO_GATE_TDMINB]      = &audio_tdminb.hw,
+	[CLKID_AUDIO_GATE_TDMINC]      = &audio_tdminc.hw,
+	[CLKID_AUDIO_GATE_TDMINLB]     = &audio_tdminlb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTA]     = &audio_tdmouta.hw,
+	[CLKID_AUDIO_GATE_TDMOUTB]     = &audio_tdmoutb.hw,
+	[CLKID_AUDIO_GATE_TDMOUTC]     = &audio_tdmoutc.hw,
+	[CLKID_AUDIO_GATE_FRDDRA]      = &audio_frddra.hw,
+	[CLKID_AUDIO_GATE_FRDDRB]      = &audio_frddrb.hw,
+	[CLKID_AUDIO_GATE_FRDDRC]      = &audio_frddrc.hw,
+	[CLKID_AUDIO_GATE_TODDRA]      = &audio_toddra.hw,
+	[CLKID_AUDIO_GATE_TODDRB]      = &audio_toddrb.hw,
+	[CLKID_AUDIO_GATE_TODDRC]      = &audio_toddrc.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKA]   = &audio_loopbacka.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN]     = &audio_spdifin.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_A]  = &audio_spdifout.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEA]   = &audio_resamplea.hw,
+	[CLKID_AUDIO_GATE_RESERVED0]   = &audio_reserved0.hw,
+	[CLKID_AUDIO_GATE_RESERVED1]   = &audio_reserved1.hw,
+	[CLKID_AUDIO_GATE_SPDIFOUT_B]  = &audio_spdifoutb.hw,
+	[CLKID_AUDIO_GATE_EQDRC]       = &audio_eqdrc.hw,
+	[CLKID_AUDIO_GATE_RESERVED2]   = &audio_reserved2.hw,
+	[CLKID_AUDIO_GATE_RESERVED3]   = &audio_reserved3.hw,
+	[CLKID_AUDIO_GATE_RESERVED4]   = &audio_reserved4.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEB]   = &audio_resampleb.hw,
+	[CLKID_AUDIO_GATE_TOVAD]       = &audio_tovad.hw,
+	[CLKID_AUDIO_GATE_AUDIOLOCKER] = &audio_audiolocker.hw,
+	[CLKID_AUDIO_GATE_SPDIFIN_LB]  = &audio_spdifin_lb.hw,
+	[CLKID_AUDIO_GATE_FRATV]       = &audio_fratv.hw,
+	[CLKID_AUDIO_GATE_FRHDMIRX]    = &audio_frhdmirx.hw,
+
+	[CLKID_AUDIO_GATE_FRDDRD]      = &audio_frddrd.hw,
+	[CLKID_AUDIO_GATE_TODDRD]      = &audio_toddrd.hw,
+	[CLKID_AUDIO_GATE_LOOPBACKB]   = &audio_loopbackb.hw,
+	[CLKID_AUDIO_GATE_FRDDRE]      = &audio_frddre.hw,
+	[CLKID_AUDIO_GATE_TODDRE]      = &audio_toddre.hw,
+	[CLKID_AUDIO_GATE_EARCTX]      = &audio_earctx.hw,
+	[CLKID_AUDIO_GATE_EARCRX]      = &audio_earcrx.hw,
+	[CLKID_AUDIO_GATE_RESAMPLEB_OLD] = &audio_resampleb_old.hw,
+	[CLKID_AUDIO_GATE_LOCKER]      = &audio_locker.hw,
+};
+
+static int tm2_clk_gates_init(struct clk **clks, void __iomem *iobase)
+{
+	int clkid;
+
+	if (ARRAY_SIZE(tm2_audio_clk_gates) != MCLK_BASE) {
+		pr_err("check clk gates number\n");
+		return -EINVAL;
+	}
+
+	for (clkid = 0; clkid < MCLK_BASE; clkid++) {
+		unsigned long offset =
+			(unsigned long)tm2_audio_clk_gates[clkid]->reg;
+		tm2_audio_clk_gates[clkid]->reg =
+			(void __iomem *)((unsigned long)iobase + offset);
+		clks[clkid] = clk_register(NULL, tm2_audio_clk_hws[clkid]);
+		WARN_ON(IS_ERR_OR_NULL(clks[clkid]));
+	}
+
+	return 0;
+}
+
+/* mclk_a */
+CLOCK_COM_MUX(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_a, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_A_CTRL(1)), 31);
+/* mclk_b */
+CLOCK_COM_MUX(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_b, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_B_CTRL(1)), 31);
+/* mclk_c */
+CLOCK_COM_MUX(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_c, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_C_CTRL(1)), 31);
+/* mclk_d */
+CLOCK_COM_MUX(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_d, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_D_CTRL(1)), 31);
+/* mclk_e */
+CLOCK_COM_MUX(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_e, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_E_CTRL(1)), 31);
+/* mclk_f */
+CLOCK_COM_MUX(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 0, 16);
+CLOCK_COM_GATE(mclk_f, AUD_ADDR_OFFSET(EE_AUDIO_MCLK_F_CTRL(1)), 31);
+/* mclk_pad0 */
+CLOCK_COM_MUX(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0x7, 8);
+CLOCK_COM_DIV(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0, 8);
+CLOCK_COM_GATE(mclk_pad0, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 15);
+/* mclk_pad1 */
+CLOCK_COM_MUX(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 0x7, 24);
+CLOCK_COM_DIV(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 16, 8);
+CLOCK_COM_GATE(mclk_pad1, AUD_ADDR_OFFSET(EE_AUDIO_MST_PAD_CTRL0(1)), 31);
+
+/* spdifin */
+CLOCK_COM_MUX(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 0, 8);
+CLOCK_COM_GATE(spdifin, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFIN_CTRL), 31);
+/* spdifout */
+CLOCK_COM_MUX(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_CTRL), 31);
+/* audio resample_a */
+CLOCK_COM_MUX(resample_a,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_a, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEA_CTRL), 31);
+/* audio locker_out */
+CLOCK_COM_MUX(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 24);
+CLOCK_COM_DIV(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 16, 8);
+CLOCK_COM_GATE(locker_out, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 31);
+/* audio locker_in */
+CLOCK_COM_MUX(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0xf, 8);
+CLOCK_COM_DIV(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 0, 8);
+CLOCK_COM_GATE(locker_in, AUD_ADDR_OFFSET(EE_AUDIO_CLK_LOCKER_CTRL), 15);
+/* pdmin0 */
+CLOCK_COM_MUX(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 0, 16);
+CLOCK_COM_GATE(pdmin0, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL0), 31);
+/* pdmin1 */
+CLOCK_COM_MUX(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0x7, 24);
+CLOCK_COM_DIV(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 0, 16);
+CLOCK_COM_GATE(pdmin1, AUD_ADDR_OFFSET(EE_AUDIO_CLK_PDMIN_CTRL1), 31);
+/* spdifout b*/
+CLOCK_COM_MUX(spdifout_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x7, 24);
+CLOCK_COM_DIV(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 10);
+CLOCK_COM_GATE(spdifout_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio resample_b */
+CLOCK_COM_MUX(resample_b,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0xf, 24);
+CLOCK_COM_DIV(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 0, 8);
+CLOCK_COM_GATE(resample_b, AUD_ADDR_OFFSET(EE_AUDIO_CLK_RESAMPLEB_CTRL), 31);
+/* spdifin_lb, div is a fake */
+CLOCK_COM_MUX(spdifin_lb,
+	AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0x1, 30);
+CLOCK_COM_DIV(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 0, 29);
+CLOCK_COM_GATE(spdifin_lb, AUD_ADDR_OFFSET(EE_AUDIO_CLK_SPDIFOUT_B_CTRL), 31);
+/* audio eqdrc  */
+CLOCK_COM_MUX(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0x7, 24);
+CLOCK_COM_DIV(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 0, 16);
+CLOCK_COM_GATE(eqdrc, AUD_ADDR_OFFSET(EE_AUDIO_CLK_EQDRC_CTRL0), 31);
+/* audio vad  */
+CLOCK_COM_MUX(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0x7, 24);
+CLOCK_COM_DIV(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 0, 16);
+CLOCK_COM_GATE(vad, AUD_ADDR_OFFSET(EE_AUDIO_CLK_VAD_CTRL), 31);
+/* EARC TX CMDC */
+CLOCK_COM_MUX(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earctx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_CMDC_CLK_CTRL), 31);
+/* EARC TX DMAC */
+CLOCK_COM_MUX(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earctx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCTX_DMAC_CLK_CTRL), 31);
+/* EARC RX CMDC */
+CLOCK_COM_MUX(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earcrx_cmdc,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_CMDC_CLK_CTRL), 31);
+/* EARC RX DMAC */
+CLOCK_COM_MUX(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 0x7, 24);
+CLOCK_COM_DIV(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 0, 16);
+CLOCK_COM_GATE(earcrx_dmac,
+	AUD_ADDR_OFFSET(EE_AUDIO_EARCRX_DMAC_CLK_CTRL), 31);
+
+static int tm2_clks_init(struct clk **clks, void __iomem *iobase)
+{
+	IOMAP_COM_CLK(mclk_a, iobase);
+	clks[CLKID_AUDIO_MCLK_A] = REGISTER_CLK_COM(mclk_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_A]));
+
+	IOMAP_COM_CLK(mclk_b, iobase);
+	clks[CLKID_AUDIO_MCLK_B] = REGISTER_CLK_COM(mclk_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_B]));
+
+	IOMAP_COM_CLK(mclk_c, iobase);
+	clks[CLKID_AUDIO_MCLK_C] = REGISTER_CLK_COM(mclk_c);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_C]));
+
+	IOMAP_COM_CLK(mclk_d, iobase);
+	clks[CLKID_AUDIO_MCLK_D] = REGISTER_CLK_COM(mclk_d);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_D]));
+
+	IOMAP_COM_CLK(mclk_e, iobase);
+	clks[CLKID_AUDIO_MCLK_E] = REGISTER_CLK_COM(mclk_e);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_E]));
+
+	IOMAP_COM_CLK(mclk_f, iobase);
+	clks[CLKID_AUDIO_MCLK_F] = REGISTER_CLK_COM(mclk_f);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_F]));
+
+	IOMAP_COM_CLK(spdifin, iobase);
+	clks[CLKID_AUDIO_SPDIFIN] = REGISTER_CLK_COM(spdifin);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN]));
+
+	IOMAP_COM_CLK(spdifout, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_A] = REGISTER_CLK_COM(spdifout);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_A]));
+
+	IOMAP_COM_CLK(resample_a, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_A] = REGISTER_AUDIOCLK_COM(resample_a);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_A]));
+
+	IOMAP_COM_CLK(locker_out, iobase);
+	clks[CLKID_AUDIO_LOCKER_OUT] = REGISTER_AUDIOCLK_COM(locker_out);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_OUT]));
+
+	IOMAP_COM_CLK(locker_in, iobase);
+	clks[CLKID_AUDIO_LOCKER_IN] = REGISTER_AUDIOCLK_COM(locker_in);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_LOCKER_IN]));
+
+	IOMAP_COM_CLK(pdmin0, iobase);
+	clks[CLKID_AUDIO_PDMIN0] = REGISTER_CLK_COM(pdmin0);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN0]));
+
+	IOMAP_COM_CLK(pdmin1, iobase);
+	clks[CLKID_AUDIO_PDMIN1] = REGISTER_CLK_COM(pdmin1);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_PDMIN1]));
+
+	IOMAP_COM_CLK(spdifout_b, iobase);
+	clks[CLKID_AUDIO_SPDIFOUT_B] = REGISTER_CLK_COM(spdifout_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFOUT_B]));
+
+	IOMAP_COM_CLK(resample_b, iobase);
+	clks[CLKID_AUDIO_RESAMPLE_B] = REGISTER_AUDIOCLK_COM(resample_b);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_RESAMPLE_B]));
+
+	IOMAP_COM_CLK(spdifin_lb, iobase);
+	clks[CLKID_AUDIO_SPDIFIN_LB] = REGISTER_CLK_COM(spdifin_lb);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_SPDIFIN_LB]));
+
+	IOMAP_COM_CLK(eqdrc, iobase);
+	clks[CLKID_AUDIO_EQDRC] = REGISTER_CLK_COM(eqdrc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_EQDRC]));
+
+	IOMAP_COM_CLK(vad, iobase);
+	clks[CLKID_AUDIO_VAD] = REGISTER_CLK_COM(vad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_VAD]));
+
+	IOMAP_COM_CLK(earctx_cmdc, iobase);
+	clks[CLKID_EARCTX_CMDC] = REGISTER_CLK_COM(earctx_cmdc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCTX_CMDC]));
+
+	IOMAP_COM_CLK(earctx_dmac, iobase);
+	clks[CLKID_EARCTX_DMAC] = REGISTER_CLK_COM(earctx_dmac);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCTX_DMAC]));
+
+	IOMAP_COM_CLK(earcrx_cmdc, iobase);
+	clks[CLKID_EARCRX_CMDC] = REGISTER_CLK_COM(earcrx_cmdc);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCRX_CMDC]));
+
+	IOMAP_COM_CLK(earcrx_dmac, iobase);
+	clks[CLKID_EARCRX_DMAC] = REGISTER_CLK_COM(earcrx_dmac);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_EARCRX_DMAC]));
+
+	IOMAP_COM_CLK(mclk_pad0, iobase);
+	clks[CLKID_AUDIO_MCLK_PAD0] =
+			REGISTER_CLK_COM_PARENTS(mclk_pad0, mclk_pad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_PAD0]));
+
+	IOMAP_COM_CLK(mclk_pad1, iobase);
+	clks[CLKID_AUDIO_MCLK_PAD1] =
+			REGISTER_CLK_COM_PARENTS(mclk_pad1, mclk_pad);
+	WARN_ON(IS_ERR_OR_NULL(clks[CLKID_AUDIO_MCLK_PAD1]));
+
+	return 0;
+}
+
+struct audio_clk_init tm2_audio_clks_init = {
+	.clk_num   = NUM_AUDIO_CLKS,
+	.clk_gates = tm2_clk_gates_init,
+	.clks      = tm2_clks_init,
+};
