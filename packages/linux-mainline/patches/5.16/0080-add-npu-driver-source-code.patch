From 00d75e3520b8b26972fec940217fabb94579943a Mon Sep 17 00:00:00 2001
From: Yan <yan-wyb@foxmail.com>
Date: Tue, 14 Dec 2021 14:04:33 +0800
Subject: [PATCH 80/81] add npu driver source code

Signed-off-by: Yan <yan-wyb@foxmail.com>
---
 .../npu/inc/drvi/gc_vsc_drvi_interface.h      |  153 +-
 .../npu/inc/drvi/gc_vsc_drvi_kernel_profile.h |    5 +-
 .../npu/inc/drvi/gc_vsc_drvi_lib_link.h       |   16 +-
 .../inc/drvi/gc_vsc_drvi_program_profile.h    |   43 +-
 .../drvi/gc_vsc_drvi_shader_priv_mapping.h    |    5 +-
 .../npu/inc/drvi/gc_vsc_drvi_shader_profile.h |    6 +-
 drivers/staging/npu/inc/gc_feature_database.h | 1124 ++++++-
 drivers/staging/npu/inc/gc_hal.h              |   21 +-
 drivers/staging/npu/inc/gc_hal_base.h         |   24 +-
 drivers/staging/npu/inc/gc_hal_cl.h           |   19 +-
 drivers/staging/npu/inc/gc_hal_debug_zones.h  |    2 +-
 drivers/staging/npu/inc/gc_hal_driver.h       |    2 +-
 drivers/staging/npu/inc/gc_hal_driver_vg.h    |    2 +-
 drivers/staging/npu/inc/gc_hal_drm.h          |   14 +-
 drivers/staging/npu/inc/gc_hal_dump.h         |    2 +-
 drivers/staging/npu/inc/gc_hal_eglplatform.h  |    2 +-
 .../staging/npu/inc/gc_hal_eglplatform_type.h |    2 +-
 drivers/staging/npu/inc/gc_hal_engine.h       |   14 +-
 drivers/staging/npu/inc/gc_hal_engine_vg.h    |    2 +-
 drivers/staging/npu/inc/gc_hal_enum.h         |  142 +-
 drivers/staging/npu/inc/gc_hal_mem.h          |    2 +-
 drivers/staging/npu/inc/gc_hal_metadata.h     |    2 +-
 drivers/staging/npu/inc/gc_hal_options.h      |   47 +-
 drivers/staging/npu/inc/gc_hal_priv.h         |   10 +-
 drivers/staging/npu/inc/gc_hal_profiler.h     |  188 +-
 drivers/staging/npu/inc/gc_hal_raster.h       |   14 +-
 .../npu/inc/gc_hal_security_interface.h       |    2 +-
 drivers/staging/npu/inc/gc_hal_statistics.h   |    2 +-
 drivers/staging/npu/inc/gc_hal_types.h        |    2 +-
 drivers/staging/npu/inc/gc_hal_version.h      |    8 +-
 drivers/staging/npu/inc/gc_hal_vg.h           |    2 +-
 drivers/staging/npu/inc/gc_hal_vx.h           |   26 +-
 drivers/staging/npu/inc/gc_vsc_precomp.h      |    2 +-
 .../inc/old_impl/gc_vsc_old_drvi_interface.h  |  128 +-
 .../npu/inc/old_impl/gc_vsc_old_gcsl.h        |  176 +-
 .../staging/npu/inc/probeStatistics_Driver.h  | 1632 ++++++++++
 .../npu/inc/shared/gc_hal_base_shared.h       |    2 +-
 .../npu/inc/shared/gc_hal_driver_shared.h     |   13 +-
 .../npu/inc/shared/gc_hal_driver_vg_shared.h  |    4 +-
 .../npu/inc/shared/gc_hal_enum_shared.h       |   65 +-
 .../npu/inc/shared/gc_hal_profiler_shared.h   |    7 +-
 .../npu/inc/shared/gc_hal_types_shared.h      |   90 +-
 .../staging/npu/inc/shared/gc_hal_vg_shared.h |    2 +-
 drivers/staging/npu/kernel/Android.mk         |    3 +-
 .../staging/npu/kernel/arch/cebuild/makefile  |    4 +-
 .../staging/npu/kernel/arch/cebuild/sources   |    4 +-
 .../npu/kernel/arch/gc_hal_kernel_context.c   |   38 +-
 .../npu/kernel/arch/gc_hal_kernel_context.h   |   11 +-
 .../npu/kernel/arch/gc_hal_kernel_hardware.c  |  559 +++-
 .../npu/kernel/arch/gc_hal_kernel_hardware.h  |   29 +-
 .../arch/gc_hal_kernel_hardware_async_fe.c    |    4 +-
 .../kernel/arch/gc_hal_kernel_hardware_fe.h   |    4 +-
 .../kernel/arch/gc_hal_kernel_hardware_func.c |  236 +-
 .../kernel/arch/gc_hal_kernel_hardware_func.h |    7 +-
 .../gc_hal_kernel_hardware_func_flop_reset.c  | 2689 +++--------------
 .../gc_hal_kernel_hardware_func_flop_reset.h  |    8 +-
 ...l_kernel_hardware_func_flop_reset_config.h | 1911 ++++--------
 .../arch/gc_hal_kernel_hardware_func_ppu.h    |    4 +-
 .../arch/gc_hal_kernel_hardware_func_usc.h    |    4 +-
 .../arch/gc_hal_kernel_hardware_mc_fe.c       |   43 +-
 .../arch/gc_hal_kernel_hardware_waitlink_fe.c |   14 +-
 .../npu/kernel/arch/gc_hal_kernel_recorder.c  |    4 +-
 .../staging/npu/kernel/arch/makefile.linux    |    4 +-
 drivers/staging/npu/kernel/cebuild/makefile   |    4 +-
 drivers/staging/npu/kernel/cebuild/sources    |    5 +-
 drivers/staging/npu/kernel/gc_hal_kernel.c    |  148 +-
 drivers/staging/npu/kernel/gc_hal_kernel.h    |   21 +-
 .../npu/kernel/gc_hal_kernel_command.c        |  315 +-
 drivers/staging/npu/kernel/gc_hal_kernel_db.c |    4 +-
 .../staging/npu/kernel/gc_hal_kernel_event.c  |    4 +-
 .../staging/npu/kernel/gc_hal_kernel_heap.c   |    4 +-
 .../staging/npu/kernel/gc_hal_kernel_mmu.c    | 2052 ++++++++++---
 .../staging/npu/kernel/gc_hal_kernel_power.c  |    4 +-
 .../npu/kernel/gc_hal_kernel_precomp.h        |    4 +-
 .../npu/kernel/gc_hal_kernel_preemption.c     |  331 +-
 .../npu/kernel/gc_hal_kernel_preemption.h     |   12 +-
 .../npu/kernel/gc_hal_kernel_security.c       |    4 +-
 .../npu/kernel/gc_hal_kernel_security_v1.c    |    4 +-
 .../npu/kernel/gc_hal_kernel_video_memory.c   |  149 +-
 .../npu/kernel/inc/gc_feature_database.h      | 1124 ++++++-
 drivers/staging/npu/kernel/inc/gc_hal.h       |   23 +-
 drivers/staging/npu/kernel/inc/gc_hal_base.h  |   26 +-
 .../npu/kernel/inc/gc_hal_debug_zones.h       |    4 +-
 .../staging/npu/kernel/inc/gc_hal_driver.h    |    4 +-
 .../staging/npu/kernel/inc/gc_hal_driver_vg.h |    4 +-
 drivers/staging/npu/kernel/inc/gc_hal_drm.h   |   16 +-
 drivers/staging/npu/kernel/inc/gc_hal_dump.h  |    4 +-
 .../npu/kernel/inc/gc_hal_eglplatform.h       |    4 +-
 .../npu/kernel/inc/gc_hal_eglplatform_type.h  |    4 +-
 .../staging/npu/kernel/inc/gc_hal_engine.h    |   16 +-
 .../staging/npu/kernel/inc/gc_hal_engine_vg.h |    4 +-
 drivers/staging/npu/kernel/inc/gc_hal_enum.h  |  144 +-
 .../npu/kernel/inc/gc_hal_kernel_buffer.h     |    4 +-
 drivers/staging/npu/kernel/inc/gc_hal_mem.h   |    4 +-
 .../staging/npu/kernel/inc/gc_hal_metadata.h  |    4 +-
 .../staging/npu/kernel/inc/gc_hal_options.h   |   50 +-
 .../staging/npu/kernel/inc/gc_hal_profiler.h  |  190 +-
 .../staging/npu/kernel/inc/gc_hal_raster.h    |   16 +-
 .../kernel/inc/gc_hal_security_interface.h    |    4 +-
 .../npu/kernel/inc/gc_hal_statistics.h        |    4 +-
 drivers/staging/npu/kernel/inc/gc_hal_types.h |    4 +-
 .../staging/npu/kernel/inc/gc_hal_version.h   |   10 +-
 drivers/staging/npu/kernel/inc/gc_hal_vg.h    |    4 +-
 .../npu/kernel/inc/probeStatistics_Driver.h   | 1674 ++++++++++
 .../kernel/inc/shared/gc_hal_base_shared.h    |    4 +-
 .../kernel/inc/shared/gc_hal_driver_shared.h  |   15 +-
 .../inc/shared/gc_hal_driver_vg_shared.h      |    6 +-
 .../kernel/inc/shared/gc_hal_enum_shared.h    |   67 +-
 .../inc/shared/gc_hal_profiler_shared.h       |    9 +-
 .../kernel/inc/shared/gc_hal_types_shared.h   |   92 +-
 .../npu/kernel/inc/shared/gc_hal_vg_shared.h  |    4 +-
 drivers/staging/npu/kernel/makefile.linux     |    5 +-
 drivers/staging/npu/os/libGAL.def.mak         |   32 +-
 .../default/gc_hal_kernel_allocator_array.h   |    4 +-
 .../default/gc_hal_kernel_allocator_dma.c     |   98 +-
 .../default/gc_hal_kernel_allocator_dmabuf.c  |   13 +-
 .../default/gc_hal_kernel_allocator_gfp.c     |   60 +-
 .../gc_hal_kernel_allocator_reserved_mem.c    |   82 +-
 .../gc_hal_kernel_allocator_user_memory.c     |  254 +-
 .../os/linux/kernel/gc_hal_kernel_allocator.c |   26 +-
 .../os/linux/kernel/gc_hal_kernel_allocator.h |    8 +-
 .../linux}/kernel/gc_hal_kernel_debug.c       |   18 +-
 .../npu/os/linux/kernel/gc_hal_kernel_debug.h |    6 +-
 .../os/linux/kernel/gc_hal_kernel_debugfs.c   |    4 +-
 .../os/linux/kernel/gc_hal_kernel_debugfs.h   |    6 +-
 .../os/linux/kernel/gc_hal_kernel_device.c    | 1110 +++----
 .../os/linux/kernel/gc_hal_kernel_device.h    |    4 +-
 .../os/linux/kernel/gc_hal_kernel_driver.c    |  173 +-
 .../npu/os/linux/kernel/gc_hal_kernel_drm.c   |   45 +-
 .../npu/os/linux/kernel/gc_hal_kernel_iommu.c |  178 +-
 .../npu/os/linux/kernel/gc_hal_kernel_linux.c |    4 +-
 .../npu/os/linux/kernel/gc_hal_kernel_linux.h |   51 +-
 .../npu/os/linux/kernel/gc_hal_kernel_math.c  |    4 +-
 .../npu/os/linux/kernel/gc_hal_kernel_mutex.h |    4 +-
 .../npu/os/linux/kernel/gc_hal_kernel_os.c    |  141 +-
 .../npu/os/linux/kernel/gc_hal_kernel_os.h    |    4 +-
 .../os/linux/kernel/gc_hal_kernel_platform.h  |   68 +-
 ...08x.c => gc_hal_kernel_platform_amlogic.c} |  230 +-
 .../kernel/gc_hal_kernel_security_channel.c   |    4 +-
 .../gc_hal_kernel_security_channel_emulator.c |    4 +-
 .../npu/os/linux/kernel/gc_hal_kernel_sync.c  |    4 +-
 .../npu/os/linux/kernel/gc_hal_kernel_sync.h  |    4 +-
 .../amlogic/gc_hal_kernel_platform_amlogic.c  |    6 +-
 .../gc_hal_kernel_platform_c308x.config       |    4 -
 .../amlogic/gc_hal_kernel_platform_pico.c     |  453 ---
 .../gc_hal_kernel_platform_pico.config        |    4 -
 .../amlogic/gc_hal_kernel_platform_vim3.c     |  179 --
 .../gc_hal_kernel_platform_vim3.config        |    4 -
 .../default/gc_hal_kernel_platform_default.c  |  627 +++-
 .../default/gc_hal_kernel_platform_default.h  |   80 +
 drivers/staging/npu/security_v1/gc_hal_ta.c   |    4 +-
 drivers/staging/npu/security_v1/gc_hal_ta.h   |    4 +-
 .../npu/security_v1/gc_hal_ta_hardware.c      |    4 +-
 .../npu/security_v1/gc_hal_ta_hardware.h      |    4 +-
 .../staging/npu/security_v1/gc_hal_ta_mmu.c   |    4 +-
 .../os/emulator/gc_hal_ta_emulator.c          |    4 +-
 156 files changed, 13120 insertions(+), 7122 deletions(-)
 create mode 100644 drivers/staging/npu/inc/probeStatistics_Driver.h
 create mode 100644 drivers/staging/npu/kernel/inc/probeStatistics_Driver.h
 rename drivers/staging/npu/{ => os/linux}/kernel/gc_hal_kernel_debug.c (98%)
 rename drivers/staging/npu/os/linux/kernel/{platform/amlogic/gc_hal_kernel_platform_c308x.c => gc_hal_kernel_platform_amlogic.c} (62%)
 delete mode 100755 drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.config
 delete mode 100644 drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.c
 delete mode 100755 drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.config
 delete mode 100644 drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.c
 delete mode 100755 drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.config
 create mode 100644 drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.h

diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_interface.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_interface.h
index 0eccfd3f0d05..bd0f951df95b 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_interface.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_interface.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -70,8 +70,27 @@
 /* 0.0.1.47 Save the HW specific attributes in VIR_Shader 05/26/2020 */
 /* 0.0.1.48 Add a new variable to save the symbol ID of the register spill base address in VIR_Shader 07/13/2020 */
 /* 0.0.1.49 Save the RA instruction ID in VIR_Instruction 08/11/2020 */
-#define gcdVIR_SHADER_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 49)
-#define gcdVIR_PROGRAM_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 49)
+/* 0.0.1.50 Always save enclose function ID 01/19/2021 */
+/* 0.0.1.51 Add a new enumeration for VIR_InstFlag 01/25/2021 */
+/* 0.0.1.52 Save the linkage information for VIR_Symbol 02/23/2021 */
+/* 0.0.1.53 Change the layout of VIR_OPERAND_REL_INFO 02/24/2021 */
+/* 0.0.1.54 Save VIR_OPERAND_REL_INFO 02/25/2021 */
+/* 0.0.1.55 Change the value of VIR_SymFlagExt 03/03/2021 */
+#define gcdVIR_SHADER_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 55)
+#define gcdVIR_PROGRAM_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 55)
+
+/*********************** VIR SHADER BINARY FILE SUB VERSION *********************/
+#define gcdVIR_SHADER_BINARY_SUB_VERSION gcmCC(SHADER_64BITMODE, 0, 0, 0)
+
+/******************** VIR SHADER LIBRARY BINARY FILE VERSION *********************/
+/* Current vir shader CL/VX library version */
+/* 0.0.0.0 Start to set vir shader cl/vx library version, 12/23/2020 */
+/* 0.0.0.1 Change vir shader cl/vx library version to add long/ulong intrinsic functions, 03/15/2021 */
+#define gcdVIR_SHADER_CL_LIBRARY_FILE_VERSION  gcmCC(SHADER_64BITMODE, 0, 0, 1)
+
+/* Current vir shader graphic library version */
+/* 0.0.0.0 Start to set vir shader library version, 12/23/2020 */
+#define gcdVIR_SHADER_GRAPHICS_LIBRARY_FILE_VERSION  gcmCC(SHADER_64BITMODE, 0, 0, 0)
 
 #if !defined(gcdTARGETHOST_BIGENDIAN)
 #define gcdTARGETHOST_BIGENDIAN 0  /* default host little endian, to change the
@@ -421,31 +440,39 @@ typedef enum _VSC_IMAGE_FORMAT
     VSC_IMAGE_FORMAT_NONE = 0x00000000,
     /*F32.*/
     VSC_IMAGE_FORMAT_RGBA32F,
+    VSC_IMAGE_FORMAT_RGB32F,
     VSC_IMAGE_FORMAT_RG32F,
     VSC_IMAGE_FORMAT_R32F,
     /*I32.*/
     VSC_IMAGE_FORMAT_RGBA32I,
+    VSC_IMAGE_FORMAT_RGB32I,
     VSC_IMAGE_FORMAT_RG32I,
     VSC_IMAGE_FORMAT_R32I,
     /*UI32.*/
     VSC_IMAGE_FORMAT_RGBA32UI,
+    VSC_IMAGE_FORMAT_RGB32UI,
     VSC_IMAGE_FORMAT_RG32UI,
     VSC_IMAGE_FORMAT_R32UI,
     /*F16.*/
     VSC_IMAGE_FORMAT_RGBA16F,
+    VSC_IMAGE_FORMAT_RGB16F,
     VSC_IMAGE_FORMAT_RG16F,
     VSC_IMAGE_FORMAT_R16F,
     /*I16.*/
     VSC_IMAGE_FORMAT_RGBA16I,
+    VSC_IMAGE_FORMAT_RGB16I,
     VSC_IMAGE_FORMAT_RG16I,
     VSC_IMAGE_FORMAT_R16I,
     /*UI16.*/
     VSC_IMAGE_FORMAT_RGBA16UI,
+    VSC_IMAGE_FORMAT_RGB16UI,
     VSC_IMAGE_FORMAT_RG16UI,
     VSC_IMAGE_FORMAT_R16UI,
     /*F16 SNORM/UNORM.*/
     VSC_IMAGE_FORMAT_RGBA16,
     VSC_IMAGE_FORMAT_RGBA16_SNORM,
+    VSC_IMAGE_FORMAT_RGB16,
+    VSC_IMAGE_FORMAT_RGB16_SNORM,
     VSC_IMAGE_FORMAT_RG16,
     VSC_IMAGE_FORMAT_RG16_SNORM,
     VSC_IMAGE_FORMAT_R16,
@@ -454,26 +481,33 @@ typedef enum _VSC_IMAGE_FORMAT
     VSC_IMAGE_FORMAT_BGRA8_UNORM,
     VSC_IMAGE_FORMAT_RGBA8,
     VSC_IMAGE_FORMAT_RGBA8_SNORM,
+    VSC_IMAGE_FORMAT_RGB8,
+    VSC_IMAGE_FORMAT_RGB8_SNORM,
     VSC_IMAGE_FORMAT_RG8,
     VSC_IMAGE_FORMAT_RG8_SNORM,
     VSC_IMAGE_FORMAT_R8,
     VSC_IMAGE_FORMAT_R8_SNORM,
     /*I8.*/
     VSC_IMAGE_FORMAT_RGBA8I,
+    VSC_IMAGE_FORMAT_RGB8I,
     VSC_IMAGE_FORMAT_RG8I,
     VSC_IMAGE_FORMAT_R8I,
     /*UI8.*/
     VSC_IMAGE_FORMAT_RGBA8UI,
+    VSC_IMAGE_FORMAT_RGB8UI,
     VSC_IMAGE_FORMAT_RG8UI,
     VSC_IMAGE_FORMAT_R8UI,
     /*F-PACK.*/
     VSC_IMAGE_FORMAT_R5G6B5_UNORM_PACK16,
+    VSC_IMAGE_FORMAT_R5G5B5_UNORM_PACK16,
     VSC_IMAGE_FORMAT_ABGR8_UNORM_PACK32,
     VSC_IMAGE_FORMAT_ABGR8I_PACK32,
     VSC_IMAGE_FORMAT_ABGR8UI_PACK32,
     VSC_IMAGE_FORMAT_A2R10G10B10_UNORM_PACK32,
     VSC_IMAGE_FORMAT_A2B10G10R10_UNORM_PACK32,
     VSC_IMAGE_FORMAT_A2B10G10R10UI_PACK32,
+
+    VSC_IMAGE_FORMAT_COUNT,
 } VSC_IMAGE_FORMAT;
 
 typedef enum _VSC_ADDRSPACE
@@ -667,6 +701,8 @@ typedef struct _VSC_DRV_CALLBACKS
     PFN_FREE_VIDMEM_CB  pfnFreeVidMemCb;
 }VSC_DRV_CALLBACKS, *PVSC_DRV_CALLBACKS;
 
+#define __MINIMUM_VID_MEM_ALIGN_SIZE__      256
+
 /* VSC hardware (chip) configuration that poses on (re)-compiling */
 typedef struct _VSC_HW_CONFIG
 {
@@ -731,7 +767,7 @@ typedef struct _VSC_HW_CONFIG
         gctUINT          canSrc0OfImgLdStBeTemp : 1;
 
         gctUINT          hasPSIOInterlock       : 1;
-        gctUINT          support128BppImage     : 1;
+        gctUINT          support128bppTexture   : 1;
         gctUINT          supportMSAATexture     : 1;
         gctUINT          supportPerCompDepForLS : 1;
         gctUINT          supportImgAddr         : 1;
@@ -794,7 +830,23 @@ typedef struct _VSC_HW_CONFIG
         gctUINT          hasUSCAtomicFix2       : 1;
         gctUINT          hasFloatingMadFix      : 1;
         gctUINT          hasA0WriteEnableFix    : 1;
-        gctUINT          reserved1              : 26;
+        gctUINT          dstTexI2FInstDeprecate : 1;
+        gctUINT          hasAluFp16InstSupport  : 1;
+        gctUINT          has14BitPcDual16       : 1;
+        gctUINT          ldstConv4RoundingMode  : 1;
+        gctUINT          fullPackModeSupport    : 1;
+        gctUINT          hasFp32ToFp16ConvFix   : 1;
+        gctUINT          ldDststSrc2DenormFp32  : 1;
+        gctUINT          supportFloatOrdNotEqual: 1;
+        gctUINT          hasCallRetFix          : 1;
+        gctUINT          supportJmpAfterEndPC   : 1;
+        gctUINT          hasImgLdCompCountFix   : 1;
+        /* CModel and some old chips have the different behavior, CModel doesn't calculate shift all the time. */
+        gctUINT          CalcShiftForImgLdSt    : 1;
+        gctUINT          supportFP32FMA         : 1;
+        gctUINT          hasVec2IntMulMad       : 1;
+        gctUINT          hasVec4IntMulMad       : 1;
+        gctUINT          reserved1              : 11;
 
         /* Last word */
         /* Followings will be removed after shader programming is removed out of VSC */
@@ -833,6 +885,7 @@ typedef struct _VSC_HW_CONFIG
     gctUINT              maxTotalInstCount;
     gctUINT              maxVSInstCount;
     gctUINT              maxPSInstCount;
+    gctUINT              maxInstCountUnderDual16;
     gctUINT              maxHwNativeTotalConstRegCount;
     gctUINT              maxTotalConstRegCount;
     gctUINT              unifiedConst;
@@ -960,6 +1013,7 @@ typedef gcsGLSLCaps VSC_GL_API_CONFIG, *PVSC_GL_API_CONFIG;
 #define VSC_COMPILER_FLAG_ENABLE_DUAL16_FOR_VK         0x00200000  /* It is a temp option to enable dual16 for vulkan. we need to remove after verify all vulkan cases. */
 #define VSC_COMPILER_FLAG_USE_CONST_REG_FOR_UBO        0x00400000
 #define VSC_COMPILER_FLAG_FORCE_GEN_FLOAT_MAD          0x00800000  /* Force generate a floating MAD, no matter if HW can support it. */
+#define VSC_COMPILER_FLAG_ALWAYS_EMIT_OUTPUT           0x01000000
 
 #define VSC_COMPILER_FLAG_COMPILE_FULL_LEVELS          0x0000000F
 
@@ -1006,6 +1060,9 @@ VSC_SHADER_STAGE_BIT;
 #define VSC_CPT_SHADER_STAGE_CS                        0
 
 typedef void* SHADER_HANDLE;
+typedef void* PROGRAM_RESOURCE_LAYOUT_HANDLE;
+typedef void* SHADER_RESOURCE_LAYOUT_HANDLE;
+typedef void* PROGRAM_LINKER_PARAM_HANDLE;
 typedef void* VSC_PRIV_DATA_HANDLE;
 
 typedef enum _VSC_SHADER_RESOURCE_TYPE
@@ -1225,6 +1282,36 @@ gceSTATUS vscFinalizeHwPipelineShadersStates(VSC_SYS_CONTEXT* pSysCtx, VSC_HW_PI
 gceSTATUS vscCreatePrivateData(VSC_CORE_SYS_CONTEXT* pCoreSysCtx, VSC_PRIV_DATA_HANDLE* phOutPrivData, gctBOOL bForOCL);
 gceSTATUS vscDestroyPrivateData(VSC_CORE_SYS_CONTEXT* pCoreSysCtx, VSC_PRIV_DATA_HANDLE hPrivData);
 
+/* Two ways to save VSC_PROGRAM_LINKER_PARAM binary:
+ * 1) compiler allocates memory and return the memory in *pBinary and size in pSizeInByte
+ *    if (* pBinary) is NULL when calling the function
+ * 2) Allocate memory in (*pBinary), size in pSizeInByte
+ * 3) Only save cfg and pPgResourceLayout to binary.
+ */
+gceSTATUS vscSaveProgramLinkerParamToBinary(
+    IN PROGRAM_LINKER_PARAM_HANDLE handle,
+    OUT void ** pBinary,
+    OUT gctUINT* pSizeInByte);
+
+/* read VSC_PROGRAM_LINKER_PARAM from binary
+ * binary is the out from vscSaveProgramLinkerParamToBinary function.
+ * sizeInByte is length of binary.
+ * If pLayout is empty, the function will allocate memory space.
+ * Only read cfg and pPgResourceLayout from binary.
+ */
+gceSTATUS vscReadProgramLinkerParamFromBinary(
+    IN void * binary,
+    IN gctUINT sizeInByte,
+    OUT VSC_PROGRAM_LINKER_PARAM **pParam);
+
+/*
+ * Destroy all VSC_SHADER_COMPILER_PARAM's pointer member variables.
+ * But memory pointed to by param pointer will not be destroyed.
+ */
+gceSTATUS vscDestroyProgramLinkerParam(
+    IN OUT VSC_PROGRAM_LINKER_PARAM *param);
+
+
 /* Create a shader with content unfilled. In general, driver calls this
    function to create a shader, and then pass this shader handle to shader
    generator. Or alternatively, shader generator can directly call this
@@ -1235,6 +1322,9 @@ gceSTATUS vscCreateShader(SHADER_HANDLE* pShaderHandle,
                           gctUINT shStage);
 gceSTATUS vscDestroyShader(SHADER_HANDLE hShader);
 
+/* Get VIR Shader version. */
+gceSTATUS vscGetShaderVersion(OUT gctUINT32 * shaderVersion);
+
 /* Print (dump) shader */
 gceSTATUS vscPrintShader(SHADER_HANDLE hShader,
                          gctFILE hFile,
@@ -1412,6 +1502,16 @@ vscImageSamplerNeedLibFuncForHWCfg(
     gctUINT *               KeyofImgSampler         /* the key state of the image-sampler pair */
     );
 
+/* For given image descriptor and sampler value for HW cfg, do we
+ * need to do recompilation for the image read due to the component count issue ? */
+gctBOOL
+vscImageSamplerHasImgLdCompCountIssue(
+    void *                  pImageDesc,
+    gctUINT                 imageSamplerValue,
+    VSC_HW_CONFIG*          pHwCfg,
+    gctUINT*                pKeyofImgSampler
+    );
+
 /* For given image descriptorfor HW cfg, do we
  * need to do recompilation for the image write ?  */
 gctBOOL
@@ -1470,6 +1570,49 @@ gceSTATUS vscGetTemporaryDir(OUT gctSTRING gcTmpDir);
 
 void vscSetIsLibraryShader(SHADER_HANDLE hShader, gctBOOL bIsLibraryShader);
 
+/****************************************************************************
+    Following are for driver to query some information.
+*****************************************************************************/
+gctBOOL
+vscQueryImgLdStSuppport(
+    IN  VSC_HW_CONFIG*      pHwCfg,
+    IN  gctBOOL             bUseInGraphicStage
+    );
+
+gctBOOL
+vscQueryTexldUSupport(
+    IN  VSC_HW_CONFIG*      pHwCfg
+    );
+
+/****************************************************************************
+    Following are for the OpenCL SPIR-V/VIR_Shader support.
+*****************************************************************************/
+gctUINT
+vscGetKernelFunctionCount(
+    IN  SHADER_HANDLE       pKernelShaderHandle
+    );
+
+gceSTATUS
+vscGetKernelFunctionNameByIndex(
+    IN  SHADER_HANDLE       pKernelShaderHandle,
+    IN  gctUINT             kernelIndex,
+    OUT gctSTRING*          pFuncNameString
+    );
+
+gceSTATUS
+vscLinkKernel(
+    OUT SHADER_HANDLE       destShaderHandle,
+    IN  SHADER_HANDLE*      srcShaderHandles,
+    IN  gctUINT             count,
+    IN  VSC_SYS_CONTEXT*    sysCtx
+    );
+
+gceSTATUS
+vscLoadKernel(
+    IN  SHADER_HANDLE       pShaderHandle,
+    IN  gctSTRING           pKernelName
+    );
+
 END_EXTERN_C();
 
 #endif /*__gc_vsc_drvi_interface_h_ */
diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_kernel_profile.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_kernel_profile.h
index 9d69e60789e6..8c6c93b8021d 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_kernel_profile.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_kernel_profile.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -106,6 +106,9 @@ typedef struct PROG_CL_IMAGE_TABLE_ENTRY
 {
     gctUINT                                    imageArgIndex;
 
+    /* Decl'ed array size by OCL, at this time, it must be 1 */
+    gctSIZE_T                                  arraySize;
+
     gctBOOL                                    kernelHardcodeSampler;
     gctUINT                                    samplerArgIndex;
     gctUINT                                    constSamplerValue;
diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_lib_link.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_lib_link.h
index 7e5b210f0b19..efc1406b4d9d 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_lib_link.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_lib_link.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -111,9 +111,16 @@ typedef enum _VSC_RES_OP_BIT
     VSC_RES_OP_BIT_TEXLD_PCF        = 0x00002000,
     VSC_RES_OP_BIT_TEXLD_BIAS_PCF   = 0x00004000,
     VSC_RES_OP_BIT_TEXLD_LOD_PCF    = 0x00008000,
-    VSC_RES_OP_BIT_LOAD_STORE       = 0x00010000,
-    VSC_RES_OP_BIT_IMAGE_OP         = 0x00020000,
-    VSC_RES_OP_BIT_ATOMIC           = 0x00040000,
+    VSC_RES_OP_BIT_MEM_LD_OP        = 0x00010000,
+    VSC_RES_OP_BIT_MEM_ST_OP        = 0x00020000,
+    VSC_RES_OP_BIT_MEM_LD_ST_OP     = VSC_RES_OP_BIT_MEM_LD_OP
+                                    | VSC_RES_OP_BIT_MEM_ST_OP,
+    VSC_RES_OP_BIT_IMAGE_LD_OP      = 0x00040000,
+    VSC_RES_OP_BIT_IMAGE_ST_OP      = 0x00080000,
+    VSC_RES_OP_BIT_IMAGE_ADDR_OP    = 0x00100000,
+    VSC_RES_OP_BIT_IMAGE_OP         = VSC_RES_OP_BIT_IMAGE_LD_OP
+                                    | VSC_RES_OP_BIT_IMAGE_ST_OP,
+    VSC_RES_OP_BIT_ATOMIC           = 0x00200000,
 }VSC_RES_OP_BIT;
 
 typedef enum _VSC_RES_ACT_BIT
@@ -132,6 +139,7 @@ typedef enum _VSC_LINK_POINT_RESOURCE_SUBTYPE
     VSC_LINK_POINT_RESOURCE_SUBTYPE_TEXGATHERPCF_D32F               = 6,
     VSC_LINK_POINT_RESOURCE_SUBTYPE_NORMALIZE_TEXCOORD              = 7,
     VSC_LINK_POINT_RESOURCE_SUBTYPE_YCBCR_TEXTURE                   = 8,
+    VSC_LINK_POINT_RESOURCE_SUBTYPE_UNORM_SNORM_TEXTURE             = 9,
 } VSC_LINK_POINT_RESOURCE_SUBTYPE;
 
 typedef struct _VSC_LIB_LINK_POINT_FUNC_NAME
diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_program_profile.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_program_profile.h
index f0e6770f7aa8..80e02995315d 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_program_profile.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_program_profile.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -511,7 +511,7 @@ typedef struct PROG_VK_SAMPLER_DERIVED_INFO
     SHADER_PRIV_CONSTANT_ENTRY*                 pLodMinMax[2];
 
     /* For a sampler, it might need a levelsSamples attached. As each sampler in
-       rraySize array has levelsSamples, so this is the first entry
+       arraySize array has levelsSamples, so this is the first entry
        of levelsSamples array. */
     SHADER_PRIV_CONSTANT_ENTRY*                 pLevelsSamples[2];
 }
@@ -535,6 +535,8 @@ typedef struct PROG_VK_PRIV_COMB_TEX_SAMP_HW_MAPPING
     /* Index based on countOfArray in PROG_VK_PRIV_COMB_TEX_SAMP_HW_MAPPING_POOL. */
     gctUINT                                     pctsHmEntryIndex;
 
+    gctUINT                                     stageIdx;
+
     /* For sub-array-size m of sampler, and sub-array-size n of tex, if
        bSamplerMajor is true, the hw sampler will be organized as
               ((t0, t1, t2...tn), (t0, t1, t2...tn), ...),
@@ -617,9 +619,12 @@ typedef struct PROG_VK_COMBINED_TEX_SAMPLER_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /*----------------------------------Sampler-related----------------------------------*/
     PROG_VK_SAMPLER_DERIVED_INFO                samplerDerivedInfo[VSC_MAX_SHADER_STAGE_COUNT];
 
@@ -669,9 +674,12 @@ typedef struct PROG_VK_SEPARATED_SAMPLER_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /* Which kinds of inst operation acting on sampler. The count of this
        resOpBit is same as samplerBinding::arraySize */
     VSC_RES_OP_BIT*                             pResOpBits;
@@ -727,9 +735,12 @@ typedef struct PROG_VK_SEPARATED_TEXTURE_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /* Which kinds of inst operation acting on texture. The count of this
        resOpBit is same as texBinding::arraySize */
     VSC_RES_OP_BIT*                             pResOpBits;
@@ -802,9 +813,12 @@ typedef struct PROG_VK_UNIFORM_TEXEL_BUFFER_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     PROG_VK_UNIFORM_TEXEL_BUFFER_ENTRY_FLAG     utbEntryFlag;
 
     /*----------------------------------Sampler-related----------------------------------*/
@@ -835,7 +849,7 @@ PROG_VK_UNIFORM_TEXEL_BUFFER_TABLE;
    VSC_SHADER_RESOURCE_TYPE_INPUT_ATTACHMENT
 */
 
-typedef union PROG_VK_INPUT_ATTACHMENT_HW_MAPPING
+typedef struct PROG_VK_INPUT_ATTACHMENT_HW_MAPPING
 {
     SHADER_UAV_SLOT_MAPPING                     uavMapping;
 
@@ -856,9 +870,12 @@ typedef struct PROG_VK_INPUT_ATTACHMENT_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /* Different shader stage may have different HW mappings. */
     PROG_VK_INPUT_ATTACHMENT_HW_MAPPING         hwMappings[VSC_MAX_SHADER_STAGE_COUNT];
 
@@ -905,9 +922,12 @@ typedef struct PROG_VK_STORAGE_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /*----------------------------------Image-related----------------------------------*/
     PROG_VK_IMAGE_DERIVED_INFO                  imageDerivedInfo[VSC_MAX_SHADER_STAGE_COUNT];
 
@@ -945,9 +965,12 @@ typedef struct PROG_VK_UNIFORM_BUFFER_TABLE_ENTRY
     /* Which shader stages access this entry */
     VSC_SHADER_STAGE_BIT                        stageBits;
 
-    /* Is this entry really used by shader */
+    /* Is this entry active in shader */
     gctUINT                                     activeStageMask;
 
+    /* Is this entry really used by shader */
+    gctUINT                                     usedStageMask;
+
     /* Different shader stage may have different HW mappings. */
     SHADER_CONSTANT_HW_LOCATION_MAPPING         hwMappings[VSC_MAX_SHADER_STAGE_COUNT];
 }
diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_priv_mapping.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_priv_mapping.h
index b041932da585..57acd63ebe2b 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_priv_mapping.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_priv_mapping.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -57,6 +57,7 @@ typedef enum SHS_PRIV_CONSTANT_KIND
     SHS_PRIV_CONSTANT_KIND_DEFAULT_UBO_ADDRESS              = 27,
     SHS_PRIV_CONSTANT_KIND_THREAD_ID_MEM_ADDR               = 28,
     SHS_PRIV_CONSTANT_KIND_ENQUEUED_LOCAL_SIZE              = 29,
+    SHS_PRIV_CONSTANT_KIND_BASE_VERTEX                      = 30,
     SHS_PRIV_CONSTANT_KIND_COUNT, /* last member, add new kind beofre this */
 }SHS_PRIV_CONSTANT_KIND;
 
@@ -88,7 +89,7 @@ typedef struct SHADER_PRIV_MAPPING_COMMON_ENTRY
     gctUINT                                     privmKindIndex;
 
     /* For some flags, they will have their private data to tell driver how to do. */
-    gctBOOL                                     notAllocated;
+    gctBOOL                                     bNotAllocated;
     void*                                       pPrivateData;
 }
 SHADER_PRIV_MAPPING_COMMON_ENTRY;
diff --git a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_profile.h b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_profile.h
index 2d0ef85f5f3d..0ed084556cca 100644
--- a/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_profile.h
+++ b/drivers/staging/npu/inc/drvi/gc_vsc_drvi_shader_profile.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -1310,7 +1310,9 @@ typedef struct SHADER_EXECUTABLE_DERIVED_HINTS
             /* Whether the shader depends on the workGroupSize. */
             gctUINT               bDependOnWorkGroupSize          : 1;
 
-            gctUINT               reserved                        : 27;
+            gctUINT               localIdWKind                    : 2;
+
+            gctUINT               reserved                        : 25;
 
             gctUINT16             workGroupSizeFactor[3];
         } gps;
diff --git a/drivers/staging/npu/inc/gc_feature_database.h b/drivers/staging/npu/inc/gc_feature_database.h
index c5fbe642bbc4..7cc6ea21aba9 100644
--- a/drivers/staging/npu/inc/gc_feature_database.h
+++ b/drivers/staging/npu/inc/gc_feature_database.h
@@ -11,7 +11,7 @@
 *****************************************************************************/
 
 
-/*Auto created on 2020-11-03 11:19*/
+/*Auto created on 2021-04-12 17:20*/
 #ifndef _gc_feature_database_h_
 #define _gc_feature_database_h_
 
@@ -59,8 +59,10 @@ typedef struct
     gctUINT32 RESULT_WINDOW_MAX_SIZE;
     gctUINT32 ClusterAliveMask;
     gctUINT32 G2D_DEC400_MINOR;
+    gctUINT32 PS_INSTRUCTION_COUNT;
     gctUINT32 NNMadPerCore;
     gctUINT32 NNCoreCount;
+    gctUINT32 NN_ACTIVE_CORE_COUNT;
     gctUINT32 NNCoreCount_INT8;
     gctUINT32 NNCoreCount_INT16;
     gctUINT32 NNCoreCount_FLOAT16;
@@ -106,6 +108,8 @@ typedef struct
     gctUINT32 MAX_TILE_X_SIZE;
     gctUINT32 NN_CLUSTER_NUM_FOR_POWER_CONTROL;
     gctUINT32 NN_IN_LINES_PER_CYCLE;
+    gctUINT32 VIP_CLUSTER_COUNT;
+    gctUINT32 NN_MP_INTER_CONNECT_RING_COUNT;
     gctUINT32 REG_FastClear:1;
     gctUINT32 REG_SpecialAntiAliasing:1;
     gctUINT32 REG_Pipe3D:1;
@@ -489,6 +493,7 @@ typedef struct
     gctUINT32 ENDIAN_CONTROL:1;
     gctUINT32 G2D_RGB_PLANAR:1;
     gctUINT32 G2D_DEC400EX:1;
+    gctUINT32 G2D_NO_YUV420_SOURCE:1;
     gctUINT32 G2D_YUV420_101010:1;
     gctUINT32 SH_VX2_FLOATING_MAD_FIX:1;
     gctUINT32 TS_FC_VULKAN_SUPPORT:1;
@@ -506,6 +511,13 @@ typedef struct
     gctUINT32 LDST_CONV_4ROUNDING_MODES:1;
     gctUINT32 FULL_PACK_MODE_SUPPORT:1;
     gctUINT32 DEPTH_FLOAT32_SUPPORT:1;
+    gctUINT32 GPU_INSPECTOR_COUNTERS:1;
+    gctUINT32 FP32_TO_FP16_CONV_FIX:1;
+    gctUINT32 IMGLD_COMP_COUNT_FIX:1;
+    gctUINT32 IMGLD_WIDTH_LT16_FIX:1;
+    gctUINT32 TX_FILTER_ROUND_FIX:1;
+    gctUINT32 SH_FP32_FMA_SUPPORT:1;
+    gctUINT32 TX_ETC2_COMPRESSION:1;
     gctUINT32 VG_TS_CULLING:1;
     gctUINT32 VG_FP25:1;
     gctUINT32 VG_AYUV_INPUT_OUTPUT:1;
@@ -612,6 +624,9 @@ typedef struct
     gctUINT32 PRELU_LEAKLY_RELU_CLAMP:1;
     gctUINT32 TPLITE_BFLOAT16:1;
     gctUINT32 PREPROCESS_IMG_BUF_640BYTE_LIMIT:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_FP16:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_BF16:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_FP32:1;
     gctUINT32 TP_KERNEL_1BYTE_ALGIN:1;
     gctUINT32 BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE:1;
     gctUINT32 NN_COMPRESSION_BYPASSS:1;
@@ -625,10 +640,12 @@ typedef struct
     gctUINT32 TILE_ACCESS_CAPABILITY:1;
     gctUINT32 FAST_DP3_PREPROCESSOR:1;
     gctUINT32 DEPTHWISE_SUPPORT_16BIT_FORMAT:1;
-    gctUINT32 SH_SUPPORT_VEC2:1;
-    gctUINT32 NN_SUPPORT_ALU_LUT:1;
+    gctUINT32 NN_SUPPORT_ALU:1;
     gctUINT32 NN_ENHANCED_MAX_POOLING:1;
     gctUINT32 NN_TRANSPOSE_PHASE2:1;
+    gctUINT32 NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD:1;
+    gctUINT32 NN_CONV_CORE_BYPASS:1;
+    gctUINT32 NN_TENSOR_ADD_RELU:1;
     gctUINT32 TPLITE_SUPPORT_TP_DATA_TRANSPOSE:1;
     gctUINT32 NN_SUPPORT_CONV_1D:1;
     gctUINT32 USE_VIPSRAM_FOR_KERNEL_STREAMING:1;
@@ -637,6 +654,8 @@ typedef struct
     gctUINT32 NN_1x1_NON_POOLING_PACKING:1;
     gctUINT32 NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING:1;
     gctUINT32 NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2:1;
+    gctUINT32 TP_REMOVE_FC:1;
+    gctUINT32 VIP_REMOVE_MMU:1;
     gctUINT32 NN_MP_INTER_CONNECT_RING:1;
     gctUINT32 NN_SUPPORT_BATCH:1;
     gctUINT32 NN_2D_AVERAGE_OUTPUT:1;
@@ -694,15 +713,31 @@ typedef struct
     gctUINT32 BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX:1;
     gctUINT32 INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX:1;
     gctUINT32 TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX:1;
-    gctUINT32 NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE:1;
+    gctUINT32 NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX:1;
     gctUINT32 NN_IN_TILE_DATA_IS_ALL_PAD_FIX:1;
     gctUINT32 NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX:1;
+    gctUINT32 CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX:1;
     gctUINT32 TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX:1;
     gctUINT32 NN_KERNEL_1x1_NO_PAD_FIX:1;
     gctUINT32 NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX:1;
     gctUINT32 TP_NOT_FULL_USE_CACHE_LINE_FIX:1;
     gctUINT32 SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX:1;
     gctUINT32 BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX:1;
+    gctUINT32 TP_ASSYM_INT8_FIX:1;
+    gctUINT32 NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX:1;
+    gctUINT32 NN_2ND_IMG_BASE_ADDR_FIX:1;
+    gctUINT32 NN_TP_SYSTEM_FIX:1;
+    gctUINT32 NN_INTILE_YSIZE_128_LIMIT_FIX:1;
+    gctUINT32 SH_CLOCK_GATOR_IDLE_CONDITON_FIX:1;
+    gctUINT32 NN_BURST_COLLECTER_LAST_FLAG_FIX:1;
+    gctUINT32 NN_2ND_IMG_SMALL_3D_TILE_FIX:1;
+    gctUINT32 NN_TILE_YSIZE_127_LIMITATION_FIX:1;
+    gctUINT32 NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX:1;
+    gctUINT32 NN_VIPSRAM_DOUBLE_BUFFER_FIX:1;
+    gctUINT32 NN_JD_DIRECT_MODE_FIX:1;
+    gctUINT32 NN_KERNEL_DIRECT_WRONG_PUSH_FIX:1;
+    gctUINT32 HI_DEFAULT_ENABLE_REORDER_FIX:1;
+    gctUINT32 V83_INTILESIZE_1X1_10BITS_FIX:1;
     gctUINT32 NN_INTERLEVE8:1;
     gctUINT32 NN_FP16_ALU:1;
     gctUINT32 NN_INT16_ALU:1;
@@ -718,15 +753,751 @@ typedef struct
     gctUINT32 IMAGE_PARTIAL_CACHE:1;
 } gcsFEATURE_DATABASE;
 
-#define FEATURE_BIT_START 89
-#define FEATURE_BIT_END 698
+#define FEATURE_BIT_START 93
+#define FEATURE_BIT_END 733
 static gcsFEATURE_DATABASE gChipInfo[] = {
+    /* vip9000nano-di */
+    {
+        0x9000, /* ChipID */
+        0x8302, /* ChipRevision */
+        0x5090009, /* ProductID */
+        0x8000000, /* EcoID */
+        0xe8, /* CustomerID */
+        0x0, /* PatchVersion */
+        "", /* ProductName */
+        0x0, /* FormalRelease */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x100, /* gcFEATURE_VALUE_ThreadCount */
+        0x1, /* gcFEATURE_VALUE_NumShaderCores */
+        0x200, /* gcFEATURE_VALUE_InstructionCount */
+        0x140, /* gcFEATURE_VALUE_NumberOfConstants */
+        0x1, /* gcFEATURE_VALUE_CoreCount */
+        0x10, /* gcFEATURE_VALUE_LocalStorageSize */
+        0x0, /* gcFEATURE_VALUE_LocalStorageSize_1 */
+        0x0, /* gcFEATURE_VALUE_LocalStorageSize_2 */
+        0x10, /* gcFEATURE_VALUE_L1CacheSize */
+        0x0, /* gcFEATURE_VALUE_L1CacheSize_1 */
+        0x0, /* gcFEATURE_VALUE_L1CacheSize_2 */
+        0x200, /* gcFEATURE_VALUE_InstructionMemorySize */
+        0x14, /* gcFEATURE_VALUE_ShaderPCLength */
+        0x10, /* gcFEATURE_VALUE_USC_MAX_PAGES */
+        0x0, /* gcFEATURE_VALUE_USC_MAX_PAGES_1 */
+        0x0, /* gcFEATURE_VALUE_USC_MAX_PAGES_2 */
+        0x1, /* gcFEATURE_VALUE_NumPixelPipes */
+        0x2, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS */
+        0x0, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS_1 */
+        0x0, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS_2 */
+        0x2, /* gcFEATURE_VALUE_USC_BANKS */
+        0x0, /* gcFEATURE_VALUE_USC_BANKS_1 */
+        0x0, /* gcFEATURE_VALUE_USC_BANKS_2 */
+        0x8, /* gcFEATURE_VALUE_Streams */
+        0x10, /* gcFEATURE_VALUE_VaryingCount */
+        0x400, /* gcFEATURE_VALUE_VertexOutputBufferSize */
+        0x0, /* gcFEATURE_VALUE_BufferSize */
+        0x10, /* gcFEATURE_VALUE_VertexCacheSize */
+        0x0, /* gcFEATURE_VALUE_NumResolvePipes */
+        0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
+        0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
+        0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
+        0x40, /* gcFEATURE_VALUE_NNMadPerCore */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
+        0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
+        0x0, /* gcFEATURE_VALUE_NNCoreCount_BFLOAT */
+        0x9, /* gcFEATURE_VALUE_NNInputBufferDepth */
+        0x20, /* gcFEATURE_VALUE_NNAccumBufferDepth */
+        0x400, /* gcFEATURE_VALUE_TPEngine_PwlLUTCount */
+        0x10, /* gcFEATURE_VALUE_TPEngine_PwlLUTSize */
+        0x100000, /* gcFEATURE_VALUE_VIP_SRAM_SIZE */
+        0x1, /* gcFEATURE_VALUE_TPEngine_CoreCount */
+        0x0, /* gcFEATURE_VALUE_AXI_SRAM_SIZE */
+        0x5, /* gcFEATURE_VALUE_NN_INIMAGE_OFFSET_BITS */
+        0x200, /* gcFEATURE_VALUE_TP_REORDER_INIMAGE_SIZE */
+        0x0, /* gcFEATURE_VALUE_TPLite_CoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_PREPROCESSOR_MAX_SEGMENT_PER_CYCLE */
+        0x0, /* gcFEATURE_VALUE_NNFP16_XYDP_X */
+        0x0, /* gcFEATURE_VALUE_NNFP16_XYDP_Y */
+        0x0, /* gcFEATURE_VALUE_NNFP16_ZDP */
+        0x20, /* gcFEATURE_VALUE_NN_LANES_PER_OUT_CYCLE */
+        0x40, /* gcFEATURE_VALUE_MAX_OT_NUMBER */
+        0x80, /* gcFEATURE_VALUE_PHYSICAL_VIP_SRAM_WIDTH_IN_BYTE */
+        0x20, /* gcFEATURE_VALUE_EQUIVALENT_VIP_SRAM_WIDTH_INBYTE */
+        0x8, /* gcFEATURE_VALUE_TP_ZRL_BITS */
+        0x8, /* gcFEATURE_VALUE_NN_ZRL_BITS */
+        0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
+        0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
+        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
+        0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
+        0x1f, /* gcFEATURE_VALUE_NN_X_OFFSET */
+        0x1f, /* gcFEATURE_VALUE_NN_Y_OFFSET */
+        0x100, /* gcFEATURE_VALUE_DDR_KERNEL_BURST_SIZE */
+        0x10, /* gcFEATURE_VALUE_OUTIMAGE_X_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_OUTIMAGE_Y_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_INIMAGE_X_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_IMIMAGE_Y_STRIDE_BITS */
+        0xd, /* gcFEATURE_VALUE_OUTIMAGE_X_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_OUTIMAGE_Y_SIZE_BITS */
+        0xe, /* gcFEATURE_VALUE_OUTIMAGE_Z_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_INIMAGE_X_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_INIMAGE_Y_SIZE_BITS */
+        0x80, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
+        0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
+        0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
+        0x0, /* gcFEATURE_BIT_REG_FastClear */
+        0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
+        0x1, /* gcFEATURE_BIT_REG_Pipe3D */
+        0x1, /* gcFEATURE_BIT_REG_DXTTextureCompression */
+        0x0, /* gcFEATURE_BIT_REG_DebugMode */
+        0x1, /* gcFEATURE_BIT_REG_ZCompression */
+        0x0, /* gcFEATURE_BIT_REG_YUV420Filter */
+        0x1, /* gcFEATURE_BIT_REG_MSAA */
+        0x0, /* gcFEATURE_BIT_REG_DC */
+        0x0, /* gcFEATURE_BIT_REG_Pipe2D */
+        0x1, /* gcFEATURE_BIT_REG_ETC1TextureCompression */
+        0x1, /* gcFEATURE_BIT_REG_FastScaler */
+        0x1, /* gcFEATURE_BIT_REG_HighDynamicRange */
+        0x1, /* gcFEATURE_BIT_REG_YUV420Tiler */
+        0x1, /* gcFEATURE_BIT_REG_ModuleCG */
+        0x0, /* gcFEATURE_BIT_REG_MinArea */
+        0x0, /* gcFEATURE_BIT_REG_NoEZ */
+        0x0, /* gcFEATURE_BIT_REG_No422Texture */
+        0x0, /* gcFEATURE_BIT_REG_BufferInterleaving */
+        0x1, /* gcFEATURE_BIT_REG_ByteWrite2D */
+        0x0, /* gcFEATURE_BIT_REG_NoScaler */
+        0x1, /* gcFEATURE_BIT_REG_YUY2Averaging */
+        0x0, /* gcFEATURE_BIT_REG_HalfPECache */
+        0x0, /* gcFEATURE_BIT_REG_HalfTXCache */
+        0x0, /* gcFEATURE_BIT_REG_YUY2RenderTarget */
+        0x0, /* gcFEATURE_BIT_REG_Mem32BitSupport */
+        0x0, /* gcFEATURE_BIT_REG_PipeVG */
+        0x0, /* gcFEATURE_BIT_REG_VGTS */
+        0x0, /* gcFEATURE_BIT_REG_FE20 */
+        0x1, /* gcFEATURE_BIT_REG_ByteWrite3D */
+        0x1, /* gcFEATURE_BIT_REG_RsYuvTarget */
+        0x1, /* gcFEATURE_BIT_REG_FE20BitIndex */
+        0x1, /* gcFEATURE_BIT_REG_FlipY */
+        0x1, /* gcFEATURE_BIT_REG_DualReturnBus */
+        0x1, /* gcFEATURE_BIT_REG_EndiannessConfig */
+        0x1, /* gcFEATURE_BIT_REG_Texture8K */
+        0x1, /* gcFEATURE_BIT_REG_CorrectTextureConverter */
+        0x1, /* gcFEATURE_BIT_REG_SpecialMsaaLod */
+        0x1, /* gcFEATURE_BIT_REG_FastClearFlush */
+        0x1, /* gcFEATURE_BIT_REG_2DPE20 */
+        0x0, /* gcFEATURE_BIT_REG_CorrectAutoDisable */
+        0x1, /* gcFEATURE_BIT_REG_Render8K */
+        0x1, /* gcFEATURE_BIT_REG_TileStatus2Bits */
+        0x1, /* gcFEATURE_BIT_REG_SeparateTileStatusWhenInterleaved */
+        0x1, /* gcFEATURE_BIT_REG_SuperTiled32x32 */
+        0x0, /* gcFEATURE_BIT_REG_VG20 */
+        0x0, /* gcFEATURE_BIT_REG_TSExtendedCommands */
+        0x1, /* gcFEATURE_BIT_REG_CompressionFifoFixed */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions0 */
+        0x0, /* gcFEATURE_BIT_REG_VGFilter */
+        0x0, /* gcFEATURE_BIT_REG_VG21 */
+        0x1, /* gcFEATURE_BIT_REG_ShaderGetsW */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions1 */
+        0x1, /* gcFEATURE_BIT_REG_DefaultReg0 */
+        0x1, /* gcFEATURE_BIT_REG_MC20 */
+        0x0, /* gcFEATURE_BIT_REG_ShaderMSAASideband */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes0 */
+        0x0, /* gcFEATURE_BIT_REG_VAA */
+        0x0, /* gcFEATURE_BIT_REG_BypassInMSAA */
+        0x0, /* gcFEATURE_BIT_REG_HierarchicalZ */
+        0x0, /* gcFEATURE_BIT_REG_NewTexture */
+        0x0, /* gcFEATURE_BIT_REG_A8TargetSupport */
+        0x1, /* gcFEATURE_BIT_REG_CorrectStencil */
+        0x1, /* gcFEATURE_BIT_REG_EnhanceVR */
+        0x1, /* gcFEATURE_BIT_REG_RSUVSwizzle */
+        0x1, /* gcFEATURE_BIT_REG_V2Compression */
+        0x0, /* gcFEATURE_BIT_REG_VGDoubleBuffer */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes1 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes2 */
+        0x0, /* gcFEATURE_BIT_REG_TextureStride */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes3 */
+        0x1, /* gcFEATURE_BIT_REG_CorrectAutoDisable1 */
+        0x0, /* gcFEATURE_BIT_REG_AutoRestartTS */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes4 */
+        0x0, /* gcFEATURE_BIT_REG_L2Windowing */
+        0x1, /* gcFEATURE_BIT_REG_HalfFloatPipe */
+        0x1, /* gcFEATURE_BIT_REG_PixelDither */
+        0x1, /* gcFEATURE_BIT_REG_TwoStencilReference */
+        0x1, /* gcFEATURE_BIT_REG_ExtendedPixelFormat */
+        0x1, /* gcFEATURE_BIT_REG_CorrectMinMaxDepth */
+        0x1, /* gcFEATURE_BIT_REG_DitherAndFilterPlusAlpha2D */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes5 */
+        0x0, /* gcFEATURE_BIT_REG_New2D */
+        0x1, /* gcFEATURE_BIT_REG_NewFloatingPointArithmetic */
+        0x1, /* gcFEATURE_BIT_REG_TextureHorizontalAlignmentSelect */
+        0x1, /* gcFEATURE_BIT_REG_NonPowerOfTwo */
+        0x1, /* gcFEATURE_BIT_REG_LinearTextureSupport */
+        0x1, /* gcFEATURE_BIT_REG_Halti0 */
+        0x0, /* gcFEATURE_BIT_REG_CorrectOverflowVG */
+        0x1, /* gcFEATURE_BIT_REG_NegativeLogFix */
+        0x1, /* gcFEATURE_BIT_REG_ResolveOffset */
+        0x1, /* gcFEATURE_BIT_REG_OkToGateAxiClock */
+        0x1, /* gcFEATURE_BIT_REG_MMU */
+        0x1, /* gcFEATURE_BIT_REG_WideLine */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes6 */
+        0x1, /* gcFEATURE_BIT_REG_FcFlushStall */
+        0x1, /* gcFEATURE_BIT_REG_LineLoop */
+        0x1, /* gcFEATURE_BIT_REG_LogicOp */
+        0x1, /* gcFEATURE_BIT_REG_SeamlessCubeMap */
+        0x1, /* gcFEATURE_BIT_REG_SuperTiledTexture */
+        0x1, /* gcFEATURE_BIT_REG_LinearPE */
+        0x1, /* gcFEATURE_BIT_REG_RectPrimitive */
+        0x0, /* gcFEATURE_BIT_REG_Composition */
+        0x1, /* gcFEATURE_BIT_REG_CorrectAutoDisableCountWidth */
+        0x1, /* gcFEATURE_BIT_REG_PESwizzle */
+        0x1, /* gcFEATURE_BIT_REG_EndEvent */
+        0x1, /* gcFEATURE_BIT_REG_S1S8 */
+        0x1, /* gcFEATURE_BIT_REG_Halti1 */
+        0x0, /* gcFEATURE_BIT_REG_RGB888 */
+        0x1, /* gcFEATURE_BIT_REG_TX_YUVAssembler */
+        0x1, /* gcFEATURE_BIT_REG_DynamicFrequencyScaling */
+        0x0, /* gcFEATURE_BIT_REG_TXFilter */
+        0x1, /* gcFEATURE_BIT_REG_FullDirectFB */
+        0x0, /* gcFEATURE_BIT_REG_OnePass2DFilter */
+        0x1, /* gcFEATURE_BIT_REG_ThreadWalkerInPS */
+        0x1, /* gcFEATURE_BIT_REG_TileFiller */
+        0x1, /* gcFEATURE_BIT_REG_YUVStandard */
+        0x0, /* gcFEATURE_BIT_REG_MultiSourceBlt */
+        0x0, /* gcFEATURE_BIT_REG_YUVConversion */
+        0x1, /* gcFEATURE_BIT_REG_FlushFixed2D */
+        0x1, /* gcFEATURE_BIT_REG_Interleaver */
+        0x1, /* gcFEATURE_BIT_REG_MixedStreams */
+        0x0, /* gcFEATURE_BIT_REG_L2CacheFor2D420 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes7 */
+        0x0, /* gcFEATURE_BIT_REG_NoIndexPattern */
+        0x1, /* gcFEATURE_BIT_REG_TextureTileStatus */
+        0x1, /* gcFEATURE_BIT_REG_DecompressZ16 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes8 */
+        0x1, /* gcFEATURE_BIT_REG_DERotationStallFix */
+        0x0, /* gcFEATURE_BIT_REG_OclOnly */
+        0x1, /* gcFEATURE_BIT_REG_NewFeatures0 */
+        0x1, /* gcFEATURE_BIT_REG_InstructionCache */
+        0x0, /* gcFEATURE_BIT_REG_GeometryShader */
+        0x1, /* gcFEATURE_BIT_REG_TexCompressionSupertiled */
+        0x1, /* gcFEATURE_BIT_REG_Generics */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes9 */
+        0x0, /* gcFEATURE_BIT_REG_FastMSAA */
+        0x0, /* gcFEATURE_BIT_REG_WClip */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes10 */
+        0x1, /* gcFEATURE_BIT_REG_UnifiedSamplers */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes11 */
+        0x1, /* gcFEATURE_BIT_REG_PerformanceCounters */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes12 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes13 */
+        0x1, /* gcFEATURE_BIT_REG_DEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_ACE */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_DEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes14 */
+        0x0, /* gcFEATURE_BIT_REG_PowerOptimizations0 */
+        0x1, /* gcFEATURE_BIT_REG_NewHZ */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes15 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_FEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_PAEnhancements1 */
+        0x0, /* gcFEATURE_BIT_REG_DENoGamma */
+        0x0, /* gcFEATURE_BIT_REG_PAEnhancements2 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_HIEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements5 */
+        0x1, /* gcFEATURE_BIT_REG_FEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes16 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements5 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements4 */
+        0x0, /* gcFEATURE_BIT_REG_PEEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_MCEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_Halti2 */
+        0x0, /* gcFEATURE_BIT_REG_DEMirrorRotate */
+        0x1, /* gcFEATURE_BIT_REG_SmallMSAA */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes17 */
+        0x0, /* gcFEATURE_BIT_REG_Rasterizer2 */
+        0x0, /* gcFEATURE_BIT_REG_DualPipeOPF */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV2 */
+        0x0, /* gcFEATURE_BIT_REG_CSCV2 */
+        0x1, /* gcFEATURE_BIT_REG_PAEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes18 */
+        0x0, /* gcFEATURE_BIT_REG_Compression2D */
+        0x0, /* gcFEATURE_BIT_REG_Probe */
+        0x1, /* gcFEATURE_BIT_REG_MediumPrecision */
+        0x0, /* gcFEATURE_BIT_REG_DESupertile */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes19 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements6 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements7 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes20 */
+        0x0, /* gcFEATURE_BIT_REG_DEAddress40 */
+        0x0, /* gcFEATURE_BIT_REG_MiniMMUFix */
+        0x1, /* gcFEATURE_BIT_REG_EEZ */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes21 */
+        0x0, /* gcFEATURE_BIT_REG_ExtraVgCaps */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV15 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes22 */
+        0x1, /* gcFEATURE_BIT_REG_Halti3 */
+        0x0, /* gcFEATURE_BIT_REG_TessellationShaders */
+        0x0, /* gcFEATURE_BIT_REG_OPF9Tap */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV2StrQuad */
+        0x0, /* gcFEATURE_BIT_REG_SeperateSRCAndDstCache */
+        0x1, /* gcFEATURE_BIT_REG_Halti4 */
+        0x1, /* gcFEATURE_BIT_REG_RAWriteDepth */
+        0x0, /* gcFEATURE_BIT_REG_AndroidOnly */
+        0x1, /* gcFEATURE_BIT_REG_HasChipProductReg */
+        0x0, /* gcFEATURE_BIT_REG_TXSupportDEC */
+        0x1, /* gcFEATURE_BIT_REG_S8MSAACompression */
+        0x1, /* gcFEATURE_BIT_REG_BugFixesIn544 */
+        0x0, /* gcFEATURE_BIT_REG_L2CacheRemove */
+        0x1, /* gcFEATURE_BIT_REG_FEAllowRndVtxCnt */
+        0x0, /* gcFEATURE_BIT_REG_CubeMapFL28 */
+        0x1, /* gcFEATURE_BIT_REG_TX6bitFrac */
+        0x1, /* gcFEATURE_BIT_REG_FEAllowStallPrefetchEng */
+        0x0, /* gcFEATURE_BIT_REG_ThirdPartyCompression */
+        0x1, /* gcFEATURE_BIT_REG_RSS8 */
+        0x1, /* gcFEATURE_BIT_REG_MSAACoherencyCheck */
+        0x1, /* gcFEATURE_BIT_REG_Halti5 */
+        0x1, /* gcFEATURE_BIT_REG_Evis */
+        0x0, /* gcFEATURE_BIT_REG_BltEngine */
+        0x0, /* gcFEATURE_BIT_REG_BugFixes23 */
+        0x0, /* gcFEATURE_BIT_REG_BugFixes24 */
+        0x0, /* gcFEATURE_BIT_REG_DEC */
+        0x0, /* gcFEATURE_BIT_REG_VSTileNV12 */
+        0x0, /* gcFEATURE_BIT_REG_VSTileNV12_10BIT */
+        0x0, /* gcFEATURE_BIT_REG_DisableVIP */
+        0x0, /* gcFEATURE_BIT_RenderTarget8 */
+        0x0, /* gcFEATURE_BIT_TxLodFlowCorrection */
+        0x0, /* gcFEATURE_BIT_FaceLod */
+        0x0, /* gcFEATURE_BIT_MultiCoreSemaphoreStallV2 */
+        0x1, /* gcFEATURE_BIT_VMSAA */
+        0x0, /* gcFEATURE_BIT_ChipEnableLink */
+        0x0, /* gcFEATURE_BIT_MULTI_SRC_BLT_1_5_ENHANCEMENT */
+        0x0, /* gcFEATURE_BIT_MULTI_SRC_BLT_BILINEAR_FILTER */
+        0x1, /* gcFEATURE_BIT_RA_HZEZ_CLOCK_CONTROL */
+        0x1, /* gcFEATURE_BIT_CACHE128B256BPERLINE */
+        0x1, /* gcFEATURE_BIT_V4Compression */
+        0x0, /* gcFEATURE_BIT_DE2D_MAJOR_SUPER_TILE */
+        0x0, /* gcFEATURE_BIT_PE2D_MAJOR_SUPER_TILE */
+        0x1, /* gcFEATURE_BIT_PE_32BPC_COLORMASK_FIX */
+        0x1, /* gcFEATURE_BIT_ALPHA_BLENDING_OPT */
+        0x1, /* gcFEATURE_BIT_NEW_GPIPE */
+        0x0, /* gcFEATURE_BIT_PIPELINE_32_ATTRIBUTES */
+        0x0, /* gcFEATURE_BIT_MSAA_SHADING */
+        0x0, /* gcFEATURE_BIT_NO_ANISTRO_FILTER */
+        0x1, /* gcFEATURE_BIT_NO_ASTC */
+        0x0, /* gcFEATURE_BIT_NO_DXT */
+        0x0, /* gcFEATURE_BIT_HWTFB */
+        0x1, /* gcFEATURE_BIT_RA_DEPTH_WRITE_MSAA1X_FIX */
+        0x1, /* gcFEATURE_BIT_EZHZ_CLOCKGATE_FIX */
+        0x1, /* gcFEATURE_BIT_SH_SNAP2PAGE_FIX */
+        0x1, /* gcFEATURE_BIT_SH_HALFDEPENDENCY_FIX */
+        0x1, /* gcFEATURE_BIT_USC_MCFILL_FIX */
+        0x1, /* gcFEATURE_BIT_TPG_TCPERF_FIX */
+        0x1, /* gcFEATURE_BIT_USC_MDFIFO_OVERFLOW_FIX */
+        0x1, /* gcFEATURE_BIT_SH_TEXLD_BARRIER_IN_CS_FIX */
+        0x1, /* gcFEATURE_BIT_RS_NEW_BASEADDR */
+        0x1, /* gcFEATURE_BIT_PE_8bpp_DUALPIPE_FIX */
+        0x0, /* gcFEATURE_BIT_SH_ADVANCED_INSTR */
+        0x1, /* gcFEATURE_BIT_SH_FLAT_INTERPOLATION_DUAL16_FIX */
+        0x1, /* gcFEATURE_BIT_USC_CONTINUOUS_FLUS_FIX */
+        0x0, /* gcFEATURE_BIT_SH_SUPPORT_V4 */
+        0x0, /* gcFEATURE_BIT_SH_SUPPORT_ALPHA_KILL */
+        0x1, /* gcFEATURE_BIT_PE_NO_ALPHA_TEST */
+        0x0, /* gcFEATURE_BIT_TX_LOD_NEAREST_SELECT */
+        0x1, /* gcFEATURE_BIT_SH_FIX_LDEXP */
+        0x1, /* gcFEATURE_BIT_SUPPORT_MOVAI */
+        0x1, /* gcFEATURE_BIT_SH_SNAP2PAGE_MAXPAGES_FIX */
+        0x1, /* gcFEATURE_BIT_PE_RGBA16I_FIX */
+        0x1, /* gcFEATURE_BIT_BLT_8bpp_256TILE_FC_FIX */
+        0x1, /* gcFEATURE_BIT_PE_64bit_FENCE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_FULL_CACHE_FIX */
+        0x1, /* gcFEATURE_BIT_TX_YUV_ASSEMBLER_10BIT */
+        0x1, /* gcFEATURE_BIT_FE_32bit_INDEX_FIX */
+        0x1, /* gcFEATURE_BIT_BLT_64bpp_MASKED_CLEAR_FIX */
+        0x1, /* gcFEATURE_BIT_SECURITY */
+        0x1, /* gcFEATURE_BIT_ROBUSTNESS */
+        0x1, /* gcFEATURE_BIT_USC_ATOMIC_FIX */
+        0x1, /* gcFEATURE_BIT_SH_PSO_MSAA1x_FIX */
+        0x1, /* gcFEATURE_BIT_USC_VX_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_USC_GOS_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_TX_8bit_UVFrac */
+        0x1, /* gcFEATURE_BIT_TX_DESC_CACHE_CLOCKGATE_FIX */
+        0x1, /* gcFEATURE_BIT_RSBLT_MSAA_DECOMPRESSION */
+        0x0, /* gcFEATURE_BIT_TX_INTEGER_COORDINATE */
+        0x1, /* gcFEATURE_BIT_DRAWID */
+        0x1, /* gcFEATURE_BIT_PSIO_SAMPLEMASK_IN_R0ZW_FIX */
+        0x1, /* gcFEATURE_BIT_TX_INTEGER_COORDINATE_V2 */
+        0x0, /* gcFEATURE_BIT_MULTI_CORE_BLOCK_SET_CONFIG */
+        0x0, /* gcFEATURE_BIT_SNAPPAGE_CMD */
+        0x1, /* gcFEATURE_BIT_SH_NO_INDEX_CONST_ON_A0 */
+        0x1, /* gcFEATURE_BIT_SH_NO_ONECONST_LIMIT */
+        0x1, /* gcFEATURE_BIT_SH_IMG_LDST_ON_TEMP */
+        0x1, /* gcFEATURE_BIT_COMPUTE_ONLY */
+        0x1, /* gcFEATURE_BIT_SH_IMG_LDST_CLAMP */
+        0x1, /* gcFEATURE_BIT_SH_ICACHE_ALLOC_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_ICACHE_PREFETCH */
+        0x0, /* gcFEATURE_BIT_PE2D_SEPARATE_CACHE */
+        0x1, /* gcFEATURE_BIT_PE_MSAA_OQ_FIX */
+        0x1, /* gcFEATURE_BIT_PSIO_MSAA_CL_FIX */
+        0x1, /* gcFEATURE_BIT_USC_DEFER_FILL_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATE_FIX */
+        0x0, /* gcFEATURE_BIT_FE_NEED_DUMMYDRAW */
+        0x0, /* gcFEATURE_BIT_PE2D_LINEAR_YUV420_OUTPUT */
+        0x0, /* gcFEATURE_BIT_PE2D_LINEAR_YUV420_10BIT */
+        0x0, /* gcFEATURE_BIT_MULTI_CLUSTER */
+        0x0, /* gcFEATURE_BIT_SH_MULTI_WG_PACK */
+        0x0, /* gcFEATURE_BIT_SH_DUAL16_SAMPLEMASK_ZW */
+        0x0, /* gcFEATURE_BIT_TPG_TRIVIAL_MODE_FIX */
+        0x0, /* gcFEATURE_BIT_TX_ASTC_MULTISLICE_FIX */
+        0x0, /* gcFEATURE_BIT_FE_ROBUST_FIX */
+        0x0, /* gcFEATURE_BIT_SH_GPIPE_ACCESS_FULLTEMPS */
+        0x0, /* gcFEATURE_BIT_PSIO_INTERLOCK */
+        0x1, /* gcFEATURE_BIT_PA_WIDELINE_FIX */
+        0x0, /* gcFEATURE_BIT_WIDELINE_HELPER_FIX */
+        0x0, /* gcFEATURE_BIT_G2D_3rd_PARTY_COMPRESSION_1_1 */
+        0x0, /* gcFEATURE_BIT_TX_FLUSH_L1CACHE */
+        0x1, /* gcFEATURE_BIT_PE_DITHER_FIX2 */
+        0x0, /* gcFEATURE_BIT_SH_TEXLD_U_FIX */
+        0x0, /* gcFEATURE_BIT_MC_FCCACHE_BYTEMASK */
+        0x0, /* gcFEATURE_BIT_SH_MULTI_WG_PACK_FIX */
+        0x0, /* gcFEATURE_BIT_PE_ADVANCE_BLEND_PART0 */
+        0x0, /* gcFEATURE_BIT_FE_PATCHLIST_FETCH_FIX */
+        0x1, /* gcFEATURE_BIT_RA_CG_FIX */
+        0x0, /* gcFEATURE_BIT_DEC400 */
+        0x0, /* gcFEATURE_BIT_LS_SUPPORT_PERCOMP_DEPENDENCY */
+        0x0, /* gcFEATURE_BIT_MULTI_CORE_BLOCK_SET_CONFIG2 */
+        0x0, /* gcFEATURE_BIT_PE_VMSAA_COVERAGE_CACHE_FIX */
+        0x1, /* gcFEATURE_BIT_SECURITY_AHB */
+        0x0, /* gcFEATURE_BIT_MULTICORE_SEMAPHORESTALL_V3 */
+        0x0, /* gcFEATURE_BIT_SMALLBATCH */
+        0x0, /* gcFEATURE_BIT_SH_CMPLX */
+        0x0, /* gcFEATURE_BIT_SH_IDIV0_SWZL_EHS */
+        0x0, /* gcFEATURE_BIT_TX_LERP_LESS_BIT */
+        0x0, /* gcFEATURE_BIT_SH_GM_ENDIAN */
+        0x0, /* gcFEATURE_BIT_SH_GM_USC_UNALLOC */
+        0x0, /* gcFEATURE_BIT_SH_END_OF_BB */
+        0x0, /* gcFEATURE_BIT_TX_BORDER_CLAMP_FIX */
+        0x0, /* gcFEATURE_BIT_SH_IMG_LD_LASTPIXEL_FIX */
+        0x0, /* gcFEATURE_BIT_ASYNC_BLT */
+        0x0, /* gcFEATURE_BIT_ASYNC_FE_FENCE_FIX */
+        0x1, /* gcFEATURE_BIT_PSCS_THROTTLE */
+        0x0, /* gcFEATURE_BIT_SEPARATE_LS */
+        0x0, /* gcFEATURE_BIT_WIDELINE_TRIANGLE_EMU */
+        0x0, /* gcFEATURE_BIT_FENCE_32BIT */
+        0x0, /* gcFEATURE_BIT_FENCE_64BIT */
+        0x0, /* gcFEATURE_BIT_PE_DEPTH_ONLY_OQFIX */
+        0x0, /* gcFEATURE_BIT_TX_SEAMLESS_CUBE */
+        0x0, /* gcFEATURE_BIT_TX_SNORM_SUPPORT */
+        0x0, /* gcFEATURE_BIT_SH_SCATTER_GATHER */
+        0x0, /* gcFEATURE_BIT_HWMANAGED_LS */
+        0x0, /* gcFEATURE_BIT_SH_IMAGE_ENABLE_FIX */
+        0x1, /* gcFEATURE_BIT_MSAA_FRAGMENT_OPERATION */
+        0x0, /* gcFEATURE_BIT_PE_TILE_CACHE_FLUSH_FIX */
+        0x0, /* gcFEATURE_BIT_BLT_YUV_OUTPUT */
+        0x1, /* gcFEATURE_BIT_SH_IO_CG_FIX */
+        0x0, /* gcFEATURE_BIT_PE_SWIZZLE */
+        0x0, /* gcFEATURE_BIT_SH_ROBUSTNESS_FIX */
+        0x0, /* gcFEATURE_BIT_USC_ATOMIC_FIX2 */
+        0x0, /* gcFEATURE_BIT_PE_A8B8G8R8 */
+        0x0, /* gcFEATURE_BIT_MULTIVIEW_RENDER */
+        0x0, /* gcFEATURE_BIT_FE_DRAW_DIRECT */
+        0x0, /* gcFEATURE_BIT_TX_VKBORDER_MODE */
+        0x0, /* gcFEATURE_BIT_TX_UNNORMALIZED_COORD */
+        0x0, /* gcFEATURE_BIT_PA_LINECLIP_FIX */
+        0x0, /* gcFEATURE_BIT_TX_8bit_UVFrac_ROUNDING_FIX */
+        0x0, /* gcFEATURE_BIT_MP_ARCH */
+        0x0, /* gcFEATURE_BIT_TX_NO_FIXED_FILTER */
+        0x0, /* gcFEATURE_BIT_SHARE_Z */
+        0x0, /* gcFEATURE_BIT_DE_2D_FAST_CLEAR */
+        0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
+        0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
+        0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
+        0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
+        0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
+        0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
+        0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
+        0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
+        0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
+        0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
+        0x0, /* gcFEATURE_BIT_MSAA_FLOAT_64BIT */
+        0x0, /* gcFEATURE_BIT_INDIRECT_COMPUTE_ZERODIM_FIX */
+        0x0, /* gcFEATURE_BIT_Q_CHANNEL_SUPPORT */
+        0x0, /* gcFEATURE_BIT_MMU_PAGE_DESCRIPTOR */
+        0x0, /* gcFEATURE_BIT_YUV_LINEAR_TO_TILE_ROTATE */
+        0x0, /* gcFEATURE_BIT_VEC2_IMULIMAD32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_VEC4_IMULIMAD32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_VEC2_IDIVIMOD16_SUPPORT */
+        0x0, /* gcFEATURE_BIT_DST_TEX_I2F_F2I_INST_DEPRECATE */
+        0x0, /* gcFEATURE_BIT_ALU_FP16_INSTRUCTIONS */
+        0x0, /* gcFEATURE_BIT_DUAL16_14BIT_PC_SUPPORT */
+        0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
+        0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
+        0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
+        0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
+        0x0, /* gcFEATURE_BIT_VG_FP25 */
+        0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
+        0x0, /* gcFEATURE_BIT_VG_DOUBLE_IMAGE */
+        0x0, /* gcFEATURE_BIT_VG_RECTANGLE_STRIPE_MODE */
+        0x0, /* gcFEATURE_BIT_VG_MMU */
+        0x0, /* gcFEATURE_BIT_VG_IM_FILTER */
+        0x0, /* gcFEATURE_BIT_VG_IM_YUV_PACKET */
+        0x0, /* gcFEATURE_BIT_VG_IM_YUV_PLANAR */
+        0x0, /* gcFEATURE_BIT_VG_PE_YUV_PACKET */
+        0x0, /* gcFEATURE_BIT_VG_COLOR_PRECISION_8_BIT */
+        0x0, /* gcFEATURE_BIT_VG_RESOLVE_ENGINE */
+        0x0, /* gcFEATURE_BIT_VG_PE_COLOR_KEY */
+        0x0, /* gcFEATURE_BIT_VG_IM_INDEX_FORMAT */
+        0x0, /* gcFEATURE_BIT_VG_RESOLUTION_8K */
+        0x0, /* gcFEATURE_BIT_VG_IMAGE_16K */
+        0x0, /* gcFEATURE_BIT_VG_FORMAT_ARGB2222 */
+        0x0, /* gcFEATURE_BIT_G2D_DEC400 */
+        0x0, /* gcFEATURE_BIT_DC_OVERLAY_SCALING */
+        0x0, /* gcFEATURE_BIT_DC_SOURCE_ROTATION */
+        0x0, /* gcFEATURE_BIT_DC_TILED */
+        0x0, /* gcFEATURE_BIT_DC_YUV_L1 */
+        0x0, /* gcFEATURE_BIT_DC_D30_OUTPUT */
+        0x0, /* gcFEATURE_BIT_DC_MMU */
+        0x0, /* gcFEATURE_BIT_DC_COMPRESSION */
+        0x0, /* gcFEATURE_BIT_DC_QOS */
+        0x1, /* gcFEATURE_BIT_VIP_HW_FINAL_RELEASE */
+        0x1, /* gcFEATURE_BIT_NN_SINGLEPORT_ACCUMBUFFER */
+        0x1, /* gcFEATURE_BIT_NN_STRIDE_SUPPORT */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE1 */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE2 */
+        0x0, /* gcFEATURE_BIT_TP_SIMPLE_INT16 */
+        0x1, /* gcFEATURE_BIT_TP_REAL_INT16 */
+        0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
+        0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
+        0x1, /* gcFEATURE_BIT_TP_LRN */
+        0x1, /* gcFEATURE_BIT_TP_REORDER */
+        0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
+        0x1, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
+        0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
+        0x0, /* gcFEATURE_BIT_AI_GPU */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_ABSDIFF */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_BITREPLACE */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_BOXFILTER */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_CORDIAC */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_DP32 */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_FILTER */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_IADD */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_SELECTADD */
+        0x0, /* gcFEATURE_BIT_EVIS_LERP_7OUTPUT */
+        0x0, /* gcFEATURE_BIT_EVIS_ACCSQ_8OUTPUT */
+        0x1, /* gcFEATURE_BIT_EVIS_VX2 */
+        0x1, /* gcFEATURE_BIT_TP_ENGINE */
+        0x1, /* gcFEATURE_BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_TENSOR_ADD_MUL */
+        0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_INT16XINT8 */
+        0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_8BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_SOFTMAX */
+        0x0, /* gcFEATURE_BIT_NN_23BITS_POST_MULTIPLIER_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_23BITS_POST_MULTIPLIER_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_CONV_INT16X8BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_NN_REMOVE_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_40BIT_BIAS */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_USC */
+        0x0, /* gcFEATURE_BIT_NN_ZDP6 */
+        0x0, /* gcFEATURE_BIT_NN_XYDP9 */
+        0x1, /* gcFEATURE_BIT_NN_FIRST_PIXEL_POOLING */
+        0x1, /* gcFEATURE_BIT_NN_ZDP3 */
+        0x0, /* gcFEATURE_BIT_NN_XYDP6 */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE3 */
+        0x0, /* gcFEATURE_BIT_MCFE */
+        0x0, /* gcFEATURE_BIT_USC_STAY_LRU */
+        0x1, /* gcFEATURE_BIT_COEF_COMPRESSION_ENHANCEMENT */
+        0x1, /* gcFEATURE_BIT_TP_COEF_COMPRESSION_ENHANCEMENT */
+        0x1, /* gcFEATURE_BIT_NN_COEF_DECOMPRESS_PERF2X */
+        0x1, /* gcFEATURE_BIT_TP_SMALLBATCH_PHASE1 */
+        0x1, /* gcFEATURE_BIT_OCB_COUNTER */
+        0x0, /* gcFEATURE_BIT_SCALER */
+        0x0, /* gcFEATURE_BIT_SCALER_4K */
+        0x0, /* gcFEATURE_BIT_INPUT_4BIT */
+        0x1, /* gcFEATURE_BIT_NN_NO_Z_LOCATION_OFFSET */
+        0x1, /* gcFEATURE_BIT_OCB_REMAP_PHYSICAL_ADDRESS */
+        0x1, /* gcFEATURE_BIT_NN_SLOW_OUTPUT */
+        0x1, /* gcFEATURE_BIT_NO_NARROW_POST_PROCESS_PIPE */
+        0x1, /* gcFEATURE_BIT_TP_NN_PROBE */
+        0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_SUPPORT */
+        0x1, /* gcFEATURE_BIT_NN_XYDP0 */
+        0x1, /* gcFEATURE_BIT_NN_WRITE_WITHOUT_USC */
+        0x1, /* gcFEATURE_BIT_NN_HW_LIMITATION_NATIVE_KER_1x2_2x1 */
+        0x1, /* gcFEATURE_BIT_NN_SMALLBATCH_PHASE1 */
+        0x1, /* gcFEATURE_BIT_NN_SLICE_PADDING_TO_64BYTE_ALIGN */
+        0x0, /* gcFEATURE_BIT_NN_DW_1x1_CONV_MERGE */
+        0x1, /* gcFEATURE_BIT_TP_BFLOAT16 */
+        0x0, /* gcFEATURE_BIT_TP_23BITS_POST_MULTIPLIER */
+        0x1, /* gcFEATURE_BIT_NN_TRANSPOSE */
+        0x0, /* gcFEATURE_BIT_NN_ZDP_TRANSPOSE_CH9_ONLY */
+        0x1, /* gcFEATURE_BIT_USE_SINGLE_PORT_VIPSRAM */
+        0x1, /* gcFEATURE_BIT_NN_LEAKY_RELU */
+        0x1, /* gcFEATURE_BIT_NN_PRELU */
+        0x1, /* gcFEATURE_BIT_NN_PER_CHANNEL_QUANT */
+        0x1, /* gcFEATURE_BIT_NN_PER_CHANNEL_QUANT_ASYM */
+        0x1, /* gcFEATURE_BIT_NN_ASYMMETRIC_INT8 */
+        0x1, /* gcFEATURE_BIT_NN_FLOAT_POST_MULT */
+        0x1, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
+        0x1, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
+        0x1, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x1, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
+        0x1, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
+        0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
+        0x1, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
+        0x0, /* gcFEATURE_BIT_TP_3_USC */
+        0x1, /* gcFEATURE_BIT_BFP_COEF_AUTO_PAD_INCOMPLETE_ZERO_IN_KZ_PLANE */
+        0x1, /* gcFEATURE_BIT_NN_NATIVE_STRIDE_TWO */
+        0x1, /* gcFEATURE_BIT_NN_TENSOR_ADD */
+        0x0, /* gcFEATURE_BIT_NN_FLOAT32_IO */
+        0x1, /* gcFEATURE_BIT_TP_FLOAT32_IO */
+        0x0, /* gcFEATURE_BIT_NN_SMALL_BATCH_PHASE2 */
+        0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
+        0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
+        0x1, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
+        0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
+        0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
+        0x1, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
+        0x1, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
+        0x1, /* gcFEATURE_BIT_NN_SUPPORT_DUMMY_TILE */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_KERNEL_1BYTE_ALIGN */
+        0x1, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
+        0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
+        0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
+        0x0, /* gcFEATURE_BIT_NN_JOB_CANCELATION */
+        0x0, /* gcFEATURE_BIT_NN_DISTRIBUTED_VIPSRAM */
+        0x0, /* gcFEATURE_BIT_NN_FC_ENHANCEMENT */
+        0x0, /* gcFEATURE_BIT_VIP_DEC400 */
+        0x1, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_REQ_SLOWARBITRATION_FIX */
+        0x0, /* gcFEATURE_BIT_IMAGE_PARTIAL_CACHE_FIX */
+        0x0, /* gcFEATURE_BIT_FULLCACHE_KERNELHEAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
+        0x1, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
+        0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
+        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
+        0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
+        0x1, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
+        0x1, /* gcFEATURE_BIT_COEF_DELTA_CORD_OVERFLOW_ZRL_8BIT_FIX */
+        0x1, /* gcFEATURE_BIT_USC_INDIVIDUAL_PORT_WRT_EARLY_EVICT_DATA_CORRUPT_FIX */
+        0x1, /* gcFEATURE_BIT_LOW_EFFICIENCY_OF_ID_WRITE_IMGBUF_FIX */
+        0x1, /* gcFEATURE_BIT_KERNEL_VIP_SRAM_READ_BW_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_USC_BOTTLENECK_FIX */
+        0x0, /* gcFEATURE_BIT_KERNEL_PER_CORE_LESS_THAN_THIRD_COEF_BUFF_DEPTH_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_NUM_BIGGER_THAN_1024_FIX */
+        0x1, /* gcFEATURE_BIT_KERNEL_SIZE_WASTE_IN_PARTIAL_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_COMMAND_KERNEL_REQUEST_CONFICT_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
+        0x1, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
+        0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
+        0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_CAHCE_MODE_MUST_0_IN_IMG_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
+        0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
+        0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
+        0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
+        0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
+        0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x0, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x0, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x0, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
+        0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
+        0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
+        0x1, /* gcFEATURE_BIT_NN_INT8_SCALE */
+        0x1, /* gcFEATURE_BIT_NN_POWER_ISOLATION */
+        0x0, /* gcFEATURE_BIT_ZRL_7BIT */
+        0x0, /* gcFEATURE_BIT_NN_SMALLBATCH */
+        0x0, /* gcFEATURE_BIT_TP_SMALLBATCH */
+        0x1, /* gcFEATURE_BIT_ZRL_8BIT */
+        0x0, /* gcFEATURE_BIT_DDR_BURST_LEN_256B */
+        0x1, /* gcFEATURE_BIT_XY_OFFSET_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_NONZERO_MIRROR_BORDER */
+        0x1, /* gcFEATURE_BIT_IMAGE_PARTIAL_CACHE */
+    },
     /* vipnano-qi */
     {
         0x8000, /* ChipID */
         0x7004, /* ChipRevision */
         0x45080009, /* ProductID */
-        0x1, /* EcoID */
+        0x0, /* EcoID */
         0x7d, /* CustomerID */
         0x0, /* PatchVersion */
         "", /* ProductName */
@@ -764,8 +1535,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -792,8 +1565,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x5, /* gcFEATURE_VALUE_NN_ZRL_BITS */
         0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
         0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
         0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
         0x7, /* gcFEATURE_VALUE_NN_X_OFFSET */
@@ -811,6 +1584,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -1194,6 +1969,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -1211,6 +1987,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -1247,7 +2030,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
         0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
         0x1, /* gcFEATURE_BIT_TP_LRN */
-        0x1, /* gcFEATURE_BIT_TP_REORDER */
+        0x0, /* gcFEATURE_BIT_TP_REORDER */
         0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
         0x0, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
         0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
@@ -1317,6 +2100,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -1330,10 +2116,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -1342,6 +2130,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -1352,13 +2142,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
         0x0, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
-        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_TP_REORDER_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
         0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
         0x0, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
-        0x0, /* gcFEATURE_BIT_HI_REORDER_FIX */
-        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
         0x0, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
         0x0, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
@@ -1368,7 +2158,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
         0x0, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
         0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
-        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
         0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
         0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
         0x0, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
@@ -1384,7 +2174,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -1399,15 +2189,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -1427,7 +2233,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x8000, /* ChipID */
         0x7004, /* ChipRevision */
         0x45080009, /* ProductID */
-        0x0, /* EcoID */
+        0x1, /* EcoID */
         0x7d, /* CustomerID */
         0x0, /* PatchVersion */
         "", /* ProductName */
@@ -1465,8 +2271,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -1512,6 +2320,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -1895,6 +2705,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -1912,6 +2723,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -1948,7 +2766,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
         0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
         0x1, /* gcFEATURE_BIT_TP_LRN */
-        0x0, /* gcFEATURE_BIT_TP_REORDER */
+        0x1, /* gcFEATURE_BIT_TP_REORDER */
         0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
         0x0, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
         0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
@@ -2018,6 +2836,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -2031,10 +2852,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -2043,6 +2866,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -2053,13 +2878,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
         0x0, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
-        0x0, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
         0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
         0x0, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
-        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
-        0x1, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x0, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
         0x0, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
         0x0, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
@@ -2069,7 +2894,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
         0x0, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
         0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
-        0x0, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
         0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
         0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
         0x0, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
@@ -2085,7 +2910,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -2100,15 +2925,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -2166,8 +3007,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -2194,8 +3037,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x5, /* gcFEATURE_VALUE_NN_ZRL_BITS */
         0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
         0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
         0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_X_OFFSET */
@@ -2213,6 +3056,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -2596,6 +3441,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -2613,6 +3459,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -2719,6 +3572,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -2732,10 +3588,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -2744,6 +3602,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -2786,7 +3646,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -2801,15 +3661,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -2867,8 +3743,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x4, /* gcFEATURE_VALUE_NNCoreCount */
+        0x4, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x4, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x4, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -2914,6 +3792,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -3291,12 +4171,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
         0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
         0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
-        0x0, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
         0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
         0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -3314,6 +4195,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -3420,6 +4308,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -3433,10 +4324,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -3445,6 +4338,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -3492,9 +4387,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
         0x0, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
-        0x0, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
-        0x0, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
         0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
         0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
@@ -3502,15 +4397,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x0, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -3568,8 +4479,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -3615,6 +4528,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -3992,12 +4907,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
         0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
         0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
-        0x0, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
         0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
         0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -4015,6 +4931,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -4121,6 +5044,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -4134,10 +5060,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -4146,6 +5074,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -4193,9 +5123,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
         0x0, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
-        0x0, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
-        0x0, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
         0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
         0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
@@ -4203,15 +5133,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x0, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -4269,8 +5215,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -4316,6 +5264,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -4699,6 +5649,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -4716,6 +5667,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -4822,6 +5780,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -4835,10 +5796,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -4847,6 +5810,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -4889,7 +5854,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -4904,15 +5869,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -4970,8 +5951,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x2, /* gcFEATURE_VALUE_NNCoreCount */
+        0x2, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x2, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -5017,6 +6000,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -5400,6 +6385,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -5417,6 +6403,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -5523,6 +6516,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -5536,10 +6532,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -5548,6 +6546,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -5590,7 +6590,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -5605,15 +6605,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x0, /* gcFEATURE_BIT_NN_INT16_ALU */
diff --git a/drivers/staging/npu/inc/gc_hal.h b/drivers/staging/npu/inc/gc_hal.h
index 822743502120..25ba41962643 100644
--- a/drivers/staging/npu/inc/gc_hal.h
+++ b/drivers/staging/npu/inc/gc_hal.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -765,7 +765,7 @@ gckOS_Delay(
     IN gctUINT32 Delay
     );
 
-/* Delay a number of microseconds. */
+/* Delay a number of milliseconds. */
 gceSTATUS
 gckOS_Udelay(
     IN gckOS Os,
@@ -1103,6 +1103,14 @@ gckOS_GetPolicyID(
     OUT gctUINT32_PTR AXIConfig
     );
 
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gckOS_SwitchCoreCount(
+    IN gckOS Os,
+    OUT gctUINT32 *Count
+    );
+#endif
+
 /******************************************************************************\
 ************************** Android Native Fence Sync ***************************
 \******************************************************************************/
@@ -2115,7 +2123,10 @@ gceSTATUS
 gckMMU_FillFlatMapping(
     IN gckMMU Mmu,
     IN gctUINT64 PhysBase,
-    IN gctSIZE_T Size
+    IN gctSIZE_T Size,
+    IN gctBOOL   Reserved,
+    IN gctBOOL   AbleToShift,
+    OUT gctUINT32 *GpuBaseAddress
     );
 
 gceSTATUS
@@ -2138,15 +2149,13 @@ gceSTATUS
 gckHARDWARE_QueryContextProfile(
     IN gckHARDWARE Hardware,
     IN gctBOOL Reset,
-    IN gckCONTEXT Context,
     OUT gcsPROFILER_COUNTERS_PART1 * Counters_part1,
     OUT gcsPROFILER_COUNTERS_PART2 * Counters_part2
     );
 
 gceSTATUS
 gckHARDWARE_UpdateContextProfile(
-    IN gckHARDWARE Hardware,
-    IN gckCONTEXT Context
+    IN gckHARDWARE Hardware
     );
 
 gceSTATUS
diff --git a/drivers/staging/npu/inc/gc_hal_base.h b/drivers/staging/npu/inc/gc_hal_base.h
index f09bd3efe18f..f1814eb16bba 100644
--- a/drivers/staging/npu/inc/gc_hal_base.h
+++ b/drivers/staging/npu/inc/gc_hal_base.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -62,6 +62,7 @@ typedef struct _gcsUSER_MEMORY_DESC *   gcsUSER_MEMORY_DESC_PTR;
 typedef struct _gcsNN_FIXED_FEATURE
 {
     gctUINT  vipCoreCount;
+    gctUINT  vipRingCount;
     gctUINT  nnMadPerCore;
     gctUINT  nnInputBufferDepth;
     gctUINT  nnAccumBufferDepth;
@@ -542,7 +543,7 @@ gcoHAL_QueryChipAxiBusWidth(
 gceSTATUS
 gcoHAL_QueryMultiGPUAffinityConfig(
     IN gceHARDWARE_TYPE Type,
-    OUT gceMULTI_GPU_MODE *Mode,
+    OUT gceMULTI_PROCESSOR_MODE *Mode,
     OUT gctUINT32_PTR CoreIndex
     );
 
@@ -1044,12 +1045,31 @@ gcoHAL_SetLastCommitStatus(
     IN gctBOOL Pending
     );
 
+gceSTATUS
+gcoHAL_CommitDone(
+    IN gcoHAL Hal
+    );
+
 gceSTATUS
 gcoHAL_IsFlatMapped(
     IN gctPHYS_ADDR_T PhysicalAddress,
     OUT gctUINT32 *Address
     );
 
+gceSTATUS
+gcoHAL_QueryMCFESemaphoreCapacity(
+    IN gcoHAL Hal,
+    OUT gctUINT32 * Capacity
+    );
+
+
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gcoHAL_SwitchMpMode(
+    gcoHAL Hal
+    );
+#endif
+
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
 \******************************************************************************/
diff --git a/drivers/staging/npu/inc/gc_hal_cl.h b/drivers/staging/npu/inc/gc_hal_cl.h
index b185c5e3ea8b..6ce4622770f2 100644
--- a/drivers/staging/npu/inc/gc_hal_cl.h
+++ b/drivers/staging/npu/inc/gc_hal_cl.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -69,6 +69,7 @@ typedef struct _gcoCL_DEVICE_INFO
     gctUINT64           queueProperties;        /* cl_command_queue_properties */
     gctBOOL             hostUnifiedMemory;
     gctBOOL             errorCorrectionSupport;
+    gctUINT64           halfFpConfig;           /* cl_device_fp_config */
     gctUINT64           singleFpConfig;         /* cl_device_fp_config */
     gctUINT64           doubleFpConfig;         /* cl_device_fp_config */
     gctUINT             profilingTimingRes;
@@ -93,11 +94,12 @@ typedef struct _gcoCL_DEVICE_INFO
 
     /* cluster info */
     gctBOOL             clusterSupport;
-    gctUINT32           clusterCount;
-    gctUINT32           clusterAliveMask;
-    gctUINT32           clusterAliveCount;
-    gctUINT32           clusterMinID;
-    gctUINT32           clusterMaxID;
+    gctUINT32           clusterCount[gcdMAX_MAJOR_CORE_COUNT];
+    gctUINT32           clusterAliveMask[gcdMAX_MAJOR_CORE_COUNT];
+    gctUINT32           clusterAliveCount[gcdMAX_MAJOR_CORE_COUNT];
+    gctUINT32           clusterMinID[gcdMAX_MAJOR_CORE_COUNT];
+    gctUINT32           clusterMaxID[gcdMAX_MAJOR_CORE_COUNT];
+    gctUINT32           totalClusterAliveCount;
 
     gceCHIPMODEL        chipModel;
     gctUINT32           chipRevision;
@@ -842,6 +844,11 @@ gcoCL_IsFeatureAvailable(
     IN gceFEATURE Feature
     );
 
+gctUINT
+gcoCL_QueryBLTFenceEndianHint(
+    IN gcoHARDWARE Hardware
+    );
+
 gceSTATUS
 gcoCL_3dBltLock(
     IN gcoHARDWARE Hardware,
diff --git a/drivers/staging/npu/inc/gc_hal_debug_zones.h b/drivers/staging/npu/inc/gc_hal_debug_zones.h
index bf23c8a24651..82f8ddde8d5d 100644
--- a/drivers/staging/npu/inc/gc_hal_debug_zones.h
+++ b/drivers/staging/npu/inc/gc_hal_debug_zones.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_driver.h b/drivers/staging/npu/inc/gc_hal_driver.h
index a9c5f569e73f..b7a2f367d781 100644
--- a/drivers/staging/npu/inc/gc_hal_driver.h
+++ b/drivers/staging/npu/inc/gc_hal_driver.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_driver_vg.h b/drivers/staging/npu/inc/gc_hal_driver_vg.h
index a482ea7150e5..6ff1618577bc 100644
--- a/drivers/staging/npu/inc/gc_hal_driver_vg.h
+++ b/drivers/staging/npu/inc/gc_hal_driver_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_drm.h b/drivers/staging/npu/inc/gc_hal_drm.h
index 0d7e405935ec..139c8c1ea739 100644
--- a/drivers/staging/npu/inc/gc_hal_drm.h
+++ b/drivers/staging/npu/inc/gc_hal_drm.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -97,11 +97,17 @@ struct drm_viv_gem_timestamp {
 #define DRM_VIV_GEM_TS_NORMAL       0x02
 #define DRM_VIV_GEM_TS_COMPRESSED   0x03
 
+/* ts cache mode. */
+#define DRM_VIV_GEM_TS_CACHE_MODE_64B     0x00
+#define DRM_VIV_GEM_TS_CACHE_MODE_128B    0x01
+#define DRM_VIV_GEM_TS_CACHE_MODE_256B    0x02
+
 struct drm_viv_gem_set_tiling {
     __u32 handle;
     __u32 tiling_mode;
 
     __u32 ts_mode;
+    __u32 ts_cache_mode;
     __u64 clear_value;
 };
 
@@ -110,6 +116,7 @@ struct drm_viv_gem_get_tiling {
     __u32 tiling_mode;
 
     __u32 ts_mode;
+    __u32 ts_cache_mode;
     __u64 clear_value;
 };
 
@@ -153,7 +160,10 @@ struct drm_viv_gem_ref_node {
 #define DRM_IOCTL_VIV_GEM_REF_NODE      DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_REF_NODE, struct drm_viv_gem_ref_node)
 
 #ifdef __KERNEL__
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+#define drm_gem_object_unreference_unlocked drm_gem_object_put
+#define drm_dev_unref drm_dev_put
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
 #define drm_gem_object_unreference_unlocked drm_gem_object_put_unlocked
 #define drm_dev_unref drm_dev_put
 #endif
diff --git a/drivers/staging/npu/inc/gc_hal_dump.h b/drivers/staging/npu/inc/gc_hal_dump.h
index 3348073aa915..b4fd6fb3f548 100644
--- a/drivers/staging/npu/inc/gc_hal_dump.h
+++ b/drivers/staging/npu/inc/gc_hal_dump.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_eglplatform.h b/drivers/staging/npu/inc/gc_hal_eglplatform.h
index cf6ecc77de1a..7975ae2d4fb3 100644
--- a/drivers/staging/npu/inc/gc_hal_eglplatform.h
+++ b/drivers/staging/npu/inc/gc_hal_eglplatform.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_eglplatform_type.h b/drivers/staging/npu/inc/gc_hal_eglplatform_type.h
index e6969d86641b..33d67c88ea76 100644
--- a/drivers/staging/npu/inc/gc_hal_eglplatform_type.h
+++ b/drivers/staging/npu/inc/gc_hal_eglplatform_type.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright 2012 - 2020 Vivante Corporation, Santa Clara, California.
+*    Copyright 2012 - 2021 Vivante Corporation, Santa Clara, California.
 *    All Rights Reserved.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining
diff --git a/drivers/staging/npu/inc/gc_hal_engine.h b/drivers/staging/npu/inc/gc_hal_engine.h
index c64ab25b2bd0..36733589baec 100644
--- a/drivers/staging/npu/inc/gc_hal_engine.h
+++ b/drivers/staging/npu/inc/gc_hal_engine.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -82,6 +82,13 @@ typedef struct _gcoBUFOBJ *             gcoBUFOBJ;
 #define gcdATTRIBUTE_COUNT              32
 #define gcdVERTEXARRAY_POOL_CAPACITY    32
 
+#define gcdSTREAM_POOL_SIZE      128
+#define gcdSTREAM_GROUP_SIZE     16
+#define gcdSTREAM_SIGNAL_NUM \
+    (\
+        (gcdSTREAM_POOL_SIZE + gcdSTREAM_GROUP_SIZE - 1) / gcdSTREAM_GROUP_SIZE \
+    )
+
 #define gcvPORGRAM_STAGE_GPIPE (gcvPROGRAM_STAGE_VERTEX_BIT | \
                                 gcvPROGRAM_STAGE_TCS_BIT    | \
                                 gcvPROGRAM_STAGE_TES_BIT    | \
@@ -1558,6 +1565,8 @@ typedef struct _gcsVX_IMAGE_INFO
 #if gcdVX_OPTIMIZER
     gctUINT32       uniformData[3][4];
 #endif
+    /* the uniform data type of save nbg */
+    gctUINT32       uniformSaveDataType;
 }
 gcsVX_IMAGE_INFO;
 typedef struct _gcsVX_DISTRIBUTION_INFO * gcsVX_DISTRIBUTION_INFO_PTR;
@@ -2391,6 +2400,9 @@ typedef struct _gcsATTRIBUTE
     /* Divisor of the attribute */
     gctUINT             divisor;
 
+    /* Offset of the attribute */
+    gctUINT             offset;
+
     /* Pointer to the attribute data. */
     gctCONST_POINTER    pointer;
 
diff --git a/drivers/staging/npu/inc/gc_hal_engine_vg.h b/drivers/staging/npu/inc/gc_hal_engine_vg.h
index 6bff2abdc5e2..ea14196adfac 100644
--- a/drivers/staging/npu/inc/gc_hal_engine_vg.h
+++ b/drivers/staging/npu/inc/gc_hal_engine_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_enum.h b/drivers/staging/npu/inc/gc_hal_enum.h
index 3860f74f31e1..7279fc0f12e6 100644
--- a/drivers/staging/npu/inc/gc_hal_enum.h
+++ b/drivers/staging/npu/inc/gc_hal_enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -878,13 +878,6 @@ typedef enum _gceMULTI_GPU_RENDERING_MODE
 }
 gceMULTI_GPU_RENDERING_MODE;
 
-typedef enum _gceMULTI_GPU_MODE
-{
-    gcvMULTI_GPU_MODE_COMBINED    = 0,
-    gcvMULTI_GPU_MODE_INDEPENDENT = 1
-}
-gceMULTI_GPU_MODE;
-
 typedef enum _gceMACHINECODE
 {
     gcvMACHINECODE_ANTUTU0 = 0x0,
@@ -960,8 +953,10 @@ gceMCFE_CHANNEL_TYPE;
 
 typedef enum _gcePAGE_TYPE
 {
-    gcvPAGE_TYPE_1M,
     gcvPAGE_TYPE_4K,
+    gcvPAGE_TYPE_64K,
+    gcvPAGE_TYPE_1M,
+    gcvPAGE_TYPE_16M,
 }
 gcePAGE_TYPE;
 
@@ -1692,20 +1687,29 @@ typedef enum _gceBUFOBJ_TYPE
 
 typedef enum _gceBUFOBJ_USAGE
 {
-    gcvBUFOBJ_USAGE_STREAM_DRAW = 1,
-    gcvBUFOBJ_USAGE_STREAM_READ,
-    gcvBUFOBJ_USAGE_STREAM_COPY,
-    gcvBUFOBJ_USAGE_STATIC_DRAW,
-    gcvBUFOBJ_USAGE_STATIC_READ,
-    gcvBUFOBJ_USAGE_STATIC_COPY,
-    gcvBUFOBJ_USAGE_DYNAMIC_DRAW,
-    gcvBUFOBJ_USAGE_DYNAMIC_READ,
-    gcvBUFOBJ_USAGE_DYNAMIC_COPY,
-
+    gcvBUFOBJ_USAGE_NONE                                = 0x0,
+    gcvBUFOBJ_USAGE_STREAM_DRAW                         = 0x1,
+    gcvBUFOBJ_USAGE_STREAM_READ                         = 0x2,
+    gcvBUFOBJ_USAGE_STREAM_COPY                         = 0x3,
+    gcvBUFOBJ_USAGE_STATIC_DRAW                         = 0x4,
+    gcvBUFOBJ_USAGE_STATIC_READ                         = 0x5,
+    gcvBUFOBJ_USAGE_STATIC_COPY                         = 0x6,
+    gcvBUFOBJ_USAGE_DYNAMIC_DRAW                        = 0x7,
+    gcvBUFOBJ_USAGE_DYNAMIC_READ                        = 0x8,
+    gcvBUFOBJ_USAGE_DYNAMIC_COPY                        = 0x9,
+
+    /* Use 8bits to save the usage. */
+    gcvBUFOBJ_USAGE_MASK                                = 0xFF,
+
+    /* Some special flags. */
     /* special patch for optimaize performance,
     ** no fence and duplicate stream to ensure data correct
     */
-    gcvBUFOBJ_USAGE_DISABLE_FENCE_DYNAMIC_STREAM = 256
+    gcvBUFOBJ_USAGE_FLAG_DISABLE_FENCE_DYNAMIC_STREAM   = 0x100,
+
+    /* This buffer object is used by driver, so we need to copy the data to the logical memory. */
+    gcvBUFOBJ_USAGE_FLAG_DATA_USED_BY_DRIVER            = 0x200,
+
 } gceBUFOBJ_USAGE;
 
 /**
@@ -2078,55 +2082,57 @@ enum
     gcvPLATFORM_FLAG_IMX_MM           = 1 << 1,
 };
 
-/* No special needs. */
-#define gcvALLOC_FLAG_NONE                  0x00000000
-
-/* Physical contiguous. */
-#define gcvALLOC_FLAG_CONTIGUOUS            0x00000001
-/* Physical non contiguous. */
-#define gcvALLOC_FLAG_NON_CONTIGUOUS        0x00000002
-
-/* Should not swap out. */
-#define gcvALLOC_FLAG_NON_PAGED             0x00000004
-
-/* CPU access explicitly needed. */
-#define gcvALLOC_FLAG_CPU_ACCESS            0x00000008
-/* Can be remapped as cacheable. */
-#define gcvALLOC_FLAG_CACHEABLE             0x00000010
-
-/* Need 32bit address. */
-#define gcvALLOC_FLAG_4GB_ADDR              0x00000020
-
-/* Secure buffer. */
-#define gcvALLOC_FLAG_SECURITY              0x00000040
-/* Can be exported as dmabuf-fd */
-#define gcvALLOC_FLAG_DMABUF_EXPORTABLE     0x00000080
-/* Do not try slow pools (gcvPOOL_VIRTUAL) */
-#define gcvALLOC_FLAG_FAST_POOLS            0x00000100
-
-/* Only accessed by GPU */
-#define gcvALLOC_FLAG_NON_CPU_ACCESS        0x00000200
-
-/* Import DMABUF. */
-#define gcvALLOC_FLAG_DMABUF                0x00001000
-/* Import USERMEMORY. */
-#define gcvALLOC_FLAG_USERMEMORY            0x00002000
-/* Import an External Buffer. */
-#define gcvALLOC_FLAG_EXTERNAL_MEMORY       0x00004000
-/* Import linux reserved memory. */
-#define gcvALLOC_FLAG_LINUX_RESERVED_MEM    0x00008000
-
-/* 1M pages unit allocation. */
-#define gcvALLOC_FLAG_1M_PAGES              0x00010000
-
-/* Non 1M pages unit allocation. */
-#define gcvALLOC_FLAG_4K_PAGES              0x00020000
-
-/* Real allocation happens when GPU page fault. */
-#define gcvALLOC_FLAG_ALLOC_ON_FAULT        0x01000000
-/* Alloc with memory limit. */
-#define gcvALLOC_FLAG_MEMLIMIT              0x02000000
+#if gcdUSE_CAPBUF
+typedef enum _gceCAPBUF_META_TYPE
+{
+    gcvCAPBUF_META_TYPE_BASE = 0,
+    gcvCAPBUF_META_TYPE_STATE_BUFFER = 0,
+    gcvCAPBUF_META_TYPE_DRAW_ID,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM,
+    gcvCAPBUF_META_TYPE_VIP_SRAM,
+    gcvCAPBUF_META_TYPE_AXI_SRAM,
+    gcvCAPBUF_META_TYPE_PPU_PARAMETERS,
+    gcvCAPBUF_META_TYPE_VIP_SRAM_REMAP,
+    gcvCAPBUF_META_TYPE_AXI_SRAM_REMAP,
+    gcvCAPBUF_META_TYPE_IMAGE_PHYSICAL_ADDRESS,
+    gcvCAPBUF_META_TYPE_SH_INST_ADDRESS,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM_ARGS_LOCAL_ADDRESS_SPACE,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM_ARGS_CONSTANT_ADDRESS_SPACE,
+    /* Keep it at the end of the list. */
+    gcvCAPBUF_META_TYPE_COUNT
+}
+gceCAPBUF_META_TYPE;
+
+typedef enum _gceCAPBUF_SH_UNIFROM_ARGS
+{
+    gcvCAPBUF_SH_UNIFORM_ARGS_INVALID = 0,
+    gcvCAPBUF_SH_UNIFORM_ARGS_IMAGE_PHYSICAL_ADDRESS,
+    gcvCAPBUF_SH_UNIFORM_ARGS_LOCAL_ADDRESS_SPACE,
+    gcvCAPBUF_SH_UNIFORM_ARGS_CONSTANT_ADDRESS_SPACE,
+    /* Keep it at the end of the list. */
+    gcvCAPBUF_SH_UNIFORM_ARGS_COUNT
+}
+gceCAPBUF_SH_UNIFORM_ARGS;
+
+typedef enum _gceCAPBUF_PPU_PARAMETERS_INDEX
+{
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_X = 0,
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_Y,
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_Z,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_X,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_Y,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_Z,
+    gcvCAPBUF_PPU_GROUP_SIZE_X,
+    gcvCAPBUF_PPU_GROUP_SIZE_Y,
+    gcvCAPBUF_PPU_GROUP_SIZE_Z,
+    gcvCAPBUF_PPU_GROUP_COUNT_X,
+    gcvCAPBUF_PPU_GROUP_COUNT_Y,
+    gcvCAPBUF_PPU_GROUP_COUNT_Z,
+    gcvCAPBUF_PPU_PARAMETERS_COUNT
+}
+gceCAPBUF_PPU_GLOBALE_OFFSET_INDEX;
 
+#endif
 
 /* GL_VIV internal usage */
 #ifndef GL_MAP_BUFFER_OBJ_VIV
diff --git a/drivers/staging/npu/inc/gc_hal_mem.h b/drivers/staging/npu/inc/gc_hal_mem.h
index a1b70b9b9bb7..58af211ed32e 100644
--- a/drivers/staging/npu/inc/gc_hal_mem.h
+++ b/drivers/staging/npu/inc/gc_hal_mem.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_metadata.h b/drivers/staging/npu/inc/gc_hal_metadata.h
index d4ab2d2e3bb1..fa72b8072f82 100644
--- a/drivers/staging/npu/inc/gc_hal_metadata.h
+++ b/drivers/staging/npu/inc/gc_hal_metadata.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_options.h b/drivers/staging/npu/inc/gc_hal_options.h
index 3a6cd44a1df9..283f1f43f52e 100644
--- a/drivers/staging/npu/inc/gc_hal_options.h
+++ b/drivers/staging/npu/inc/gc_hal_options.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -163,7 +163,7 @@ This define enables the use of VM for gckCommand and fence buffers.
         When set to 1, will dump TP/NN command buffer when GPU/VIP hang.
 */
 #ifndef gcdDUMP_TPNN_SUBCOMMAND
-#   define gcdDUMP_TPNN_SUBCOMMAND              0
+#   define gcdDUMP_TPNN_SUBCOMMAND              1
 #endif
 
 /*
@@ -294,15 +294,6 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_FSCALE_VAL_ADJUST          1
 #endif
 
-/*
-    gcdCAPTURE_ONLY_MODE
-        When non-zero, driver is built with capture only mode.
-        1) Set DDR address range in capture file with contiguousBase and contiguoutsSize.
-           Video memory allocation will go through reserved pool with capture only mode.
-        2) Set SRAM address range in capture file with sRAMBases, sRAMSizes and extSRAMBases, extSRAMSizes.
-           Video memory querion will go through reserved pool with capture only mode.
-        3) TODO: SRAM video memory allocation.
-*/
 #ifndef gcdCAPTURE_ONLY_MODE
 #   define gcdCAPTURE_ONLY_MODE                 0
 #endif
@@ -1399,6 +1390,15 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_SW_PREEMPTION 0
 #endif
 
+/*
+    gcdSUPPORT_DEVICE_TREE_SOURCE
+        To suppor device tree feature if set to 1, disable by default.
+        Only works on linux OS.
+*/
+#ifndef gcdSUPPORT_DEVICE_TREE_SOURCE
+#   define gcdSUPPORT_DEVICE_TREE_SOURCE        0
+#endif
+
 /*
     gcdENABLE_PER_DEVICE_PM
         Enable per device power management if set to 2, all the hardware cores will be one device.
@@ -1410,6 +1410,31 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_PER_DEVICE_PM 0
 #endif
 
+/*
+    gcdUSE_CAPBUF
+ */
+#ifndef gcdUSE_CAPBUF
+#   define gcdUSE_CAPBUF 1
+#endif
+
+/*
+    gcdENABLE_MP_SWITCH
+        Enable multi-processor mode dynamic switch, the processor count is determined by specific conditions.
+        Only support Linux OS currently.
+*/
+#ifndef gcdENABLE_MP_SWITCH
+#   define gcdENABLE_MP_SWITCH 0
+#endif
+
+/*
+    gcdANON_FILE_FOR_ALLOCATOR
+        Enable this macro can replace the /dev/zero by anon_inode:[galcore] in /proc/<pid>/maps.
+        Without the macro, run 'cat /proc/<pid>/maps' will print "/dev/zero".
+*/
+#ifndef gcdANON_FILE_FOR_ALLOCATOR
+#   define gcdANON_FILE_FOR_ALLOCATOR 0
+#endif
+
 #endif /* __gc_hal_options_h_ */
 
 
diff --git a/drivers/staging/npu/inc/gc_hal_priv.h b/drivers/staging/npu/inc/gc_hal_priv.h
index 1c1738bd2fd7..64b2449eac47 100644
--- a/drivers/staging/npu/inc/gc_hal_priv.h
+++ b/drivers/staging/npu/inc/gc_hal_priv.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -42,6 +42,7 @@ typedef enum _gcePATCH_ID
     gcvPATCH_GLBM27,
     gcvPATCH_GLBMGUI,
     gcvPATCH_GFXBENCH,
+    gcvPATCH_ANDROID_GPUTEST,
     gcvPATCH_ANTUTU, /* Antutu 3.x */
     gcvPATCH_ANTUTU4X, /* Antutu 4.x */
     gcvPATCH_ANTUTU5X, /* Antutu 5.x */
@@ -137,6 +138,7 @@ typedef enum _gcePATCH_ID
     gcvPATCH_LEANBACKSCROLLING,
     gcvPATCH_ANTUTU6X, /* Antutu 6.x */
     gcvPATCH_ANTUTU3DBench,
+    gcvPATCH_ANTUTU_V8_REFINERY,
     gcvPATCH_CAR_CHASE,
     gcvPATCH_ANDROID_BROWSER,
     gcvPATCH_COMPUTBENCH_CL, /* ComputBench 1.5 */
@@ -150,6 +152,7 @@ typedef enum _gcePATCH_ID
     gcvPATCH_SASCHAWILLEMS,
     gcvPATCH_NATIVEHARDWARE_CTS,
     gcvPATCH_ANDROID_PHOTOS,
+    gcvPATCH_MUSTANG,
     gcvPATCH_OVX_CTS,
     gcvPATCH_DEQP_VK,
     gcvPATCH_KANZI,
@@ -158,11 +161,14 @@ typedef enum _gcePATCH_ID
     gcvPATCH_VK_T3DSTRESSTEST,
     gcvPATCH_VK_HDR02_FBBASICTONEMAPPING,
     gcvPATCH_VK_BLOOM,
+    gcvPATCH_VK_GFXBENCH5,
     gcvPATCH_CLBLAST,
     gcvPATCH_GRAPHICS_BENCHMARKS,
     gcvPATCH_INTEL_CL_BITONICSORT,
     gcvPATCH_PIGLIT_CL,
-
+    gcvPATCH_VK_UNITY,
+    gcvPATCH_VK_UNREAL,
+    gcvPATCH_VK_UNITY_SAMPLEASSETS,
     gcvPATCH_COUNT
 } gcePATCH_ID;
 
diff --git a/drivers/staging/npu/inc/gc_hal_profiler.h b/drivers/staging/npu/inc/gc_hal_profiler.h
index 40cb32a076a4..f0909437f51e 100644
--- a/drivers/staging/npu/inc/gc_hal_profiler.h
+++ b/drivers/staging/npu/inc/gc_hal_profiler.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -181,17 +181,36 @@ extern "C" {
 #define PPS_SOURCE           (PPS_FUNCTIONCOUNT    + 1)
 /* End of MISC Counter IDs. */
 
+#define VPG(x) (gcoPROFILER_getVPGConst(x))
+
+enum gceVPG
+{
+    VPHEADER,
+    INFO,
+    FRAME,
+    TIME,
+    ES11,
+    ES20,
+    VG11,
+    HW,
+    MULTI_GPU,
+    PROG,
+    ES11DRAW,
+    ES20DRAW,
+    MEM,
+    PVS,
+    PPS,
+    ES11_TIME,
+    ES20_TIME,
+    ES30,
+    ES30_DRAW,
+    ES30_TIME,
+    FINISH,
+    END,
+};
 
 /* Category Constants. */
-#define VPHEADER        0x010000
-#define VPG_INFO        0x020000
-#define VPG_TIME        0x030000
-#define VPG_MEM         0x040000
-#define VPG_ES11        0x050000
-#define VPG_ES30        0x060000
-#define VPG_VG11        0x070000
 #define VPG_HAL         0x080000
-#define VPG_HW          0x090000
 #define VPG_GPU         0x0a0000
 #define VPG_VS          0x0b0000
 #define VPG_PS          0x0c0000
@@ -202,17 +221,8 @@ extern "C" {
 #define VPG_PE          0x110000
 #define VPG_MC          0x120000
 #define VPG_AXI         0x130000
-#define VPG_PROG        0x140000
-#define VPG_PVS         0x150000
-#define VPG_PPS         0x160000
-#define VPG_ES11_TIME   0x170000
-#define VPG_ES30_TIME   0x180000
-#define VPG_FRAME       0x190000
-#define VPG_ES11_DRAW   0x200000
-#define VPG_ES30_DRAW   0x210000
 #define VPG_VG11_TIME   0x220000
 #define VPG_FE          0x230000
-#define VPG_MULTI_GPU   0x240000
 #define VPNG_FE         0x250000
 #define VPNG_VS         0x260000
 #define VPNG_PS         0x270000
@@ -227,49 +237,48 @@ extern "C" {
 #define VPNG_L2         0x300000
 #define VPNG_NN         0x310000
 #define VPNG_TP         0x320000
-#define VPG_FINISH      0x330000
-#define VPG_END         0xff0000
 
 /* Info. */
-#define VPC_INFOCOMPANY         (VPG_INFO + 1)
+#define VPC_INFOCOMPANY         (VPG(INFO) + 1)
 #define VPC_INFOVERSION         (VPC_INFOCOMPANY + 1)
 #define VPC_INFORENDERER        (VPC_INFOVERSION + 1)
 #define VPC_INFOREVISION        (VPC_INFORENDERER + 1)
 #define VPC_INFODRIVER          (VPC_INFOREVISION + 1)
 #define VPC_INFODRIVERMODE      (VPC_INFODRIVER + 1)
 #define VPC_INFOSCREENSIZE      (VPC_INFODRIVERMODE + 1)
+#define VPC_INFOASICMODE        (VPC_INFOSCREENSIZE + 1)
 
 /* Counter Constants. */
-#define VPC_ELAPSETIME          (VPG_TIME + 1)
+#define VPC_ELAPSETIME          (VPG(TIME) + 1)
 #define VPC_CPUTIME             (VPC_ELAPSETIME + 1)
 
-#define VPC_MEMMAXRES           (VPG_MEM + 1)
+#define VPC_MEMMAXRES           (VPG(MEM) + 1)
 #define VPC_MEMSHARED           (VPC_MEMMAXRES + 1)
 #define VPC_MEMUNSHAREDDATA     (VPC_MEMSHARED + 1)
 #define VPC_MEMUNSHAREDSTACK    (VPC_MEMUNSHAREDDATA + 1)
 
 /* OpenGL ES11 Statics Counter IDs. */
-#define    VPC_ES11CALLS            (VPG_ES11 +    ES11_CALLS)
-#define    VPC_ES11DRAWCALLS        (VPG_ES11 +    ES11_DRAWCALLS)
-#define    VPC_ES11STATECHANGECALLS (VPG_ES11 +    ES11_STATECHANGECALLS)
-#define    VPC_ES11POINTCOUNT       (VPG_ES11 +    ES11_POINTCOUNT)
-#define    VPC_ES11LINECOUNT        (VPG_ES11 +    ES11_LINECOUNT)
-#define    VPC_ES11TRIANGLECOUNT    (VPG_ES11 +    ES11_TRIANGLECOUNT)
+#define    VPC_ES11CALLS            (VPG(ES11) +    ES11_CALLS)
+#define    VPC_ES11DRAWCALLS        (VPG(ES11) +    ES11_DRAWCALLS)
+#define    VPC_ES11STATECHANGECALLS (VPG(ES11) +    ES11_STATECHANGECALLS)
+#define    VPC_ES11POINTCOUNT       (VPG(ES11) +    ES11_POINTCOUNT)
+#define    VPC_ES11LINECOUNT        (VPG(ES11) +    ES11_LINECOUNT)
+#define    VPC_ES11TRIANGLECOUNT    (VPG(ES11) +    ES11_TRIANGLECOUNT)
 
 /* OpenGL ES30 Statistics Counter IDs. */
-#define    VPC_ES30CALLS            (VPG_ES30 +    ES30_CALLS)
-#define    VPC_ES30DRAWCALLS        (VPG_ES30 +    ES30_DRAWCALLS)
-#define    VPC_ES30STATECHANGECALLS (VPG_ES30 +    ES30_STATECHANGECALLS)
-#define    VPC_ES30POINTCOUNT       (VPG_ES30 +    ES30_POINTCOUNT)
-#define    VPC_ES30LINECOUNT        (VPG_ES30 +    ES30_LINECOUNT)
-#define    VPC_ES30TRIANGLECOUNT    (VPG_ES30 +    ES30_TRIANGLECOUNT)
+#define    VPC_ES30CALLS            (VPG(ES30) +    ES30_CALLS)
+#define    VPC_ES30DRAWCALLS        (VPG(ES30) +    ES30_DRAWCALLS)
+#define    VPC_ES30STATECHANGECALLS (VPG(ES30) +    ES30_STATECHANGECALLS)
+#define    VPC_ES30POINTCOUNT       (VPG(ES30) +    ES30_POINTCOUNT)
+#define    VPC_ES30LINECOUNT        (VPG(ES30) +    ES30_LINECOUNT)
+#define    VPC_ES30TRIANGLECOUNT    (VPG(ES30) +    ES30_TRIANGLECOUNT)
 
 /* OpenVG Statistics Counter IDs. */
-#define    VPC_VG11CALLS            (VPG_VG11 +    VG11_CALLS)
-#define    VPC_VG11DRAWCALLS        (VPG_VG11 +    VG11_DRAWCALLS)
-#define    VPC_VG11STATECHANGECALLS (VPG_VG11 +    VG11_STATECHANGECALLS)
-#define    VPC_VG11FILLCOUNT        (VPG_VG11 +    VG11_FILLCOUNT)
-#define    VPC_VG11STROKECOUNT      (VPG_VG11 +    VG11_STROKECOUNT)
+#define    VPC_VG11CALLS            (VPG(VG11) +    VG11_CALLS)
+#define    VPC_VG11DRAWCALLS        (VPG(VG11) +    VG11_DRAWCALLS)
+#define    VPC_VG11STATECHANGECALLS (VPG(VG11) +    VG11_STATECHANGECALLS)
+#define    VPC_VG11FILLCOUNT        (VPG(VG11) +    VG11_FILLCOUNT)
+#define    VPC_VG11STROKECOUNT      (VPG(VG11) +    VG11_STROKECOUNT)
 
 /* HAL Counters. */
 #define VPC_HALVERTBUFNEWBYTEALLOC      (VPG_HAL + HAL_VERTBUFNEWBYTEALLOC)
@@ -596,27 +605,27 @@ extern "C" {
 #define TOTAL_MODULE_NUMBER              12
 
 /* PROGRAM: Shader program counters. */
-#define VPC_PVSINSTRCOUNT           (VPG_PVS + PVS_INSTRCOUNT)
-#define VPC_PVSALUINSTRCOUNT        (VPG_PVS + PVS_ALUINSTRCOUNT)
-#define VPC_PVSTEXINSTRCOUNT        (VPG_PVS + PVS_TEXINSTRCOUNT)
-#define VPC_PVSATTRIBCOUNT          (VPG_PVS + PVS_ATTRIBCOUNT)
-#define VPC_PVSUNIFORMCOUNT         (VPG_PVS + PVS_UNIFORMCOUNT)
-#define VPC_PVSFUNCTIONCOUNT        (VPG_PVS + PVS_FUNCTIONCOUNT)
-#define VPC_PVSSOURCE               (VPG_PVS + PVS_SOURCE)
-
-#define VPC_PPSINSTRCOUNT           (VPG_PPS + PPS_INSTRCOUNT)
-#define VPC_PPSALUINSTRCOUNT        (VPG_PPS + PPS_ALUINSTRCOUNT)
-#define VPC_PPSTEXINSTRCOUNT        (VPG_PPS + PPS_TEXINSTRCOUNT)
-#define VPC_PPSATTRIBCOUNT          (VPG_PPS + PPS_ATTRIBCOUNT)
-#define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
-#define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
-#define VPC_PPSSOURCE               (VPG_PPS + PPS_SOURCE)
-
-#define VPC_PROGRAMHANDLE           (VPG_PROG + 1)
-
-#define VPC_ES30_DRAW_NO            (VPG_ES30_DRAW + 1)
+#define VPC_PVSINSTRCOUNT           (VPG(PVS) + PVS_INSTRCOUNT)
+#define VPC_PVSALUINSTRCOUNT        (VPG(PVS) + PVS_ALUINSTRCOUNT)
+#define VPC_PVSTEXINSTRCOUNT        (VPG(PVS) + PVS_TEXINSTRCOUNT)
+#define VPC_PVSATTRIBCOUNT          (VPG(PVS) + PVS_ATTRIBCOUNT)
+#define VPC_PVSUNIFORMCOUNT         (VPG(PVS) + PVS_UNIFORMCOUNT)
+#define VPC_PVSFUNCTIONCOUNT        (VPG(PVS) + PVS_FUNCTIONCOUNT)
+#define VPC_PVSSOURCE               (VPG(PVS) + PVS_SOURCE)
+
+#define VPC_PPSINSTRCOUNT           (VPG(PPS) + PPS_INSTRCOUNT)
+#define VPC_PPSALUINSTRCOUNT        (VPG(PPS) + PPS_ALUINSTRCOUNT)
+#define VPC_PPSTEXINSTRCOUNT        (VPG(PPS) + PPS_TEXINSTRCOUNT)
+#define VPC_PPSATTRIBCOUNT          (VPG(PPS) + PPS_ATTRIBCOUNT)
+#define VPC_PPSUNIFORMCOUNT         (VPG(PPS) + PPS_UNIFORMCOUNT)
+#define VPC_PPSFUNCTIONCOUNT        (VPG(PPS) + PPS_FUNCTIONCOUNT)
+#define VPC_PPSSOURCE               (VPG(PPS) + PPS_SOURCE)
+
+#define VPC_PROGRAMHANDLE           (VPG(PROG) + 1)
+
+#define VPC_ES30_DRAW_NO            (VPG(ES30_DRAW) + 1)
 #define VPC_ES11_DRAW_NO            (VPG_ES11_DRAW + 1)
-#define VPC_ES30_GPU_NO             (VPG_MULTI_GPU + 1)
+#define VPC_ES30_GPU_NO             (VPG(MULTI_GPU) + 1)
 
 
 #define   MODULE_FRONT_END_COUNTER_NUM                    0x5
@@ -945,6 +954,8 @@ struct gcsCounterBuffer
     gctPOINTER                  logicalAddress;
     gceCOUNTER_OPTYPE           opType;
     gctUINT32                   opID;
+    gctUINT32                   opCount[4];
+    gctUINT32                   currentShaderId[6];
     gctUINT32                   startPos;
     gctUINT32                   endPos;
     gctUINT32                   dataSize;
@@ -954,6 +965,22 @@ struct gcsCounterBuffer
     gcsCounterBuffer_PTR        prev;
 };
 
+typedef struct _gcoPROBE         gcoPROBE;
+struct _gcoPROBE
+{
+    gctUINT32                   address;
+    gctUINT32                   offset;
+};
+
+typedef struct _gcoMODULE         gcoMODULE;
+struct _gcoMODULE
+{
+    gctUINT32                   name;
+    gctUINT32                   address;
+    gctUINT32                   numProbe;
+    gcoPROBE                    probe[256];
+};
+
 typedef struct _gcoPROFILER *        gcoPROFILER;
 
 struct _gcoPROFILER
@@ -961,11 +988,13 @@ struct _gcoPROFILER
     gctBOOL                     enable;
     gctBOOL                     enablePrint;
     gctBOOL                     disableProbe;
-    gctBOOL                     probeMode;
+
     gctBOOL                     vipProbe;
 
     gctFILE                     file;
     gctCHAR*                    fileName;
+    gceProfilerMode             profilerMode;
+    gceProbeMode                probeMode;
 
     gcsCounterBuffer_PTR        counterBuf;
     gctUINT32                   bufferCount;
@@ -993,12 +1022,21 @@ typedef struct _gcsPROBESTATES
 
 typedef struct _gckPROFILER
 {
-    /* Profile mode */
-    gceProfilerMode             profileMode;
     /* Enable profiling */
     gctBOOL                     profileEnable;
+    /* Profile mode */
+    gceProfilerMode             profileMode;
+    /* Probe mode */
+    gceProbeMode                probeMode;
     /* Clear profile register or not*/
     gctBOOL                     profileCleanRegister;
+    /* Profile counter */
+    gcsPROFILER_COUNTERS_PART1  latestProfiler_part1;
+    gcsPROFILER_COUNTERS_PART1  histroyProfiler_part1;
+    gcsPROFILER_COUNTERS_PART1  preProfiler_part1;
+    gcsPROFILER_COUNTERS_PART2  latestProfiler_part2;
+    gcsPROFILER_COUNTERS_PART2  histroyProfiler_part2;
+    gcsPROFILER_COUNTERS_PART2  preProfiler_part2;
 }gckPROFILER;
 
 /* Construct a Profiler object per context. */
@@ -1053,6 +1091,30 @@ gcoPROFILER_GetProbeNumber(
     OUT gctUINT32 *TotalProbeNumber
     );
 
+gctUINT32 gcoPROFILER_getMuduleNum(
+    IN gcoPROFILER Profiler
+    );
+
+gctUINT32 gcoPROFILER_getMuduleProbeNum(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 index
+    );
+
+gctUINT32 gcoPROFILER_getModuleAddress(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 ModuleIndex
+    );
+
+gctUINT32 gcoPROFILER_getProbeAddress(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 ModuleIndex,
+    IN gctUINT32 ProbeIndex
+    );
+
+gctUINT32 gcoPROFILER_getCounterBufferSize(
+    IN gcoPROFILER Profiler
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/staging/npu/inc/gc_hal_raster.h b/drivers/staging/npu/inc/gc_hal_raster.h
index 5b7cab406bdf..47b4c180ed77 100644
--- a/drivers/staging/npu/inc/gc_hal_raster.h
+++ b/drivers/staging/npu/inc/gc_hal_raster.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -986,6 +986,18 @@ gco2D_SetTargetTileStatus(
     IN gctUINT32 GpuAddress
     );
 
+gceSTATUS
+gco2D_SetSourceCacheMode(
+    IN gco2D Engine,
+    IN gceCACHE_MODE CacheMode
+    );
+
+gceSTATUS
+gco2D_SetTargetCacheMode(
+    IN gco2D Engine,
+    IN gceCACHE_MODE CacheMode
+    );
+
 gceSTATUS
 gco2D_QueryU32(
     IN gco2D Engine,
diff --git a/drivers/staging/npu/inc/gc_hal_security_interface.h b/drivers/staging/npu/inc/gc_hal_security_interface.h
index d1a07bf73491..b9086207d6b2 100644
--- a/drivers/staging/npu/inc/gc_hal_security_interface.h
+++ b/drivers/staging/npu/inc/gc_hal_security_interface.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_statistics.h b/drivers/staging/npu/inc/gc_hal_statistics.h
index 294f4e9d3fd0..cfc1c7a4e26d 100644
--- a/drivers/staging/npu/inc/gc_hal_statistics.h
+++ b/drivers/staging/npu/inc/gc_hal_statistics.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_types.h b/drivers/staging/npu/inc/gc_hal_types.h
index f6c0ceee41c9..0a150c56ab09 100644
--- a/drivers/staging/npu/inc/gc_hal_types.h
+++ b/drivers/staging/npu/inc/gc_hal_types.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_version.h b/drivers/staging/npu/inc/gc_hal_version.h
index d73e5ed4eead..4ff634ed6db1 100644
--- a/drivers/staging/npu/inc/gc_hal_version.h
+++ b/drivers/staging/npu/inc/gc_hal_version.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -18,11 +18,11 @@
 
 #define gcvVERSION_MINOR        4
 
-#define gcvVERSION_PATCH        4
+#define gcvVERSION_PATCH        6
 
-#define gcvVERSION_BUILD     310723
+#define gcvVERSION_BUILD     345497
 
-#define gcvVERSION_STRING    "6.4.4.3.310723AAA"
+#define gcvVERSION_STRING    "6.4.6.2.5.3.2"
 
 #endif /* __gc_hal_version_h_ */
 
diff --git a/drivers/staging/npu/inc/gc_hal_vg.h b/drivers/staging/npu/inc/gc_hal_vg.h
index 2f1674608541..53de6ceb8ede 100644
--- a/drivers/staging/npu/inc/gc_hal_vg.h
+++ b/drivers/staging/npu/inc/gc_hal_vg.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/gc_hal_vx.h b/drivers/staging/npu/inc/gc_hal_vx.h
index 109a213841e1..d1f3a8f6be66 100644
--- a/drivers/staging/npu/inc/gc_hal_vx.h
+++ b/drivers/staging/npu/inc/gc_hal_vx.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -225,6 +225,7 @@ gcoVX_ProgrammCrossEngine(
     IN gctPOINTER                Data,
     IN gceVX_ACCELERATOR_TYPE    Type,
     IN gctPOINTER                Options,
+    IN gctUINT32                 cmdType,
     IN OUT gctUINT32_PTR        *Instruction
     );
 
@@ -340,6 +341,25 @@ gcoVX_CaptureState(
     IN gctBOOL dropCommandEnabled
     );
 
+#if gcdUSE_CAPBUF
+gceSTATUS gcoVX_StartCAPBUF();
+gceSTATUS gcoVX_EndCAPBUF();
+
+gceSTATUS
+gcoVX_QueryCAPBUFMetaData(
+    IN gceCAPBUF_META_TYPE Type,
+    IN gctBOOL WithPattern,
+    IN gctUINT32 Pattern,
+    OUT gctUINT32_PTR Count,
+    OUT gctUINT32_PTR *Data
+    );
+
+gceSTATUS
+gcoVX_FreeCAPBUFMetaQueryBuffer(
+    IN gctUINT32_PTR Data
+    );
+#endif
+
 gceSTATUS
 gcoVX_SetRemapAddress(
     IN gctUINT32 remapStart,
@@ -380,6 +400,10 @@ gceSTATUS gcoVX_QueryNNClusters(
     OUT gctUINT32 *Clusters
     );
 
+gceSTATUS gcoVX_QueryNNRingCount(
+    OUT gctUINT32 *RingCount
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/staging/npu/inc/gc_vsc_precomp.h b/drivers/staging/npu/inc/gc_vsc_precomp.h
index 39b5aa376ea2..48ee415e2aba 100644
--- a/drivers/staging/npu/inc/gc_vsc_precomp.h
+++ b/drivers/staging/npu/inc/gc_vsc_precomp.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/old_impl/gc_vsc_old_drvi_interface.h b/drivers/staging/npu/inc/old_impl/gc_vsc_old_drvi_interface.h
index c960c3f10dad..026a0e6e425c 100644
--- a/drivers/staging/npu/inc/old_impl/gc_vsc_old_drvi_interface.h
+++ b/drivers/staging/npu/inc/old_impl/gc_vsc_old_drvi_interface.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -49,7 +49,8 @@ BEGIN_EXTERN_C()
 
 /* For OES. */
 #define _sldSharedVariableStorageBlockName  "#sh_sharedVar"
-#define _sldWorkGroupIdName                 "#sh_workgroupId"
+#define _sldWorkGroupIndex                  "#sh_workGroupIndex"
+#define _sldModWorkGroupIdName              "#sh_modWorkgroupId"
 #define __INIT_VALUE_FOR_WORK_GROUP_INDEX__ 0x1234
 
 /* For OCL. */
@@ -655,6 +656,14 @@ typedef struct _gcWORK_GROUP_SIZE
     gctUINT       z;
 }gcWORK_GROUP_SIZE;
 
+/* The same definition of VIR_LocalIdWKind. */
+typedef enum _gceLOCAL_ID_W_KIND
+{
+    gcvLOCAL_ID_W_DISABLE               = 0x0000,
+    gcvLOCAL_ID_W_LOCAL_STORAGE_BASE    = 0x0001,
+    gcvLOCAL_ID_W_RUNNING_WORK_GROUP_ID = 0x0002,
+} gceLOCAL_ID_W_KIND;
+
 typedef struct _gcsHINT
 {
     /* fields for the program */
@@ -855,6 +864,8 @@ typedef struct _gcsHINT
     /* Concurrent workGroupCount. */
     gctUINT16   workGroupCount;
 
+    gceLOCAL_ID_W_KIND localIdWKind;
+
     /* Sampler Base offset. */
     gctBOOL     useGPRSpill[gcvPROGRAM_STAGE_LAST];
 
@@ -862,7 +873,7 @@ typedef struct _gcsHINT
     gctINT32    GSmaxThreadsPerHwTG;
     gctUINT     tpgTopology;
     /* padding bytes to make the offset of shaderVidNodes field be consistent in 32bit and 64bit platforms */
-    gctCHAR     reservedByteForShaderVidNodeOffset[8];
+    gctCHAR     reservedByteForShaderVidNodeOffset[4];
 
     /* shaderVidNodes should always be the LAST filed in hits. */
     /* SURF Node for memory that is used in shader. */
@@ -1085,9 +1096,16 @@ typedef enum _gceSHADER_FLAGS
 }
 gceSHADER_FLAGS;
 
+typedef enum _gceSHADER_EXT_FLAGS
+{
+    gcvSHADER_EXTFLAG_NONE                  = 0x00000000,
+    gcvSHADER_EXTFLAG_ALWAYS_EMIT_OUTPUT    = 0x00000001,
+} gceSHADER_EXT_FLAGS;
+
 typedef struct _gceSHADER_SUB_FLAGS
 {
-    gctUINT     dual16PrecisionRule;
+    gctUINT                                 dual16PrecisionRule;
+    gceSHADER_EXT_FLAGS                     extFlags;
 }
 gceSHADER_SUB_FLAGS;
 
@@ -1231,6 +1249,9 @@ typedef enum _Dual16_PrecisionRule
     thus require output to be highp */
     Dual16_PrecisionRule_OUTPUT_HP              = 1 << 5,
 
+    /* enable hp MAD for dual16*/
+    Dual16_PrecisionRule_MAD_HP                 = 1 << 6,
+
     /*  default rules */
     Dual16_PrecisionRule_DEFAULT                = Dual16_PrecisionRule_TEXLD_COORD_HP |
                                                   Dual16_PrecisionRule_RCP_HP         |
@@ -1606,6 +1627,22 @@ typedef struct _gcOPTIMIZER_OPTION
      */
     gctBOOL     oclPackedBasicType;
 
+    /*
+     * Handle OCL half type as packed
+     *
+     *   VC_OPTION=-OCLPACKEDHALFTYPE:0|1
+     *
+     */
+    gctBOOL     oclPackedHalfType;
+
+    /*
+     * Handle OCL short type as packed
+     *
+     *   VC_OPTION=-OCLPACKEDSHORTTYPE:0|1
+     *
+     */
+    gctBOOL     oclPackedShortType;
+
     /*
      * Handle OCL  relaxing local address space in OCV
      *
@@ -1731,6 +1768,12 @@ typedef struct _gcOPTIMIZER_OPTION
     /* Close all optimization fro OCL debugger */
     gctBOOL     disableOptForDebugger;
 
+    /* use intrinsic instruction for OCL built-in functions */
+    gctBOOL     useIntrinsicInstForOclBuiltinFunc;
+
+    /* Since we don't want to change the interface to add a extra flag, we add here. */
+    gceSHADER_EXT_FLAGS     extFlags;
+
     /* NOTE: when you add a new option, you MUST initialize it with default
        value in theOptimizerOption too */
 } gcOPTIMIZER_OPTION;
@@ -1740,11 +1783,13 @@ typedef struct _gcOPTIMIZER_OPTION
    DUAL16_AUTO_ALL:   turn on dual16 for all
    DUAL16_FORCE_ON:   we have heuristic to turn off dual16 if the single-t instructions are too many,
                       this option will ignore the heuristic
+   DUAL16_FORCE_HP_TO_MP: force dual16 on and change all the hp to mp to generate more dual-t instructions
 */
 #define DUAL16_FORCE_OFF            0
 #define DUAL16_AUTO_BENCH           1
 #define DUAL16_AUTO_ALL             2
 #define DUAL16_FORCE_ON             3
+#define DUAL16_FORCE_HP_TO_MP       4
 
 #define VC_OPTION_OCLFPCAPS_FASTRELAXEDMATH     (1 << 0 )
 #define VC_OPTION_OCLFPCAPS_FINITEMATHONLY      (1 << 1 )
@@ -1815,15 +1860,23 @@ extern gcOPTIMIZER_OPTION theOptimizerOption;
 #define gcmOPT_DisableOPTforDebugger()     (gcmGetOptimizerOption()->disableOptForDebugger)
 #define gcmOPT_SetDisableOPTforDebugger(b) (gcmGetOptimizerOption()->disableOptForDebugger = b)
 
+#define gcmOPT_UseIntrinsicInstForOclBuiltinFunc()     (gcmGetOptimizerOption()->useIntrinsicInstForOclBuiltinFunc)
+#define gcmOPT_SetUseIntrinsicInstForOclBuiltinFunc(b) (gcmGetOptimizerOption()->useIntrinsicInstForOclBuiltinFunc = b)
+
 #define gcmOPT_TESSLEVEL()          (gcmGetOptimizerOption()->testTessLevel)
 
 #define gcmOPT_DualFP16PrecisionRule()          (gcmGetOptimizerOption()->dual16PrecisionRule)
 #define gcmOPT_DualFP16PrecisionRuleFromEnv()   (gcmGetOptimizerOption()->dual16PrecisionRuleFromEnv)
 
+#define gcmOPT_GetExtFlags()        (gcmGetOptimizerOption()->extFlags)
+#define gcmOPT_SetExtFlags(b)       (gcmGetOptimizerOption()->extFlags = b)
+
 #define gcmOPT_ForceInline()        (gcmGetOptimizerOption()->forceInline)
 #define gcmOPT_UploadUBO()          (gcmGetOptimizerOption()->uploadUBO)
 #define gcmOPT_oclFpCaps()          (gcmGetOptimizerOption()->oclFpCaps)
 #define gcmOPT_oclPackedBasicType() (gcmGetOptimizerOption()->oclPackedBasicType)
+#define gcmOPT_oclPackedHalfType()  (gcmGetOptimizerOption()->oclPackedHalfType)
+#define gcmOPT_oclPackedShortType() (gcmGetOptimizerOption()->oclPackedShortType)
 #define gcmOPT_oclOcvLocalAddressSpace() (gcmGetOptimizerOption()->oclOcvLocalAddressSpace)
 #define gcmOPT_oclOpenCV()          (gcmGetOptimizerOption()->oclOpenCV)
 #define gcmOPT_oclHasLong()         (gcmGetOptimizerOption()->oclHasLong)
@@ -2104,27 +2157,45 @@ extern gcePATCH_ID *
 #define GetPatchID()                          (gcGetPatchId())
 
 /* HW caps.*/
+typedef enum _gcHW_KIND {
+    gcHW_KIND_GPU       = 0,
+    gcHW_KIND_VIP       = 1,
+    gcHW_KIND_COUNT     = 2,
+} gcHW_KIND;
+
 typedef struct _VSC_HW_CONFIG gcsHWCaps;
-extern gcsHWCaps gcHWCaps;
+
 extern gcsHWCaps *
     gcGetHWCaps(
     void
     );
 
+void
+gcSetHWCaps(
+  gcsHWCaps* hwCaps,
+  gcHW_KIND currentHwKind
+);
+
 /* Get HW features. */
 #define GetHWHasHalti0()                      (gcGetHWCaps()->hwFeatureFlags.hasHalti0)
 #define GetHWHasHalti1()                      (gcGetHWCaps()->hwFeatureFlags.hasHalti1)
 #define GetHWHasHalti2()                      (gcGetHWCaps()->hwFeatureFlags.hasHalti2)
 #define GetHWHasHalti5()                      (gcGetHWCaps()->hwFeatureFlags.hasHalti5)
 #define GetHWHasAdvancedInst()                (gcGetHWCaps()->hwFeatureFlags.supportAdvancedInsts)
-#define GetHWHasFmaSupport()                  (GetHWHasHalti5() && GetHWHasAdvancedInst())
-#define GetHWHasLoadStoreConv4RoundingMode()  gcvFALSE
-#define GetHWHasFullPackedModeSupport()       gcvFALSE
+#define GetHWHasOldFmaSupport()               (GetHWHasHalti5() && GetHWHasAdvancedInst())
+#define GetHWHasNewFmaSupport()               (gcGetHWCaps()->hwFeatureFlags.supportFP32FMA)
+#define GetHWHasFmaSupport()                  (GetHWHasNewFmaSupport() || GetHWHasOldFmaSupport())
+#define GetHWHasLoadStoreConv4RoundingMode()  (gcGetHWCaps()->hwFeatureFlags.ldstConv4RoundingMode)
+#define GetHWHasFullPackedModeSupport()       (gcGetHWCaps()->hwFeatureFlags.fullPackModeSupport)
 #define GetHWHasTS()                          (gcGetHWCaps()->hwFeatureFlags.supportTS)
 #define GetHWHasGS()                          (gcGetHWCaps()->hwFeatureFlags.supportGS)
 #define GetHWHasSamplerBaseOffset()           (gcGetHWCaps()->hwFeatureFlags.hasSamplerBaseOffset)
+#define GetHWHasUniversalTexldV1()            (gcGetHWCaps()->hwFeatureFlags.hasUniversalTexld)
 #define GetHWHasUniversalTexldV2()            (gcGetHWCaps()->hwFeatureFlags.hasUniversalTexldV2)
 #define GetHWHasTexldUFix()                   (gcGetHWCaps()->hwFeatureFlags.hasTexldUFix)
+#define GetHWSupportTexldUV1()                (GetHWHasUniversalTexldV1())
+#define GetHWSupportTexldUV2()                (GetHWHasUniversalTexldV2() && GetHWHasTexldUFix())
+#define GetHWSupportTexldU()                  (GetHWSupportTexldUV1() && GetHWSupportTexldUV2())
 #define GetHWHasImageOutBoundaryFix()         (gcGetHWCaps()->hwFeatureFlags.hasImageOutBoundaryFix)
 
 /* Get HW caps. */
@@ -2490,6 +2561,21 @@ gcSHADER_GetShaderID(
     IN gctUINT32 * ID
     );
 
+/*******************************************************************************
+**  gcSHADER_GetShaderVersion
+**
+**  Get the gc shader version.
+**
+**  OUTPUT:
+**
+**      gctUINT32 * shaderVersion
+**          The shader version of gcshader.
+*/
+gceSTATUS
+gcSHADER_GetShaderVersion(
+    OUT gctUINT32 * shaderVersion
+    );
+
 /*******************************************************************************
 **  gcSHADER_SetDisableEZ
 **
@@ -5411,6 +5497,29 @@ gcSHADER_UpdateTargetPacked(
     IN gctINT Components
     );
 
+/*****************************************************************************************************
+**  gcSHADER_UpdateTargetRegMemorySameFormat
+**
+**  Update instruction target's regMemorySameFormat field to indicate target and memory data of same format
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctUINT8  RegMemorySameFormat
+**          Flag to indicate if reg and memory reference is of same format
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_UpdateTargetRegMemorySameFormat(
+    IN gcSHADER Shader,
+    IN gctUINT8 RegMemorySameFormat
+    );
+
 /*******************************************************************************
 **  gcSHADER_UpdateSourcePacked
 **
@@ -7421,7 +7530,8 @@ gcKERNEL_FUNCTION_AddArgument(
     IN gctUINT16 VariableIndex,
     IN gctUINT32 TempIndex,
     IN gctUINT8 Enable,
-    IN gctUINT8 Qualifier
+    IN gctUINT8 Qualifier,
+    IN gctUINT16 TypeQualifier
     );
 
 gceSTATUS
diff --git a/drivers/staging/npu/inc/old_impl/gc_vsc_old_gcsl.h b/drivers/staging/npu/inc/old_impl/gc_vsc_old_gcsl.h
index b469e07eb8cd..98e1e578c28e 100644
--- a/drivers/staging/npu/inc/old_impl/gc_vsc_old_gcsl.h
+++ b/drivers/staging/npu/inc/old_impl/gc_vsc_old_gcsl.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -150,9 +150,41 @@ BEGIN_EXTERN_C()
 /* bump up version to 1.55 for saving shaderKind and swizzle of uniform to gcSHADER on 09/09/2020 */
 /* bump up version to 1.56 for refine save and load inputLocation and outputLocation in gcSHADER on 09/22/2020 */
 
-/* current version */
-#define gcdSL_SHADER_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 57)
-#define gcdSL_PROGRAM_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 57)
+/* bump up version to 1.57 for saving ocl packed types to gcSHADER on 10/13/2020 */
+#define gcdSL_SHADER_BINARY_BEFORE_SAVEING_OCL_PACKED_TYPE gcmCC(0, 0, 1, 57)
+/* bump up version to 1.58 for saving and loading attribute inputIndex gcSHADER on 10/27/2020 */
+/* bump up version to 1.59 for saving and loading isDual16Shader in gcSHADER binary on 11/04/2020 */
+/* bump up version to 1.60 for adding some information for saving and loading gcSHADER binary on 10/28/2020 */
+/* bump up version to 1.61 for OCL target target and memory data are of same format gcSHADER binary on 11/23/2020 */
+/* bump up version to 1.63 for saving and loading uniforms in uniform block on 12/04/2020 */
+/* bump up version to 1.64 for the type qualifier into the function argument on 03/08/2021 */
+
+
+/* current shader binary version */
+#define gcdSL_SHADER_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 64)
+#define gcdSL_PROGRAM_BINARY_FILE_VERSION gcmCC(SHADER_64BITMODE, 0, 1, 64)
+
+/*********************** SHADER BINARY FILE SUB VERSION *********************/
+#define gcdSL_SHADER_BINARY_SUB_VERSION gcmCC(SHADER_64BITMODE, 0, 0, 0)
+
+/******************** SHADER LIBRARY BINARY FILE VERSION *********************/
+/* Current gcshader CL/VX library version*/
+/* 0.0.0.0 Start to set gcshader cl/vx library version, 12/23/2020 */
+/* Upped version to 1 for fixing precision of _viv_vstore_half*_rtz, 1/7/2021 */
+/* Upped version to 2 for handling NAN inputs for viv_vstore_half*_rtz(), 1/12/2021 */
+/* Upped version to 3 for handling denorms inputs for viv_vstore_half*_rtn(), 1/18/2021 */
+/* Upped version to 4 for implementing sinh and exp, exp10 ..., 2/22/2021 */
+/* Upped version to 5 for implementing cosh 2/23/2021 */
+/* Upped version to 6 for implementing tanh 2/24/2021 */
+/* Upped version to 7 for implementing acosh 3/5/2021 */
+/* Upped version to 8 for implementing atanh 3/6/2021 */
+/* Upped version to 9 for implementing log, log2, log10 3/15/2021 */
+/* Upped version to 10 for implementing log1p 3/17/2021 */
+#define gcdSL_SHADER_CL_LIBRARY_FILE_VERSION  gcmCC(SHADER_64BITMODE, 0, 0, 10)
+
+/* Current gcshader graphic library version*/
+/* 0.0.0.0 Start to set gcshader library version, 12/23/2020 */
+#define gcdSL_SHADER_GRAPHICS_LIBRARY_FILE_VERSION  gcmCC(SHADER_64BITMODE, 0, 0, 0)
 
 typedef union _gcsValue
 {
@@ -251,6 +283,7 @@ gceFRAGOUT_USAGE;
 
 #define gcShader_IsCL(S)           (GetShaderType(S) == gcSHADER_TYPE_CL && (((S)->compilerVersion[0] & 0xFFFF) == _cldLanguageType))
 #define gcShader_IsGlCompute(S)    (GetShaderType(S) == gcSHADER_TYPE_COMPUTE && (((S)->compilerVersion[0] & 0xFFFF) != _cldLanguageType))
+#define gcShader_IsLibrary(S)      (GetShaderType(S) == gcSHADER_TYPE_LIBRARY)
 
 /* Client version. */
 typedef enum _gcSL_OPCODE
@@ -403,8 +436,8 @@ typedef enum _gcSL_OPCODE
     gcSL_GET_SAMPLER_LBS, /* 0x8E Get sampler's levelbasesize */
     gcSL_TEXLD_U, /* 0x8F For TEXLD_U, use the format of coord to select FLOAT/INT/UNSIGINED. */
     gcSL_PARAM_CHAIN, /* 0x90 No specific semantic, only used to chain two sources to one dest. */
-    gcSL_INTRINSIC, /* 0x91 Instrinsic dest, IntrinsicId, Param */
-    gcSL_INTRINSIC_ST, /* 0x92 Instrinsic dest, IntrinsicId, Param; Param is stored implicitly */
+    gcSL_INTRINSIC, /* 0x91 Intrinsic dest, IntrinsicId, Param */
+    gcSL_INTRINSIC_ST, /* 0x92 Intrinsic dest, IntrinsicId, Param; Param is stored implicitly */
     gcSL_CMAD, /* 0x93 Complex number mad. */
     gcSL_CONJ, /* 0x94 Conjugate modifier. */
     gcSL_CMUL, /* 0x95 Complex number mul. */
@@ -1049,6 +1082,17 @@ typedef enum _gcSHADER_TYPE
     gcSHADER_USAMPLER_1D, /* 0xCC */
     gcSHADER_SAMPLER_1D_SHADOW, /* 0xCD */
 
+    /* FP16 matrix. */
+    gcSHADER_FLOAT16_2X2, /* 0xCE */
+    gcSHADER_FLOAT16_2X3, /* 0xCF */
+    gcSHADER_FLOAT16_2X4, /* 0xD0 */
+    gcSHADER_FLOAT16_3X2, /* 0xD1 */
+    gcSHADER_FLOAT16_3X3, /* 0xD2 */
+    gcSHADER_FLOAT16_3X4, /* 0xD3 */
+    gcSHADER_FLOAT16_4X2, /* 0xD4 */
+    gcSHADER_FLOAT16_4X3, /* 0xD5 */
+    gcSHADER_FLOAT16_4X4, /* 0xD6 */
+
     gcSHADER_UNKONWN_TYPE, /* do not add type after this */
     gcSHADER_TYPE_COUNT         /* must to change gcvShaderTypeInfo at the
                                  * same time if you add any new type! */
@@ -1615,6 +1659,8 @@ typedef enum _gceBuiltinNameKind
 /* non-zero field to indicate the number of components in target being packed; width of six bits
  allows number of components to 32. */
 #define gcdSL_TARGET_PackedComponents          19 : 6
+/* target and memory data are of same format */
+#define gcdSL_TARGET_RegMemorySameFormat       25 : 1
 typedef gctUINT32 gctTARGET_t;
 
 #define gcmSL_TARGET_GET(Value, Field) \
@@ -2107,6 +2153,9 @@ typedef struct _gcBINARY_ATTRIBUTE
     /* IO block array index. */
     gctINT16                      ioBlockArrayIndex;
 
+    /* Field index. */
+    gctINT16                      fieldIndex;
+
     /* Only used for a IO block member, point to the next element in block. */
     gctINT16                      nextSibling;
 
@@ -2119,6 +2168,15 @@ typedef struct _gcBINARY_ATTRIBUTE
     /* shader mode: flat/smooth/... */
     gctINT16                      shaderMode;
 
+    /* If other attributes packed to this attribute, we need to change the shade mode for each components. */
+    gctINT16                      componentShadeMode[4];
+
+    /* Assigned input register index. */
+    gctINT16                      inputIndex;
+
+    /* Location index. */
+    gctINT                        location;
+
     /* The attribute name. */
     char                          name[1];
 }
@@ -2447,20 +2505,23 @@ typedef struct _gcBINARY_UNIFORM_BLOCK
     /* points to the previous array element for block, if any */
     gctINT16                        prevSibling;
 
-    /* Index of the uniform to keep the base address. */
+    /* Index of the uniform block. */
     gctINT16                        index;
 
-    /* Index of the uniform to keep the base address. */
+    /* Array Index of the uniform block. */
     gctINT16                        arrayIndex;
 
     /* Length of the uniform block name. */
     gctINT16                        nameLength;
 
+    /* Number of uniforms in block */
+    gctINT16                        uniformCount;
+
     /* binding point */
     char                            binding[sizeof(gctINT32)];
 
-    /* The uniform block name. */
-    char                            name[1];
+    /* The uniformIndexList and name. */
+    char                            memory[1];
 }
 *gcBINARY_UNIFORM_BLOCK;
 
@@ -2695,8 +2756,8 @@ struct _gcUNIFORM
 
     union
     {
-        /* Data type for this most-inner variable. */
-        gcSHADER_TYPE               type;
+        /* Data type for this most-inner variable. use gctUINT16 to replace gcSHADER_TYPE*/
+        gctUINT16                   type;
 
         /* Number of element in structure if arraySize of this */
         /* struct is 1, otherwise, set it to 0 */
@@ -2770,6 +2831,9 @@ struct _gcUNIFORM
     /* image format */
     gctINT16                        imageFormat;
 
+    /* the uniform data type of save nbg */
+    gctUINT32                       uniformSaveDataType;
+
     gcUNIFORM                       followingAddr;
     gctUINT32                       followingOffset;            /* or sampler_t constant value */
 
@@ -2869,6 +2933,9 @@ typedef struct _gcBINARY_UNIFORM
     }
     u;
 
+    /* Index of the uniform. */
+    gctUINT16                       index;
+
     /* Number of array elements for this uniform. */
     gctINT16                        arraySize;
 
@@ -2880,15 +2947,33 @@ typedef struct _gcBINARY_UNIFORM
     /* uniform flags */
     char                            flags[sizeof(gceUNIFORM_FLAGS)];
 
+    /* Format of element of the uniform shaderType. */
+    gctUINT16                       format;
+
+    /* Wheter the uniform is a pointer. */
+    gctINT16                        isPointer;
+
+    gctTYPE_QUALIFIER               qualifier;
+
     /* Physically assigned values. */
     gctUINT8                        swizzle;
 
     /* Shader type for this uniform. Set this at the end of link. */
     gcSHADER_KIND                   shaderKind;
 
+    /* companion to format field to denote vector size,
+       value of 0 denote the underlying type is scalar */
+    gctINT16                        vectorSize;
+
+    /* offset to typeNameBuffer in gcSHADER at which the name of derived type reside */
+    gctCHAR                         typeNameOffset[sizeof(gctINT)];
+
     /* Corresponding Index of Program's GLUniform */
     gctINT16                        glUniformIndex;
 
+    /* Index to corresponding image sampler */
+    gctUINT16                       imageSamplerIndex;
+
     /* Variable category */
     gctINT16                        varCategory;
 
@@ -3293,6 +3378,8 @@ typedef struct _gcBINARY_OUTPUT
     /* Temporary register index that holds the output value. */
     gctUINT32                       tempIndex;
 
+    gctINT32                        output2RTIndex;
+
     gctUINT16                       flags1;
 
     gctUINT16                       flags2;
@@ -3309,6 +3396,9 @@ typedef struct _gcBINARY_OUTPUT
     /* IO block array index. */
     gctINT16                        ioBlockArrayIndex;
 
+    /* Field Index. */
+    gctINT16                        fieldIndex;
+
     /* Only used for a IO block member, point to the next element in block. */
     gctINT16                        nextSibling;
 
@@ -3393,8 +3483,8 @@ struct _gcVARIABLE
 
     union
     {
-        /* Data type for this most-inner variable. */
-        gcSHADER_TYPE               type;
+        /* Data type for this most-inner variable. use gctUINT16 to store gcSHADER_TYPE */
+        gctUINT16                   type;
 
         /* Number of element in structure if arraySize of this */
         /* struct is 1, otherwise, set it to 0 */
@@ -3547,7 +3637,7 @@ typedef struct _gcBINARY_VARIABLE
            definition in struct _gcVARIABLE. This is a potential
            problem - KLC
         */
-    gctINT16                         arraySize;
+    gctINT16                        arraySize;
 
     gctUINT16                       arrayLengthCount;
 
@@ -3590,6 +3680,14 @@ typedef struct _gcBINARY_VARIABLE
     /* Storage block index: Default block index = -1 */
     gctINT16                        blockIndex;
 
+    char                            matrixStride[sizeof(gctINT16)];
+
+    /* stride on array. For scalar, it represents its size in bytes */
+    char                            arrayStride[sizeof(gctINT32)];
+
+    /* offset from constant memory base address */
+    char                            offset[sizeof(gctINT32)];
+
     /* The variable arrayLengthList and name. */
     char                            memory[1];
 }
@@ -3614,7 +3712,7 @@ typedef struct _gcBINARY_VARIABLE_EX
            definition in struct _gcVARIABLE. This is a potential
            problem - KLC
         */
-    gctINT16                         arraySize;
+    gctINT16                        arraySize;
 
     gctUINT16                       arrayLengthCount;
 
@@ -3680,6 +3778,8 @@ typedef struct _gcsFUNCTION_ARGUMENT
     gctUINT32                       index;
     gctUINT8                        enable;
     gctUINT8                        qualifier;
+    /* For some reason we don't create a variable for each argument, so we need to store the typeQualifier here. */
+    gctUINT16                       typeQualifier;
     gctUINT8                        precision;
     gctUINT16                       variableIndex;
     gctUINT8                        flags;
@@ -3697,9 +3797,10 @@ typedef struct _gcBINARY_ARGUMENT
     gctUINT32                       index;
     gctUINT8                        enable;
     gctUINT8                        qualifier;
+    gctUINT16                       typeQualifier;
     gctUINT8                        precision;
-    gctUINT8                        flags;
     gctUINT16                       variableIndex;
+    gctUINT8                        flags;
 }
 * gcBINARY_ARGUMENT;
 
@@ -4296,6 +4397,7 @@ typedef enum _gcSHADER_FLAGS
     gcSHADER_FLAG_USE_LOCAL_MEM             = 0x8000, /* the shader use local memory */
     gcSHADER_FLAG_VP_TWO_SIDE_ENABLE        = 0x10000, /* the shader use two side, for GL fragment shader only. */
     gcSHADER_FLAG_CLAMP_OUTPUT_COLOR        = 0x20000, /* Clamp the output color, for GL shader only. */
+    gcSHADER_FLAG_HAS_CL_FLOAT16            = 0x20000, /* Has half operations, for CL shader only. This bit is shared with CLAMP_OUTPUT_COLOR which should be mutually exclusive */
     gcSHADER_FLAG_HAS_INT64_PATCH           = 0x40000, /* the shader has 64 bit integer data and operation patch (recompile). */
     gcSHADER_FLAG_AFTER_LINK                = 0x80000, /* the shader is linked(gcLinkProgram/gcLinkShaders/gcLinkKernel). */
     gcSHADER_FLAG_LOADED_KERNEL             = 0x100000, /* shader has loaded a specified kernel function, for OCL shader only. */
@@ -4308,6 +4410,8 @@ typedef enum _gcSHADER_FLAGS
     gcSHADER_FLAG_COMPATIBILITY_PROFILE     = 0x8000000, /* the shader version is compatibility profile for OGL.*/
     gcSHADER_FLAG_USE_CONST_REG_FOR_UBO     = 0x10000000, /* Use constant register to save the UBO.*/
     gcSHADER_FLAG_HAS_CL_KHR_FP16_EXTENSION = 0x20000000, /* the shader has OCL extension cl-khr-fp16 enabled */
+    gcSHADER_FLAG_HAS_OCL_PACKED_TYPE       = 0x40000000, /* the shader has OCL packed type */
+    gcSHADER_FLAG_DENORM_FLUSH_TO_ZERO      = 0x80000000, /* denorm needs to be flushed to zero */
 } gcSHADER_FLAGS;
 
 #define gcShaderIsOldHeader(Shader)             (((Shader)->flags & gcSHADER_FLAG_OLDHEADER) != 0)
@@ -4322,12 +4426,14 @@ typedef enum _gcSHADER_FLAGS
 #define gcShaderNeedPatchForCentroid(Shader)    (((Shader)->flags & gcSHADER_FLAG_NEED_PATCH_FOR_CENTROID) != 0)
 #define gcShaderHasBaseMemoryAddr(Shader)       (((Shader)->flags & gcSHADER_FLAG_HAS_BASE_MEMORY_ADDR) != 0)
 #define gcShaderHasLocalMemoryAddr(Shader)      (((Shader)->flags & gcSHADER_FLAG_HAS_LOCAL_MEMORY_ADDR) != 0)
+#define gcShaderHasClFloat16(Shader)            (((Shader)->flags & gcSHADER_FLAG_HAS_CL_FLOAT16) != 0)
 #define gcShaderHasInt64(Shader)                (((Shader)->flags & gcSHADER_FLAG_HAS_INT64) != 0)
 #define gcShaderHasInt64Patch(Shader)           (((Shader)->flags & gcSHADER_FLAG_HAS_INT64_PATCH) != 0)
 #define gcShaderHasImageQuery(Shader)           (((Shader)->flags & gcSHADER_FLAG_HAS_IMAGE_QUERY) != 0)
 #define gcShaderHasVivVxExtension(Shader)       (((Shader)->flags & gcSHADER_FLAG_HAS_VIV_VX_EXTENSION) != 0)
 #define gcShaderHasVivGcslDriverImage(Shader)   (((Shader)->flags & gcSHADER_FLAG_HAS_VIV_GCSL_DRIVER_IMAGE) != 0)
 #define gcShaderHasClKhrFp16Extension(Shader)   (((Shader)->flags & gcSHADER_FLAG_HAS_CL_KHR_FP16_EXTENSION) != 0)
+#define gcShaderHasOclPackedType(Shader)        (((Shader)->flags & gcSHADER_FLAG_HAS_OCL_PACKED_TYPE) != 0)
 #define gcShaderUseLocalMem(Shader)             (((Shader)->flags & gcSHADER_FLAG_USE_LOCAL_MEM) != 0)
 #define gcShaderVPTwoSideEnable(Shader)         (((Shader)->flags & gcSHADER_FLAG_VP_TWO_SIDE_ENABLE) != 0)
 #define gcShaderClampOutputColor(Shader)        (((Shader)->flags & gcSHADER_FLAG_CLAMP_OUTPUT_COLOR) != 0)
@@ -4340,6 +4446,7 @@ typedef enum _gcSHADER_FLAGS
 #define gcShaderEnableOfflineCompiler(Shader)   (((Shader)->flags & gcSHADER_FLAG_GENERATED_OFFLINE_COMPILER) != 0)
 #define gcShaderIsCompatibilityProfile(Shader)  (((Shader)->flags & gcSHADER_FLAG_COMPATIBILITY_PROFILE) != 0)
 #define gcShaderUseConstRegForUBO(Shader)       (((Shader)->flags & gcSHADER_FLAG_USE_CONST_REG_FOR_UBO) != 0)
+#define gcShaderDenormFlushToZero(Shader)       (((Shader)->flags & gcSHADER_FLAG_DENORM_FLUSH_TO_ZERO) != 0)
 
 #define gcShaderGetFlag(Shader)                 (Shader)->flags)
 
@@ -4361,6 +4468,8 @@ typedef enum _gcSHADER_FLAGS
 #define gcShaderClrHasBaseMemoryAddr(Shader)    do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_BASE_MEMORY_ADDR; } while (0)
 #define gcShaderSetHasLocalMemoryAddr(Shader)   do { (Shader)->flags |= gcSHADER_FLAG_HAS_LOCAL_MEMORY_ADDR; } while (0)
 #define gcShaderClrHasLocalMemoryAddr(Shader)   do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_LOCAL_MEMORY_ADDR; } while (0)
+#define gcShaderSetHasClFloat16(Shader)         do { (Shader)->flags |= gcSHADER_FLAG_HAS_CL_FLOAT16; } while (0)
+#define gcShaderClrHasClFloat16(Shader)         do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_CL_FLOAT16; } while (0)
 #define gcShaderSetHasInt64(Shader)             do { (Shader)->flags |= gcSHADER_FLAG_HAS_INT64; } while (0)
 #define gcShaderClrHasInt64(Shader)             do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_INT64; } while (0)
 #define gcShaderSetHasInt64Patch(Shader)        do { (Shader)->flags |= gcSHADER_FLAG_HAS_INT64_PATCH; } while (0)
@@ -4373,6 +4482,10 @@ typedef enum _gcSHADER_FLAGS
 #define gcShaderClrHasVivGcslDriverImage(Shader)    do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_VIV_GCSL_DRIVER_IMAGE; } while (0)
 #define gcShaderSetHasClKhrFp16Extension(Shader)    do { (Shader)->flags |= gcSHADER_FLAG_HAS_CL_KHR_FP16_EXTENSION; } while (0)
 #define gcShaderClrHasClKhrFp16Extension(Shader)    do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_CL_KHR_FP16_EXTENSION; } while (0)
+#define gcShaderSetHasOclPackedType(Shader)     do { (Shader)->flags |= gcSHADER_FLAG_HAS_OCL_PACKED_TYPE; } while (0)
+#define gcShaderClrHasOclPackedType(Shader)     do { (Shader)->flags &= ~gcSHADER_FLAG_HAS_OCL_PACKED_TYPE; } while (0)
+#define gcShaderSetUseLocalMem(Shader)          do { (Shader)->flags |= gcSHADER_FLAG_USE_LOCAL_MEM; } while (0)
+#define gcShaderClrUseLocalMem(Shader)          do { (Shader)->flags &= ~gcSHADER_FLAG_USE_LOCAL_MEM; } while (0)
 #define gcShaderSetVPTwoSideEnable(Shader)      do { (Shader)->flags |= gcSHADER_FLAG_VP_TWO_SIDE_ENABLE; } while (0)
 #define gcShaderClrVPTwoSideEnable(Shader)      do { (Shader)->flags &= ~gcSHADER_FLAG_VP_TWO_SIDE_ENABLE; } while (0)
 #define gcShaderSetClampOutputColor(Shader)     do { (Shader)->flags |= gcSHADER_FLAG_CLAMP_OUTPUT_COLOR; } while (0)
@@ -4395,7 +4508,29 @@ typedef enum _gcSHADER_FLAGS
 #define gcShaderClrIsCompatibilityProfile(Shader)     do { (Shader)->flags &= ~gcSHADER_FLAG_COMPATIBILITY_PROFILE; } while (0)
 #define gcShaderSetUseConstRegForUBO(Shader)    do { (Shader)->flags |= gcSHADER_FLAG_USE_CONST_REG_FOR_UBO; } while (0)
 #define gcShaderClrUseConstRegForUBO(Shader)    do { (Shader)->flags &= ~gcSHADER_FLAG_USE_CONST_REG_FOR_UBO; } while (0)
-#define gcShaderSetFlag(Shader, Flag)           do { (Shader)->flags = (Flag); } while (0)
+#define gcShaderSetDenormFlushToZero(Shader)    do { (Shader)->flags |= gcSHADER_FLAG_DENORM_FLUSH_TO_ZERO; } while (0)
+#define gcShaderClrDenormFlushToZero(Shader)    do { (Shader)->flags &= ~gcSHADER_FLAG_DENORM_FLUSH_TO_ZERO; } while (0)
+#define gcShaderSetFlags(Shader, Flag)          do { (Shader)->flags = (Flag); } while (0)
+
+typedef enum _gcSHADER_OCL_PACKED_TYPES
+{
+    gcSHADER_OCL_PACKED_NONE        = 0x00000000,
+    gcSHADER_OCL_PACKED_HALF        = 0x00000001,
+    gcSHADER_OCL_PACKED_SHORT       = 0x00000002,
+    gcSHADER_OCL_PACKED_USHORT      = 0x00000004,
+    gcSHADER_OCL_PACKED_CHAR        = 0x00000008,
+    gcSHADER_OCL_PACKED_UCHAR       = 0x00000010,
+    gcSHADER_OCL_PACKED_ALL         = 0xFFFFFFFF,
+} gcSHADER_OCL_PACKED_TYPES;
+
+#define gcShaderSetOclPackedType(Shader, Type)          do { (Shader)->oclPackedTypes |= (Type); } while (0)
+#define gcShaderClrOclPackedType(Shader, Type)          do { (Shader)->oclPackedTypes &= (~Type); } while (0)
+#define gcShaderHasPackHalf(Shader)                     (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_HALF) != 0)
+#define gcShaderHasPackShort(Shader)                    (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_SHORT) != 0)
+#define gcShaderHasPackUShort(Shader)                   (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_USHORT) != 0)
+#define gcShaderHasPackChar(Shader)                     (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_CHAR) != 0)
+#define gcShaderHasPackUChar(Shader)                    (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_UCHAR) != 0)
+#define gcShaderHasPackALl(Shader)                      (((Shader)->oclPackedTypes & gcSHADER_OCL_PACKED_ALL) != 0)
 
 typedef struct _gcLibraryList gcLibraryList;
 
@@ -4560,6 +4695,9 @@ struct _gcSHADER
     /* Flags */
     gcSHADER_FLAGS              flags;
 
+    /* OCL packed types. */
+    gcSHADER_OCL_PACKED_TYPES   oclPackedTypes;
+
     /* Maximum of kernel function arguments, used to calculation the starting uniform index */
     gctUINT32                   maxKernelFunctionArgs;
 
@@ -4760,6 +4898,7 @@ struct _gcSHADER
 #define _gcdOCL_NumMemoryAddressRegs             8  /*number of memory address registers */
 #define _gcdOCL_MaxLocalTempRegs                16  /*maximum # of local temp register including the reserved ones for base addresses to memory spaces*/
 
+#define gcShaderIsOpenCL(S)                     ((S)->clientApiVersion == gcvAPI_OPENCL)
 #define gcShaderIsDesktopGL(S)                  ((S)->clientApiVersion == gcvAPI_OPENGL)
 #define gcShaderIsOpenVG(S)                     ((S)->clientApiVersion == gcvAPI_OPENVG || (((S)->compilerVersion[0] & 0xffff) == _SHADER_VG_TYPE))
 
@@ -4821,6 +4960,7 @@ struct _gcSHADER
 #define GetShaderKernelFunction(s, i)           ((s)->kernelFunctions[(i)])
 #define GetShaderCurrentKernelFunction(s)       ((s)->currentKernelFunction)
 #define GetShaderWorkGroupSize(s)               ((s)->shaderLayout.compute.workGroupSize)
+#define GetShaderWorkGroupSizeFactor(s)         ((s)->shaderLayout.compute.workGroupSizeFactor)
 #define SetShaderWorkGroupSize(s, v)            ((s)->shaderLayout.compute.workGroupSize[0] = (v)[0], \
                                                  (s)->shaderLayout.compute.workGroupSize[1] = (v)[1], \
                                                  (s)->shaderLayout.compute.workGroupSize[2] = (v)[2])
diff --git a/drivers/staging/npu/inc/probeStatistics_Driver.h b/drivers/staging/npu/inc/probeStatistics_Driver.h
new file mode 100644
index 000000000000..24c1a4547327
--- /dev/null
+++ b/drivers/staging/npu/inc/probeStatistics_Driver.h
@@ -0,0 +1,1632 @@
+/****************************************************************************
+*
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
+*
+*    The material in this file is confidential and contains trade secrets
+*    of Vivante Corporation. This is proprietary information owned by
+*    Vivante Corporation. No part of this work may be disclosed,
+*    reproduced, copied, transmitted, or used in any way for any purpose,
+*    without the express written permission of Vivante Corporation.
+*
+*****************************************************************************/
+
+
+#define MDUID_PPA                                               0xe0000
+#define MDUID_SE                                                0x30000
+#define MDUID_APPINFO                                           0x1f0000
+#define MDUID_RA                                                0x40000
+#define MDUID_PA                                                0x20000
+#define MDUID_VS                                                0x10000
+#define MDUID_TCS                                               0x100000
+#define MDUID_TES                                               0x110000
+#define MDUID_GS                                                0x120000
+#define MDUID_PSCS                                              0x50000
+#define MDUID_HI                                                0xa0000
+#define MDUID_MC                                                0x80000
+#define MDUID_TX                                                0x60000
+#define MDUID_FE                                                0x00000
+#define MDUID_USC                                               0x140000
+#define MDUID_WD                                                0xd0000
+#define MDUID_CHIPINFO                                          0x1e0000
+#define MDUID_FPA                                               0xf0000
+#define MDUID_PE                                                0x70000
+#define MDUID_TFB                                               0x130000
+#define MDUID_DIR                                               0x150000
+
+#define MDUSEL_APPINFO_ProbeState_OpNum                         0x0401
+#define MDUSEL_APPINFO_ProbeState_OpTyp                         0x0402
+#define MDUSEL_APPINFO_ProbeState_DrawNum                       0x0403
+#define MDUSEL_APPINFO_ProbeState_BlitNum                       0x0404
+#define MDUSEL_APPINFO_ProbeState_ComputeNum                    0x0405
+#define MDUSEL_APPINFO_ProbeState_ResolveNum                    0x0406
+#define MDUSEL_APPINFO_ProbeState_VsId                          0x0407
+#define MDUSEL_APPINFO_ProbeState_TcsId                         0x0408
+#define MDUSEL_APPINFO_ProbeState_TesId                         0x0409
+#define MDUSEL_APPINFO_ProbeState_GsId                          0x040A
+#define MDUSEL_APPINFO_ProbeState_PsId                          0x040B
+#define MDUSEL_APPINFO_ProbeState_CsId                          0x040C
+
+#define MDUSEL_APPINFO_NUM                                      12
+
+#define MDUSEL_CHIPINFO_ProbeState_ChipID                       0x0001
+#define MDUSEL_CHIPINFO_ProbeState_ChipVer                      0x0002
+#define MDUSEL_CHIPINFO_ProbeState_PID                          0x0003
+#define MDUSEL_CHIPINFO_ProbeState_CID                          0x0004
+
+#define MDUSEL_CHIPINFO_NUM                                     4
+
+DefineModule(FE, 0x00000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+
+DefineModule(WD, 0xd0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x30);
+DefineProbe(0x31);
+DefineProbe(0x32);
+DefineProbe(0x33);
+DefineProbe(0x34);
+DefineProbe(0x35);
+DefineProbe(0x36);
+DefineProbe(0x37);
+DefineProbe(0x38);
+DefineProbe(0x39);
+DefineProbe(0x3a);
+DefineProbe(0x3b);
+DefineProbe(0x50);
+DefineProbe(0x51);
+DefineProbe(0x52);
+DefineProbe(0x53);
+DefineProbe(0x54);
+DefineProbe(0x55);
+DefineProbe(0x56);
+DefineProbe(0x57);
+DefineProbe(0x58);
+DefineProbe(0x59);
+DefineProbe(0x5a);
+DefineProbe(0x5b);
+DefineProbe(0x5c);
+DefineProbe(0x5d);
+DefineProbe(0x5e);
+DefineProbe(0x5f);
+DefineProbe(0x60);
+DefineProbe(0x61);
+DefineProbe(0x62);
+DefineProbe(0x63);
+DefineProbe(0x64);
+DefineProbe(0x65);
+DefineProbe(0x66);
+DefineProbe(0x80);
+DefineProbe(0x81);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(TFB, 0x130000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x15);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+
+DefineModule(PPA, 0xe0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(FPA, 0xf0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(PA, 0x20000);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+DefineProbe(0xc10);
+DefineProbe(0xc11);
+DefineProbe(0xc12);
+DefineProbe(0xc13);
+DefineProbe(0xc14);
+DefineProbe(0xc15);
+DefineProbe(0xc16);
+DefineProbe(0xc17);
+DefineProbe(0xc18);
+DefineProbe(0xc19);
+DefineProbe(0xc1a);
+
+DefineModule(SE, 0x30000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+
+DefineModule(RA, 0x40000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0x10);
+DefineProbe(0x1b);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+
+DefineModule(VS, 0x10000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x405);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TCS, 0x100000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TES, 0x110000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(GS, 0x120000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(PSCS, 0x50000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x28);
+DefineProbe(0x80);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x403);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x408);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TX, 0x60000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x28);
+DefineProbe(0x29);
+DefineProbe(0x2a);
+DefineProbe(0x2b);
+DefineProbe(0x2c);
+DefineProbe(0x2d);
+DefineProbe(0x2e);
+DefineProbe(0x2f);
+DefineProbe(0x30);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+
+DefineModule(PE, 0x70000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+
+DefineModule(USC, 0x140000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0xc00);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+DefineProbe(0xc10);
+DefineProbe(0xc11);
+DefineProbe(0xc12);
+DefineProbe(0xc13);
+DefineProbe(0xc14);
+DefineProbe(0xc15);
+DefineProbe(0xc16);
+DefineProbe(0xc17);
+DefineProbe(0xc18);
+DefineProbe(0xc19);
+DefineProbe(0xc1a);
+DefineProbe(0xc1b);
+
+DefineModule(MC, 0x80000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+
+DefineModule(HI, 0xa0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x40);
+DefineProbe(0x41);
+DefineProbe(0x42);
+DefineProbe(0x46);
+DefineProbe(0x47);
+DefineProbe(0x48);
+DefineProbe(0x49);
+DefineProbe(0x4a);
+DefineProbe(0x4b);
+DefineProbe(0x52);
+DefineProbe(0x53);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+
+DefineModule(DIR, 0x150000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+
+
diff --git a/drivers/staging/npu/inc/shared/gc_hal_base_shared.h b/drivers/staging/npu/inc/shared/gc_hal_base_shared.h
index 97c1f6be7b50..cbe1525c4834 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_base_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_base_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/inc/shared/gc_hal_driver_shared.h b/drivers/staging/npu/inc/shared/gc_hal_driver_shared.h
index 94257d67965a..a8749c8d6afc 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_driver_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_driver_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -647,6 +647,13 @@ typedef struct _gcsHAL_COMMIT
     /* Brother cores in user device of current commit process. */
     gctUINT32                   broCoreMask;
 
+#if gcdENABLE_MP_SWITCH
+    /* Multi-processor mode. */
+    gctUINT32                   mpMode;
+
+    /* Switch multi-processor mode. */
+    gctUINT32                   switchMpMode;
+#endif
 
 #if gcdENABLE_SW_PREEMPTION
     /* If user need to merge the delta. */
@@ -801,6 +808,8 @@ typedef struct _gcsHAL_GET_PROFILE_SETTING
     OUT gctBOOL                 enable;
     /* Profile mode */
     OUT gceProfilerMode         profileMode;
+    /* Probe mode */
+    OUT gceProbeMode            probeMode;
 }
 gcsHAL_GET_PROFILE_SETTING;
 
@@ -811,6 +820,8 @@ typedef struct _gcsHAL_SET_PROFILE_SETTING
     IN gctBOOL                  enable;
     /* Profile mode */
     IN gceProfilerMode          profileMode;
+    /* Probe mode */
+    IN gceProbeMode             probeMode;
 }
 gcsHAL_SET_PROFILE_SETTING;
 
diff --git a/drivers/staging/npu/inc/shared/gc_hal_driver_vg_shared.h b/drivers/staging/npu/inc/shared/gc_hal_driver_vg_shared.h
index e669b8d74583..67c3696b25ad 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_driver_vg_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_driver_vg_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -192,7 +192,7 @@ typedef struct _gcsTASK_FREE_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gctUINT32                node;
+    IN gctUINT64                node;
 }
 gcsTASK_FREE_VIDEO_MEMORY;
 
diff --git a/drivers/staging/npu/inc/shared/gc_hal_enum_shared.h b/drivers/staging/npu/inc/shared/gc_hal_enum_shared.h
index 158567b38137..d7701a34affb 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_enum_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_enum_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -217,6 +217,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_2D_10BIT_OUTPUT_LINEAR,
     gcvFEATURE_2D_YUV420_OUTPUT_LINEAR,
     gcvFEATURE_ACE,
+    gcvFEATURE_NO_YUV420_SOURCE,/* unsupported source with three planes */
     gcvFEATURE_COLOR_COMPRESSION,
     gcvFEATURE_32BPP_COMPONENT_TEXTURE_CHANNEL_SWIZZLE,
     gcvFEATURE_64BPP_HW_CLEAR_SUPPORT,
@@ -606,6 +607,20 @@ typedef enum _gceFEATURE
     gcvFEATURE_PE_A8B8G8R8, /* For PE support A8B8G8R8 format feature*/
     gcvFEATURE_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX,
 
+    /* FP16 enhancement-related features. */
+    gcvFEATURE_DST_TEX_I2F_F2I_INST_DEPRECATE,
+    gcvFEATURE_ALU_FP16_INST_SUPPORT,
+    gcvFEATURE_DUAL16_14BIT_PC_SUPPORT,
+    gcvFEATURE_LDST_CONV_4ROUNDING_MODES,
+    gcvFEATURE_FULL_PACK_MODE_SUPPORT,
+    gcvFEATURE_FP32_TO_FP16_CONV_FIX,
+
+    gcvFEATURE_SH_HAS_IMGLD_COMP_COUNT_FIX,
+    gcvFEATURE_SH_SUPPORT_FP32_FMA,
+
+    gcvFEATURE_SH_SUPPORT_VEC2_INT_MULMAD,
+    gcvFEATURE_SH_SUPPORT_VEC4_INT_MULMAD,
+
     /* AIGPU feature. */
     gcvFEATURE_AI_GPU,
     gcvFEATURE_NN_FAST_FIRST_PIXEL_POOLING,
@@ -647,7 +662,7 @@ typedef enum _gceFEATURE
 
     /* TP reorder the int tile x should be less than 512 */
     gcFEATURE_TP_REORDER_INTILE_X_SIZE_512_FIX,
-    gcFEATURE_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE,
+    gcFEATURE_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX,
     gcFEATURE_BIT_BFP_COEF_AUTO_PAD_INCOMPLETE_ZERO_IN_KZ_PLANE,
     gcvFEATURE_NN_FLOAT32_IO,
     gcvFEATURE_TP_FLOAT32_IO,
@@ -691,6 +706,22 @@ typedef enum _gceFEATURE
     gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING,
     gcvFEATURE_NN_1x1_NON_POOLING_PACKING,
     gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING,
+    gcFEATURE_BIT_NN_SUPPORT_ALU,
+    gcvFEATURE_BIT_NN_TRANSPOSE_PHASE2,
+    gcvFEATURE_BIT_NN_FC_ENHANCEMENT,
+    gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX,
+    gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD,
+
+    gcvFEATURE_IMGLD_WIDTH_LT16_FIX,
+    gcvFEATURE_BIT_GPU_INSPECTOR_COUNTERS,
+
+    gcvFEATURE_VIP_REMOVE_MMU,
+    gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE,
+    gcvFEATURE_BIT_NN_JD_DIRECT_MODE_FIX,
+    gcFEATURE_BIT_NN_CONV_CORE_BYPASS,
+    gcvFEATURE_BIT_TP_REMOVE_FC,
+
+    gcvFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX,
 
     /* Insert features above this comment only. */
     gcvFEATURE_COUNT                /* Not a feature. */
@@ -776,6 +807,7 @@ typedef enum _gceSURF_TYPE
     gcvSURF_3D                      = 0x200000, /* It's 3d surface */
     gcvSURF_DMABUF_EXPORTABLE       = 0x400000, /* master node can be exported as dma-buf fd */
     gcvSURF_CACHE_MODE_128          = 0x800000,
+    gcvSURF_TILED                   = 0x1000000, /* force create tile buffer, as we will convert it to supertile according to related hardware feature by default */
 
     gcvSURF_TEXTURE_LINEAR               = gcvSURF_TEXTURE
                                          | gcvSURF_LINEAR,
@@ -1391,6 +1423,7 @@ typedef enum _gceCORE
 #if gcdDEC_ENABLE_AHB
     gcvCORE_DEC,
 #endif
+    gcvCORE_2D1,
     gcvCORE_COUNT
 }
 gceCORE;
@@ -1940,11 +1973,35 @@ gceSYNC_VIDEO_MEMORY_REASON;
 
 typedef enum _gceProfilerMode
 {
-    gcvPROFILER_PROBE_MODE = 0,
-    gcvPROFILER_AHB_MODE   = 1,
+    gcvPROFILER_UNKNOWN_MODE = 0,
+    gcvPROFILER_PROBE_MODE,
+    gcvPROFILER_AHB_MODE,
 }
 gceProfilerMode;
 
+typedef enum _gceProbeMode
+{
+    gcvPROFILER_UNKNOWN_PROBE = 0,
+    gcvPROFILER_GPU_PROBE,
+    gcvPROFILER_VIP_PROBE,
+}
+gceProbeMode;
+
+typedef enum _gceMULTI_PROCESSOR_MODE
+{
+    gcvMP_MODE_COMBINED    = 0,
+    gcvMP_MODE_INDEPENDENT = 1
+}
+gceMULTI_PROCESSOR_MODE;
+
+typedef enum _gceSwitchMpMode
+{
+    gcvMP_MODE_NO_SWITCH = 0,
+    gcvMP_MODE_SWITCH_TO_SINGLE,
+    gcvMP_MODE_SWITCH_TO_MULTI,
+}
+gceSwitchMpMode;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/staging/npu/inc/shared/gc_hal_profiler_shared.h b/drivers/staging/npu/inc/shared/gc_hal_profiler_shared.h
index 989656bc15a0..859ef0373562 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_profiler_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_profiler_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -18,6 +18,11 @@
 extern "C" {
 #endif
 
+#define ANDROID_PROFILER_COUNTERS   1
+#define APP_INFO   1
+#define FPGA_INFO   0
+#define RECORD_COUNTER_ADDRESS  0
+
 /* HW profile information. */
 typedef struct _gcsPROFILER_COUNTERS_PART1
 {
diff --git a/drivers/staging/npu/inc/shared/gc_hal_types_shared.h b/drivers/staging/npu/inc/shared/gc_hal_types_shared.h
index 3a36c8ea258b..6b0577398ad1 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_types_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_types_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
@@ -85,7 +85,11 @@ extern "C" {
 
 #if defined(ANDROID) && defined(__BIONIC_FORTIFY)
 #if defined(__clang__)
-#       define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline))
+#if (__clang_major__ >= 10)
+#           define gcmINLINE            __inline__ __attribute__ ((always_inline))
+#       else
+#           define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline))
+#       endif
 #   else
 #       define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline)) __attribute__ ((artificial))
 #   endif
@@ -255,7 +259,56 @@ gcuFLOAT_UINT32;
 #define gcvNEGONE_X             ((gctFIXED_POINT) 0xFFFF0000)
 #define gcvTWO_X                ((gctFIXED_POINT) 0x00020000)
 
-
+/* No special needs. */
+#define gcvALLOC_FLAG_NONE                  0x00000000
+
+/* Physical contiguous. */
+#define gcvALLOC_FLAG_CONTIGUOUS            0x00000001
+/* Physical non contiguous. */
+#define gcvALLOC_FLAG_NON_CONTIGUOUS        0x00000002
+
+/* Should not swap out. */
+#define gcvALLOC_FLAG_NON_PAGED             0x00000004
+
+/* CPU access explicitly needed. */
+#define gcvALLOC_FLAG_CPU_ACCESS            0x00000008
+/* Can be remapped as cacheable. */
+#define gcvALLOC_FLAG_CACHEABLE             0x00000010
+
+/* Need 32bit address. */
+#define gcvALLOC_FLAG_4GB_ADDR              0x00000020
+
+/* Secure buffer. */
+#define gcvALLOC_FLAG_SECURITY              0x00000040
+/* Can be exported as dmabuf-fd */
+#define gcvALLOC_FLAG_DMABUF_EXPORTABLE     0x00000080
+/* Do not try slow pools (gcvPOOL_VIRTUAL) */
+#define gcvALLOC_FLAG_FAST_POOLS            0x00000100
+
+/* Only accessed by GPU */
+#define gcvALLOC_FLAG_NON_CPU_ACCESS        0x00000200
+/* Do not be moved */
+#define gcvALLOC_FLAG_NO_EVICT              0x00000400
+
+/* Import DMABUF. */
+#define gcvALLOC_FLAG_DMABUF                0x00001000
+/* Import USERMEMORY. */
+#define gcvALLOC_FLAG_USERMEMORY            0x00002000
+/* Import an External Buffer. */
+#define gcvALLOC_FLAG_EXTERNAL_MEMORY       0x00004000
+/* Import linux reserved memory. */
+#define gcvALLOC_FLAG_LINUX_RESERVED_MEM    0x00008000
+
+/* 1M pages unit allocation. */
+#define gcvALLOC_FLAG_1M_PAGES              0x00010000
+
+/* Non 1M pages unit allocation. */
+#define gcvALLOC_FLAG_4K_PAGES              0x00020000
+
+/* Real allocation happens when GPU page fault. */
+#define gcvALLOC_FLAG_ALLOC_ON_FAULT        0x01000000
+/* Alloc with memory limit. */
+#define gcvALLOC_FLAG_MEMLIMIT              0x02000000
 
 #define gcmFIXEDCLAMP_NEG1_TO_1(_x) \
     (((_x) < gcvNEGONE_X) \
@@ -722,6 +775,26 @@ gcs2D_PROFILE;
         (((gctUINT32)(x) & (gctUINT32)0x00FF0000U) << 8)  | \
         (((gctUINT32)(x) & (gctUINT32)0xFF000000U) >> 8)))
 
+/*******************************************************************************
+**
+** gcmBSWAP16IN32EX
+**
+**      Return a value with whole 16 bit swapped of a 32 bit data type.
+*/
+#  define gcmBSWAP16IN32EX(x) ((gctUINT32)(\
+        (((gctUINT32)(x) & (gctUINT32)0x0000FFFFU) << 16)  | \
+        (((gctUINT32)(x) & (gctUINT32)0xFFFF0000U) >> 16)))
+
+/*******************************************************************************
+**
+** gcmBSWAP32IN64
+**
+**      Return a value with whole 32 bit swapped of a 64 bit data type.
+*/
+#  define gcmBSWAP32IN64(x) ((gctUINT64)(\
+        (((gctUINT64)(x) & (gctUINT64)0x00000000FFFFFFFFULL) << 32) | \
+        (((gctUINT64)(x) & (gctUINT64)0xFFFFFFFF00000000ULL) >> 32)))
+
 /*******************************************************************************
 ***** Database ****************************************************************/
 
@@ -940,6 +1013,17 @@ typedef struct _gcsHAL_PATCH_VIDMEM_TIMESTAMP
 }
 gcsHAL_PATCH_VIDMEM_TIMESTAMP;
 
+/* Put together patch list handling variables. */
+typedef struct _gcsPATCH_LIST_VARIABLE
+{
+    /* gcvHAL_PATCH_VIDMEM_TIMESTAMP. */
+    gctUINT64 maxAsyncTimestamp;
+
+    /* gcvHAL_PATCH_MCFE_SEMAPHORE. */
+    gctBOOL semaUsed;
+}
+gcsPATCH_LIST_VARIABLE;
+
 /*
     gcvFEATURE_DATABASE_DATE_MASK
 
diff --git a/drivers/staging/npu/inc/shared/gc_hal_vg_shared.h b/drivers/staging/npu/inc/shared/gc_hal_vg_shared.h
index 140d02233c34..8001166f45e6 100644
--- a/drivers/staging/npu/inc/shared/gc_hal_vg_shared.h
+++ b/drivers/staging/npu/inc/shared/gc_hal_vg_shared.h
@@ -1,6 +1,6 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 *
 *    The material in this file is confidential and contains trade secrets
 *    of Vivante Corporation. This is proprietary information owned by
diff --git a/drivers/staging/npu/kernel/Android.mk b/drivers/staging/npu/kernel/Android.mk
index ba4dcded8484..3c26f02bb18d 100755
--- a/drivers/staging/npu/kernel/Android.mk
+++ b/drivers/staging/npu/kernel/Android.mk
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+#    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 #
 #    The material in this file is confidential and contains trade secrets
 #    of Vivante Corporation. This is proprietary information owned by
@@ -81,7 +81,6 @@ include $(CLEAR_VARS)
 LOCAL_SRC_FILES := \
           gc_hal_kernel_command.c \
           gc_hal_kernel_db.c \
-          gc_hal_kernel_debug.c \
           gc_hal_kernel_event.c \
           gc_hal_kernel_heap.c \
           gc_hal_kernel.c \
diff --git a/drivers/staging/npu/kernel/arch/cebuild/makefile b/drivers/staging/npu/kernel/arch/cebuild/makefile
index 988556ed5f95..9be0642c7166 100755
--- a/drivers/staging/npu/kernel/arch/cebuild/makefile
+++ b/drivers/staging/npu/kernel/arch/cebuild/makefile
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/cebuild/sources b/drivers/staging/npu/kernel/arch/cebuild/sources
index e8fe06d92256..a9a7a846eeb8 100755
--- a/drivers/staging/npu/kernel/arch/cebuild/sources
+++ b/drivers/staging/npu/kernel/arch/cebuild/sources
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.c
index e7953a831b74..336e5381ed4c 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -149,12 +149,12 @@
         gcvFALSE, gcvFALSE                                                     \
         )
 
-#define _STATE_INIT_VALUE_1(reg, value)                                        \
+#define _STATE_INIT_VALUE_OFFSET(reg, offset, value)                           \
     _State(\
         Context, index, \
-        (reg ## _Address >> 2) + 1, \
+        (reg ## _Address >> 2) + offset, \
         value, \
-        reg ## _Count, \
+        1, \
         gcvFALSE, gcvFALSE                                                     \
         )
 
@@ -3325,6 +3325,9 @@ _InitializeContextBuffer(
     gctBOOL hasMsaaFragOperation;
     gctBOOL newGPipe;
     gctBOOL computeOnly;
+#if gcdSYNC && gcdENDIAN_BIG
+    gctUINT PEFenceEndianControl;
+#endif
 #endif
 
     gckHARDWARE hardware;
@@ -3383,6 +3386,11 @@ _InitializeContextBuffer(
     hasMsaaFragOperation = gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_MSAA_FRAGMENT_OPERATION);
     newGPipe = gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_NEW_GPIPE);
     computeOnly = gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_COMPUTE_ONLY);
+#if gcdSYNC && gcdENDIAN_BIG
+    PEFenceEndianControl = gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_FENCE_64BIT)
+                                                           ? 0x3
+                                                           : 0x2;
+#endif
 
     /* Multi render target. */
     if (Context->hardware->identity.chipModel == gcv880 &&
@@ -3441,7 +3449,7 @@ _InitializeContextBuffer(
 
     if (multiCluster)
     {
-        index += _State(Context, index, 0x03910 >> 2, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+        index += _State(Context, index, (0x03910 >> 2) + 0, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  7:0) - (0 ?
  7:0) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ?
@@ -3451,7 +3459,7 @@ _InitializeContextBuffer(
  7:0) - (0 ?
  7:0) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ?
- 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))), 4, gcvFALSE, gcvFALSE);
+ 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))), 1, gcvFALSE, gcvFALSE);
 
         index += _State(Context, index, (0x03910 >> 2) + 1, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  7:0) - (0 ?
@@ -3463,7 +3471,7 @@ _InitializeContextBuffer(
  7:0) - (0 ?
  7:0) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ?
- 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))), 4, gcvFALSE, gcvFALSE);
+ 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0))), 1, gcvFALSE, gcvFALSE);
 
         index += _State(Context, index, 0x03908 >> 2, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  2:0) - (0 ?
@@ -4418,7 +4426,21 @@ _InitializeContextBuffer(
 
     if (halti3)
     {
+#if gcdSYNC && gcdENDIAN_BIG
+        index += _State(Context, index, 0x014BC >> 2, ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 10:9) - (0 ?
+ 10:9) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 10:9) - (0 ?
+ 10:9) + 1))))))) << (0 ?
+ 10:9))) | (((gctUINT32) ((gctUINT32) (PEFenceEndianControl) & ((gctUINT32) ((((1 ?
+ 10:9) - (0 ?
+ 10:9) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 10:9) - (0 ? 10:9) + 1))))))) << (0 ? 10:9))), 1, gcvFALSE, gcvFALSE);
+#else
         index += _State(Context, index, 0x014BC >> 2, 0x00000000, 1, gcvFALSE, gcvFALSE);
+#endif
     }
 
     if (halti4)
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.h
index 0f44d95f8678..af77038fe0cc 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_context.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -181,13 +181,6 @@ struct _gckCONTEXT
 
     gctUINT32                   pipeSelectBytes;
 
-    gcsPROFILER_COUNTERS_PART1    latestProfiler_part1;
-    gcsPROFILER_COUNTERS_PART1    histroyProfiler_part1;
-    gcsPROFILER_COUNTERS_PART1    preProfiler_part1;
-    gcsPROFILER_COUNTERS_PART2    latestProfiler_part2;
-    gcsPROFILER_COUNTERS_PART2    histroyProfiler_part2;
-    gcsPROFILER_COUNTERS_PART2    preProfiler_part2;
-
 #if gcdENABLE_SW_PREEMPTION
     /* Kernel delta. */
     gcsSTATE_DELTA_PTR            delta;
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.c
index 119b1d8d331a..2e8bf0fcb7b7 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -1235,10 +1235,17 @@ _FlushCache(
 }
 
 static gctBOOL
-_IsGPUIdle(
-    IN gctUINT32 Idle
+_IsHWIdle(
+    IN gctUINT32 Idle,
+    IN gckHARDWARE Hardware
     )
 {
+    if (Hardware->identity.customerID == 0x15 ||
+        gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_VIP_SCALER) ||
+        gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_VIP_SCALER_4K))
+    {
+        Idle = (Idle | (1 << 14));
+    }
     return Idle == 0x7FFFFFFF;
 }
 
@@ -1680,6 +1687,18 @@ _QueryFeatureDatabase(
         available = database->MMU_PAGE_DESCRIPTOR;
         break;
 
+    case gcvFEATURE_VIP_REMOVE_MMU:
+        available = database->VIP_REMOVE_MMU;
+        break;
+
+    case gcvFEATURE_VIP_SCALER:
+        available = database->SCALER;
+        break;
+
+    case gcvFEATURE_VIP_SCALER_4K:
+        available = database->SCALER_4K;
+        break;
+
         /*FALLTHRU*/
     default:
         gcmkFATAL("Invalid feature has been requested.");
@@ -1790,6 +1809,53 @@ _ConfigurePolicyID(
             ));
     }
 }
+
+static gceSTATUS
+_QueryNNClusters(
+    IN gckHARDWARE Hardware
+    )
+{
+    gctUINT64 enableNN = ~0UL;
+    gctUINT32 value = 0;
+    gceSTATUS status = gcvSTATUS_OK;
+
+    if (gcmIS_SUCCESS(gckOS_QueryOption(Hardware->os, "enableNN", &enableNN)))
+    {
+        if (!enableNN)
+        {
+            value = 0x2;
+        }
+        else if (enableNN == 0xFF || (enableNN == Hardware->identity.nnClusterNum))
+        {
+            value = 0;
+        }
+        else
+        {
+            /* We only support maximum 8 clusters by current. */
+            if (enableNN > 0x7)
+            {
+                gcmkPRINT("[Galcore warning]: Invalid enableNN value is configured.");
+
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+            }
+
+            value = (gctUINT32)enableNN + 0x2;
+        }
+    }
+
+    Hardware->options.enableNNClusters = (gctUINT32)enableNN;
+
+    if (value && Hardware->identity.customerID != 0x85)
+    {
+        gcmkPRINT("Galcore warning: Don't set enableNN as this chip not support NN cluster power control!\n");
+    }
+
+    Hardware->options.configNNPowerControl = value;
+
+OnError:
+    return status;
+}
+
 /****************************
 ** Initialise hardware options
 */
@@ -1808,7 +1874,7 @@ _SetHardwareOptions(
     gctBOOL featureTS = gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_TESSELLATION) ? gcvTRUE : gcvFALSE;
     gctUINT32 featureL1CacheSize = database->L1CacheSize;
     gctUINT32 featureUSCMaxPages = database->USC_MAX_PAGES;
-
+    gctUINT32 i;
 
     status = gckOS_QueryOption(Hardware->os, "powerManagement", &data);
     options->powerManagement = (data != 0);
@@ -1819,14 +1885,33 @@ _SetHardwareOptions(
         options->powerManagement = gcvTRUE;
     }
 
-    status = gckOS_QueryOption(Hardware->os, "mmu", &data);
-    options->enableMMU = (data != 0);
-
-    if (status == gcvSTATUS_NOT_SUPPORTED)
+#if 0
+#ifndef EMULATOR
+    if (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_VIP_REMOVE_MMU))
     {
-        /* Disable MMU if we can't get result from OS layer query */
         options->enableMMU = gcvFALSE;
     }
+    else
+#endif
+#endif
+    {
+        status = gckOS_QueryOption(Hardware->os, "mmu", &data);
+        options->enableMMU = (data != 0);
+
+        if (status == gcvSTATUS_NOT_SUPPORTED)
+        {
+            /* Disable MMU if we can't get result from OS layer query */
+            options->enableMMU = gcvFALSE;
+        }
+    }
+
+    if (options->enableMMU == gcvFALSE)
+    {
+        gcmkPRINT("Galcore warning: MMU is disabled!\n");
+    }
+
+    /* Query enabled NN clusters. */
+    _QueryNNClusters(Hardware);
 
     gcmCONFIGUSC2(gcmk, featureUSC, featureSeparateLS, featureComputeOnly, featureTS,
                  featureL1CacheSize, featureUSCMaxPages,
@@ -1842,6 +1927,11 @@ _SetHardwareOptions(
 
     status = gckOS_QueryOption(Hardware->os, "userClusterMasks", (gctUINT64 *)options->userClusterMasks);
 
+    for (i = 0; i < gcdMAX_MAJOR_CORE_COUNT; i++)
+    {
+        options->userClusterMasks[i] &= Hardware->identity.clusterAvailMask;
+    }
+
     options->userClusterMask = options->userClusterMasks[Hardware->core];
 
     if (status == gcvSTATUS_NOT_SUPPORTED || (options->userClusterMask == 0))
@@ -2127,7 +2217,7 @@ gckHARDWARE_Construct(
     gctUINT16 data = 0xff00;
     gctPOINTER pointer = gcvNULL;
     gctUINT    i;
-
+    gctUINT64 enableSoftReset = 1;
     gcmkHEADER_ARG("Os=0x%x", Os);
 
     /* Verify the arguments. */
@@ -2213,12 +2303,16 @@ gckHARDWARE_Construct(
             ? 0x0100
             : 0x0000;
 
-
-    /* _ResetGPU need powerBaseAddress. */
-    status = _ResetGPU(hardware, Os, Core);
-    if (status != gcvSTATUS_OK)
+    status = gckOS_QueryOption(Os, "softReset", (gctUINT64 *)&enableSoftReset);
+    if (enableSoftReset == 1)
     {
-        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE, "_ResetGPU failed: status=%d\n", status);
+        /* _ResetGPU need powerBaseAddress. */
+        status = _ResetGPU(hardware, Os, Core);
+
+        if (status != gcvSTATUS_OK)
+        {
+            gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE, "_ResetGPU failed: status=%d\n", status);
+        }
     }
 
 #if gcdDEC_ENABLE_AHB
@@ -2990,9 +3084,11 @@ gckHARDWARE_InitializeHardware(
     }
 
     if (Hardware->identity.chipModel == 0x620 &&
-        Hardware->identity.chipRevision == 0x5552 &&
         Hardware->identity.productID == 0x6200 &&
-        Hardware->identity.customerID == 0x209)
+        ((Hardware->identity.chipRevision == 0x5552 &&
+        Hardware->identity.customerID == 0x209) ||
+        (Hardware->identity.chipRevision == 0x5553 &&
+        Hardware->identity.customerID == 0x210)))
     {
         gctUINT32 offset = 0;
 
@@ -3324,6 +3420,31 @@ gckHARDWARE_InitializeHardware(
                                   data));
     }
 
+    if (_IsHardwareMatch(Hardware, gcv8000, 0x7200))
+    {
+        if (regPMC == 0)
+        {
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+                                 Hardware->core,
+                                 Hardware->powerBaseAddress
+                                 + 0x00104,
+                                 &regPMC));
+        }
+
+        /* Disable SH_EU clock gating. */
+        regPMC = ((((gctUINT32) (regPMC)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 10:10) - (0 ?
+ 10:10) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 10:10) - (0 ?
+ 10:10) + 1))))))) << (0 ?
+ 10:10))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
+ 10:10) - (0 ?
+ 10:10) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 10:10) - (0 ? 10:10) + 1))))))) << (0 ? 10:10)));
+    }
+
     if (regPMC != 0)
     {
         gcmkONERROR(
@@ -3421,7 +3542,8 @@ gckHARDWARE_InitializeHardware(
 
     if (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_NN_ENGINE) &&
         (!gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_HI_REORDER_FIX) ||
-        (((gcsFEATURE_DATABASE *)Hardware->featureDatabase)->AXI_SRAM_SIZE == 0))
+        (((gcsFEATURE_DATABASE *)Hardware->featureDatabase)->AXI_SRAM_SIZE == 0)) &&
+        (((gcsFEATURE_DATABASE *)Hardware->featureDatabase)->HI_DEFAULT_ENABLE_REORDER_FIX)
         )
     {
         gcmkONERROR(gckOS_ReadRegisterEx(
@@ -3444,6 +3566,8 @@ gckHARDWARE_InitializeHardware(
 
     _ConfigurePolicyID(Hardware);
 
+    gcmkONERROR(gckHARDWARE_PowerControlClusters(Hardware, Hardware->options.configNNPowerControl, gcvTRUE));
+
 #if gcdDEBUG_MODULE_CLOCK_GATING
     _ConfigureModuleLevelClockGating(Hardware);
 #endif
@@ -6256,7 +6380,7 @@ gckHARDWARE_GetIdle(
                                              &address));
 
             /* See if we have to wait for FE idle. */
-            if (_IsGPUIdle(idle)
+            if (_IsHWIdle(idle, Hardware)
              && (address == Hardware->lastEnd + 8)
              )
             {
@@ -6266,7 +6390,7 @@ gckHARDWARE_GetIdle(
         }
 
         /* Check if we need to wait for FE and FE is busy. */
-        if (Wait && !_IsGPUIdle(idle))
+        if (Wait && !_IsHWIdle(idle, Hardware))
         {
             /* Wait a little. */
             gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
@@ -7724,18 +7848,40 @@ gckHARDWARE_SetFastClear(
 #endif
 }
 
+/*******************************************************************************
+**
+**  gckHARDWARE_PowerControlClusters
+**
+**  Power control clusters of one core.
+**  Currently only support NN clusters.
+**
+**  INPUT:
+**
+**      gckHARDWARE Harwdare
+**          Pointer to an gckHARDWARE object.
+**
+**      gctUINT32 PowerControlVaule
+**          The value programmed to power control register.
+**
+**      gctBOOL PowerState
+**          Power State to switch.
+**
+*/
+
 gceSTATUS
-gckHARDWARE_PowerControlNNClusters(
+gckHARDWARE_PowerControlClusters(
     gckHARDWARE Hardware,
-    gctUINT32  PowerControlValue
+    gctUINT32  PowerControlValue,
+    gctBOOL PowerState
     )
 {
     gceSTATUS status = gcvSTATUS_OK;
-    gckCOMMAND command;
-    gctPOINTER buffer;
-    gctUINT32_PTR logical;
+    gckCOMMAND command = gcvNULL;
+    gctPOINTER buffer = gcvNULL;
+    gctUINT32_PTR logical = gcvNULL;
     gctUINT32 reqBytes = 16;
     gctUINT32 bytes;
+    gctUINT32 idle, timer = 0;
 
     gcmkHEADER_ARG("Hardware=%p PowerControlValue=%x", Hardware, PowerControlValue);
 
@@ -7743,7 +7889,17 @@ gckHARDWARE_PowerControlNNClusters(
 
     command = Hardware->kernel->command;
 
-    if (Hardware->mcFE)
+#if !gcdFPGA_BUILD
+    if (Hardware->identity.customerID != 0x85 || !Hardware->mcFE ||
+        Hardware->options.enableNNClusters == ~0UL ||
+        (!PowerState && !Hardware->powerState))
+#endif
+    {
+        gcmkFOOTER_NO();
+        return gcvSTATUS_OK;
+    }
+
+    /* Program cluster power control command, only with MCFE by current. */
     {
         /* Start the command parser. */
         gcmkONERROR(gckCOMMAND_Start(command));
@@ -7821,19 +7977,34 @@ gckHARDWARE_PowerControlNNClusters(
  31:27) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
 
-        gcmkONERROR(gckCOMMAND_ExecuteMultiChannel(command, gcvFALSE, 0, reqBytes));
+        gcmkONERROR(gckCOMMAND_ExecuteMultiChannel(command, gcvFALSE, 2, reqBytes));
+
+        do
+        {
+            gckOS_Udelay(Hardware->os, 10);
+
+            gcmkONERROR(gckOS_ReadRegisterEx(
+                Hardware->os,
+                Hardware->core,
+                0x00004,
+                &idle));
 
-        /* Wait for handshake? */
-        /* gckOS_Delay(gcvNULL, 1);*/
+            timer += 1;
+
+#if gcdGPU_TIMEOUT
+            if (timer >= Hardware->kernel->timeOut)
+            {
+                gcmkPRINT("%s %d Galcore timeout...\n", __FUNCTION__, __LINE__);
+
+                gcmkONERROR(gcvSTATUS_DEVICE);
+            }
+#endif
+        }
+        while (!_IsHWIdle(idle, Hardware));
 
         /* Stop the command parser. */
         gcmkONERROR(gckCOMMAND_Stop(command));
     }
-    else
-    {
-        /* Only support NN power control when it is MCFE currently. */
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-    }
 
 OnError:
     gcmkFOOTER();
@@ -7941,20 +8112,6 @@ _PmClockOff(
 {
     gceSTATUS status;
 
-    if (Hardware->options.enableNNClusters &&
-        Hardware->identity.customerID == 0x85)
-    {
-        /* Power on. */
-        if (PowerState)
-        {
-            gcmkONERROR(gckHARDWARE_PowerControlNNClusters(Hardware, Hardware->options.configNNPowerControl));
-        }
-        else /* Power off. */
-        {
-            gcmkONERROR(gckHARDWARE_PowerControlNNClusters(Hardware, 0x2));
-        }
-    }
-
     gcmkONERROR(gckOS_SetGPUPower(Hardware->os, Hardware->core,
                                   gcvFALSE, PowerState));
 
@@ -8357,7 +8514,6 @@ _PmFlushCache(
     else
     {
         gcmkONERROR(gckFUNCTION_Execute(&Hardware->functions[gcvFUNCTION_EXECUTION_FLUSH]));
-        gckOS_Delay(gcvNULL, 1);
     }
 
 OnError:
@@ -8404,7 +8560,6 @@ _PmSetPowerOnDirection(
         }
 
         requireInit = gcvTRUE;
-		break;
         /* FALLTHRU */
 
     case gcvPOWER_SUSPEND:
@@ -8490,7 +8645,6 @@ _PmSetPowerOffDirection(
             gcmkONERROR(_PmClockControl(Hardware, gcvPOWER_IDLE));
             break;
         }
-		break;
         /* FALLTHRU */
 
     case gcvPOWER_IDLE:
@@ -8506,7 +8660,6 @@ _PmSetPowerOffDirection(
             gcmkONERROR(_PmClockOff(Hardware, gcvTRUE));
             break;
         }
-		break;
 
         /* FALLTHRU */
 
@@ -8517,6 +8670,8 @@ _PmSetPowerOffDirection(
             gcmkONERROR(_PmFlushCache(Hardware, command));
         }
 
+        gcmkONERROR(gckHARDWARE_PowerControlClusters(Hardware, 0x2, gcvFALSE));
+
         /* Clock control. */
         gcmkONERROR(_PmClockControl(Hardware, gcvPOWER_OFF));
 
@@ -8727,7 +8882,6 @@ _QchannelPowerOnDirection(
         }
 
         requireInit = gcvTRUE;
-		break;
         /* FALLTHRU */
 
     case gcvPOWER_SUSPEND:
@@ -8807,7 +8961,6 @@ _QchannelPowerOffDirection(
             gcmkONERROR(_PmClockControl(Hardware, gcvPOWER_IDLE));
             break;
         }
-		break;
         /* FALLTHRU */
 
     case gcvPOWER_IDLE:
@@ -8823,7 +8976,6 @@ _QchannelPowerOffDirection(
             gcmkONERROR(gckHARDWARE_QchannelPowerControl(Hardware, gcvFALSE, gcvTRUE));
             break;
         }
-		break;
 
         /* FALLTHRU */
 
@@ -8922,7 +9074,6 @@ gckHARDWARE_SetPowerState(
     case gcvPOWER_IDLE_TIMEOUT:
     case gcvPOWER_SUSPEND_TIMEOUT:
         timeout   = gcvTRUE;
-		break;
         /* FALLTHRU */
     case gcvPOWER_OFF_BROADCAST:
     case gcvPOWER_IDLE_BROADCAST:
@@ -8972,7 +9123,7 @@ gckHARDWARE_SetPowerState(
     if (Hardware->chipPowerState == state)
     {
         /* No state change. */
-        gckOS_ReleaseMutex(os, Hardware->powerMutex)
+        gckOS_ReleaseMutex(os, Hardware->powerMutex);
         gcmkFOOTER_NO();
         return gcvSTATUS_OK;
     }
@@ -8981,7 +9132,7 @@ gckHARDWARE_SetPowerState(
         state == gcvPOWER_SUSPEND && Hardware->chipPowerState == gcvPOWER_OFF)
     {
         /* Do nothing, donot change chipPowerState. */
-        gckOS_ReleaseMutex(os, Hardware->powerMutex)
+        gckOS_ReleaseMutex(os, Hardware->powerMutex);
         gcmkFOOTER_NO();
         return gcvSTATUS_OK;
     }
@@ -8991,7 +9142,7 @@ gckHARDWARE_SetPowerState(
         if (Hardware->nextPowerState == gcvPOWER_INVALID)
         {
             /* delayed power state change is canceled. */
-            gckOS_ReleaseMutex(os, Hardware->powerMutex)
+            gckOS_ReleaseMutex(os, Hardware->powerMutex);
             gcmkFOOTER_NO();
             return gcvSTATUS_OK;
         }
@@ -9202,7 +9353,8 @@ gckHARDWARE_SetPowerState(
         Hardware->nextPowerState = gcvPOWER_OFF_TIMEOUT;
 
         /* Start a timer to power off GPU when GPU enters IDLE or SUSPEND. */
-        if(Hardware->powerTimeout > 0)
+        //gcmkVERIFY_OK(gckOS_StartTimer(os, Hardware->powerStateTimer, gcdPOWEROFF_TIMEOUT));
+		if(Hardware->powerTimeout > 0)
 		{
 			gcmkVERIFY_OK(gckOS_StartTimer(os, Hardware->powerStateTimer, Hardware->powerTimeout));
 		}
@@ -9977,8 +10129,8 @@ CalcDelta(
 #if USE_SW_RESET
 #define gcmkRESET_PROFILE_DATA_PART1(counterName) \
     temp = profiler_part1->counterName; \
-    profiler_part1->counterName = CalcDelta(temp, Context->preProfiler_part1.counterName); \
-    Context->preProfiler_part1.counterName = temp
+    profiler_part1->counterName = CalcDelta(temp, Hardware->kernel->profiler.preProfiler_part1.counterName); \
+    Hardware->kernel->profiler.preProfiler_part1.counterName = temp
 #endif
 
 #define gcmkUPDATE_PROFILE_DATA_PART1(data) \
@@ -9990,7 +10142,6 @@ gceSTATUS
 gckHARDWARE_QueryContextProfile(
     IN gckHARDWARE Hardware,
     IN gctBOOL Reset,
-    IN gckCONTEXT Context,
     OUT gcsPROFILER_COUNTERS_PART1 * Counters_part1,
     OUT gcsPROFILER_COUNTERS_PART2 * Counters_part2
 )
@@ -10005,10 +10156,6 @@ gckHARDWARE_QueryContextProfile(
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
 
-    if (!Context)
-    {
-        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
-    }
     /* Acquire the context sequnence mutex. */
     gcmkONERROR(gckOS_AcquireMutex(
         command->os, command->mutexContextSeq, gcvINFINITE
@@ -10018,13 +10165,13 @@ gckHARDWARE_QueryContextProfile(
     if (Counters_part1)
     {
         gcmkVERIFY_OK(gckOS_MemCopy(
-            profiler_part1, &Context->histroyProfiler_part1, gcmSIZEOF(gcsPROFILER_COUNTERS_PART1)
+            profiler_part1, &Hardware->kernel->profiler.histroyProfiler_part1, gcmSIZEOF(gcsPROFILER_COUNTERS_PART1)
             ));
     }
     else if (Counters_part2)
     {
         gcmkVERIFY_OK(gckOS_MemCopy(
-            profiler_part2, &Context->histroyProfiler_part2, gcmSIZEOF(gcsPROFILER_COUNTERS_PART2)
+            profiler_part2, &Hardware->kernel->profiler.histroyProfiler_part2, gcmSIZEOF(gcsPROFILER_COUNTERS_PART2)
             ));
     }
 
@@ -10034,13 +10181,13 @@ gckHARDWARE_QueryContextProfile(
         if (Counters_part1)
         {
             gcmkVERIFY_OK(gckOS_ZeroMemory(
-                &Context->histroyProfiler_part1, gcmSIZEOF(gcsPROFILER_COUNTERS_PART1)
+                &Hardware->kernel->profiler.histroyProfiler_part1, gcmSIZEOF(gcsPROFILER_COUNTERS_PART1)
                 ));
         }
         else if (Counters_part2)
         {
             gcmkVERIFY_OK(gckOS_ZeroMemory(
-                &Context->histroyProfiler_part2, gcmSIZEOF(gcsPROFILER_COUNTERS_PART2)
+                &Hardware->kernel->profiler.histroyProfiler_part2, gcmSIZEOF(gcsPROFILER_COUNTERS_PART2)
                 ));
         }
     }
@@ -10061,15 +10208,14 @@ gckHARDWARE_QueryContextProfile(
 
 gceSTATUS
 gckHARDWARE_UpdateContextProfile(
-    IN gckHARDWARE Hardware,
-    IN gckCONTEXT Context
+    IN gckHARDWARE Hardware
 )
 {
     gceSTATUS status;
-    gcsPROFILER_COUNTERS_PART1 * profiler_part1 = &Context->latestProfiler_part1;
-    gcsPROFILER_COUNTERS_PART1 * profilerHistroy_part1 = &Context->histroyProfiler_part1;
-    gcsPROFILER_COUNTERS_PART2 * profiler_part2 = &Context->latestProfiler_part2;
-    gcsPROFILER_COUNTERS_PART2 * profilerHistroy_part2 = &Context->histroyProfiler_part2;
+    gcsPROFILER_COUNTERS_PART1 * profiler_part1 = &Hardware->kernel->profiler.latestProfiler_part1;
+    gcsPROFILER_COUNTERS_PART1 * profilerHistroy_part1 = &Hardware->kernel->profiler.histroyProfiler_part1;
+    gcsPROFILER_COUNTERS_PART2 * profiler_part2 = &Hardware->kernel->profiler.latestProfiler_part2;
+    gcsPROFILER_COUNTERS_PART2 * profilerHistroy_part2 = &Hardware->kernel->profiler.histroyProfiler_part2;
     gceCHIPMODEL chipModel;
     gctUINT32 chipRevision;
     gctUINT32 i;
@@ -10083,11 +10229,10 @@ gckHARDWARE_UpdateContextProfile(
     gckCOMMAND command = Hardware->kernel->command;
     gctBOOL mutexAcquired = gcvFALSE;
 
-    gcmkHEADER_ARG("Hardware=0x%x Context=0x%x", Hardware, Context);
+    gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
     /* Verify the arguments. */
     gcmkVERIFY_OBJECT(Hardware, gcvOBJ_HARDWARE);
-    gcmkVERIFY_OBJECT(Context, gcvOBJ_CONTEXT);
 
     /* Acquire the context sequnence mutex. */
     gcmkONERROR(gckOS_AcquireMutex(
@@ -12073,7 +12218,6 @@ gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00478,   ((((g
     return status;
 }
 
-
 gceSTATUS
 gckHARDWARE_InitProfiler(
     IN gckHARDWARE Hardware
@@ -12675,7 +12819,7 @@ gckHARDWARE_DumpMMUException(
               Hardware->identity.chipRevision);
 
     gcmkPRINT("**************************\n");
-    gcmkPRINT("***   MMU ERROR DUMP   ***\n");
+    gcmkPRINT("***   MMU STATUS DUMP   ***\n");
     gcmkPRINT("**************************\n");
 
 
@@ -13136,7 +13280,7 @@ gckHARDWARE_DumpGPUState(
     };
 
     gceSTATUS status;
-    gctUINT32 idle = 0, axi = 0;
+    gctUINT32 idle = 0, axi = 0, hiControl = 0;
     gctUINT32 dmaAddress1 = 0, dmaAddress2 = 0;
     gctUINT32 dmaState1 = 0, dmaState2 = 0;
     gctUINT32 dmaLow = 0, dmaHigh = 0;
@@ -13192,6 +13336,7 @@ gckHARDWARE_DumpGPUState(
     veReqState  = (dmaState2 >> 16) & 0x03;
 
     gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00004, &idle));
+    gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00000, &hiControl));
     gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x0000C, &axi));
     gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00668, &dmaLow));
     gcmkONERROR(gckOS_ReadRegisterEx(os, core, 0x00668, &dmaLow));
@@ -13227,6 +13372,8 @@ gckHARDWARE_DumpGPUState(
     if ((idle & 0x00080000) == 0) gcmkPRINT_N(0, "    TP not idle\n");
     if ((idle & 0x80000000) != 0) gcmkPRINT_N(0, "    AXI low power mode\n");
 
+    gcmkPRINT_N(4, "  AQ_HI_CLOCK_CONTROL  = 0x%08X\n", hiControl);
+
     if ((dmaAddress1 == dmaAddress2)
      && (dmaState1 == dmaState2))
     {
@@ -14148,10 +14295,20 @@ gckHARDWARE_ExecuteFunctions(
     {
         address = Execution->funcCmd[i].address;
 
+#if gcdDUMP_IN_KERNEL
+        gcmkDUMP_BUFFER(
+            hardware->os,
+            gcvDUMP_BUFFER_KERNEL_COMMAND,
+            Execution->funcCmd[i].logical,
+            Execution->funcCmd[i].address,
+            Execution->funcCmd[i].bytes
+            );
+#endif
+
         /* Execute prepared command sequence. */
         if (hardware->mcFE)
         {
-            gcmkONERROR(gckMCFE_Execute(hardware, gcvFALSE, 0, address, Execution->funcCmd[i].bytes));
+            gcmkONERROR(gckMCFE_Execute(hardware, gcvFALSE, Execution->funcCmd[i].channelId, address, Execution->funcCmd[i].bytes));
         }
         else
         {
@@ -14173,16 +14330,6 @@ gckHARDWARE_ExecuteFunctions(
         }
 #endif
 
-#if gcdDUMP_IN_KERNEL
-        gcmkDUMP_BUFFER(
-            hardware->os,
-            gcvDUMP_BUFFER_KERNEL_COMMAND,
-            Execution->funcCmd[i].logical,
-            Execution->funcCmd[i].address,
-            Execution->funcCmd[i].bytes
-            );
-#endif
-
         /* Wait until GPU idle. */
         do
         {
@@ -14214,9 +14361,8 @@ gckHARDWARE_ExecuteFunctions(
             }
 #endif
         }
-        while (!_IsGPUIdle(idle));
+        while (!_IsHWIdle(idle, hardware));
     }
-
     return gcvSTATUS_OK;
 
 OnError:
@@ -16481,7 +16627,6 @@ gckHARDWARE_ExitQueryClock(
 
         if (!shCycle)
         {
-            /*TODO: [VIV] Query SH cycle not support for old chips */
             *ShClk = *McClk;
             return gcvSTATUS_OK;
         }
@@ -16678,7 +16823,7 @@ gckHARDWARE_SetClock(
 
     if (mcScale > 0 && mcScale <= 64)
     {
-        gckOS_ReadRegisterEx(Hardware->os, core, 0x00000, &org);
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, core, 0x00000, &org));
 
         org = ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  8:2) - (0 ?
@@ -16692,7 +16837,7 @@ gckHARDWARE_SetClock(
  ~0U : (~(~0U << ((1 ? 8:2) - (0 ? 8:2) + 1))))))) << (0 ? 8:2)));
 
         /* Write the clock control register. */
-        gckOS_WriteRegisterEx(Hardware->os, core,
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, core,
                             0x00000,
                             ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  9:9) - (0 ?
@@ -16703,10 +16848,10 @@ gckHARDWARE_SetClock(
  9:9))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
  9:9) - (0 ?
  9:9) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))));
+ ~0U : (~(~0U << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
 
         /* Done loading the frequency scaler. */
-        gckOS_WriteRegisterEx(Hardware->os, core,
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, core,
                             0x00000,
                             ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  9:9) - (0 ?
@@ -16717,21 +16862,21 @@ gckHARDWARE_SetClock(
  9:9))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
  9:9) - (0 ?
  9:9) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9))));
+ ~0U : (~(~0U << ((1 ? 9:9) - (0 ? 9:9) + 1))))))) << (0 ? 9:9)))));
 
         /* Need to change 0x0010C when it is introduced. */
-        gckOS_ReadRegisterEx(Hardware->os, core, 0x0010C, &org);
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, core, 0x0010C, &org));
 
         /* Never impact shader clk. */
         org = 0x01020800 | (org & 0xFF);
 
-        gckOS_WriteRegisterEx(Hardware->os, core, 0x0010C, org);
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, core, 0x0010C, org));
     }
 
     /* set SH clock */
     if (shScale > 0 && shScale <= 64)
     {
-        gckOS_ReadRegisterEx(Hardware->os, core, 0x0010C, &org);
+        gcmkONERROR(gckOS_ReadRegisterEx(Hardware->os, core, 0x0010C, &org));
 
         org = ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  7:1) - (0 ?
@@ -16765,7 +16910,7 @@ gckHARDWARE_SetClock(
  ~0U : (~(~0U << ((1 ? 17:17) - (0 ? 17:17) + 1))))))) << (0 ? 17:17)));
 
         /* Write the clock control register. */
-        gckOS_WriteRegisterEx(Hardware->os, core,
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, core,
                             0x0010C,
                             ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  0:0) - (0 ?
@@ -16776,10 +16921,10 @@ gckHARDWARE_SetClock(
  0:0))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
  0:0) - (0 ?
  0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))));
+ ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))));
 
         /* Done loading the frequency scaler. */
-        gckOS_WriteRegisterEx(Hardware->os, core,
+        gcmkONERROR(gckOS_WriteRegisterEx(Hardware->os, core,
                             0x0010C,
                             ((((gctUINT32) (org)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  0:0) - (0 ?
@@ -16790,7 +16935,7 @@ gckHARDWARE_SetClock(
  0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
  0:0) - (0 ?
  0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0))));
+ ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))));
     }
 
     /* Release the global semaphore. */
@@ -16818,3 +16963,199 @@ gckHARDWARE_SetClock(
     return status;
 }
 
+gceSTATUS
+gckHARDWARE_QueryCycleCount(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 *hi_total_cycle_count,
+    OUT gctUINT32 *hi_total_idle_cycle_count
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gceCHIPMODEL chipModel;
+
+    gcmkHEADER_ARG("Hardware=0x%p hi_total_cycle_count=0x%p hi_total_idle_cycle_count=0x%p", Hardware, hi_total_cycle_count, hi_total_idle_cycle_count);
+
+    gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
+
+    chipModel = Hardware->identity.chipModel;
+
+    if (chipModel == gcv2100 || chipModel == gcv2000 || chipModel == gcv880)
+    {
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+            Hardware->core,
+            0x00078,
+            hi_total_idle_cycle_count));
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+            Hardware->core,
+            0x00438,
+            hi_total_cycle_count));
+     }
+     else
+     {
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+            Hardware->core,
+            0x0007C,
+            hi_total_idle_cycle_count));
+
+        gcmkONERROR(
+            gckOS_ReadRegisterEx(Hardware->os,
+            Hardware->core,
+            0x00078,
+            hi_total_cycle_count));
+      }
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_CleanCycleCount(
+    IN gckHARDWARE Hardware
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+
+    gcmkHEADER_ARG("Hardware=0x%p", Hardware);
+
+    gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
+
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x0007C, 0));
+
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00438, 0));
+
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os, Hardware->core, 0x00078, 0));
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
+gceSTATUS
+gckHARDWARE_QueryCoreLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 *Load
+    )
+{
+    gctUINT32 i = 0;
+    gceSTATUS status = gcvSTATUS_OK;
+    gceCHIPPOWERSTATE statesStored, state;
+    gctBOOL powerManagement = gcvFALSE;
+    static gctUINT32 hardwareCount = 0;
+    static gctBOOL profilerEnable = gcvFALSE;
+    gckHARDWARE hardware[gcvCORE_3D_MAX + 1] = {gcvNULL};
+    gctUINT32 hi_total_cycle_count = 0, hi_total_idle_cycle_count =0;
+
+    gcmkHEADER_ARG("Hardware=0x%p Load=0x%p", Hardware, Load);
+
+    gcmkVERIFY_ARGUMENT(Hardware != gcvNULL);
+
+    powerManagement = Hardware->options.powerManagement;
+
+    if (powerManagement)
+    {
+        gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+        Hardware, gcvFALSE
+        ));
+    }
+
+    gcmkONERROR(gckHARDWARE_QueryPowerState(
+        Hardware, &statesStored
+        ));
+
+    gcmkONERROR(gckHARDWARE_SetPowerState(
+        Hardware, gcvPOWER_ON_AUTO
+        ));
+
+    if (hardwareCount == 0)
+    {
+        hardware[0] = Hardware;
+        hardwareCount = 1;
+    }
+    else
+    {
+        for (i = 0; i < hardwareCount; i++)
+        {
+            if (Hardware == hardware[i])
+            {
+                break;
+            }
+            else if (i == hardwareCount - 1)
+            {
+                profilerEnable = gcvFALSE;
+                hardware[hardwareCount] = Hardware;
+                hardwareCount++;
+                break;
+            }
+        }
+    }
+
+    if (!profilerEnable)
+    {
+        gcmkONERROR(gckHARDWARE_SetGpuProfiler(
+            Hardware,
+            gcvTRUE
+            ));
+
+        gcmkONERROR(gckHARDWARE_InitProfiler(Hardware));
+
+        profilerEnable = gcvTRUE;
+    }
+
+    Hardware->waitCount = 200 * 100;
+
+    gcmkONERROR(gckHARDWARE_CleanCycleCount(Hardware));
+
+    gcmkONERROR(gckHARDWARE_QueryCycleCount(Hardware,
+        &hi_total_cycle_count,
+        &hi_total_idle_cycle_count));
+
+    switch(statesStored)
+    {
+    case gcvPOWER_OFF:
+        state = gcvPOWER_OFF_BROADCAST;
+        break;
+    case gcvPOWER_IDLE:
+        state = gcvPOWER_IDLE_BROADCAST;
+        break;
+    case gcvPOWER_SUSPEND:
+        state = gcvPOWER_SUSPEND_BROADCAST;
+        break;
+    case gcvPOWER_ON:
+        state = gcvPOWER_ON_AUTO;
+        break;
+    default:
+        state = statesStored;
+        break;
+    }
+
+    Hardware->waitCount = 200;
+
+    if (powerManagement)
+    {
+        gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+            Hardware, gcvTRUE
+            ));
+    }
+
+    gcmkONERROR(gckHARDWARE_SetPowerState(
+        Hardware, state
+        ));
+
+    *Load = (hi_total_cycle_count - hi_total_idle_cycle_count) * 100 / hi_total_cycle_count;
+
+OnError:
+    /* Return the status. */
+    gcmkFOOTER();
+    return status;
+}
+
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.h
index 5cb006452d8a..e309b46fde2c 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -310,6 +310,31 @@ gckHARDWARE_SetClock(
     IN gctUINT32 SHScale
     );
 
+gceSTATUS
+gckHARDWARE_PowerControlClusters(
+    gckHARDWARE Hardware,
+    gctUINT32  PowerControlValue,
+    gctBOOL PowerState
+    );
+
+gceSTATUS
+gckHARDWARE_QueryCycleCount(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 *hi_total_cycle_count,
+    OUT gctUINT32 *hi_total_idle_cycle_count
+    );
+
+gceSTATUS
+gckHARDWARE_CleanCycleCount(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_QueryCoreLoad(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32 *Load
+    );
+
 #define gcmkWRITE_MEMORY(logical, data) \
     do { \
     gcmkVERIFY_OK(gckOS_WriteMemory(os, logical, data)); \
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_async_fe.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_async_fe.c
index a339e5ac8005..2e79d81e2ab6 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_async_fe.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_async_fe.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_fe.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_fe.h
index cc397e8f2d45..59e1c6947a1f 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_fe.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_fe.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.c
index c33d53a701ac..c250ba89e7f4 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -2319,6 +2319,7 @@ _FuncRelease(
         if(command->golden)
         {
             gcmkVERIFY_OK(gckOS_Free(hardware->os, (gctPOINTER)command->golden));
+            command->golden = gcvNULL;
         }
 #endif
 
@@ -2417,35 +2418,41 @@ _FuncExecute(IN gcsFUNCTION_EXECUTION_PTR Execution)
     return gckHARDWARE_ExecuteFunctions(Execution);
 }
 
+#if gcdFLOP_RESET
 static gceSTATUS
 _FuncExecute_FLOPRESET(IN gcsFUNCTION_EXECUTION_PTR Execution)
 {
 #if gcdENABLE_FLOP_RESET_DEBUG
-    gctUINT32 i = 0, j = 0, minus_flag = 0;
+    gctUINT32 i=0, j=0, minus_flag = 0;
 #endif
 
     gceSTATUS status = gckHARDWARE_ExecuteFunctions(Execution);
+
 #if gcdENABLE_FLOP_RESET_DEBUG && gcdFLOP_RESET_PPU
     minus_flag += 1;
 #endif
 
-    //check output;
+
 #if gcdENABLE_FLOP_RESET_DEBUG
     for (i  = 0; i < Execution->funcCmdCount - minus_flag; i++)
     {
-        //ignore PPU
         gcmkPRINT("outSizeBytes is : %d", Execution->funcCmd[i].outSize);
+        gcmkPRINT("outAddress is %x", Execution->funcCmd[i].data[2].address);
         for(j = 0; j < Execution->funcCmd[i].outSize; j++ )
         {
-            if(((char*)(Execution->funcCmd[i].golden))[j] != ((char*)(Execution->funcCmd[i].outlogical))[j])
+            if(((gctUINT8_PTR)(Execution->funcCmd[i].golden))[j] != ((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[j])
             {
                 if(i == 0)
                 {
+                    gcmkPRINT("top 2 outputBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[1]);
+                    gcmkPRINT("top 2 goldenBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].golden))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].golden))[1]);
                     gcmkPRINT("NN workaround verify failed!");
                     return status;
                 }
                 else if(i == 1)
                 {
+                    gcmkPRINT("top 2 outputBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[1]);
+                    gcmkPRINT("top 2 goldenBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].golden))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].golden))[1]);
                     gcmkPRINT("TP workaround verify failed!");
                     return status;
                 }
@@ -2453,13 +2460,14 @@ _FuncExecute_FLOPRESET(IN gcsFUNCTION_EXECUTION_PTR Execution)
         }
         if(i == 0)
         {
-            gcmkPRINT("top 2 outputBytes: %c, %c",((char*)(Execution->funcCmd[i].outlogical))[0], ((char*)(Execution->funcCmd[i].outlogical))[1]);
-            gcmkPRINT("top 2 goldenBytes: %c, %c",((char*)(Execution->funcCmd[i].golden))[0], ((char*)(Execution->funcCmd[i].golden))[1]);
-            //gcmkPRINT("when copmaring gloden address is %p", Execution->funcCmd[i].golden);
+            gcmkPRINT("top 2 outputBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[1]);
+            gcmkPRINT("top 2 goldenBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].golden))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].golden))[1]);
             gcmkPRINT("NN workaround verify success!");
         }
         else
         {
+            gcmkPRINT("top 2 outputBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].outlogical))[1]);
+            gcmkPRINT("top 2 goldenBytes: %x, %x",((gctUINT8_PTR)(Execution->funcCmd[i].golden))[0], ((gctUINT8_PTR)(Execution->funcCmd[i].golden))[1]);
             gcmkPRINT("TP workaround verify success!");
         }
     }
@@ -2467,6 +2475,8 @@ _FuncExecute_FLOPRESET(IN gcsFUNCTION_EXECUTION_PTR Execution)
 
     return status;
 }
+#endif
+
 static gceSTATUS
 _FuncValidate_MMU(IN gcsFUNCTION_EXECUTION_PTR Execution)
 {
@@ -2524,48 +2534,6 @@ _FuncRelease_MMU(IN gcsFUNCTION_EXECUTION_PTR Execution)
     return gcvSTATUS_OK;
 }
 
-gceSTATUS
-_QueryNNClusters(
-    gckHARDWARE Hardware,
-    gctUINT32 * Value
-    )
-{
-    gctUINT64 enableNN = 0xFF;
-    gctUINT32 value = 0;
-    gceSTATUS status = gcvSTATUS_OK;
-
-    if (gcmIS_SUCCESS(gckOS_QueryOption(Hardware->os, "enableNN", &enableNN)))
-    {
-        if (!enableNN)
-        {
-            value = 0x2;
-        }
-        else if (enableNN == 0xFF || (enableNN == Hardware->identity.nnClusterNum))
-        {
-            value = 0;
-        }
-        else
-        {
-            /* We only support maximum 8 clusters by current. */
-            if (enableNN > 0x7)
-            {
-                gcmkPRINT("[Galcore warning]: Invalid enableNN value is configured.");
-
-                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
-            }
-
-            value = (gctUINT32)enableNN + 0x2;
-        }
-    }
-
-    Hardware->options.enableNNClusters = (gctUINT32)enableNN;
-    Hardware->options.configNNPowerControl = value;
-
-    *Value = value;
-
-OnError:
-    return status;
-}
 
 static gceSTATUS
 _ProgramMMUStates(
@@ -2583,8 +2551,6 @@ _ProgramMMUStates(
     gctUINT32_PTR buffer;
     gctBOOL ace;
     gctUINT32 reserveBytes = 0;
-    gctUINT32 nnConfig = 0;
-
     gctBOOL config2D;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
@@ -2759,7 +2725,7 @@ _ProgramMMUStates(
             gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
                      (unsigned long long)Hardware->pagetableArray.address + 4, entry->high, 4);
 
-            gcmkVERIFY_OK(gckVIDMEM_NODE_CleanCache(
+            gcmkONERROR(gckVIDMEM_NODE_CleanCache(
                 Hardware->kernel,
                 Hardware->pagetableArray.videoMem,
                 0,
@@ -2999,57 +2965,6 @@ _ProgramMMUStates(
  22:22) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ? 22:22) - (0 ? 22:22) + 1))))))) << (0 ? 22:22)));
 
-        gcmkONERROR(_QueryNNClusters(Hardware, &nnConfig));
-
-        if (nnConfig)
-        {
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E4C) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 11:8) - (0 ?
- 11:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 11:8) - (0 ?
- 11:8) + 1))))))) << (0 ?
- 11:8))) | (((gctUINT32) ((gctUINT32) (nnConfig) & ((gctUINT32) ((((1 ?
- 11:8) - (0 ?
- 11:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)));
-
-            reserveBytes += 8;
-        }
-
         do{*buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  31:27) - (0 ?
  31:27) + 1) == 32) ?
@@ -3526,7 +3441,6 @@ _ProgramMMUStatesMCFE(
     gctUINT32_PTR buffer;
     gctBOOL ace;
     gctUINT32 reserveBytes = 0;
-    gctUINT32 nnConfig = 0;
 
     gcmkHEADER_ARG("Hardware=0x%x", Hardware);
 
@@ -3681,7 +3595,7 @@ _ProgramMMUStatesMCFE(
             gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
                      (unsigned long long)Hardware->pagetableArray.address + 4, entry->high, 4);
 
-            gcmkVERIFY_OK(gckVIDMEM_NODE_CleanCache(
+            gcmkONERROR(gckVIDMEM_NODE_CleanCache(
                 Hardware->kernel,
                 Hardware->pagetableArray.videoMem,
                 0,
@@ -3897,86 +3811,6 @@ _ProgramMMUStatesMCFE(
  ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
             }
         }
-
-        gcmkONERROR(_QueryNNClusters(Hardware, &nnConfig));
-
-        if (nnConfig)
-        {
-            if (Hardware->identity.customerID != 0x85)
-            {
-                gcmkPRINT("Galcore info: Don't set enableNN as this chip not support NN cluster power control!\n");
-                gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-            }
-
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E4C) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-
-            *buffer++
-                = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 11:8) - (0 ?
- 11:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 11:8) - (0 ?
- 11:8) + 1))))))) << (0 ?
- 11:8))) | (((gctUINT32) ((gctUINT32) (nnConfig) & ((gctUINT32) ((((1 ?
- 11:8) - (0 ?
- 11:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)));
-
-            *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x03 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
-            *buffer++ = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x03 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)));
-
-            reserveBytes += 16;
-        }
-
-
     }
 
     if (Bytes != gcvNULL)
@@ -4019,11 +3853,11 @@ _FuncInit_MMU(IN gcsFUNCTION_EXECUTION_PTR Execution)
     mode = gcvMMU_MODE_4K;
 #endif
 
-#if defined(CONFIG_ZONE_DMA32)
+#if defined(CONFIG_ZONE_DMA32) || defined(CONFIG_ZONE_DMA)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
     if (!gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_MMU_PAGE_DESCRIPTOR))
     {
-        flags |= gcvALLOC_FLAG_4GB_ADDR;
+        flags |= gcvALLOC_FLAG_4GB_ADDR | gcvALLOC_FLAG_4K_PAGES;
     }
 #endif
 #endif
@@ -4302,7 +4136,7 @@ _FuncExecute_MMU_CMD(IN gcsFUNCTION_EXECUTION_PTR Execution)
     gceSTATUS status = gcvSTATUS_OK;
     gctUINT32 address = 0;
     gctUINT32 idle;
-    gctUINT32 timer = 0, delay = 1;
+    gctUINT32 timer = 0, delay = 10;
     gckHARDWARE hardware = (gckHARDWARE)Execution->hardware;
     gckMMU mmu = hardware->kernel->mmu;
     gctUINT32_PTR endLogical = (gctUINT32_PTR)Execution->funcCmd[0].endLogical;
@@ -4491,7 +4325,7 @@ _FuncExecute_MMU_CMD(IN gcsFUNCTION_EXECUTION_PTR Execution)
     /* Wait until MMU configure finishes. */
     do
     {
-        gckOS_Delay(hardware->os, delay);
+        gckOS_Udelay(hardware->os, delay);
 
         gcmkONERROR(gckOS_ReadRegisterEx(
             hardware->os,
@@ -4683,6 +4517,7 @@ _FuncInit_Flush(IN gcsFUNCTION_EXECUTION_PTR Execution)
     Execution->funcCmd = (gcsFUNCTION_COMMAND_PTR)pointer;
 
     Execution->funcCmd[0].funcVidMemBytes = 1024;
+    Execution->funcCmd[0].channelId = 0;
     /* Allocate video memory node for aux functions. */
     gcmkONERROR(gckKERNEL_AllocateVideoMemory(
                 hardware->kernel,
@@ -4766,6 +4601,10 @@ _FuncValidate_FlopReset(
     {
         Execution->valid = gcvTRUE;
     }
+    if(hardware->identity.customerID == 0x15)
+    {
+        Execution->valid = gcvTRUE;
+    }
 #endif
 
     return status;
@@ -4776,8 +4615,14 @@ gceSTATUS gckFUNCTION_CheckCHIPID(
     )
 {
     gckHARDWARE hardware = (gckHARDWARE)Execution->hardware;
-    if( (hardware->identity.customerID == 0xb5) || (hardware->identity.customerID == 0x9f) || (hardware->identity.customerID == 0x99) ||
-        (hardware->identity.customerID == 0xa1) || (hardware->identity.customerID == 0x88) || (hardware->identity.customerID == 0x98))
+    if((hardware->identity.customerID == 0xb5) || (hardware->identity.customerID == 0x9f) || (hardware->identity.customerID == 0x7d) || (hardware->identity.customerID == 0x99) ||
+        (hardware->identity.customerID == 0xa1) || (hardware->identity.customerID == 0x88) || (hardware->identity.customerID == 0x98) || (hardware->identity.customerID == 0x92) ||
+        (hardware->identity.customerID == 0xa3) || (hardware->identity.customerID == 0xa9) ||(hardware->identity.customerID == 0x97) || (hardware->identity.customerID == 0x82) ||
+        (hardware->identity.customerID == 0x84) || (hardware->identity.customerID == 0x9) || (hardware->identity.customerID == 0xa0) || (hardware->identity.customerID == 0xa5) ||
+        (hardware->identity.customerID == 0x23) || (hardware->identity.customerID == 0xb3) || (hardware->identity.customerID == 0x96) || (hardware->identity.customerID == 0x86) ||
+        (hardware->identity.customerID == 0x83) || (hardware->identity.customerID == 0x7f) || (hardware->identity.customerID == 0x80) || (hardware->identity.customerID == 0x15) ||
+        (hardware->identity.customerID == 0x85)
+    )
     {
         return gcvSTATUS_TRUE;
     }
@@ -4803,7 +4648,7 @@ _FuncInit_FlopReset(
     Execution->funcCmdCount = 0;
 
 #if gcdFLOP_RESET_NN
-    if ((gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_NN_ENGINE) && (hardware->identity.customerID == 0x9f)) || (gckFUNCTION_CheckCHIPID(Execution) && gcdENABLE_FLOP_RESET))
+    if ((gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_NN_ENGINE) && (hardware->identity.customerID == 0x9f)) || gckFUNCTION_CheckCHIPID(Execution))
     {
         doNN = gcvTRUE;
         Execution->funcCmdCount++;
@@ -4811,7 +4656,7 @@ _FuncInit_FlopReset(
 #endif
 
 #if gcdFLOP_RESET_TP
-    if ((gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_NN_ENGINE) && (hardware->identity.customerID == 0x9f)) || (gckFUNCTION_CheckCHIPID(Execution) && gcdENABLE_FLOP_RESET))
+    if ((gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_TP_ENGINE) && (hardware->identity.customerID == 0x9f)) || gckFUNCTION_CheckCHIPID(Execution))
     {
         doTP = gcvTRUE;
         Execution->funcCmdCount++;
@@ -4819,7 +4664,6 @@ _FuncInit_FlopReset(
 #endif
 
 #if gcdFLOP_RESET_PPU
-    /* PPU is always there. */
     doPPU = gcvTRUE;
     Execution->funcCmdCount++;
 #endif
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.h
index 5f4bb302d6a8..f1412041e2b9 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -156,6 +156,9 @@ typedef struct _gcsFUNCTION_COMMAND
     /* Physical of End in this function. */
     gctPHYS_ADDR_T              endPhysical;
 
+    /* mcfe channel set. */
+    gctUINT32                   channelId;
+
     /* Function private data */
     gctUINT32                   dataCount;
     gcsFUNCTION_EXECUTION_DATA_PTR data;
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.c
index cfb939653d4c..0446777d873e 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -58,8 +58,6 @@
 #include "gc_hal_kernel_hardware_func_flop_reset.h"
 #include "gc_hal_kernel_hardware_func_flop_reset_config.h"
 
-
-
 /*
  * Flop reset.
  *
@@ -96,76 +94,7 @@
 /*
  * PPU.
  */
-#define PPU_IMAGE_XSIZE 64
-#define PPU_IMAGE_YSIZE 6
-#define PPU_IMAGE_DATA 0x01010101
-#define MAX_PPU_INSTRUCTION_COUNT 16
-#define MAX_PPU_COMMAND_NUM 128
-
-#define GCREG_SH_INSTRUCTION_TYPE_INVALID (~0U)
-
-typedef enum _gceFLOP_RESET_PPU_DATA {
-    gcvFLOP_RESET_PPU_INSTRUCTION = 0,
-    gcvFLOP_RESET_PPU_INPUT       = 1,
-    gcvFLOP_RESET_PPU_OUTPUT      = 2,
-    gcvFLOP_RESET_PPU_DATA_NUM
-}
-gceFLOP_RESET_PPU_DATA;
-
-/*
- * NN convolution.
- */
-#define MAX_NN_COMMAND_NUM 192
-
-#define NN_KERNEL_XSIZE 2
-#define NN_KERNEL_YSIZE 2
-#define NN_KERNEL_ZSIZE 1
-
-#define NN_INPUT_XSIZE 3
-#define NN_INPUT_YSIZE 2
-#define NN_INPUT_ZSIZE 1
 
-#define NN_OUTPUT_XSIZE 2
-#define NN_OUTPUT_YSIZE 1
-#define NN_OUTPUT_ZSIZE 1
-
-typedef enum _gceVIP_ARCH_TYPE {
-    gcvVIP_ARCH_TYPE_V6,
-    gcvVIP_ARCH_TYPE_V7,
-    gcvVIP_ARCH_TYPE_V8
-}
-gceVIP_ARCH_TYPE;
-
-typedef enum _gceFLOP_RESET_NN_DATA {
-    gcvFLOP_RESET_NN_INSTRUCTION = 0,
-    gcvFLOP_RESET_NN_INPUT       = 1,
-    gcvFLOP_RESET_NN_OUTPUT      = 2,
-    gcvFLOP_RESET_NN_KERNEL      = 3,
-    gcvFLOP_RESET_NN_DATA_NUM
-}
-gceFLOP_RESET_NN_DATA;
-
-#define TP_KERNEL_XSIZE 1
-#define TP_KERNEL_YSIZE 1
-#define TP_KERNEL_ZSIZE 2
-#define TP_KENREL_UNITS 64
-
-#define TP_INPUT_XSIZE 1
-#define TP_INPUT_YSIZE 1
-#define TP_INPUT_ZSIZE 2
-
-#define TP_OUTPUT_XSIZE 1
-#define TP_OUTPUT_YSIZE 64
-#define TP_OUTPUT_ZSIZE 1
-
-typedef enum _gceFLOP_RESET_TP_DATA {
-    gcvFLOP_RESET_TP_INSTRUCTION = 0,
-    gcvFLOP_RESET_TP_INPUT       = 1,
-    gcvFLOP_RESET_TP_OUTPUT      = 2,
-    gcvFLOP_RESET_TP_KERNEL      = 3,
-    gcvFLOP_RESET_TP_DATA_NUM
-}
-gceFLOP_RESET_TP_DATA;
 
 
 static gceSTATUS
@@ -457,6 +386,15 @@ _GetVIPCoreInfo(
         *ArchType = archType;
     }
 
+    if(Hardware->identity.customerID == 0x23 || Hardware->identity.customerID == 0x83)
+    {
+        dataType = 0x1;
+    }
+    else if(Hardware->identity.customerID == 0x96)
+    {
+        dataType = 0x2;
+    }
+
     if (DataType)
     {
         *DataType = dataType;
@@ -483,42 +421,6 @@ _GetVIPCoreInfo(
     return status;
 }
 
-#if gcdENABLE_FLOP_RESET == 0
-static gceSTATUS
-_GetMapIndex(
-    gctUINT8 DataType,
-    gctUINT32_PTR Index
-    )
-{
-    gceSTATUS status = gcvSTATUS_OK;
-
-    if (!Index)
-    {
-        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
-    }
-
-    switch (DataType)
-    {
-    case 0x1:
-        *Index = 1;
-        break;
-
-    case 0x7:
-        *Index = 2;
-        break;
-
-    default:
-        *Index = 0;
-        break;
-    }
-
-    return gcvSTATUS_OK;
-
-OnError:
-    return status;
-}
-#endif
-
 static gceSTATUS
 _GetNNDataSize(
    IN gctUINT8 DataType,
@@ -579,7 +481,7 @@ _ProgramPPUInput(
     gctUINT32 *buffer = gcvNULL;
     gctUINT32 i;
 
-    bufferBytes = bytes = InImageXSize * InImageYSize * itemBytes;
+    bufferBytes = bytes = (gctSIZE_T)(InImageXSize * InImageYSize * itemBytes);
 
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -657,7 +559,7 @@ _ProgramPPUOutput(
     gctUINT32 bufferAddress = 0;
     gctSIZE_T bufferBytes, bytes;
 
-    bufferBytes = bytes = Width * Height * itemBytes;
+    bufferBytes = bytes = (gctSIZE_T)(Width * Height * itemBytes);
 
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -1153,6 +1055,10 @@ gckPPU_AddOpCode(
 {
     gceSTATUS status = gcvSTATUS_OK;
 
+    if (!Inst)
+    {
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
 
     Inst[0] = ((((gctUINT32) (Inst[0])) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  5:0) - (0 ?
@@ -1175,11 +1081,6 @@ gckPPU_AddOpCode(
  16:16) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)));
 
-    if (!Inst)
-    {
-        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
-    }
-
     switch (OpCode)
     {
     case 0x7F:
@@ -1696,6 +1597,7 @@ static gceSTATUS
 _ProgramPPUInstruction(
     IN gckHARDWARE Hardware,
     IN gctUINT32 DataType,
+    IN gctUINT32 numShaderCores,
     IN gctUINT32 AllocFlag,
     IN OUT gcePOOL *Pool,
     OUT gctUINT32 *InstCount,
@@ -1764,7 +1666,7 @@ _ProgramPPUInstruction(
 
     /* img_store.u8 r1, c2, r0.xy, r1 */
     gcmkONERROR(gckPPU_AddOpCode(Hardware, 0x7A, 0, outImageDataType, &inst[instCount]));
-    gcmkONERROR(gckPPU_SetEVIS(0, gckPPU_GetPixel(outImageDataType), 1, &inst[instCount]));
+    gcmkONERROR(gckPPU_SetEVIS(0, (gckPPU_GetPixel(outImageDataType) + 1) / numShaderCores - 1, 1, &inst[instCount]));
     gcmkONERROR(gckPPU_SetUniform(0, 1, gcdVX_SWIZZLE, 0, &inst[instCount]));
     gcmkONERROR(gckPPU_SetTempReg(1, 0, gcdVX_SWIZZLE2(0, 1), 0, &inst[instCount]));
     gcmkONERROR(gckPPU_SetTempReg(2, 1, gcdVX_SWIZZLE, 0, &inst[instCount]));
@@ -4138,6 +4040,7 @@ gckHARDWARE_ResetFlopWithPPU(
     gcmkONERROR(_ProgramPPUInstruction(
         Hardware,
         dataType,
+        numShaderCores,
         AllocFlag,
         Pool,
         &instCount,
@@ -4190,6 +4093,10 @@ gckHARDWARE_ResetFlopWithPPU(
 
     Command->data = data;
     Command->dataCount = dataCount;
+    if(Hardware->identity.customerID == 0x85)
+    {
+        Command->channelId = 1;
+    }
 
     return gcvSTATUS_OK;
 
@@ -4228,253 +4135,16 @@ gckHARDWARE_ResetFlopWithPPU(
 static gceSTATUS
 _ProgramNNKernel(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
-    IN gctUINT32 CoreCount,
-    IN gctUINT32 Zdp,
     IN gctUINT8 DataType,
     IN gctUINT32 KernelXSize,
     IN gctUINT32 KernelYSize,
     IN gctUINT32 KernelZSize,
+    IN chipCmdData* cd,
     IN gctUINT32 AllocFlag,
     IN OUT gcePOOL *Pool,
     OUT gcsFUNCTION_EXECUTION_DATA *Data
     )
 {
-#if gcdENABLE_FLOP_RESET == 0
-    gceSTATUS status = gcvSTATUS_OK;
-
-    gctUINT32 filterBytes = 0;
-    gctUINT8_PTR kernels = gcvNULL;
-    gctUINT32 offset = 0;
-    gctUINT8_PTR kernelStreamSizePtr = gcvNULL;
-    gctUINT32 filterTotalCount = 1;
-    gctUINT32 itemBytes = 1;
-    gctUINT32 biasBytes = 4;
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress = 0;
-    gctSIZE_T bufferBytes, bytes;
-
-    gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
-
-    filterBytes = KernelXSize * KernelYSize * KernelZSize * itemBytes;
-
-    /* Kernel buffer. */
-    if (gcvVIP_ARCH_TYPE_V8 == ArchType)
-    {
-        /* Head (align to 64) + body (align to 64) + tail (align to 64). */
-        gcmkASSERT(Zdp == 1 || Zdp == 3);
-        bufferBytes = 64 + gcmALIGN_NP2((gcmALIGN_NP2(filterBytes, Zdp * 3) * (Zdp * 3) * filterTotalCount) + (1 * (16 / itemBytes)), 64) + 64;
-    }
-    else
-    {
-        /* Head (align to 64) + body (align to 64). */
-        bufferBytes = 64 + gcmALIGN_NP2(((filterBytes + biasBytes +  3) * filterTotalCount + 3), 64);
-    }
-
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_BITMAP,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    kernels = (gctUINT8_PTR)bufferLogical;
-
-    /* V8 huffman encoder. */
-    if (gcvVIP_ARCH_TYPE_V8 == ArchType)
-    {
-        gctUINT32 i = 0;
-        gctUINT8 rlt[][18] = {
-            {0}, /* uint8 */
-            {1, 1, 0, 1}, /* fp16 */
-            {7, 1}, /* int8 */
-            {0}, /* uint16 */
-            {3, 1, 0, 1}, /* int16 */
-            {0}, /* uint4 */
-            {0}, /* int4 */
-            {1, 1, 0, 1}    /* bf16 */
-        };
-        gctUINT8 map[][9] = {
-            {1, 8, 7, 0, 4, 5, 6, 2, 3},
-            {1, 5, 0, 7, 8, 2, 6, 3, 4},
-            {1, 0, 7, 8, 4, 5, 6, 2, 3},
-        };
-        gctBOOL bit16 = DataType == 0x4 ||
-                        DataType == 0x1  ||
-                        DataType == 0x7;
-        gctBOOL fp16 = DataType == 0x1;
-        gctUINT32 index = 0;
-
-        if (Hardware->identity.customerID == 0x9f)
-        {
-            rlt[0][0] = 3;
-            rlt[0][1] = 1;
-            rlt[0][3] = 1;
-        }
-
-        gcmkONERROR(_GetMapIndex(DataType, &index));
-
-        gcmkONERROR(_BitValue(&kernels, 0, &offset, 1));        /* precode */
-        gcmkONERROR(_BitValue(&kernels, bit16, &offset, 1));    /* bit16 */
-        gcmkONERROR(_BitValue(&kernels, fp16, &offset, 1));     /* fp16 */
-        gcmkONERROR(_BitValue(&kernels, 0, &offset, 1));        /* reserved */
-        gcmkONERROR(_BitValue(&kernels, 1, &offset, 4));        /* version, 1 */
-        gcmkONERROR(_BitValue(&kernels, 4, &offset, 8));        /* zero run length size */
-
-        for (i = 0; i < 18; i++)
-        {
-            /* Zero run length x 18. */
-            gcmkONERROR(_BitValue(&kernels, rlt[DataType][i], &offset, 8));
-        }
-
-        for (i = 0; i < 4; i++)
-        {
-            /* Map x 4. */
-            gcmkONERROR(_BitValue(&kernels, (map[index][2 * i + 1] << 4) + map[index][2 * i], &offset, 8));
-        }
-
-        /* Avg bias */
-        gcmkONERROR(_BitValue(&kernels, 0, &offset, 16));
-
-        /* Reserved, must zero. */
-        gcmkONERROR(_BitValue(&kernels, 0, &offset, 16));
-
-        kernelStreamSizePtr = kernels;
-
-        for (i = 0; i < CoreCount; i ++)
-        {
-            /* Stream size. */
-            gcmkONERROR(_BitValue(&kernels, 0, &offset, 32));
-        }
-
-        kernels = (gctUINT8_PTR)bufferLogical + gcmALIGN_NP2((gctUINT32)((gctUINT8_PTR)kernels - (gctUINT8_PTR)bufferLogical), 64);
-
-        switch (DataType)
-        {
-        case 0x4:
-            /* Huffman data: 00000018 00924600 */
-            gcmkONERROR(_BitValue(&kernels, 0x04058000, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x640101fc, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x00001200, &offset, 32));
-
-            /* Only on core, stream size. */
-            gcmkONERROR(_BitValue(&kernelStreamSizePtr, 0x0000006d, &offset, 32));
-
-            break;
-
-        case 0x0:
-        case 0x2:
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0xec000038, &offset, 32));
-
-            /* Only on core, stream size. */
-            gcmkONERROR(_BitValue(&kernelStreamSizePtr, 0x35, &offset, 32));
-
-            break;
-
-        case 0x1:
-            /* Huffman data: 0009db68 000006c0 000001f0 00000900 00024000. */
-            gcmkONERROR(_BitValue(&kernels, 0x0009db68, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x000006c0, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x000001f0, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x00000900, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x00024000, &offset, 32));
-
-            /* Only on core, stream size. */
-            gcmkONERROR(_BitValue(&kernelStreamSizePtr, 0x000000a3, &offset, 32));
-
-            break;
-
-        case 0x7:
-            /* Huffman data: 0007fff8 7f00fdfc c0397f00 0900001f 40000000 00000002. */
-            gcmkONERROR(_BitValue(&kernels, 0x0007fff8, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x7f00fdfc, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0xc0397f00, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x0900001f, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x40000000, &offset, 32));
-            /* Huffman data. */
-            gcmkONERROR(_BitValue(&kernels, 0x00000002, &offset, 32));
-
-            /* Only on core, stream size. */
-            gcmkONERROR(_BitValue(&kernelStreamSizePtr, 0x000000b2, &offset, 32));
-
-            break;
-
-        default:
-            gcmkFATAL("Huffman encode not support this format! Please check!");
-            break;
-        }
-    }
-    else
-    {
-        gctBOOL zeroAll = gcvFALSE;
-        gctUINT8 zrl = 0;
-        gctUINT16 vzNum = 1;
-        gctUINT32 bias = 0;
-        gctUINT32 totalSize = gcmALIGN_NP2((filterTotalCount * (filterBytes + biasBytes +  3) + 3), 64);
-
-        gckOS_ZeroMemory(kernels, totalSize + 64);
-
-        *((gctUINT32_PTR)kernels) = totalSize;
-        kernels += totalSize;
-        if (zeroAll)
-        {
-            /*
-             * Zrl & coreFilterCount, both compressed weight and bias are zero,
-             * the size (1 * 1 * 2 * 2 + 4 ) < 64, aligned to 64.
-             */
-            *((gctUINT32_PTR)kernels) = (vzNum << (8 * itemBytes));
-        }
-        else
-        {
-            gctINT16 value = (DataType == 0x1) ? 0x3c00 /*1.0f*/ : 1;
-            gctUINT32 i = 0;
-
-            _BitValue(&kernels, zrl, &offset, 8);
-            _BitValue(&kernels, vzNum, &offset, 16);
-            _BitValue(&kernels, value, &offset, 8 * itemBytes);
-            _BitValue(&kernels, bias, &offset, 32);
-
-            if (DataType == 0x3 ||
-                DataType == 0x4)
-            {
-                _BitValue(&kernels, 0, &offset, 16);
-            }
-
-            for (i = 1; i < filterBytes / itemBytes; i++)
-            {
-                _BitValue(&kernels, value, &offset, 8 * itemBytes);
-            }
-        }
-    }
-
-    bytes = kernels + (offset + 7) / 8 - (gctUINT8_PTR)bufferLogical;
-
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
-
-
-#else
     gceSTATUS status = gcvSTATUS_OK;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
@@ -4482,15 +4152,10 @@ _ProgramNNKernel(
     gctSIZE_T bufferBytes;
     gctSIZE_T bytes = 0;
     gctUINT32 *buffer = gcvNULL;
-    chipCmdData *cd = gcvNULL;
+    gctBOOL need_refine = (Hardware->identity.customerID == 0x85 && Hardware->options.configNNPowerControl != 0);
 
     /*define bufferbytes*/
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
-    if(cd == gcvNULL)
-    {
-        return status;
-    }
-    bufferBytes = cd->NNkerLen;
+    bytes = bufferBytes = cd->NNkerLen;
     /* hardcode */
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -4506,8 +4171,17 @@ _ProgramNNKernel(
     buffer = (gctUINT32_PTR)bufferLogical;
 
     /* Fill the data. */
-    gckOS_MemCopy(bufferLogical, cd->NNKer, bufferBytes);
+    gckOS_MemCopy(bufferLogical, cd->NNKer, bytes);
 
+    if(need_refine)
+    {
+        buffer[16] = buffer[32];
+        buffer[17] = buffer[33];
+        buffer[18] = buffer[34];
+        buffer[32] = 0x0;
+        buffer[33] = 0x0;
+        buffer[34] = 0x0;
+    }
 
     gcmkONERROR(gckVIDMEM_NODE_CleanCache(
         Hardware->kernel,
@@ -4516,9 +4190,7 @@ _ProgramNNKernel(
         bufferLogical,
         bufferBytes
         ));
-    bytes = bufferBytes;
 
-#endif
 
 #if gcdDUMP_IN_KERNEL
     gcmkDUMP(Hardware->os, "#[flop reset: nn kernel]");
@@ -4527,15 +4199,15 @@ _ProgramNNKernel(
         gcvDUMP_BUFFER_KERNEL_COMMAND,
         bufferLogical,
         bufferAddress,
-        bytes
+        need_refine? (bytes - 0x40):bytes
         );
 #endif
 
     Data->bufVidMem = bufferNode;
-    Data->bufVidMemBytes = bufferBytes;
+    Data->bufVidMemBytes = need_refine ? (bufferBytes - 0x40) : bufferBytes;
     Data->address = bufferAddress;
     Data->logical = bufferLogical;
-    Data->bytes = bytes;
+    Data->bytes = need_refine ? (bytes - 0x40) : bytes;
 
     return gcvSTATUS_OK;
 
@@ -4554,7 +4226,6 @@ _ProgramNNKernel(
 static gceSTATUS
 _ProgramNNInput(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
     IN gctUINT8 DataType,
     IN gctUINT32 InImageXSize,
     IN gctUINT32 InImageYSize,
@@ -4576,16 +4247,6 @@ _ProgramNNInput(
 
     gctUINT32 i = 0;
     gctUINT32 offset = 0;
-    gctUINT32 value[] = {
-        0x33, /* uint8 */
-        0x3c00, /* fp16 */
-        1, /* int8 */
-        1, /* uint16 */
-        1, /* int16 */
-        1, /* uint4 */
-        1, /* int4 */
-        0x3f80  /* bf16 */
-    };
 
     gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
 
@@ -4602,16 +4263,11 @@ _ProgramNNInput(
         &bufferAddress
         ));
 
-    if (gcvVIP_ARCH_TYPE_V8 == ArchType)
-    {
-        value[0x4] = 0x81;
-    }
-
     buffer = (gctUINT8_PTR)bufferLogical;
 
     for (i = 0; i < inputSize; i++)
     {
-        _BitValue(&buffer, value[DataType], &offset, itemBytes * 8);
+        _BitValue(&buffer, flopResetInputs[DataType], &offset, itemBytes * 8);
     }
 
     bytes = buffer + (offset + 7) / 8 - (gctUINT8_PTR)bufferLogical;
@@ -4679,7 +4335,7 @@ _ProgramNNOutput(
 
     gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
 
-    bufferBytes = bytes = OutputXSize * OutputYSize * OutputZSize * itemBytes;
+    bufferBytes = bytes = (gctSIZE_T)(OutputXSize * OutputYSize * OutputZSize * itemBytes);
 
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -4720,7 +4376,6 @@ _ProgramNNOutput(
 static gceSTATUS
 _ProgramNNInstruction(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
     IN gctUINT8 DataType,
     IN gctUINT32 InImageXSize,
     IN gctUINT32 InImageYSize,
@@ -4733,38 +4388,22 @@ _ProgramNNInstruction(
     IN gctUINT32 InImageAddress,
     IN gctUINT32 OutImageAddress,
     IN gctUINT32 KernelAddress,
+    IN chipCmdData* cd,
     IN gctUINT32 AllocFlag,
     IN gcePOOL *Pool,
     OUT gcsFUNCTION_EXECUTION_DATA_PTR Data
     )
 {
-#if gcdENABLE_FLOP_RESET == 0
+    gctUINT32 itemBytes = 0;
     gceSTATUS status = gcvSTATUS_OK;
-
-    gckOS os = Hardware->os;
-
-    gctUINT32 itemBytes;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
     gctUINT32 bufferAddress = 0;
     gctSIZE_T bufferBytes, bytes;
     gctUINT32 *command = gcvNULL;
+    gctSIZE_T outbufferBytes = 0;
 
-    gctUINT8 kernelDataType;
-    gctUINT8 inImageDataType;
-    gctUINT8 outImageDataType;
-
-    gctUINT32 kernelsPerCore = 1;
-
-    gctUINT32 nnLayerFlush = 1;
-    gctUINT32 noZOffset = 0;
-    gctUINT32 imageEndAddress = 2048;
-    gctUINT32 postShift = 0;
-    gctUINT32 postShiftBit56 = 0;
-    gctUINT8 coefZP = 0;
-    gctUINT8 outputZP = 0;
-
-    bufferBytes = bytes = gcmSIZEOF(gctUINT32) * ((ArchType == gcvVIP_ARCH_TYPE_V6) ? 16 : 32);
+    bufferBytes = bytes = gckHARDWARE_IsFeatureAvailable(Hardware, gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD)? NN_INSTRUCTION_LEN_EXT:NN_INSTRUCTION_LEN;
 
     /* Allocate buffer. */
     gcmkONERROR(_AllocateVideoMemory(
@@ -4778,1543 +4417,100 @@ _ProgramNNInstruction(
         &bufferAddress
         ));
 
-    command = (gctUINT32_PTR)bufferLogical;
-
     gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
+    outbufferBytes = (gctSIZE_T)(OutImageXSize * OutImageYSize * OutImageZSize * itemBytes);
+    command = (gctUINT32_PTR)bufferLogical;
+    gckOS_MemCopy(command, cd->NNIns, bytes);
 
-    kernelDataType   =
-    inImageDataType  =
-    outImageDataType = DataType;
+    /* Fill the data. */
+    command[5] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 31:26) - (0 ?
+ 31:26) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 31:26) - (0 ?
+ 31:26) + 1))))))) << (0 ?
+ 31:26))) | (((gctUINT32) ((gctUINT32) (((KernelZSize >> 14) & 0x3F)) & ((gctUINT32) ((((1 ?
+ 31:26) - (0 ?
+ 31:26) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 31:26) - (0 ? 31:26) + 1))))))) << (0 ? 31:26)))
+      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1))))))) << (0 ?
+ 25:0))) | (((gctUINT32) ((gctUINT32) ((KernelAddress >> 6)) & ((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)));
+    command[6] = InImageAddress;
+    command[7] = OutImageAddress;
 
-    switch (ArchType)
+    if(Hardware->identity.customerID == 0x85)
     {
-    case gcvVIP_ARCH_TYPE_V8:
-        noZOffset = 1;
-        outputZP = 0;
-        postShift = (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_NN_FLOAT_POST_MULT)) ? 0x1f : 0;
-        postShiftBit56 = (gckHARDWARE_IsFeatureAvailable(Hardware, gcvFEATURE_NN_FLOAT_POST_MULT)) ? 3 : 0;
-        break;
-
-    case gcvVIP_ARCH_TYPE_V7:
-    case gcvVIP_ARCH_TYPE_V6:
-        postShift = (DataType == 0x2) ? 15 : 0;
-        break;
-
-    default:
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-        break;
+        if(Hardware->options.configNNPowerControl == 3)
+        {
+            command[12] = 0x00000900;
+        }
+        else if(Hardware->options.configNNPowerControl == 4)
+        {
+            command[12] = 0x00000A00;
+        }
+        else if(Hardware->options.configNNPowerControl == 0)
+        {
+            command[12] = 0x00000B00;
+        }
     }
 
-    /* gcregNNInstWord0 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 0:0) - (0 ?
- 0:0) + 1))))))) << (0 ?
- 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 1:1) - (0 ?
- 1:1) + 1))))))) << (0 ?
- 1:1))) | (((gctUINT32) ((gctUINT32) (noZOffset) & ((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 5:2) - (0 ?
- 5:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 5:2) - (0 ?
- 5:2) + 1))))))) << (0 ?
- 5:2))) | (((gctUINT32) ((gctUINT32) (KernelXSize) & ((gctUINT32) ((((1 ?
- 5:2) - (0 ?
- 5:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 5:2) - (0 ? 5:2) + 1))))))) << (0 ? 5:2)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 19:6) - (0 ?
- 19:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 19:6) - (0 ?
- 19:6) + 1))))))) << (0 ?
- 19:6))) | (((gctUINT32) ((gctUINT32) ((KernelZSize & 0x3FFF)) & ((gctUINT32) ((((1 ?
- 19:6) - (0 ?
- 19:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 19:6) - (0 ? 19:6) + 1))))))) << (0 ? 19:6)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 26:20) - (0 ?
- 26:20) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 26:20) - (0 ?
- 26:20) + 1))))))) << (0 ?
- 26:20))) | (((gctUINT32) ((gctUINT32) (kernelsPerCore) & ((gctUINT32) ((((1 ?
- 26:20) - (0 ?
- 26:20) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 26:20) - (0 ? 26:20) + 1))))))) << (0 ? 26:20)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 28:27) - (0 ?
- 28:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 28:27) - (0 ?
- 28:27) + 1))))))) << (0 ?
- 28:27))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 28:27) - (0 ?
- 28:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 28:27) - (0 ? 28:27) + 1))))))) << (0 ? 28:27)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 29:29) - (0 ?
- 29:29) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 29:29) - (0 ?
- 29:29) + 1))))))) << (0 ?
- 29:29))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 29:29) - (0 ?
- 29:29) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 29:29) - (0 ? 29:29) + 1))))))) << (0 ? 29:29)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 30:30) - (0 ?
- 30:30) + 1))))))) << (0 ?
- 30:30))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 30:30) - (0 ? 30:30) + 1))))))) << (0 ? 30:30)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:31) - (0 ?
- 31:31) + 1))))))) << (0 ?
- 31:31))) | (((gctUINT32) ((gctUINT32) (nnLayerFlush) & ((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
+    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+        Hardware->kernel,
+        bufferNode,
+        0,
+        bufferLogical,
+        bufferBytes
+        ));
+
+#if gcdDUMP_IN_KERNEL
+    gcmkDUMP(Hardware->os, "#[flop reset: nn instruction]");
+    gcmkDUMP_BUFFER(
+        Hardware->os,
+        gcvDUMP_BUFFER_KERNEL_COMMAND,
+        bufferLogical,
+        bufferAddress,
+        bytes
         );
+#endif
 
-    /* gcregNNInstWord1 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 18:6) - (0 ?
- 18:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 18:6) - (0 ?
- 18:6) + 1))))))) << (0 ?
- 18:6))) | (((gctUINT32) ((gctUINT32) (InImageXSize) & ((gctUINT32) ((((1 ?
- 18:6) - (0 ?
- 18:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 18:6) - (0 ? 18:6) + 1))))))) << (0 ? 18:6)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:19) - (0 ?
- 31:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:19) - (0 ?
- 31:19) + 1))))))) << (0 ?
- 31:19))) | (((gctUINT32) ((gctUINT32) (InImageYSize) & ((gctUINT32) ((((1 ?
- 31:19) - (0 ?
- 31:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:19) - (0 ? 31:19) + 1))))))) << (0 ? 31:19)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 1:1) - (0 ?
- 1:1) + 1))))))) << (0 ?
- 1:1))) | (((gctUINT32) ((gctUINT32) (kernelDataType >> 1) & ((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 3:3) - (0 ?
- 3:3) + 1))))))) << (0 ?
- 3:3))) | (((gctUINT32) ((gctUINT32) (inImageDataType >> 1) & ((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 5:5) - (0 ?
- 5:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 5:5) - (0 ?
- 5:5) + 1))))))) << (0 ?
- 5:5))) | (((gctUINT32) ((gctUINT32) (outImageDataType >> 1) & ((gctUINT32) ((((1 ?
- 5:5) - (0 ?
- 5:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 0:0) - (0 ?
- 0:0) + 1))))))) << (0 ?
- 0:0))) | (((gctUINT32) ((gctUINT32) (kernelDataType & 0x1) & ((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 2:2) - (0 ?
- 2:2) + 1))))))) << (0 ?
- 2:2))) | (((gctUINT32) ((gctUINT32) (inImageDataType & 0x1) & ((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 4:4) - (0 ?
- 4:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 4:4) - (0 ?
- 4:4) + 1))))))) << (0 ?
- 4:4))) | (((gctUINT32) ((gctUINT32) (outImageDataType & 0x1) & ((gctUINT32) ((((1 ?
- 4:4) - (0 ?
- 4:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)))
-        );
-
-    /* gcregNNInstWord2 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 24:24) - (0 ?
- 24:24) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 24:24) - (0 ?
- 24:24) + 1))))))) << (0 ?
- 24:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 24:24) - (0 ?
- 24:24) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 24:24) - (0 ? 24:24) + 1))))))) << (0 ? 24:24)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:25) - (0 ?
- 25:25) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:25) - (0 ?
- 25:25) + 1))))))) << (0 ?
- 25:25))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 25:25) - (0 ?
- 25:25) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:25) - (0 ? 25:25) + 1))))))) << (0 ? 25:25)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 2:0) - (0 ?
- 2:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 2:0) - (0 ?
- 2:0) + 1))))))) << (0 ?
- 2:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 2:0) - (0 ?
- 2:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 2:0) - (0 ? 2:0) + 1))))))) << (0 ? 2:0)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 5:3) - (0 ?
- 5:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 5:3) - (0 ?
- 5:3) + 1))))))) << (0 ?
- 5:3))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 5:3) - (0 ?
- 5:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 5:3) - (0 ? 5:3) + 1))))))) << (0 ? 5:3)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 26:26) - (0 ?
- 26:26) + 1))))))) << (0 ?
- 26:26))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) << (0 ? 26:26)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 7:7) - (0 ?
- 7:7) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 7:7) - (0 ?
- 7:7) + 1))))))) << (0 ?
- 7:7))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 7:7) - (0 ?
- 7:7) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 7:7) - (0 ? 7:7) + 1))))))) << (0 ? 7:7)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 23:8) - (0 ?
- 23:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 23:8) - (0 ?
- 23:8) + 1))))))) << (0 ?
- 23:8))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 23:8) - (0 ?
- 23:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 23:8) - (0 ? 23:8) + 1))))))) << (0 ? 23:8)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) ((gctUINT32) (postShift) & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-        );
-
-    /* gcregNNInstWord3 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 18:6) - (0 ?
- 18:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 18:6) - (0 ?
- 18:6) + 1))))))) << (0 ?
- 18:6))) | (((gctUINT32) ((gctUINT32) (OutImageXSize) & ((gctUINT32) ((((1 ?
- 18:6) - (0 ?
- 18:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 18:6) - (0 ? 18:6) + 1))))))) << (0 ? 18:6)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:19) - (0 ?
- 31:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:19) - (0 ?
- 31:19) + 1))))))) << (0 ?
- 31:19))) | (((gctUINT32) ((gctUINT32) (OutImageYSize) & ((gctUINT32) ((((1 ?
- 31:19) - (0 ?
- 31:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:19) - (0 ? 31:19) + 1))))))) << (0 ? 31:19)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 2:2) - (0 ?
- 2:2) + 1))))))) << (0 ?
- 2:2))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 3:3) - (0 ?
- 3:3) + 1))))))) << (0 ?
- 3:3))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
-        );
-
-    /* gcregNNInstWord4 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 13:0) - (0 ?
- 13:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 13:0) - (0 ?
- 13:0) + 1))))))) << (0 ?
- 13:0))) | (((gctUINT32) ((gctUINT32) (OutImageZSize) & ((gctUINT32) ((((1 ?
- 13:0) - (0 ?
- 13:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 13:0) - (0 ? 13:0) + 1))))))) << (0 ? 13:0)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:14) - (0 ?
- 15:14) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:14) - (0 ?
- 15:14) + 1))))))) << (0 ?
- 15:14))) | (((gctUINT32) ((gctUINT32) (0x0) & ((gctUINT32) ((((1 ?
- 15:14) - (0 ?
- 15:14) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:14) - (0 ? 15:14) + 1))))))) << (0 ? 15:14)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 24:18) - (0 ?
- 24:18) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 24:18) - (0 ?
- 24:18) + 1))))))) << (0 ?
- 24:18))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 24:18) - (0 ?
- 24:18) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 24:18) - (0 ? 24:18) + 1))))))) << (0 ? 24:18)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:25) - (0 ?
- 31:25) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:25) - (0 ?
- 31:25) + 1))))))) << (0 ?
- 31:25))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 31:25) - (0 ?
- 31:25) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:25) - (0 ? 31:25) + 1))))))) << (0 ? 31:25)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 16:16) - (0 ?
- 16:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 16:16) - (0 ?
- 16:16) + 1))))))) << (0 ?
- 16:16))) | (((gctUINT32) ((gctUINT32) ((0 >> 3) & 0x1) & ((gctUINT32) ((((1 ?
- 16:16) - (0 ?
- 16:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 17:17) - (0 ?
- 17:17) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 17:17) - (0 ?
- 17:17) + 1))))))) << (0 ?
- 17:17))) | (((gctUINT32) ((gctUINT32) ((0 >> 3) & 0x1) & ((gctUINT32) ((((1 ?
- 17:17) - (0 ?
- 17:17) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 17:17) - (0 ? 17:17) + 1))))))) << (0 ? 17:17)))
-        );
-
-    /* gcregNNInstWord5 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:26) - (0 ?
- 31:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:26) - (0 ?
- 31:26) + 1))))))) << (0 ?
- 31:26))) | (((gctUINT32) ((gctUINT32) (((KernelZSize >> 14) & 0x3F)) & ((gctUINT32) ((((1 ?
- 31:26) - (0 ?
- 31:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:26) - (0 ? 31:26) + 1))))))) << (0 ? 31:26)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) ((KernelAddress >> 6)) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)))
-        );
-
-    /* gcregNNInstWord6 */
-    gcmkWRITE_MEMORY(command, InImageAddress);
-
-    /* gcregNNInstWord7 */
-    gcmkWRITE_MEMORY(command, OutImageAddress);
-
-    /* gcregNNInstWord8 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:12) - (0 ?
- 15:12) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:12) - (0 ?
- 15:12) + 1))))))) << (0 ?
- 15:12))) | (((gctUINT32) ((gctUINT32) (KernelYSize) & ((gctUINT32) ((((1 ?
- 15:12) - (0 ?
- 15:12) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:12) - (0 ? 15:12) + 1))))))) << (0 ? 15:12)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:16) - (0 ?
- 31:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:16) - (0 ?
- 31:16) + 1))))))) << (0 ?
- 31:16))) | (((gctUINT32) ((gctUINT32) (OutImageYSize) & ((gctUINT32) ((((1 ?
- 31:16) - (0 ?
- 31:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16)))
-        );
-
-    /* gcregNNInstWord9 */
-    gcmkWRITE_MEMORY(command, 0);
-
-    /* gcregNNInstWord10 */
-    gcmkWRITE_MEMORY(command, 0);
-
-    /* gcregNNInstWord11 */
-    gcmkWRITE_MEMORY(command, 0);
-
-    /* gcregNNInstWord12 */
-    gcmkWRITE_MEMORY(command, 0);
-
-    /* gcregNNInstWord13 */
-    gcmkWRITE_MEMORY(command, 0);
-
-    /* gcregNNInstWord14 */
-    gcmkWRITE_MEMORY(command, imageEndAddress);
-
-    /* gcregNNInstWord15 */
-    gcmkWRITE_MEMORY(
-        command,
-        ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 1:0) - (0 ?
- 1:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 1:0) - (0 ?
- 1:0) + 1))))))) << (0 ?
- 1:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 1:0) - (0 ?
- 1:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 1:0) - (0 ? 1:0) + 1))))))) << (0 ? 1:0)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 17:2) - (0 ?
- 17:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 17:2) - (0 ?
- 17:2) + 1))))))) << (0 ?
- 17:2))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 17:2) - (0 ?
- 17:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 17:2) - (0 ? 17:2) + 1))))))) << (0 ? 17:2)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 19:19) - (0 ?
- 19:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 19:19) - (0 ?
- 19:19) + 1))))))) << (0 ?
- 19:19))) | (((gctUINT32) ((gctUINT32) (kernelDataType >> 2) & ((gctUINT32) ((((1 ?
- 19:19) - (0 ?
- 19:19) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 19:19) - (0 ? 19:19) + 1))))))) << (0 ? 19:19)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 20:20) - (0 ?
- 20:20) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 20:20) - (0 ?
- 20:20) + 1))))))) << (0 ?
- 20:20))) | (((gctUINT32) ((gctUINT32) (inImageDataType >> 2) & ((gctUINT32) ((((1 ?
- 20:20) - (0 ?
- 20:20) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 20:20) - (0 ? 20:20) + 1))))))) << (0 ? 20:20)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 21:21) - (0 ?
- 21:21) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 21:21) - (0 ?
- 21:21) + 1))))))) << (0 ?
- 21:21))) | (((gctUINT32) ((gctUINT32) (outImageDataType >> 2) & ((gctUINT32) ((((1 ?
- 21:21) - (0 ?
- 21:21) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 21:21) - (0 ? 21:21) + 1))))))) << (0 ? 21:21)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 27:22) - (0 ?
- 27:22) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 27:22) - (0 ?
- 27:22) + 1))))))) << (0 ?
- 27:22))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 27:22) - (0 ?
- 27:22) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 27:22) - (0 ? 27:22) + 1))))))) << (0 ? 27:22)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 29:28) - (0 ?
- 29:28) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 29:28) - (0 ?
- 29:28) + 1))))))) << (0 ?
- 29:28))) | (((gctUINT32) ((gctUINT32) (postShiftBit56) & ((gctUINT32) ((((1 ?
- 29:28) - (0 ?
- 29:28) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 29:28) - (0 ? 29:28) + 1))))))) << (0 ? 29:28)))
-        );
-
-    /* V7 or V8 */
-    if (ArchType == gcvVIP_ARCH_TYPE_V7 ||
-        ArchType == gcvVIP_ARCH_TYPE_V8)
-    {
-        /* gcregNNInstWord16 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (InImageXSize * itemBytes) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:16) - (0 ?
- 31:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:16) - (0 ?
- 31:16) + 1))))))) << (0 ?
- 31:16))) | (((gctUINT32) ((gctUINT32) (InImageYSize) & ((gctUINT32) ((((1 ?
- 31:16) - (0 ?
- 31:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:16) - (0 ? 31:16) + 1))))))) << (0 ? 31:16)))
-            );
-
-        /* gcregNNInstWord17 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (OutImageXSize * itemBytes) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:24) - (0 ?
- 31:24) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:24) - (0 ?
- 31:24) + 1))))))) << (0 ?
- 31:24))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 31:24) - (0 ?
- 31:24) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:24) - (0 ? 31:24) + 1))))))) << (0 ? 31:24)))
-            );
-
-        /* gcregNNInstWord18 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) (0 >> 6) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 26:26) - (0 ?
- 26:26) + 1))))))) << (0 ?
- 26:26))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) << (0 ? 26:26)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 29:29) - (0 ?
- 29:29) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 29:29) - (0 ?
- 29:29) + 1))))))) << (0 ?
- 29:29))) | (((gctUINT32) ((gctUINT32) ((0 >> 4) & 0x1) & ((gctUINT32) ((((1 ?
- 29:29) - (0 ?
- 29:29) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 29:29) - (0 ? 29:29) + 1))))))) << (0 ? 29:29)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 30:30) - (0 ?
- 30:30) + 1))))))) << (0 ?
- 30:30))) | (((gctUINT32) ((gctUINT32) ((0 >> 4) & 0x1) & ((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 30:30) - (0 ? 30:30) + 1))))))) << (0 ? 30:30)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 28:28) - (0 ?
- 28:28) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 28:28) - (0 ?
- 28:28) + 1))))))) << (0 ?
- 28:28))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 28:28) - (0 ?
- 28:28) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 28:28) - (0 ? 28:28) + 1))))))) << (0 ? 28:28)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:31) - (0 ?
- 31:31) + 1))))))) << (0 ?
- 31:31))) | (((gctUINT32) ((gctUINT32) (kernelDataType >> 3) & ((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
-            );
-
-        /* 25:0 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) (0xFFFFFFFF >> 6) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 30:30) - (0 ?
- 30:30) + 1))))))) << (0 ?
- 30:30))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 30:30) - (0 ?
- 30:30) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 30:30) - (0 ? 30:30) + 1))))))) << (0 ? 30:30)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:31) - (0 ?
- 31:31) + 1))))))) << (0 ?
- 31:31))) | (((gctUINT32) ((gctUINT32) (inImageDataType >> 3) & ((gctUINT32) ((((1 ?
- 31:31) - (0 ?
- 31:31) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:31) - (0 ? 31:31) + 1))))))) << (0 ? 31:31)))
-            );
-
-        /* GCREG_NN_INST_WORD20 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) (0 >> 6) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 26:26) - (0 ?
- 26:26) + 1))))))) << (0 ?
- 26:26))) | (((gctUINT32) ((gctUINT32) (outImageDataType >> 3) & ((gctUINT32) ((((1 ?
- 26:26) - (0 ?
- 26:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 26:26) - (0 ? 26:26) + 1))))))) << (0 ? 26:26)))
-            );
-
-        /* 25:0 */
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) (0xFFFFFFFF >> 6) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)))
-            );
-
-        /*GCREG_NN_INST_WORD22*/
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 7:0) - (0 ?
- 7:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 7:0) - (0 ?
- 7:0) + 1))))))) << (0 ?
- 7:0))) | (((gctUINT32) ((gctUINT32) (coefZP) & ((gctUINT32) ((((1 ?
- 7:0) - (0 ?
- 7:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 7:0) - (0 ? 7:0) + 1))))))) << (0 ? 7:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:8) - (0 ?
- 15:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:8) - (0 ?
- 15:8) + 1))))))) << (0 ?
- 15:8))) | (((gctUINT32) ((gctUINT32) (outputZP) & ((gctUINT32) ((((1 ?
- 15:8) - (0 ?
- 15:8) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:8) - (0 ? 15:8) + 1))))))) << (0 ? 15:8)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 16:16) - (0 ?
- 16:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 16:16) - (0 ?
- 16:16) + 1))))))) << (0 ?
- 16:16))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 16:16) - (0 ?
- 16:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 16:16) - (0 ? 16:16) + 1))))))) << (0 ? 16:16)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 17:17) - (0 ?
- 17:17) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 17:17) - (0 ?
- 17:17) + 1))))))) << (0 ?
- 17:17))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 17:17) - (0 ?
- 17:17) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 17:17) - (0 ? 17:17) + 1))))))) << (0 ? 17:17)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:18) - (0 ?
- 25:18) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:18) - (0 ?
- 25:18) + 1))))))) << (0 ?
- 25:18))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 25:18) - (0 ?
- 25:18) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:18) - (0 ? 25:18) + 1))))))) << (0 ? 25:18)))
-            );
-
-        /*GCREG_NN_INST_WORD23*/
-        gcmkWRITE_MEMORY(command, 0);
-
-        /*GCREG_NN_INST_WORD24*/
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 3:0) - (0 ?
- 3:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 3:0) - (0 ?
- 3:0) + 1))))))) << (0 ?
- 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 3:0) - (0 ?
- 3:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:4) - (0 ?
- 31:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:4) - (0 ?
- 31:4) + 1))))))) << (0 ?
- 31:4))) | (((gctUINT32) ((gctUINT32) (0 >> 4) & ((gctUINT32) ((((1 ?
- 31:4) - (0 ?
- 31:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:4) - (0 ? 31:4) + 1))))))) << (0 ? 31:4)))
-            );
-
-        /*GCREG_NN_INST_WORD25*/
-        gcmkWRITE_MEMORY(
-            command,
-            ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 3:0) - (0 ?
- 3:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 3:0) - (0 ?
- 3:0) + 1))))))) << (0 ?
- 3:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 3:0) - (0 ?
- 3:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 3:0) - (0 ? 3:0) + 1))))))) << (0 ? 3:0)))
-          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:4) - (0 ?
- 31:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:4) - (0 ?
- 31:4) + 1))))))) << (0 ?
- 31:4))) | (((gctUINT32) ((gctUINT32) (0 >> 4) & ((gctUINT32) ((((1 ?
- 31:4) - (0 ?
- 31:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:4) - (0 ? 31:4) + 1))))))) << (0 ? 31:4)))
-            );
-    }
-
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
-
-#else
-    gceSTATUS status = gcvSTATUS_OK;
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress = 0;
-    gctSIZE_T bufferBytes, bytes;
-    gctUINT32 *command = gcvNULL;
-    chipCmdData *cd = gcvNULL;
-    //v8
-
-    //gctUINT32 i;
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
-    if(cd == gcvNULL)
-    {
-        return status;
-    }
-    bufferBytes = bytes = 0x080;
-
-    /* Allocate buffer. */
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_COMMAND,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    command = (gctUINT32_PTR)bufferLogical;
-    gckOS_MemCopy(command, cd->NNIns, bufferBytes);
-
-    /* Fill the data. */
-    command[5] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:26) - (0 ?
- 31:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:26) - (0 ?
- 31:26) + 1))))))) << (0 ?
- 31:26))) | (((gctUINT32) ((gctUINT32) (((KernelZSize >> 14) & 0x3F)) & ((gctUINT32) ((((1 ?
- 31:26) - (0 ?
- 31:26) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:26) - (0 ? 31:26) + 1))))))) << (0 ? 31:26)))
-      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:0) - (0 ?
- 25:0) + 1))))))) << (0 ?
- 25:0))) | (((gctUINT32) ((gctUINT32) ((KernelAddress >> 6)) & ((gctUINT32) ((((1 ?
- 25:0) - (0 ?
- 25:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)));
-    command[6] = InImageAddress;
-    command[7] = OutImageAddress;
-
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
-
-#endif
-#if gcdDUMP_IN_KERNEL
-    gcmkDUMP(Hardware->os, "#[flop reset: nn instruction]");
-    gcmkDUMP_BUFFER(
-        Hardware->os,
-        gcvDUMP_BUFFER_KERNEL_COMMAND,
-        bufferLogical,
-        bufferAddress,
-        bytes
-        );
-#endif
-
-    Data->bufVidMem = bufferNode;
-    Data->bufVidMemBytes = bufferBytes;
-    Data->address = bufferAddress;
-    Data->logical = bufferLogical;
-    Data->bytes = bytes;
-
-    return gcvSTATUS_OK;
-
-OnError:
-    if (bufferNode)
-    {
-        gcmkVERIFY_OK(_FreeVideoMemory(
-            Hardware->kernel,
-            bufferNode
-            ));
-    }
-
-    return status;
-}
-
-static gceSTATUS
-_ProgramNNCommand(
-    IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
-    IN gctUINT32 KernelBurstSize,
-    IN gctUINT32 InstAddress,
-    IN gctUINT32 AllocFlag,
-    IN gcePOOL *Pool,
-    OUT gcsFUNCTION_COMMAND_PTR Command
-    )
-{
-#if gcdENABLE_FLOP_RESET == 0
-    gceSTATUS status = gcvSTATUS_OK;
-
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress = 0;
-    gctSIZE_T bufferBytes;
-    gctUINT32 bytes;
-    gctUINT8_PTR endLogical;
-    gctUINT32 endAddress;
-    gctUINT32 endBytes = 0;
-    gcsFEATURE_DATABASE *database = (gcsFEATURE_DATABASE *)(Hardware->featureDatabase);
-    gctUINT32 index = 0;
-    gctINT32 disableZDPN = 1, disableSWTiling = 1;
-    gctBOOL enableNNStride = gcvFALSE;
-    gctUINT32 smallBatch;
-    gctUINT32 ddrBurstSize;
-    gctUINT32 *commands = gcvNULL;
-
-    bufferBytes = gcmSIZEOF(gctUINT32) * MAX_NN_COMMAND_NUM;
-
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_COMMAND,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    commands = (gctUINT32 *)bufferLogical;
-
-    disableZDPN = (database->NN_ZDP3 || database->NN_ZDP6) ? 0 : 1;
-
-    enableNNStride = database->NN_STRIDE_SUPPORT;
-    disableSWTiling = enableNNStride ? 0 : 1;
-
-    if (Hardware->identity.chipModel == 0x8000 &&
-        Hardware->identity.chipRevision == 0x7120 &&
-        (Hardware->identity.customerID == 0x80 ||
-         Hardware->identity.customerID == 0x92))
-    {
-        smallBatch = 0x0;
-    }
-    else
-    {
-        smallBatch = (database->NN_SMALLBATCH_PHASE1 && database->NN_COMMAND_KERNEL_REQUEST_CONFICT_FIX)
-                     ? 0x0 : 0x1;
-    }
-
-    switch(KernelBurstSize)
-    {
-    case 256:
-        ddrBurstSize = 0x2;
-        break;
-
-    case 64:
-    default:
-        ddrBurstSize = 0x0;
-        break;
-    }
-
-    commands = (gctUINT32_PTR)bufferLogical;
-
-    if (gcvVIP_ARCH_TYPE_V6 == ArchType)
-    {
-        commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x006B) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-        commands[index++] = 0;
-
-        commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                          | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-        commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 6:6) - (0 ?
- 6:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 6:6) - (0 ?
- 6:6) + 1))))))) << (0 ?
- 6:6))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ?
- 6:6) - (0 ?
- 6:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6)));
-    }
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E4E) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = Hardware->options.sRAMGPUVirtAddrs[0];
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E4F) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = 0x00000000;
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E50) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = 0x00000000;
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 6:6) - (0 ?
- 6:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 6:6) - (0 ?
- 6:6) + 1))))))) << (0 ?
- 6:6))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ?
- 6:6) - (0 ?
- 6:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 6:6) - (0 ? 6:6) + 1))))))) << (0 ? 6:6)));
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E4C) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 2:2) - (0 ?
- 2:2) + 1))))))) << (0 ?
- 2:2))) | (((gctUINT32) ((gctUINT32) (disableZDPN) & ((gctUINT32) ((((1 ?
- 2:2) - (0 ?
- 2:2) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 2:2) - (0 ? 2:2) + 1))))))) << (0 ? 2:2)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 3:3) - (0 ?
- 3:3) + 1))))))) << (0 ?
- 3:3))) | (((gctUINT32) ((gctUINT32) (disableSWTiling) & ((gctUINT32) ((((1 ?
- 3:3) - (0 ?
- 3:3) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 3:3) - (0 ? 3:3) + 1))))))) << (0 ? 3:3)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 4:4) - (0 ?
- 4:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 4:4) - (0 ?
- 4:4) + 1))))))) << (0 ?
- 4:4))) | (((gctUINT32) ((gctUINT32) (smallBatch) & ((gctUINT32) ((((1 ?
- 4:4) - (0 ?
- 4:4) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 4:4) - (0 ? 4:4) + 1))))))) << (0 ? 4:4)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 6:5) - (0 ?
- 6:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 6:5) - (0 ?
- 6:5) + 1))))))) << (0 ?
- 6:5))) | (((gctUINT32) ((gctUINT32) (ddrBurstSize) & ((gctUINT32) ((((1 ?
- 6:5) - (0 ?
- 6:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 6:5) - (0 ? 6:5) + 1))))))) << (0 ? 6:5)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 12:12) - (0 ?
- 12:12) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 12:12) - (0 ?
- 12:12) + 1))))))) << (0 ?
- 12:12))) | (((gctUINT32) ((gctUINT32) (0x0) & ((gctUINT32) ((((1 ?
- 12:12) - (0 ?
- 12:12) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 12:12) - (0 ? 12:12) + 1))))))) << (0 ? 12:12)));
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E54) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 0:0) - (0 ?
- 0:0) + 1))))))) << (0 ?
- 0:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 0:0) - (0 ?
- 0:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 0:0) - (0 ? 0:0) + 1))))))) << (0 ? 0:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 1:1) - (0 ?
- 1:1) + 1))))))) << (0 ?
- 1:1))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 1:1) - (0 ?
- 1:1) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 1:1) - (0 ? 1:1) + 1))))))) << (0 ? 1:1)));
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0428) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:6) - (0 ?
- 31:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:6) - (0 ?
- 31:6) + 1))))))) << (0 ?
- 31:6))) | (((gctUINT32) ((gctUINT32) ((InstAddress >> 6)) & ((gctUINT32) ((((1 ?
- 31:6) - (0 ?
- 31:6) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:6) - (0 ? 31:6) + 1))))))) << (0 ? 31:6)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 4:0) - (0 ?
- 4:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 4:0) - (0 ?
- 4:0) + 1))))))) << (0 ?
- 4:0))) | (((gctUINT32) ((gctUINT32) (0) & ((gctUINT32) ((((1 ?
- 4:0) - (0 ?
- 4:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)));
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0429) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = 0;
-
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 31:27) - (0 ?
- 31:27) + 1))))))) << (0 ?
- 31:27))) | (((gctUINT32) (0x01 & ((gctUINT32) ((((1 ?
- 31:27) - (0 ?
- 31:27) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 31:27) - (0 ? 31:27) + 1))))))) << (0 ? 31:27)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 15:0) - (0 ?
- 15:0) + 1))))))) << (0 ?
- 15:0))) | (((gctUINT32) ((gctUINT32) (0x0E03) & ((gctUINT32) ((((1 ?
- 15:0) - (0 ?
- 15:0) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 15:0) - (0 ? 15:0) + 1))))))) << (0 ? 15:0)))
-                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 25:16) - (0 ?
- 25:16) + 1))))))) << (0 ?
- 25:16))) | (((gctUINT32) ((gctUINT32) (1) & ((gctUINT32) ((((1 ?
- 25:16) - (0 ?
- 25:16) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 25:16) - (0 ? 25:16) + 1))))))) << (0 ? 25:16)));
-    commands[index++] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
- 5:5) - (0 ?
- 5:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ?
- 5:5) - (0 ?
- 5:5) + 1))))))) << (0 ?
- 5:5))) | (((gctUINT32) (0x1 & ((gctUINT32) ((((1 ?
- 5:5) - (0 ?
- 5:5) + 1) == 32) ?
- ~0U : (~(~0U << ((1 ? 5:5) - (0 ? 5:5) + 1))))))) << (0 ? 5:5)));
-
-    bytes = gcmSIZEOF(gctUINT32) * index;
+    Data->bufVidMem = bufferNode;
+    Data->bufVidMemBytes = bufferBytes;
+    Data->address = bufferAddress;
+    Data->logical = bufferLogical;
+    Data->bytes = bytes;
 
-    endLogical = (gctUINT8_PTR)bufferLogical + bytes;
-    endAddress = bufferAddress + bytes;
+    return gcvSTATUS_OK;
 
-    if (Hardware->wlFE)
+OnError:
+    if (bufferNode)
     {
-        gcmkONERROR(gckWLFE_End(Hardware, gcvNULL, ~0U, &endBytes));
-        gcmkONERROR(gckWLFE_End(Hardware, endLogical, endAddress, &endBytes));
-    }
-
-    bytes += endBytes;
-
-    gcmkASSERT(bytes <= bufferBytes);
-
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
+        gcmkVERIFY_OK(_FreeVideoMemory(
+            Hardware->kernel,
+            bufferNode
+            ));
+    }
 
-    Command->funcVidMem = bufferNode;
-    Command->funcVidMemBytes = bufferBytes;
-    Command->logical = bufferLogical;
-    Command->address = bufferAddress;
-    Command->bytes = bytes;
-    Command->endAddress = endAddress;
-    Command->endLogical = endLogical;
+    return status;
+}
 
-    return gcvSTATUS_OK;
-#else
+static gceSTATUS
+_ProgramNNCommand(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 InstAddress,
+    IN chipCmdData* cd,
+    IN gctUINT32 AllocFlag,
+    IN gcePOOL *Pool,
+    OUT gcsFUNCTION_COMMAND_PTR Command
+    )
+{
     gceSTATUS status = gcvSTATUS_OK;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
@@ -6325,15 +4521,8 @@ _ProgramNNCommand(
     gctUINT32 endAddress;
     gctUINT32 endBytes = 0;
     gctUINT32 *commands = gcvNULL;
-    chipCmdData *cd = gcvNULL;
 
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
-    if(cd == gcvNULL)
-    {
-        return status;
-    }
     bufferBytes = gcmSIZEOF(gctUINT32) *  MAX_NN_COMMAND_NUM;
-
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
         gcvVIDMEM_TYPE_COMMAND,
@@ -6347,7 +4536,33 @@ _ProgramNNCommand(
 
     commands = (gctUINT32_PTR)bufferLogical;
     gckOS_MemCopy(commands, cd->NNCmd, cd->NNCmdLen);
-    commands[cd->NNCmdOffset] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+    if(Hardware->identity.customerID == 0x85)
+    {
+         commands[cd->NNCmdOffset - 4] = commands[cd->NNCmdOffset - 4]
+                      | ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 11:8) - (0 ?
+ 11:8) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 11:8) - (0 ?
+ 11:8) + 1))))))) << (0 ?
+ 11:8))) | (((gctUINT32) ((gctUINT32) (Hardware->options.configNNPowerControl) & ((gctUINT32) ((((1 ?
+ 11:8) - (0 ?
+ 11:8) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 11:8) - (0 ? 11:8) + 1))))))) << (0 ? 11:8)));
+         commands[cd->NNCmdOffset] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1))))))) << (0 ?
+ 25:0))) | (((gctUINT32) ((gctUINT32) ((InstAddress >> 6)) & ((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)));
+    }
+    else
+    {
+        commands[cd->NNCmdOffset] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
  31:6) - (0 ?
  31:6) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ?
@@ -6367,6 +4582,7 @@ _ProgramNNCommand(
  4:0) - (0 ?
  4:0) + 1) == 32) ?
  ~0U : (~(~0U << ((1 ? 4:0) - (0 ? 4:0) + 1))))))) << (0 ? 4:0)));
+    }
 
     bytes = cd->NNCmdLen;
 
@@ -6407,10 +4623,9 @@ _ProgramNNCommand(
         bufferAddress,
         bytes
         );
-    gcmkPRINT("NN commands dump, commands length:%d, endBytes:%d", bytes, endBytes);
 #endif
     return gcvSTATUS_OK;
-#endif
+
 
 OnError:
     if (bufferNode)
@@ -6449,17 +4664,14 @@ gckHARDWARE_ResetFlopWithNN(
     gctUINT32 i;
     gctPOINTER pointer = gcvNULL;
 
-    gceVIP_ARCH_TYPE archType;
     gctUINT8 dataType;
-    gctUINT32 coreCount = 0;
     gctUINT32 itemBytes = 0;
-    gctUINT32 zdp = 1;
-    gctUINT32 kernelBurstSize;
     gcsFUNCTION_EXECUTION_DATA_PTR data = gcvNULL;
     gctUINT32 dataCount = 0;
+    chipCmdData *cd = gcvNULL;
 
 #if gcdENABLE_FLOP_RESET_DEBUG
-    char * golden;
+    gctUINT8_PTR golden;
     gctSIZE_T outBufBytes;
 
 #endif
@@ -6471,13 +4683,20 @@ gckHARDWARE_ResetFlopWithNN(
 
     gcmkONERROR(_GetVIPCoreInfo(
         Hardware,
-        &archType,
+        gcvNULL,
         &dataType,
-        &coreCount,
-        &zdp,
-        &kernelBurstSize
+        gcvNULL,
+        gcvNULL,
+        gcvNULL
         ));
 
+    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
+    if(cd == gcvNULL)
+    {
+        return status;
+    }
+    gcmkASSERT(dataType == cd->InputDataType);
+
     gcmkONERROR(_GetNNDataSize(dataType, &itemBytes));
 
     /* Exectution data. */
@@ -6495,13 +4714,11 @@ gckHARDWARE_ResetFlopWithNN(
     /* Kernel. */
     gcmkONERROR(_ProgramNNKernel(
         Hardware,
-        archType,
-        coreCount,
-        zdp,
         dataType,
         kernelXSize,
         kernelYSize,
         kernelZSize,
+        cd,
         AllocFlag,
         Pool,
         &data[gcvFLOP_RESET_NN_KERNEL]
@@ -6510,7 +4727,6 @@ gckHARDWARE_ResetFlopWithNN(
     /* Input. */
     gcmkONERROR(_ProgramNNInput(
         Hardware,
-        archType,
         dataType,
         inImageXSize,
         inImageYSize,
@@ -6535,7 +4751,6 @@ gckHARDWARE_ResetFlopWithNN(
     /* Commands. */
     gcmkONERROR(_ProgramNNInstruction(
         Hardware,
-        archType,
         dataType,
         inImageXSize,
         inImageYSize,
@@ -6548,6 +4763,7 @@ gckHARDWARE_ResetFlopWithNN(
         data[gcvFLOP_RESET_NN_INPUT].address,
         data[gcvFLOP_RESET_NN_OUTPUT].address,
         data[gcvFLOP_RESET_NN_KERNEL].address,
+        cd,
         AllocFlag,
         Pool,
         &data[gcvFLOP_RESET_NN_INSTRUCTION]
@@ -6555,9 +4771,8 @@ gckHARDWARE_ResetFlopWithNN(
 
     gcmkONERROR(_ProgramNNCommand(
         Hardware,
-        archType,
-        kernelBurstSize,
         data[gcvFLOP_RESET_NN_INSTRUCTION].address,
+        cd,
         AllocFlag,
         Pool,
         Command
@@ -6565,29 +4780,44 @@ gckHARDWARE_ResetFlopWithNN(
 
 #if gcdENABLE_FLOP_RESET_DEBUG
     outBufBytes = outImageXSize * outImageYSize * outImageZSize * itemBytes;
-    gcmkPRINT("outImageXSize : %d,outImageYSize : %d, outImageZSize : %d, itemBytes : %d", outImageXSize, outImageYSize, outImageZSize, itemBytes);
 
     gcmkONERROR(gckOS_Allocate(Hardware->os, outBufBytes, &Command->golden));
     gckOS_ZeroMemory(Command->golden, outBufBytes);
-    golden = (char*)Command->golden;
-    for (i = 0; i < outBufBytes; ++i)
+    golden = (gctUINT8_PTR)Command->golden;
+    if(Hardware->identity.customerID == 0x23 || Hardware->identity.customerID == 0x83)
     {
-        golden[i] = '3';
+        golden[0] = 0xe3;
+        golden[1] = 0x34;
+        golden[2] = 0xe3;
+        golden[3] = 0x34;
+    }
+    else if(Hardware->identity.customerID == 0x96)
+    {
+        golden[0] = 0x50;
+        golden[1] = 0x50;
+    }
+    else
+    {
+        for (i = 0; i < outBufBytes; ++i)
+        {
+            golden[i] = '3';
+        }
     }
-
-    gcmkPRINT("when reading NN golden, NN gloden address is %p", Command->golden);
-    gcmkPRINT("NN conv result top 2 bytes: %c, %c", ((char*)Command->golden)[0], ((char*)Command->golden)[1]);
     Command->outlogical = data[gcvFLOP_RESET_NN_OUTPUT].logical;
     Command->outSize = outBufBytes;
 #endif
 
+    if(Hardware->identity.customerID == 0x85)
+    {
+        Command->channelId = 2;
+    }
     Command->data = data;
     Command->dataCount = dataCount;
 
     return gcvSTATUS_OK;
 
 OnError:
-    if (Command->funcVidMem)
+    if (Command && Command->funcVidMem)
     {
         gcmkVERIFY_OK(_FreeVideoMemory(
             Hardware->kernel,
@@ -6625,76 +4855,25 @@ gckHARDWARE_ResetFlopWithNN(
 static gceSTATUS
 _ProgramTPKernel(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
-    IN gctUINT32 CoreCount,
-    IN gctUINT32 Zdp,
     IN gctUINT8 DataType,
     IN gctUINT32 KernelXSize,
     IN gctUINT32 KernelYSize,
     IN gctUINT32 KernelZSize,
+    IN chipCmdData* cd,
     IN gctUINT32 AllocFlag,
     IN OUT gcePOOL *Pool,
     OUT gcsFUNCTION_EXECUTION_DATA *Data
     )
 {
-#if gcdENABLE_FLOP_RESET == 0
-    gceSTATUS status = gcvSTATUS_OK;
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress =0;
-    gctSIZE_T bufferBytes = 0x3C0;
-    gctUINT32 *buffer = gcvNULL;
-    gctUINT32 i;
-
-
-    /* hardcode */
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_BITMAP,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    buffer = (gctUINT32_PTR)bufferLogical;
-
-    /* Fill the data. */
-    for (i = 0; i < bufferBytes / 4; i++)
-    {
-        buffer[i] = 0;
-    }
-
-    buffer[0] = 0x01150410;
-    buffer[1] = buffer[81] = buffer[161] = 0x00000100;
-    buffer[5] = buffer[85] = buffer[165] = 0x26543780;
-    buffer[6] = buffer[86] = buffer[166] = 0x000000ff;
-    buffer[7] = buffer[87] = buffer[167] = 0x0006801a;
-    buffer[48] = buffer[128] = buffer[208] = 0x00024938;
-    buffer[64] = buffer[144] = buffer[224] = 0x00024938;
-    buffer[80] = buffer[160] = 0x01140410;
-
-
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bufferBytes
-        ));
-#else
     gceSTATUS status = gcvSTATUS_OK;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
     gctUINT32 bufferAddress = 0;
     gctSIZE_T bufferBytes = 0;
+    gctSIZE_T bytes;
     gctUINT32 *buffer = gcvNULL;
-    chipCmdData *cd;
 
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
-    bufferBytes = cd->TPkerLen;
+    bytes = bufferBytes = cd->TPkerLen;
     /* hardcode */
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -6710,7 +4889,7 @@ _ProgramTPKernel(
     buffer = (gctUINT32_PTR)bufferLogical;
 
     /* Fill the data. */
-    gckOS_MemCopy(bufferLogical, cd->TPKer, bufferBytes);
+    gckOS_MemCopy(bufferLogical, cd->TPKer, bytes);
 
     gcmkONERROR(gckVIDMEM_NODE_CleanCache(
         Hardware->kernel,
@@ -6719,7 +4898,6 @@ _ProgramTPKernel(
         bufferLogical,
         bufferBytes
         ));
-#endif
 
 #if gcdDUMP_IN_KERNEL
     gcmkDUMP(Hardware->os, "#[flop reset: TP kernel]");
@@ -6728,7 +4906,7 @@ _ProgramTPKernel(
         gcvDUMP_BUFFER_KERNEL_COMMAND,
         bufferLogical,
         bufferAddress,
-        bufferBytes
+        bytes
         );
 #endif
 
@@ -6736,7 +4914,7 @@ _ProgramTPKernel(
     Data->bufVidMemBytes = bufferBytes;
     Data->address = bufferAddress;
     Data->logical = bufferLogical;
-    Data->bytes = bufferBytes;
+    Data->bytes = bytes;
 
     return gcvSTATUS_OK;
 
@@ -6755,7 +4933,6 @@ _ProgramTPKernel(
 static gceSTATUS
 _ProgramTPInput(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
     IN gctUINT8 DataType,
     IN gctUINT32 InImageXSize,
     IN gctUINT32 InImageYSize,
@@ -6774,19 +4951,9 @@ _ProgramTPInput(
     gctUINT32 bufferAddress = 0;
     gctSIZE_T bufferBytes, bytes;
     gctUINT8_PTR buffer = gcvNULL;
-
     gctUINT32 i = 0;
     gctUINT32 offset = 0;
-    gctUINT32 value[] = {
-        0x33, /* uint8, the case set scale = 0.003921569*/
-        0x3c00, /* fp16 */
-        1, /* int8 */
-        1, /* uint16 */
-        1, /* int16 */
-        1, /* uint4 */
-        1, /* int4 */
-        0x3f80  /* bf16 */
-    };
+
     gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
 
     bufferBytes = inputSize * itemBytes;
@@ -6802,16 +4969,11 @@ _ProgramTPInput(
         &bufferAddress
         ));
 
-    if (gcvVIP_ARCH_TYPE_V8 == ArchType)
-    {
-        value[0x4] = 0x81;
-    }
-
     buffer = (gctUINT8_PTR)bufferLogical;
 
     for (i = 0; i < inputSize; i++)
     {
-        _BitValue(&buffer, value[DataType], &offset, itemBytes * 8);
+        _BitValue(&buffer, flopResetInputs[DataType], &offset, itemBytes * 8);
     }
 
     bytes = buffer + (offset + 7) / 8 - (gctUINT8_PTR)bufferLogical;
@@ -6879,12 +5041,7 @@ _ProgramTPOutput(
 
     gcmkONERROR(_GetNNDataSize(DataType, &itemBytes));
 
-    bufferBytes = bytes = OutputXSize * OutputYSize * OutputZSize * itemBytes;
-    if(Hardware->identity.customerID == 0x86)
-    {
-        bufferBytes *= 2;
-        bytes *= 2;
-    }
+    bufferBytes = bytes = (gctSIZE_T)(OutputXSize * OutputYSize * OutputZSize * itemBytes);
 
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -6925,7 +5082,6 @@ _ProgramTPOutput(
 static gceSTATUS
 _ProgramTPInstruction(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
     IN gctUINT8 DataType,
     IN gctUINT32 InImageXSize,
     IN gctUINT32 InImageYSize,
@@ -6938,90 +5094,24 @@ _ProgramTPInstruction(
     IN gctUINT32 InImageAddress,
     IN gctUINT32 OutImageAddress,
     IN gctUINT32 KernelAddress,
+    IN chipCmdData* cd,
     IN gctUINT32 AllocFlag,
     IN gcePOOL *Pool,
     OUT gcsFUNCTION_EXECUTION_DATA_PTR Data
     )
 {
-#if gcdENABLE_FLOP_RESET == 0
-    gceSTATUS status = gcvSTATUS_OK;
-
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress = 0;
-    gctSIZE_T bufferBytes, bytes;
-    gctUINT32 *command = gcvNULL;
-    gctUINT32 i;
-
-    bufferBytes = bytes = 0x180;
-
-    /* Allocate buffer. */
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_COMMAND,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    command = (gctUINT32_PTR)bufferLogical;
-
-    /* Fill the data. */
-    for (i = 0; i < bufferBytes / 4; i++)
-    {
-        command[i] = 0;
-    }
-
-    for (i = 0; i < 3; i++)
-    {
-        command[0] = command[2] = command[3] = command[20] = 0x00000001;
-        command[1] = 0x00020001;
-        command[8] = command[9] = command[16] = command[19] = 0x00010001;
-        command[10] = InImageAddress;
-        command[24] = 0x0000240a;
-        command[26] = command[28] = 0x03ffffff;
-        command[30] = 0x00008100;
-        command = command + 32;
-    }
-
-    command = (gctUINT32_PTR)bufferLogical;
-
-    command[6] = 0xa0002a1b;
-    command[38] = command[70] = 0xa000281b;
-    command[12] = command[44] = 0xc0000002;
-    command[76] = 0x80000002;
-    command[22] = 0x00010016;
-    command[54] = command[86] = 0x00010015;
-    command[11] = KernelAddress;
-    command[43] = KernelAddress + 0x140;
-    command[75] = KernelAddress + 0x280;
-    command[13] = OutImageAddress;
-    command[45] = OutImageAddress + 0x16;
-    command[77] = OutImageAddress + 0x2b;
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
-#else
     gceSTATUS status = gcvSTATUS_OK;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
     gctUINT32 bufferAddress = 0;
     gctSIZE_T bufferBytes;
+    gctSIZE_T bytes;
     gctUINT32 *command = gcvNULL;
     gctUINT32 i;
     gctSIZE_T steps = 1;
     gctUINT32 KernelAnchor = 0, OutImageAnchor = 0;
-    chipCmdData* cd;
 
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
-    bufferBytes = cd->TPInsLen;
+    bytes = bufferBytes = cd->TPCoreCount * TP_INSTRUCTION_LEN;
     /* Allocate buffer. */
     gcmkONERROR(_AllocateVideoMemory(
         Hardware->kernel,
@@ -7033,9 +5123,9 @@ _ProgramTPInstruction(
         &bufferLogical,
         &bufferAddress
         ));
-    gckOS_MemCopy(bufferLogical, cd->TPIns, bufferBytes);
+    gckOS_MemCopy(bufferLogical, cd->TPIns, bytes);
     command = (gctUINT32_PTR)bufferLogical;
-    steps = bufferBytes/128;
+    steps = bytes / TP_INSTRUCTION_LEN;
     KernelAnchor = command[11];
     OutImageAnchor = command[13];
     for(i = 0; i < steps; ++i)
@@ -7044,6 +5134,7 @@ _ProgramTPInstruction(
         command[i*32 + 11] = KernelAddress + command[i*32 + 11] - KernelAnchor;
         command[i*32 + 13] = OutImageAddress + command[i*32 + 13] - OutImageAnchor;
     }
+
     gcmkONERROR(gckVIDMEM_NODE_CleanCache(
         Hardware->kernel,
         bufferNode,
@@ -7051,7 +5142,7 @@ _ProgramTPInstruction(
         bufferLogical,
         bufferBytes
         ));
-#endif
+
 #if gcdDUMP_IN_KERNEL
     gcmkDUMP(Hardware->os, "#[flop reset: TP instruction]");
     gcmkDUMP_BUFFER(
@@ -7059,7 +5150,7 @@ _ProgramTPInstruction(
         gcvDUMP_BUFFER_KERNEL_COMMAND,
         bufferLogical,
         bufferAddress,
-        bufferBytes
+        bytes
         );
 #endif
 
@@ -7067,7 +5158,7 @@ _ProgramTPInstruction(
     Data->bufVidMemBytes = bufferBytes;
     Data->address = bufferAddress;
     Data->logical = bufferLogical;
-    Data->bytes = bufferBytes;
+    Data->bytes = bytes;
 
     return gcvSTATUS_OK;
 
@@ -7086,100 +5177,13 @@ _ProgramTPInstruction(
 static gceSTATUS
 _ProgramTPCommand(
     IN gckHARDWARE Hardware,
-    IN gceVIP_ARCH_TYPE ArchType,
     IN gctUINT32 InstAddress,
+    IN chipCmdData* cd,
     IN gctUINT32 AllocFlag,
     IN gcePOOL *Pool,
     OUT gcsFUNCTION_COMMAND_PTR Command
     )
 {
-#if gcdENABLE_FLOP_RESET == 0
-    gceSTATUS status = gcvSTATUS_OK;
-
-    gckVIDMEM_NODE bufferNode = gcvNULL;
-    gctPOINTER bufferLogical = gcvNULL;
-    gctUINT32 bufferAddress = 0;
-    gctSIZE_T bufferBytes;
-    gctUINT32 bytes;
-    gctUINT32 *commands;
-
-    gctUINT8_PTR endLogical;
-    gctUINT32 endAddress;
-    gctUINT32 endBytes = 0;
-    gctUINT32 i = 0;
-    gctUINT32 k;
-
-    bufferBytes = gcmSIZEOF(gctUINT32) * 64;
-
-    gcmkONERROR(_AllocateVideoMemory(
-        Hardware->kernel,
-        gcvVIDMEM_TYPE_COMMAND,
-        AllocFlag,
-        Pool,
-        &bufferBytes,
-        &bufferNode,
-        &bufferLogical,
-        &bufferAddress
-        ));
-
-    commands = (gctUINT32_PTR)bufferLogical;
-    for (i = 0; i < 3; i++)
-    {
-        k = 14 * i;
-        commands[0 + k] = 0x08010e4e;
-        commands[1 + k] = 0x00400000;
-        commands[2 + k] = 0x08010e4f;
-        commands[3 + k] = 0x00000000;
-        commands[4 + k] = 0x08010e50;
-        commands[5 + k] = 0x00000000;
-        commands[6 + k] = 0x08010e53;
-        commands[7 + k] = 0x00000000;
-        commands[8 + k] = 0x08010e54;
-        commands[9 + k] = 0x00000008;
-        commands[10 + k] = 0x08010e27;
-        commands[11 + k] = 0x00000000;
-        commands[12 + k] = 0x0801042e;
-    }
-
-    commands[13] = (InstAddress & 0xffffffC0) | (0x1);
-    commands[27] = ((InstAddress + 0x80) & 0xffffffC0) | (0x1);
-    commands[37] = 0x00000000;
-    commands[41] = ((InstAddress + 0x100) & 0xffffffC0);
-    commands[42] = 0x08010429;
-    commands[43] = 0;
-    commands[44] = 0x08010E03;
-    commands[45] = 0x20;
-
-    bytes = 46 * 4;
-    endLogical = (gctUINT8_PTR)bufferLogical + bytes;
-    endAddress = bufferAddress + bytes;
-
-    if (Hardware->wlFE)
-    {
-        gcmkONERROR(gckWLFE_End(Hardware, gcvNULL, ~0U, &endBytes));
-        gcmkONERROR(gckWLFE_End(Hardware, endLogical, endAddress, &endBytes));
-    }
-
-    bytes += endBytes;
-
-    gcmkASSERT(bytes <= bufferBytes);
-    gcmkONERROR(gckVIDMEM_NODE_CleanCache(
-        Hardware->kernel,
-        bufferNode,
-        0,
-        bufferLogical,
-        bytes
-        ));
-    Command->funcVidMem = bufferNode;
-    Command->funcVidMemBytes = bufferBytes;
-    Command->logical = bufferLogical;
-    Command->address = bufferAddress;
-    Command->bytes = bytes;
-    Command->endAddress = endAddress;
-    Command->endLogical = endLogical;
-
-    return gcvSTATUS_OK;
-#else
     gceSTATUS status = gcvSTATUS_OK;
     gckVIDMEM_NODE bufferNode = gcvNULL;
     gctPOINTER bufferLogical = gcvNULL;
@@ -7194,9 +5198,8 @@ _ProgramTPCommand(
     gctUINT32 endBytes = 0;
     gctUINT32 i = 0;
     gctUINT32 k = 1;
-    chipCmdData *cd;
+
     bufferBytes = gcmSIZEOF(gctUINT32) * 280;
-    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
     bytes = cd->TPCmdLen;
 
 
@@ -7213,10 +5216,23 @@ _ProgramTPCommand(
 
     commands = (gctUINT32_PTR)bufferLogical;
     gckOS_MemCopy(commands, cd->TPCmd, bytes);
-    //cannot reverse, only proper when instaddress = *00
-    i = cd->TPInsLen/128;
+
+    i = cd->TPCoreCount;
     startAnchor = commands[cd->TPCmdOffset[0]];
-    commands[cd->TPCmdOffset[0]] = (cd->TPInsLen / 0x80 == 1)?(InstAddress & 0xffffffC0):((InstAddress & 0xffffffC0) | (0x1));
+    commands[cd->TPCmdOffset[0]] = (cd->TPCoreCount == 1)?(InstAddress & 0xffffffC0):((InstAddress & 0xffffffC0) | (0x1));
+    if(Hardware->identity.customerID == 0x85)
+    {
+        commands[cd->TPCmdOffset[0]] = ((((gctUINT32) (0)) & ~(((gctUINT32) (((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1))))))) << (0 ?
+ 25:0))) | (((gctUINT32) ((gctUINT32) ((InstAddress >> 6)) & ((gctUINT32) ((((1 ?
+ 25:0) - (0 ?
+ 25:0) + 1) == 32) ?
+ ~0U : (~(~0U << ((1 ? 25:0) - (0 ? 25:0) + 1))))))) << (0 ? 25:0)));
+    }
     for(k = 1; k < i; k++)
     {
         commands[cd->TPCmdOffset[k]] =  commands[cd->TPCmdOffset[0]] + commands[cd->TPCmdOffset[k]] - startAnchor;
@@ -7241,7 +5257,7 @@ _ProgramTPCommand(
         bufferNode,
         0,
         bufferLogical,
-        bytes
+        bufferBytes
         ));
 
     Command->funcVidMem = bufferNode;
@@ -7264,7 +5280,6 @@ _ProgramTPCommand(
 #endif
 
     return gcvSTATUS_OK;
-#endif
 
 OnError:
     if (bufferNode)
@@ -7306,16 +5321,14 @@ gckHARDWARE_ResetFlopWithTP(
     gctUINT32 i;
     gctPOINTER pointer = gcvNULL;
 
-    gceVIP_ARCH_TYPE archType = gcvVIP_ARCH_TYPE_V8;
     gctUINT8 dataType;
-    gctUINT32 coreCount = 0;
-    gctUINT32 zdp = 1;
     gctUINT32 itemBytes = 0;
     gcsFUNCTION_EXECUTION_DATA_PTR data = gcvNULL;
     gctUINT32 dataCount = 0;
+    chipCmdData* cd;
 
 #if gcdENABLE_FLOP_RESET_DEBUG
-    char *golden;
+    gctUINT8_PTR golden;
     gctSIZE_T outBufBytes;
 
 #endif
@@ -7325,9 +5338,12 @@ gckHARDWARE_ResetFlopWithTP(
         gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
     }
 
-
-    dataType = 0x0;
-
+    cd = gcQuerychipCmdDB(Hardware->identity.customerID, Hardware->identity.chipModel, Hardware->identity.chipRevision, Hardware->identity.productID, Hardware->identity.ecoID);
+    if(cd == gcvNULL)
+    {
+        return status;
+    }
+    dataType = cd->InputDataType;
     gcmkONERROR(_GetNNDataSize(dataType, &itemBytes));
 
     /* Exectution data. */
@@ -7345,13 +5361,11 @@ gckHARDWARE_ResetFlopWithTP(
     /* Kernel. */
     gcmkONERROR(_ProgramTPKernel(
         Hardware,
-        archType,
-        coreCount,
-        zdp,
         dataType,
         kernelXSize,
         kernelYSize,
         kernelZSize,
+        cd,
         AllocFlag,
         Pool,
         &data[gcvFLOP_RESET_TP_KERNEL]
@@ -7360,7 +5374,6 @@ gckHARDWARE_ResetFlopWithTP(
     /* Input. */
     gcmkONERROR(_ProgramTPInput(
         Hardware,
-        archType,
         dataType,
         inImageXSize,
         inImageYSize,
@@ -7385,7 +5398,6 @@ gckHARDWARE_ResetFlopWithTP(
     /* Commands. */
     gcmkONERROR(_ProgramTPInstruction(
         Hardware,
-        archType,
         dataType,
         inImageXSize,
         inImageYSize,
@@ -7398,6 +5410,7 @@ gckHARDWARE_ResetFlopWithTP(
         data[gcvFLOP_RESET_TP_INPUT].address,
         data[gcvFLOP_RESET_TP_OUTPUT].address,
         data[gcvFLOP_RESET_TP_KERNEL].address,
+        cd,
         AllocFlag,
         Pool,
         &data[gcvFLOP_RESET_TP_INSTRUCTION]
@@ -7405,8 +5418,8 @@ gckHARDWARE_ResetFlopWithTP(
 
     gcmkONERROR(_ProgramTPCommand(
         Hardware,
-        archType,
         data[gcvFLOP_RESET_TP_INSTRUCTION].address,
+        cd,
         AllocFlag,
         Pool,
         Command
@@ -7414,21 +5427,223 @@ gckHARDWARE_ResetFlopWithTP(
 
 #if gcdENABLE_FLOP_RESET_DEBUG
     outBufBytes = outImageXSize * outImageYSize * outImageZSize * itemBytes;
-    gcmkPRINT("outImageXSize : %d,outImageYSize : %d, outImageZSize : %d, itemBytes : %d", outImageXSize, outImageYSize, outImageZSize, itemBytes);
     gcmkONERROR(gckOS_Allocate(Hardware->os, outBufBytes, &Command->golden));
     gckOS_ZeroMemory(Command->golden, outBufBytes);
-    golden = (char*)Command->golden;
-    for(i = 0; i < outBufBytes; ++i)
+    golden = (gctUINT8_PTR)Command->golden;
+    if(Hardware->identity.customerID == 0x23 || Hardware->identity.customerID == 0x83)
     {
-        golden[i] = '3';
+        golden[0] = 0x19;
+        golden[1] = 0xa9;
+        golden[2] = 0x31;
+        golden[3] = 0x31;
+        golden[4] = 0xf9;
+        golden[5] = 0x35;
+        golden[6] = 0x53;
+        golden[7] = 0x30;
+        golden[8] = 0x3c;
+        golden[9] = 0x29;
+        golden[10] = 0x3b;
+        golden[11] = 0x37;
+        golden[12] = 0x24;
+        golden[13] = 0x38;
+        golden[14] = 0x33;
+        golden[15] = 0x37;
+        golden[16] = 0xd;
+        golden[17] = 0x39;
+        golden[18] = 0x6e;
+        golden[19] = 0x32;
+        golden[20] = 0x68;
+        golden[21] = 0xba;
+        golden[22] = 0x40;
+        golden[23] = 0x2a;
+        golden[24] = 0xab;
+        golden[25] = 0xa9;
+        golden[26] = 0xb;
+        golden[27] = 0xb4;
+        golden[28] = 0xe8;
+        golden[29] = 0xab;
+        golden[30] = 0x9e;
+        golden[31] = 0x30;
+        golden[32] = 0xf0;
+        golden[33] = 0x20;
+        golden[34] = 0x98;
+        golden[35] = 0xb6;
+        golden[36] = 0x5a;
+        golden[37] = 0xb1;
+        golden[38] = 0x90;
+        golden[39] = 0xb4;
+        golden[40] = 0xff;
+        golden[41] = 0x38;
+        golden[42] = 0x7c;
+        golden[43] = 0xb4;
+        golden[44] = 0xb6;
+        golden[45] = 0x31;
+        golden[46] = 0x34;
+        golden[47] = 0xae;
+        golden[48] = 0xa3;
+        golden[49] = 0x38;
+        golden[50] = 0xb4;
+        golden[51] = 0x32;
+        golden[52] = 0x5f;
+        golden[53] = 0x31;
+        golden[54] = 0x12;
+        golden[55] = 0x34;
+        golden[56] = 0xc0;
+        golden[57] = 0x34;
+        golden[58] = 0xac;
+        golden[59] = 0xa6;
+        golden[60] = 0x6f;
+        golden[61] = 0x38;
+        golden[62] = 0xfd;
+        golden[63] = 0x34;
+        golden[64] = 0xa7;
+        golden[65] = 0xb7;
+        golden[66] = 0xa0;
+        golden[67] = 0x33;
+        golden[68] = 0x89;
+        golden[69] = 0x34;
+        golden[70] = 0xb6;
+        golden[71] = 0x33;
+        golden[72] = 0x80;
+        golden[73] = 0x94;
+        golden[74] = 0x5d;
+        golden[75] = 0xb2;
+        golden[76] = 0x68;
+        golden[77] = 0x37;
+        golden[78] = 0xbb;
+        golden[79] = 0xb1;
+        golden[80] = 0x23;
+        golden[81] = 0xb5;
+        golden[82] = 0xc3;
+        golden[83] = 0x28;
+        golden[84] = 0xac;
+        golden[85] = 0x35;
+        golden[86] = 0x8a;
+        golden[87] = 0xb3;
+        golden[88] = 0x12;
+        golden[89] = 0x34;
+        golden[90] = 0x47;
+        golden[91] = 0xb4;
+        golden[92] = 0xa6;
+        golden[93] = 0x32;
+        golden[94] = 0x86;
+        golden[95] = 0xb1;
+        golden[96] = 0x83;
+        golden[97] = 0xae;
+        golden[98] = 0x6a;
+        golden[99] = 0x32;
+        golden[100] = 0x1a;
+        golden[101] = 0xb1;
+        golden[102] = 0x99;
+        golden[103] = 0xb4;
+        golden[104] = 0xcd;
+        golden[105] = 0x32;
+        golden[106] = 0x78;
+        golden[107] = 0xb4;
+        golden[108] = 0x66;
+        golden[109] = 0x8a;
+        golden[110] = 0xa6;
+        golden[111] = 0xad;
+        golden[112] = 0xf3;
+        golden[113] = 0x2f;
+        golden[114] = 0x79;
+        golden[115] = 0xa0;
+        golden[116] = 0x15;
+        golden[117] = 0xb5;
+        golden[118] = 0x1a;
+        golden[119] = 0xb5;
+        golden[120] = 0x4a;
+        golden[121] = 0xb5;
+        golden[122] = 0x4;
+        golden[123] = 0xb8;
+        golden[124] = 0xdc;
+        golden[125] = 0x2f;
+        golden[126] = 0x8e;
+        golden[127] = 0x31;
+    }
+    else if(Hardware->identity.customerID == 0x96)
+    {
+        golden[0] = 0x32;
+        golden[1] = 0x0;
+        golden[2] = 0xfe;
+        golden[3] = 0xfa;
+        golden[4] = 0x16;
+        golden[5] = 0xfe;
+        golden[6] = 0xfc;
+        golden[7] = 0xf7;
+        golden[8] = 0x2;
+        golden[9] = 0xf;
+        golden[10] = 0x3;
+        golden[11] = 0xf;
+        golden[12] = 0x18;
+        golden[13] = 0xec;
+        golden[14] = 0x6;
+        golden[15] = 0xf6;
+        golden[16] = 0xf7;
+        golden[17] = 0xc;
+        golden[18] = 0xf8;
+        golden[19] = 0x4;
+        golden[20] = 0xef;
+        golden[21] = 0x4;
+        golden[22] = 0xea;
+        golden[23] = 0xfa;
+        golden[24] = 0xf4;
+        golden[25] = 0xd;
+        golden[26] = 0xe;
+        golden[27] = 0xfd;
+        golden[28] = 0xee;
+        golden[29] = 0xff;
+        golden[30] = 0xe6;
+        golden[31] = 0xfc;
+        golden[32] = 0x13;
+        golden[33] = 0x1;
+        golden[34] = 0xf7;
+        golden[35] = 0xdf;
+        golden[36] = 0xe9;
+        golden[37] = 0xec;
+        golden[38] = 0xf;
+        golden[39] = 0xf0;
+        golden[40] = 0xf0;
+        golden[41] = 0xb;
+        golden[42] = 0xa;
+        golden[43] = 0xe7;
+        golden[44] = 0x0;
+        golden[45] = 0xec;
+        golden[46] = 0x1b;
+        golden[47] = 0xf4;
+        golden[48] = 0xee;
+        golden[49] = 0x1b;
+        golden[50] = 0xe2;
+        golden[51] = 0x20;
+        golden[52] = 0xe9;
+        golden[53] = 0x1;
+        golden[54] = 0xfe;
+        golden[55] = 0x1;
+        golden[56] = 0x17;
+        golden[57] = 0xf7;
+        golden[58] = 0x26;
+        golden[59] = 0x8;
+        golden[60] = 0xd8;
+        golden[61] = 0xf3;
+        golden[62] = 0x5;
+        golden[63] = 0x1c;
+    }
+    else
+    {
+        for(i = 0; i < outBufBytes; ++i)
+        {
+            golden[i] = '3';
+        }
     }
-
-    gcmkPRINT("TP fc result top 3 bytes: %c, %c, %c", ((char*)Command->golden)[0], ((char*)Command->golden)[1], ((char*)Command->golden)[2]);
 
     Command->outlogical = data[gcvFLOP_RESET_TP_OUTPUT].logical;
     Command->outSize = outBufBytes;
 #endif
 
+    if(Hardware->identity.customerID == 0x85)
+    {
+        Command->channelId = 3;
+    }
     Command->data = data;
     Command->dataCount = dataCount;
 
@@ -7436,7 +5651,7 @@ gckHARDWARE_ResetFlopWithTP(
     return gcvSTATUS_OK;
 
 OnError:
-    if (Command->funcVidMem)
+    if (Command && Command->funcVidMem)
     {
         gcmkVERIFY_OK(_FreeVideoMemory(
             Hardware->kernel,
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.h
index f6b06e1fc3a0..9c8924f784f2 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -90,10 +90,6 @@ gckHARDWARE_ResetFlopWithTP(
 }
 #endif
 
-#ifndef gcdENABLE_FLOP_RESET
-#   define gcdENABLE_FLOP_RESET                    1
-#endif
-
 #ifndef gcdENABLE_FLOP_RESET_DEBUG
 #   define gcdENABLE_FLOP_RESET_DEBUG                    0
 #endif
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset_config.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset_config.h
index 51de22971a43..28d45b774344 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset_config.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_flop_reset_config.h
@@ -53,12 +53,189 @@
 *****************************************************************************/
 
 
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2021 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2021 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+
 #ifndef __gc_hal_kernel_hardware_func_flop_reset_config_h_
 #define __gc_hal_kernel_hardware_func_flop_reset_config_h_
 
 #include "gc_hal.h"
-#include "gc_hal_kernel.h"
-#include "gc_hal_kernel_hardware.h"
+
+/*
+ * Flop reset.
+ *
+ * The flops can be reset with PPU, NN and TP programs.
+ * PPU:
+ *   Requirements:
+ *   1. DP inst with all bins enabled.
+ *   2. Load inst which has at least two shader group,
+ *      and every thread should load from different 64-byte address.
+ *   3. Stroe inst which has at least 6 threads, whose addresses are
+ *      from different 64-byte address and flush.
+ *   Case:
+ *   * InImage: 64x6 = {1}, unsigned int8
+ *   * OutImage: 64x6, unsigned int8
+ *   * OutImage = InImage + InImage
+ * NN:
+ *   Requirements:
+ *   1. A XYDP6 case.
+ *   2. NN cmd that uses only 1 core and make othere core's kernel size
+ *      to be 0.
+ *   Case:
+ *   * Input: 3x2x1 = {1}
+ *   * Kernel: 2x2x1 = {1}
+ *   * Output: 2x1x1
+ * TP:
+ *   Requirements:
+ *   1. Run TP fc on all TP cores.
+ *   Case:
+ *   * Input: 1x1x2 = {1}
+ *   * Kernel: 1x1x2x64 = {1}
+ *   * Output: 1x64
+ */
+
+/*
+ * Commment: 0x85 WAR does not follow the settings.
+ */
+
+#define PPU_IMAGE_XSIZE 64
+#define PPU_IMAGE_YSIZE 6
+#define PPU_IMAGE_DATA 0x01010101
+#define MAX_PPU_INSTRUCTION_COUNT 16
+#define MAX_PPU_COMMAND_NUM 128
+#define NN_INSTRUCTION_LEN 128
+#define NN_INSTRUCTION_LEN_EXT 192
+#define TP_INSTRUCTION_LEN 128
+
+#define GCREG_SH_INSTRUCTION_TYPE_INVALID (~0U)
+
+typedef enum _gceFLOP_RESET_PPU_DATA {
+    gcvFLOP_RESET_PPU_INSTRUCTION = 0,
+    gcvFLOP_RESET_PPU_INPUT       = 1,
+    gcvFLOP_RESET_PPU_OUTPUT      = 2,
+    gcvFLOP_RESET_PPU_DATA_NUM
+}
+gceFLOP_RESET_PPU_DATA;
+
+/*
+ * NN convolution.
+ */
+#define MAX_NN_COMMAND_NUM 192
+
+#define NN_KERNEL_XSIZE 2
+#define NN_KERNEL_YSIZE 2
+#define NN_KERNEL_ZSIZE 1
+
+#define NN_INPUT_XSIZE 3
+#define NN_INPUT_YSIZE 2
+#define NN_INPUT_ZSIZE 1
+
+#define NN_OUTPUT_XSIZE 2
+#define NN_OUTPUT_YSIZE 1
+#define NN_OUTPUT_ZSIZE 1
+
+typedef enum _gceVIP_ARCH_TYPE {
+    gcvVIP_ARCH_TYPE_V6,
+    gcvVIP_ARCH_TYPE_V7,
+    gcvVIP_ARCH_TYPE_V8
+}
+gceVIP_ARCH_TYPE;
+
+typedef enum _gceFLOP_RESET_NN_DATA {
+    gcvFLOP_RESET_NN_INSTRUCTION = 0,
+    gcvFLOP_RESET_NN_INPUT       = 1,
+    gcvFLOP_RESET_NN_OUTPUT      = 2,
+    gcvFLOP_RESET_NN_KERNEL      = 3,
+    gcvFLOP_RESET_NN_DATA_NUM
+}
+gceFLOP_RESET_NN_DATA;
+
+#define TP_KERNEL_XSIZE 1
+#define TP_KERNEL_YSIZE 1
+#define TP_KERNEL_ZSIZE 2
+#define TP_KENREL_UNITS 64
+
+#define TP_INPUT_XSIZE 1
+#define TP_INPUT_YSIZE 1
+#define TP_INPUT_ZSIZE 2
+
+#define TP_OUTPUT_XSIZE 1
+#define TP_OUTPUT_YSIZE 64
+#define TP_OUTPUT_ZSIZE 1
+
+typedef enum _gceFLOP_RESET_TP_DATA {
+    gcvFLOP_RESET_TP_INSTRUCTION = 0,
+    gcvFLOP_RESET_TP_INPUT       = 1,
+    gcvFLOP_RESET_TP_OUTPUT      = 2,
+    gcvFLOP_RESET_TP_KERNEL      = 3,
+    gcvFLOP_RESET_TP_DATA_NUM
+}
+gceFLOP_RESET_TP_DATA;
+
+
+static gctUINT32 flopResetInputs[] = {
+        0x33, /* uint8 */
+        0x3266, /* fp16 */
+        0x33, /* int8 */
+        1, /* uint16 */
+        0x33, /* int16 */
+        1, /* uint4 */
+        1, /* int4 */
+        0x3f80       /* bf16 */
+    };
+
 
 typedef struct{
     gctUINT32 ChipID;
@@ -67,14 +244,15 @@ typedef struct{
     gctUINT32 EcoID;
     gctUINT32 customerID;
     gctUINT32 formalRelease;
+    gctUINT8 InputDataType;
     gctUINT32 NNkerLen;
     gctUINT32 NNCmdLen;
     gctUINT32 NNCmdOffset;
-    gctUINT32 TPInsLen;
+    gctUINT32 TPCoreCount;
     gctUINT32 TPkerLen;
     gctUINT32 TPCmdLen;
     gctUINT32 TPCmdOffset[16];
-    gctUINT32 NNIns[32];
+    gctUINT32 NNIns[48];
     gctUINT32 NNKer[256];
     gctUINT32 NNCmd[192];
     gctUINT32 TPIns[256];
@@ -85,894 +263,70 @@ typedef struct{
 static chipCmdData chipcmd[]={
     {
         0x8000, /* ChipID */
-        0x8002, /* ChipRevision */
-        0x5080009, /* ProductID */
-        0x6000000, /* EcoID */
-        0x9f, /* CustomerID */
-        0x0,
-        0xC0,
-        88,
-        15,
-        0x180,
-        0x3C0,
-        0x000000C8,
-        {
-            15, 29, 43
-        },
-        {
-            0xA010004A, 0x001000C0, 0x54000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x10000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00040000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x01030410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26540781, 0x00000000, 0x00000035,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xEC024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x0001FE00, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000040, 0x08010E54, 0x00000000,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        },
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0002A1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010016, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000281B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
-            0xC0000002, 0xDFF6E016, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010015, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000281B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62280,
-            0x80000002, 0xDFF6E02B, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010015, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        },
-        {
-            0x01150410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26543780, 0x000000FF, 0x0006801A,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x01140410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26543780, 0x000000FF, 0x0006801A,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x01140410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26543780, 0x000000FF, 0x0006801A,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-        },
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61081, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61100,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        },
-    },
-    {
-        0x8000, /* ChipID */
-        0x8003, /* ChipRevision */
-        0x5080009, /* ProductID */
-        0x4000000, /* EcoID */
-        0xb5, /* CustomerID */
+        0x7004, /* ChipRevision */
+        0x45080009, /* ProductID */
+        0x1, /* EcoID */
+        0x7d, /* CustomerID */
         0x0,
-        0x000000C0, //kerlen
-        0x00000058, //cmdlen
-        15,
-        0x100, //tpinslen
-        0x00000280, //tpkerlen
-        0x00000090, //TPCmdLen;
+        0, /*InputDataType*/
+        0x0C0,
+        0x00000040,
+        9,
+        2, /*TPCoreCount*/
+        0x00000280,
+        0x00000068,
         {
-            15, 29
+            9, 19
         },
         {
-            0xA010004A, 0x001000C0, 0x54000000, 0x00080080,
+            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
             0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
             0x00012004, 0x00000000, 0x00000000, 0x00000800,
             0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x10000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00040000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x01030410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26540781, 0x00000000, 0x00000035,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xEC024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x0001FE00, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000050, 0x08010E54, 0x00000000,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        },
-        {   // tp ins
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
-            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        },
-        {   //tp ker
-            0x011F0410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26543780, 0x000000FF, 0x0006801A,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x011F0410, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26543780, 0x000000FF, 0x0006801A,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00024938, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-        },
-        {
-            //tp cmd
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E54, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61080, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        }
-    },
-    {
-        0x8000, /* ChipID */
-        0x7004, /* ChipRevision */
-        0x45080009, /* ProductID */
-        0x0, /* EcoID */
-        0x7d, /* CustomerID */
-        0x0,
-        0x0C0, //gctUINT32 NNkerLen;
-        0x00000040, //gctUINT32 NNCmdLen;
-        9, //NNCmdoffset
-        0x100, //gctUINT32 TPInsLen;
-        0x00000280, //gctUINT32 TPkerLen;
-        0x00000068, //gctUINT32 TPCmdLen;
-        {
-            9, 19
-        }, //gctUINT32 TPCmdoffset;
-        {               //gctUINT32 NNIns[32];
-            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {//gctUINT32 NNKer[256];
-            0x00000040, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {//gctUINT32 NNCmd[64];
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000000, 0x08010E27, 0x00000000,
-            0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        },
-        //gctUINT32 TPIns[256];
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
-            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        },
-        //gctUINT32 TPKer[256];
-        {
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61001, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61080,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        }//gctUINT32 TPCmd[280];
-    },
-    {
-        0x8000, /* ChipID */
-        0x7004, /* ChipRevision */
-        0x45080009, /* ProductID */
-        0x1, /* EcoID */
-        0x7d, /* CustomerID */
-        0x0,
-        0x0C0, //gctUINT32 NNkerLen;
-        0x00000040, //gctUINT32 NNCmdLen;
-        9, //NNCmdoffset
-        0x100, //gctUINT32 TPInsLen;
-        0x00000280, //gctUINT32 TPkerLen;
-        0x00000068, //gctUINT32 TPCmdLen;
-        {
-            9, 19
-        }, //gctUINT32 TPCmdoffset;
-        {               //gctUINT32 NNIns[32];
-            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {//gctUINT32 NNKer[256];
-            0x00000040, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {//gctUINT32 NNCmd[64];
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000000, 0x08010E27, 0x00000000,
-            0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        },
-        //gctUINT32 TPIns[256];
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
-            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        },
-        //gctUINT32 TPKer[256];
-        {
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61001, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61080,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        }//gctUINT32 TPCmd[280];
-    },
-    {
-        0x8000,
-        0x7131, // ChipRevision
-        0x8000001, // ProductID
-        0x2000000, // EcoID
-        0x99, // CustomerID
-        0x0, //gctUINT32 formalRelease;
-        0x00000080, //gctUINT32 NNkerLen;
-        0x00000058, //gctUINT32 NNCmdLen;
-        15, //gctUINT32 NNCmdOffset;
-        0x400, //gctUINT32 TPInsLen;
-        0x00000800, //gctUINT32 TPkerLen;
-        0x000001E0, //gctUINT32 TPCmdLen;
-        {15, 29, 43, 57, 71, 85, 99, 113}, //gctUINT32 TPCmdOffset[16];
-        {
-            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNIns[32];
-        {
-            0x01020411, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26540781, 0x00000000, 0x00000069,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x0073FFE0, 0xC0003800, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNKer[256];
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000010, 0x08010E54, 0x00000000,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        }, //gctUINT32 NNCmd[64];
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62100,
-            0xC0000002, 0xDFF6E008, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62200,
-            0xC0000002, 0xDFF6E010, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62300,
-            0xC0000002, 0xDFF6E018, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62400,
-            0xC0000002, 0xDFF6E020, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62500,
-            0xC0000002, 0xDFF6E028, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62600,
-            0xC0000002, 0xDFF6E030, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62700,
-            0x80000002, 0xDFF6E038, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-
-        }, //gctUINT32 TPIns[256];
-        {
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 TPKer[512];
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61081, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61101,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61181, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61201,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61281, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61301,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
-            0x08010E54, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61380, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        }         //gctUINT32 TPCmd[280];
-    },
-    {
-        0x8000, //ChipID
-        0x7131, // ChipRevision
-        0x5000009, //ProductID
-        0x8000000, //EcoID
-        0xa1, //CustomerID
-        0x0, //gctUINT32 formalRelease;
-        0x00000080, //gctUINT32 NNkerLen;
-        0x00000058, //gctUINT32 NNCmdLen;
-        15, //gctUINT32 NNCmdOffset;
-        0x300, //gctUINT32 TPInsLen;
-        0x00000600, //gctUINT32 TPkerLen;
-        0x00000170, //gctUINT32 TPCmdLen;
-        {15, 29, 43, 57, 71, 85}, //gctUINT32 TPCmdOffset[16];
-        {
-            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000A00, 0x00000000, 0x00000800, 0x00000000,
             0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
             0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNIns[32];
-        {
-            0x01020411, 0x00000100, 0x00000000, 0x00000000,
-            0x00000000, 0x26540781, 0x00000000, 0x00000069,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x0073FFE0, 0xC0003800, 0x0000000F, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNKer[256];
-        {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000010, 0x08010E54, 0x00000000,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
-        }, //gctUINT32 NNCmd[64];
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62100,
-            0xC0000002, 0xDFF6E00B, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62200,
-            0xC0000002, 0xDFF6E016, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62300,
-            0xC0000002, 0xDFF6E021, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000121B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62400,
-            0xC0000002, 0xDFF6E02C, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000A, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA000121B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62500,
-            0x80000002, 0xDFF6E036, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x0001000A, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        }, //gctUINT32 TPIns[256];
-        {
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x00000040, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
+            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E4C, 0x00000000, 0x08010E27, 0x00000000,
+            0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
+            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
+        },
+        {
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
+            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x00010020, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
+            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x00010020, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
+        },
+        {
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -981,13 +335,17 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -997,30 +355,95 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61001, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61080,
+            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
+            0x08010E03, 0x00000C23
+        }
+    },
+    {
+        0x8000, /* ChipID */
+        0x7004, /* ChipRevision */
+        0x45080009, /* ProductID */
+        0x0, /* EcoID */
+        0x7d, /* CustomerID */
+        0x0,
+        0, /*InputDataType*/
+        0x0C0,
+        0x00000040,
+        9,
+        2, /*TPCoreCount*/
+        0x00000280,
+        0x00000068,
+        {
+            9, 19
+        },
+        {
+            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
+            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
+            0x00012004, 0x00000000, 0x00000000, 0x00000800,
+            0x00000880, 0x00000000, 0x00000800, 0x00000000,
+            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
+            0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x00000040, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
+            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E4C, 0x00000000, 0x08010E27, 0x00000000,
+            0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
+            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
+        },
+        {
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
+            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x00010020, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
+            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x00010020, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
+        },
+        {
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1029,13 +452,17 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1045,41 +472,28 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
+            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-
-        }, //gctUINT32 TPKer[256];,
+        },
         {
-            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61081, 0x08010E4E, 0x00400000,
             0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61101,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
-            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61181, 0x08010E4E, 0x00400000,
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61201,
-            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61001, 0x08010E4F, 0x00000000,
             0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E54, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61280, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        }         //gctUINT32 TPCmd[280];
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61080,
+            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
+            0x08010E03, 0x00000C23
+        },
     },
     {
         0x8000, /* ChipID */
@@ -1087,14 +501,15 @@ static chipCmdData chipcmd[]={
         0x45080009, /* ProductID */
         0x0, /* EcoID */
         0x88, /* CustomerID */
-        0x0, //gctUINT32 formalRelease;
-        0x00000240, //gctUINT32 NNkerLen;
-        0x00000040, //gctUINT32 NNCmdLen;
-        9, //gctUINT32 NNCmdOffset;
-        0x200, //gctUINT32 TPInsLen;
-        0x00000400, //gctUINT32 TPkerLen;
-        0x000000B8, //gctUINT32 TPCmdLen;
-        {9, 19, 29, 39}, //gctUINT32 TPCmdOffset[16];
+        0x0,
+        0, /*InputDataType*/
+        0x00000240,
+        0x00000040,
+        9,
+        4, /*TPCoreCount*/
+        0x00000400,
+        0x000000B8,
+        {9, 19, 29, 39},
         {
             0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
             0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
@@ -1104,7 +519,7 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNIns[32];
+        },
         {
             0x00000040, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1142,13 +557,13 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNKer[256];
+        },
         {
             0x08010E4F, 0x01000000, 0x08010E50, 0x01100000,
             0x08010E4C, 0x00000010, 0x08010E27, 0x00000000,
             0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
             0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        }, //gctUINT32 NNCmd[64];
+        },
         {
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
             0x00000000, 0x00000000, 0xA0001E1B, 0x00000000,
@@ -1182,7 +597,7 @@ static chipCmdData chipcmd[]={
             0x00000001, 0x00000000, 0x00010010, 0x00000000,
             0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
             0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        }, //gctUINT32 TPIns[256];
+        },
         {
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1248,7 +663,7 @@ static chipCmdData chipcmd[]={
             0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 TPKer[256];
+        },
         {
             0x08010E4F, 0x01000000, 0x08010E50, 0x01100000,
             0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
@@ -1262,195 +677,166 @@ static chipCmdData chipcmd[]={
             0x08010E27, 0x00000000, 0x0801042E, 0xDFF61180,
             0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
             0x08010E03, 0x00000C23
-        }         //gctUINT32 TPCmd[280];
+        }
     },
-        /*
     {
-        0x8000, //ChipID
-        0x7005, // ChipRevision
-        0x15080003, // ProductID
-        0x0, // EcoID
-        0x83, // CustomerID
+        0x8000,
+        0x7131,
+        0x5000009,
+        0x8000000,
+        0xa1,
         0x0,
-        0x000000C0, //gctUINT32 NNkerLen;
-        0x000000D8, //gctUINT32 NNCmdLen;
-        7, //gctUINT32 NNCmdOffset;
-        0x100, //gctUINT32 TPInsLen;
-        0x000001C0, //gctUINT32 TPkerLen;
-        0x00000108, //gctUINT32 TPCmdLen;
-        {7, 19}, //gctUINT32 TPCmdOffset[16];
+        0, /*InputDataType*/
+        0x00000080,
+        0x00000058,
+        15,
+        6, /*TPCoreCount*/
+        0x00000600,
+        0x00000170,
+        {15, 29, 43, 57, 71, 85},
         {
-            0xA0100048, 0x00180095, 0x00000000, 0x00100040,
-            0x04044001, 0x037FCE00, 0xDFF5F000, 0xDFF5E000,
-            0x00022004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00030004, 0x00000002, 0x00000000, 0x03FFFFFF,
+            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
+            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
+            0x00012004, 0x00000000, 0x00000000, 0x00000800,
+            0x00000A00, 0x00000000, 0x00000800, 0x00000000,
+            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
             0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x00000040, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x01020411, 0x00000100, 0x00000000, 0x00000000,
+            0x00000000, 0x26540781, 0x00000000, 0x00000069,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x0073FFE0, 0xC0003800, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
+        },
+        {
+            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E4C, 0x00000010, 0x08010E54, 0x00000000,
+            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
+            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
+            0x08010E03, 0x00000C23
+        },
+        {
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
+            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62100,
+            0xC0000002, 0xDFF6E00B, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62200,
+            0xC0000002, 0xDFF6E016, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000141B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62300,
+            0xC0000002, 0xDFF6E021, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000B, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000121B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62400,
+            0xC0000002, 0xDFF6E02C, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000A, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
+            0x00000001, 0x00020001, 0x00000001, 0x00000001,
+            0x00000000, 0x00000000, 0xA000121B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62500,
+            0x80000002, 0xDFF6E036, 0x00000000, 0x00000000,
+            0x00010001, 0x00000000, 0x00000000, 0x00010001,
+            0x00000001, 0x00000000, 0x0001000A, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
+        },
+        {
+            0x00000021, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x77000100, 0xB7248C3A, 0x66B2213E, 0x00B8D1B4,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x68000001, 0x00220000, 0x08010E4C, 0x00000014,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFF37000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x68000001, 0xCDCDCDCD, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00000F01, 0x68000002, 0xCDCDCDCD,
-            0x08010E02, 0x00100F01, 0x48000000, 0x01000F01,
-            0x6800FFFF, 0xCDCDCDCD, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000040,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x68000001, 0xCDCDCDCD, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00000F01, 0x68000002, 0xCDCDCDCD,
-            0x08010E02, 0x00100F01, 0x48000000, 0x01000F01,
-            0x6800FFFF, 0xCDCDCDCD
-        },
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80003E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF5F000, 0xDFF51000,
-            0x80240002, 0xDFF5E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80003E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF5F000, 0xDFF50000,
-            0x80240002, 0xDFF5E040, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x00000042, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xC0CB5EF0, 0x9C43BEF3, 0x11731F5B, 0x6833D8D3,
-            0x9A0BDFDB, 0x8692DC5B, 0x7F63D793, 0x654B583B,
-            0xD0BBBFDB, 0xD19B9A23, 0xF71B9913, 0x9FDB84DB,
-            0x7A7368FB, 0xF4FB8733, 0x6EEBB1EB, 0x467409BB,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
+            0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x1C1C00B0, 0xFB436CE3, 0xC9DB2223, 0x7D13B6BB,
-            0xB1DAEEBB, 0xEEB3EBB3, 0xAB6AE26B, 0x77C3D89B,
-            0x42137D6B, 0x16CADFAB, 0x76B3F09C, 0x4EA384B3,
-            0x82D32C33, 0x36CBC21B, 0x028BA1B3, 0x8BFBEC1C,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x68000001, 0x00000C20, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF4F000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000002, 0x00000C20, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00010000, 0x0801042E, 0xDFF4E000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x68000001, 0xCDCDCDCD, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00000F01, 0x68000002, 0xCDCDCDCD,
-            0x08010E02, 0x00100F01, 0x48000000, 0x01000F01,
-            0x6800FFFF, 0xCDCDCDCD, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000040,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x68000001, 0xCDCDCDCD, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00000F01, 0x68000002, 0xCDCDCDCD,
-            0x08010E02, 0x00100F01, 0x48000000, 0x01000F01,
-            0x6800FFFF, 0xCDCDCDCD
-        }
-
-    }, */
-    {
-        0x8000, /* ChipID */
-        0x7121, /* ChipRevision */
-        0x508000b, /* ProductID */
-        0x2000000, /* EcoID */
-        0x98, /* CustomerID */
-        0x0, //gctUINT32 formalRelease;
-        0x000000C0, //gctUINT32 NNkerLen;
-        0x00000040, //gctUINT32 NNCmdLen;
-        9, //gctUINT32 NNCmdOffset;
-        0x100, //gctUINT32 TPInsLen;
-        0x00000280, //gctUINT32 TPkerLen;
-        0x00000068, //gctUINT32 TPCmdLen;
-        {9, 19}, //gctUINT32 TPCmdOffset[16];
-        {
-            0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
-            0x00012004, 0x00000000, 0x00000000, 0x00000800,
-            0x00000880, 0x00000000, 0x00000800, 0x00000000,
-            0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
-            0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x00000040, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000021, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0FFFFFFF, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000
-        },
-        {
-            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E4C, 0x00000010, 0x08010E27, 0x00000000,
-            0x08010428, 0xDFF47000, 0x08010429, 0x00000000,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
-        },
-        {
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
-            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
-            0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0xA0003E1B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62140,
-            0x80000002, 0xDFF6E020, 0x00000000, 0x00000000,
-            0x00010001, 0x00000000, 0x00000000, 0x00010001,
-            0x00000001, 0x00000000, 0x00010020, 0x00000000,
-            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
-        },
-        {
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1459,17 +845,13 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1479,171 +861,150 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x000FFFFF, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFFFFFFF0, 0xFFFFFFFF ,0xFFFFFFFF, 0xFFFFFFFF,
-            0xFFFFFFFF, 0xFFFFFFFF ,0xFFFFFFFF, 0xFFFFFFFF,
-            0x0000000F, 0x00000000 ,0x00000000, 0x00000000,
-            0x00000000, 0x00000000 ,0x00000000, 0x00000000
+            0x00000000, 0x00000000, 0x00000000, 0x00000000
         },
         {
+            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
             0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
-            0x08010E53, 0x00000000, 0x08010E27, 0x00000000,
-            0x0801042E, 0xDFF61001, 0x08010E4F, 0x00000000,
+            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
             0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61080,
-            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000C23
+            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61081, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61101,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
+            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61181, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000000, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61201,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000000,
+            0x08010E54, 0x00000000, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61280, 0x08010429, 0x00000000,
+            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
         }
     },
     {
-        0x8000, /* ChipID */
-        0x7300, /* ChipRevision */
-        0x5080008, /* ProductID */
-        0x10000000, /* EcoID */
-        0x86, /* CustomerID */
-        0x0, //gctUINT32 formalRelease;
-        0x000000C0, //gctUINT32 NNkerLen;
-        0x00000238, //gctUINT32 NNCmdLen;
-        11, //gctUINT32 NNCmdOffset;
-        0x400, //gctUINT32 TPInsLen;
-        0x00000800, //gctUINT32 TPkerLen;
-        0, //gctUINT32 TPCmdLen;
-        {11, 27, 43, 59, 75, 91, 107, 123}, //gctUINT32 TPCmdOffset[16];
+        0x8000,
+        0x7131,
+        0x8000001,
+        0x2000000,
+        0x99,
+        0x0,
+        0, /*InputDataType*/
+        0x00000080,
+        0x00000058,
+        15,
+        8, /*TPkerLen*/
+        0x00000800,
+        0x000001E0,
+        {15, 29, 43, 57, 71, 85, 99, 113},
         {
             0xA0100048, 0x001000C0, 0xC8000000, 0x00080080,
-            0x02084001, 0x037FB600, 0xDFEFF000, 0xDFEFE000,
+            0x02084001, 0x037FD200, 0xDFF6F000, 0xDFF6E000,
             0x00012004, 0x00000000, 0x00000000, 0x00000800,
             0x00000880, 0x00000000, 0x00000800, 0x00000000,
             0x00020003, 0x01000002, 0x00000000, 0x03FFFFFF,
             0x00000000, 0x03FFFFFF, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNIns[32];
+        },
         {
-            0x00000040, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xFF000100, 0x00000000, 0x00FFFFFF, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x01020411, 0x00000100, 0x00000000, 0x00000000,
+            0x00000000, 0x26540781, 0x00000000, 0x00000069,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x0073FFE0, 0xC0003800, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 NNKer[256];
+        },
         {
-            0x68000001, 0xCDCDCDCD, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E4C, 0x00000010,
-            0x08010E27, 0x00000000, 0x08010428, 0xDFED7000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x08010E02, 0x01000F01, 0x48000000, 0x00100F01,
-            0x48000000, 0x01000F01, 0x08010E02, 0x02100F01,
-            0x48000000, 0x01200F01, 0x08010E02, 0x00100F01,
-            0x48000000, 0x02100F01, 0x08010E02, 0x03200F01,
-            0x48000000, 0x02300F01, 0x08010E02, 0x01200F01,
-            0x48000000, 0x03200F01, 0x08010E02, 0x04300F01,
-            0x48000000, 0x03400F01, 0x08010E02, 0x02300F01,
-            0x48000000, 0x04300F01, 0x08010E02, 0x05400F01,
-            0x48000000, 0x04500F01, 0x08010E02, 0x03400F01,
-            0x48000000, 0x05400F01, 0x08010E02, 0x06500F01,
-            0x48000000, 0x05600F01, 0x08010E02, 0x04500F01,
-            0x48000000, 0x06500F01, 0x08010E02, 0x07600F01,
-            0x48000000, 0x06700F01, 0x08010E02, 0x05600F01,
-            0x48000000, 0x07600F01, 0x08010E02, 0x06700F01,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000040, 0x08010E02, 0x30000701,
-            0x48000000, 0x30000701, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00100F01, 0x48000000, 0x01000F01,
-            0x08010E02, 0x02100F01, 0x48000000, 0x01200F01,
-            0x08010E02, 0x00100F01, 0x48000000, 0x02100F01,
-            0x08010E02, 0x03200F01, 0x48000000, 0x02300F01,
-            0x08010E02, 0x01200F01, 0x48000000, 0x03200F01,
-            0x08010E02, 0x04300F01, 0x48000000, 0x03400F01,
-            0x08010E02, 0x02300F01, 0x48000000, 0x04300F01,
-            0x08010E02, 0x05400F01, 0x48000000, 0x04500F01,
-            0x08010E02, 0x03400F01, 0x48000000, 0x05400F01,
-            0x08010E02, 0x06500F01, 0x48000000, 0x05600F01,
-            0x08010E02, 0x04500F01, 0x48000000, 0x06500F01,
-            0x08010E02, 0x07600F01, 0x48000000, 0x06700F01,
-            0x08010E02, 0x05600F01, 0x48000000, 0x07600F01,
-            0x08010E02, 0x06700F01
-        }, //gctUINT32 NNCmd[64];
+            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E4C, 0x00000010, 0x08010E54, 0x00000000,
+            0x08010E27, 0x00000000, 0x08010428, 0xDFF47000,
+            0x08010429, 0x00000000, 0x08010E03, 0x00000C23,
+            0x08010E03, 0x00000C23
+        },
         {
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEF1000,
-            0x80240002, 0xDFEFE000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62000,
+            0xC0000002, 0xDFF6E000, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEF0000,
-            0x80240002, 0xDFEFE010, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62100,
+            0xC0000002, 0xDFF6E008, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEEF000,
-            0x80240002, 0xDFEFE020, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62200,
+            0xC0000002, 0xDFF6E010, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEEE000,
-            0x80240002, 0xDFEFE030, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62300,
+            0xC0000002, 0xDFF6E018, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEED000,
-            0x80240002, 0xDFEFE040, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62400,
+            0xC0000002, 0xDFF6E020, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEEC000,
-            0x80240002, 0xDFEFE050, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62500,
+            0xC0000002, 0xDFF6E028, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEEB000,
-            0x80240002, 0xDFEFE060, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62600,
+            0xC0000002, 0xDFF6E030, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000,
             0x00000001, 0x00020001, 0x00000001, 0x00000001,
-            0x00000000, 0x00000000, 0x80000E4B, 0x00000000,
-            0x00010001, 0x00010001, 0xDFEFF000, 0xDFEEA000,
-            0x80240002, 0xDFEFE070, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0xA0000E1B, 0x00000000,
+            0x00010001, 0x00010001, 0xDFF6F000, 0xDFF62700,
+            0x80000002, 0xDFF6E038, 0x00000000, 0x00000000,
             0x00010001, 0x00000000, 0x00000000, 0x00010001,
             0x00000001, 0x00000000, 0x00010008, 0x00000000,
-            0x0000000A, 0x00000000, 0x03FFFFFF, 0x00000000,
-            0x03FFFFFF, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 TPIns[256];,
+            0x0000240A, 0x00000000, 0x03FFFFFF, 0x00000000,
+            0x03FFFFFF, 0x00000000, 0x00008100, 0x00000000
+        },
         {
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
@@ -1653,12 +1014,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xD8A394C0, 0xDB536192, 0x8683A0F3, 0x1F3231B3,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x9CDBAE40, 0xA023DF13, 0xED6B86CB, 0x02141263,
-            0x00000004, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1669,12 +1030,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x9163B430, 0x713C0483, 0xADCA71B3, 0xB4BB996B,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x5E840800, 0x255BF753, 0x681B233B, 0x213363BB,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1685,12 +1046,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xC4133810, 0x2F6B657B, 0xED63FA8B, 0x8893C44B,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xBFCB1F60, 0xCD6B70CB, 0x4E93CD6B, 0xC35B18F3,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1701,12 +1062,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xA6F3D660, 0xCF23293B, 0x08D3A0D3, 0x7443D1DB,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xF683E310, 0x8AA39133, 0x21339D42, 0x0073DFA2,
-            0x00000004, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1717,12 +1078,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xC0CB5EF0, 0x9C43BEF3, 0x11731F5B, 0x6833D8D3,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x1C1C00B0, 0xFB436CE3, 0xC9DB2223, 0x7D13B6BB,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1733,12 +1094,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x9A0BDFD0, 0x8692DC5B, 0x7F63D793, 0x654B583B,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xB1DAEEB0, 0xEEB3EBB3, 0xAB6AE26B, 0x77C3D89B,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1749,12 +1110,12 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0xD0BBBFD0, 0xD19B9A23, 0xF71B9913, 0x9FDB84DB,
-            0x0000000B, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x42137D60, 0x16CADFAB, 0x76B3F09C, 0x4EA384B3,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000021, 0x00000000, 0x00000000, 0x00000000,
@@ -1765,86 +1126,50 @@ static chipCmdData chipcmd[]={
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x7A7368F0, 0xF4FB8733, 0x6EEBB1EB, 0x467409BB,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
+            0xFFFFFFF0, 0xFFFFFFFF, 0x0000000F, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
-            0x82D32C30, 0x36CBC21B, 0x028BA1B3, 0x8BFBEC1C,
-            0x00000003, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000,
             0x00000000, 0x00000000, 0x00000000, 0x00000000
-        }, //gctUINT32 TPKer[256];
+        },
         {
-            0x68000001, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00000000, 0x0801042E, 0xDFEE9000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000002, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00010000, 0x0801042E, 0xDFEE8000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000004, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00020000, 0x0801042E, 0xDFEE7000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000008, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00030000, 0x0801042E, 0xDFEE6000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000010, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00040000, 0x0801042E, 0xDFEE5000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000020, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00050000, 0x0801042E, 0xDFEE4000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000040, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00060000, 0x0801042E, 0xDFEE3000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x68000080, 0x00000C20, 0x08010E4F, 0x01000000,
-            0x08010E50, 0x01180000, 0x08010E53, 0x00000000,
-            0x08010E27, 0x00070000, 0x0801042E, 0xDFEE2000,
-            0x08010429, 0x00000000, 0x6800FFFF, 0xCDCDCDCD,
-            0x08010E02, 0x30000701, 0x48000000, 0x30000701,
-            0x08010E02, 0x01000F01, 0x48000000, 0x00100F01,
-            0x48000000, 0x01000F01, 0x08010E02, 0x02100F01,
-            0x48000000, 0x01200F01, 0x08010E02, 0x00100F01,
-            0x48000000, 0x02100F01, 0x08010E02, 0x03200F01,
-            0x48000000, 0x02300F01, 0x08010E02, 0x01200F01,
-            0x48000000, 0x03200F01, 0x08010E02, 0x04300F01,
-            0x48000000, 0x03400F01, 0x08010E02, 0x02300F01,
-            0x48000000, 0x04300F01, 0x08010E02, 0x05400F01,
-            0x48000000, 0x04500F01, 0x08010E02, 0x03400F01,
-            0x48000000, 0x05400F01, 0x08010E02, 0x06500F01,
-            0x48000000, 0x05600F01, 0x08010E02, 0x04500F01,
-            0x48000000, 0x06500F01, 0x08010E02, 0x07600F01,
-            0x48000000, 0x06700F01, 0x08010E02, 0x05600F01,
-            0x48000000, 0x07600F01, 0x08010E02, 0x06700F01,
-            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23,
-            0x08010E03, 0x00000040, 0x08010E02, 0x30000701,
-            0x48000000, 0x30000701, 0x08010E02, 0x01000F01,
-            0x48000000, 0x00100F01, 0x48000000, 0x01000F01,
-            0x08010E02, 0x02100F01, 0x48000000, 0x01200F01,
-            0x08010E02, 0x00100F01, 0x48000000, 0x02100F01,
-            0x08010E02, 0x03200F01, 0x48000000, 0x02300F01,
-            0x08010E02, 0x01200F01, 0x48000000, 0x03200F01,
-            0x08010E02, 0x04300F01, 0x48000000, 0x03400F01,
-            0x08010E02, 0x02300F01, 0x48000000, 0x04300F01,
-            0x08010E02, 0x05400F01, 0x48000000, 0x04500F01,
-            0x08010E02, 0x03400F01, 0x48000000, 0x05400F01,
-            0x08010E02, 0x06500F01, 0x48000000, 0x05600F01,
-            0x08010E02, 0x04500F01, 0x48000000, 0x06500F01,
-            0x08010E02, 0x07600F01, 0x48000000, 0x06700F01,
-            0x08010E02, 0x05600F01, 0x48000000, 0x07600F01,
-            0x08010E02, 0x06700F01
-        }         //gctUINT32 TPCmd,[280];
+            0x08010E4E, 0x00400000, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61001,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
+            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61081, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61101,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
+            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61181, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61201,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
+            0x08010E54, 0x00000008, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61281, 0x08010E4E, 0x00400000,
+            0x08010E4F, 0x00000000, 0x08010E50, 0x00000000,
+            0x08010E53, 0x00000002, 0x08010E54, 0x00000008,
+            0x08010E27, 0x00000000, 0x0801042E, 0xDFF61301,
+            0x08010E4E, 0x00400000, 0x08010E4F, 0x00000000,
+            0x08010E50, 0x00000000, 0x08010E53, 0x00000002,
+            0x08010E54, 0x00000000, 0x08010E27, 0x00000000,
+            0x0801042E, 0xDFF61380, 0x08010429, 0x00000000,
+            0x08010E03, 0x00000C23, 0x08010E03, 0x00000C23
+        }
     }
-
 };
 
-//defined as static, .c have to include directly if func used.
 static chipCmdData*
 gcQuerychipCmdDB(
     gctUINT32 CustomerID,
@@ -1870,7 +1195,7 @@ gcQuerychipCmdDB(
             return &chipcmd[i];
         }
     }
-    /**/
+
     for (i = 0; i < entryNum; ++i)
     {
         if ((chipcmd[i].customerID == CustomerID)
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_ppu.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_ppu.h
index 7e7cf0892554..43c07e9a50d9 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_ppu.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_ppu.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_usc.h b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_usc.h
index c6f6297c9225..c8846d0930d3 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_usc.h
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_func_usc.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_mc_fe.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_mc_fe.c
index fd3433f2bf5a..989f900c5c2d 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_mc_fe.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_mc_fe.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -285,13 +285,6 @@ gckMCFE_Construct(
                               &fe->channels[i]));
     }
 
-    /* Enable all events. */
-    gcmkONERROR(
-        gckOS_WriteRegisterEx(Hardware->os,
-                              Hardware->core,
-                              0x00014,
-                              0xFFFFFFFF));
-
     *FE = fe;
     return gcvSTATUS_OK;
 
@@ -425,6 +418,13 @@ gckMCFE_Initialize(
         }
     }
 
+    /* Enable all events. */
+    gcmkONERROR(
+        gckOS_WriteRegisterEx(Hardware->os,
+                              Hardware->core,
+                              0x00014,
+                              0xFFFFFFFF));
+
     FE->mmuEnabled = MMUEnabled;
 
     gcmkFOOTER_NO();
@@ -770,16 +770,23 @@ gckMCFE_Execute(
     gceSTATUS status;
     gctUINT32 regBase;
     gcsMCFE_DESCRIPTOR *desc;
-    gcsMCFE_CHANNEL * channel  = &Hardware->mcFE->channels[ChannelId];
-    gcsMCFE_RING_BUF * ringBuf = Priority ? &channel->priRingBuf
-                              : &channel->stdRingBuf;
+    gckMCFE mcFE = Hardware->mcFE;
+    gcsMCFE_CHANNEL * channel  = gcvNULL;
+    gcsMCFE_RING_BUF * ringBuf = gcvNULL;
 
     gcmkHEADER_ARG("Hardware=0x%x Priority=0x%x ChannelId=%u Address=%x Bytes=%u",
                     Hardware, Priority, ChannelId, Address, Bytes);
 
+    /* ChannelId should be valid. */
+    gcmkASSERT(mcFE && ChannelId < mcFE->channelCount);
+
+    channel = &mcFE->channels[ChannelId];
+
     /* No priority channel in system channel by design. */
     gcmkASSERT(!(channel->binding == gcvMCFE_CHANNEL_SYSTEM && Priority == 1));
 
+    ringBuf = Priority ? &channel->priRingBuf : &channel->stdRingBuf;
+
     /*
      * If no more descriptor space to write in ring buffer.
      * To be improved to wait signal instead of blindly delay.
@@ -872,12 +879,18 @@ gckMCFE_HardwareIdle(
     gctUINT32 readPtr;
     gctUINT32 ChannelId = 0;
     gctBOOL Priority = gcvFALSE;
-    gcsMCFE_CHANNEL * channel  = &Hardware->mcFE->channels[ChannelId];
-    gcsMCFE_RING_BUF * ringBuf = Priority ? &channel->priRingBuf
-                              : &channel->stdRingBuf;
+    gckMCFE mcFE = Hardware->mcFE;
+    gcsMCFE_CHANNEL * channel  = gcvNULL;
+    gcsMCFE_RING_BUF * ringBuf = gcvNULL;
 
     gcmkHEADER();
 
+    /* ChannelId should be valid. */
+    gcmkASSERT(mcFE && ChannelId < mcFE->channelCount);
+
+    channel = &mcFE->channels[ChannelId];
+    ringBuf = Priority ? &channel->priRingBuf : &channel->stdRingBuf;
+
     *isIdle = gcvTRUE;
 
     /* Read idle register. */
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_waitlink_fe.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_waitlink_fe.c
index ef971ce1656c..e6042fb53570 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_waitlink_fe.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_hardware_waitlink_fe.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -1387,16 +1387,6 @@ gckWLFE_Event(
         gcmkONERROR(
             gckOS_MemoryBarrier(Hardware->os, logical + 1));
 
-#if gcmIS_DEBUG(gcdDEBUG_TRACE)
-        {
-            gctPHYS_ADDR_T phys;
-            gckOS_GetPhysicalAddress(Hardware->os, Logical, &phys);
-            gckOS_CPUPhysicalToGPUPhysical(Hardware->os, phys, &phys);
-            gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_HARDWARE,
-                           "0x%08x: EVENT %d", phys, Event);
-        }
-#endif
-
         /* Append the extra states. These are needed for the chips that do not
         ** support back-to-back events due to the async interface. The extra
         ** states add the necessary delay to ensure that event IDs do not
diff --git a/drivers/staging/npu/kernel/arch/gc_hal_kernel_recorder.c b/drivers/staging/npu/kernel/arch/gc_hal_kernel_recorder.c
index 0bdad09e0cd4..e31fce3f7e72 100644
--- a/drivers/staging/npu/kernel/arch/gc_hal_kernel_recorder.c
+++ b/drivers/staging/npu/kernel/arch/gc_hal_kernel_recorder.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/arch/makefile.linux b/drivers/staging/npu/kernel/arch/makefile.linux
index 15b252f797f6..7a6fc10524f5 100755
--- a/drivers/staging/npu/kernel/arch/makefile.linux
+++ b/drivers/staging/npu/kernel/arch/makefile.linux
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/cebuild/makefile b/drivers/staging/npu/kernel/cebuild/makefile
index 86642996693e..bd8c6e62a565 100755
--- a/drivers/staging/npu/kernel/cebuild/makefile
+++ b/drivers/staging/npu/kernel/cebuild/makefile
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/cebuild/sources b/drivers/staging/npu/kernel/cebuild/sources
index c98e6506deee..7350aaf2880a 100755
--- a/drivers/staging/npu/kernel/cebuild/sources
+++ b/drivers/staging/npu/kernel/cebuild/sources
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
@@ -63,7 +63,6 @@ SOURCES = \
     ../gc_hal_kernel.c \
     ../gc_hal_kernel_command.c \
     ../gc_hal_kernel_db.c \
-    ../gc_hal_kernel_debug.c \
     ../gc_hal_kernel_event.c \
     ../gc_hal_kernel_heap.c \
     ../gc_hal_kernel_mmu.c \
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel.c b/drivers/staging/npu/kernel/gc_hal_kernel.c
index 9630586443ce..3490de554584 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -658,7 +658,8 @@ gckKERNEL_Construct(
 #if VIVANTE_PROFILER
     /* Initialize profile setting */
     kernel->profiler.profileEnable = gcvFALSE;
-    kernel->profiler.profileMode = gcvPROFILER_PROBE_MODE;
+    kernel->profiler.profileMode = gcvPROFILER_UNKNOWN_MODE;
+    kernel->profiler.probeMode = gcvPROFILER_UNKNOWN_PROBE;
     kernel->profiler.profileCleanRegister = gcvTRUE;
 #endif
 
@@ -720,13 +721,12 @@ gckKERNEL_Construct(
     return gcvSTATUS_OK;
 
 OnError:
-    gckOS_SetGPUPower(Os, kernel->core, gcvFALSE, gcvFALSE);
-    *Kernel = gcvNULL;
-
     if (kernel != gcvNULL)
     {
+        gckOS_SetGPUPower(Os, kernel->core, gcvFALSE, gcvFALSE);
         gckKERNEL_Destroy(kernel);
     }
+    *Kernel = gcvNULL;
 
     /* Return the error. */
     gcmkFOOTER();
@@ -1006,6 +1006,8 @@ gckKERNEL_AllocateVideoMemory(
     gcmkHEADER_ARG("Kernel=%p *Pool=%d *Bytes=%lu Alignment=%lu Type=%d",
                    Kernel, *Pool, *Bytes, Alignment, Type);
 
+    gcmkVERIFY_ARGUMENT(Kernel != gcvNULL);
+
     *NodeObject = gcvNULL;
 
     /* Check flags. */
@@ -1013,6 +1015,13 @@ gckKERNEL_AllocateVideoMemory(
     cacheable  = Flag & gcvALLOC_FLAG_CACHEABLE;
     secure     = Flag & gcvALLOC_FLAG_SECURITY;
 
+    gcmkASSERT(Kernel->hardware != gcvNULL);
+
+    if (!Kernel->hardware->options.enableMMU)
+    {
+        contiguous = gcvTRUE;
+    }
+
     if (Flag & gcvALLOC_FLAG_FAST_POOLS)
     {
         fastPools = gcvTRUE;
@@ -1039,6 +1048,12 @@ gckKERNEL_AllocateVideoMemory(
         *Pool = gcvPOOL_VIRTUAL;
     }
 
+#ifdef __QNXNTO__
+    if (Flag & gcvALLOC_FLAG_4GB_ADDR) {
+        /* Use the Virtual pool, since the system pool may be allocated above 4G limit */
+        *Pool = gcvPOOL_VIRTUAL;
+    }
+#endif
     if (Flag & gcvALLOC_FLAG_DMABUF_EXPORTABLE)
     {
         gctSIZE_T pageSize = 0;
@@ -1073,6 +1088,7 @@ gckKERNEL_AllocateVideoMemory(
         }
     }
 
+
 AllocateMemory:
 
 #if gcdCAPTURE_ONLY_MODE
@@ -1407,9 +1423,6 @@ _AllocateLinearMemory(
     gckOS_QueryOption(Kernel->os, "allMapInOne", &mappingInOne);
     if (mappingInOne == 0)
     {
-        /* TODO: it should page align if driver uses dynamic mapping for mapped user memory.
-         * it should be adjusted with different os.
-         */
         alignment = gcmALIGN(alignment, 4096);
     }
 
@@ -1694,7 +1707,7 @@ _LockVideoMemory(
         gckVIDMEM_NODE_UnlockCPU(Kernel, nodeObject, ProcessID, gcvTRUE, gcvFALSE);
     }
 
-    if (address)
+    if (address != gcvINVALID_ADDRESS)
     {
         gckVIDMEM_NODE_Unlock(Kernel, nodeObject, ProcessID, &asynchronous);
 
@@ -1893,6 +1906,18 @@ _WrapUserMemory(
     gckVIDMEM_NODE nodeObject = gcvNULL;
     gceDATABASE_TYPE type;
     gctUINT32 handle = 0;
+    gctBOOL isContiguous;
+
+    gcmkHEADER_ARG("Kernel=%p ProcessID=%x", Kernel, ProcessID);
+
+    gcmkVERIFY_ARGUMENT(Kernel != gcvNULL);
+
+    gcmkASSERT(Kernel->hardware != gcvNULL);
+
+    if (!Kernel->hardware->options.enableMMU)
+    {
+        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+    }
 
     gcmkONERROR(
         gckVIDMEM_NODE_WrapUserMemory(Kernel,
@@ -1919,7 +1944,23 @@ _WrapUserMemory(
                                gcvNULL,
                                (gctSIZE_T)Interface->u.WrapUserMemory.bytes));
 
+    gcmkONERROR(gckVIDMEM_NODE_IsContiguous(Kernel, nodeObject, &isContiguous));
+
+    if (isContiguous)
+    {
+        /* Record in process db. */
+        gcmkONERROR(
+                gckKERNEL_AddProcessDB(Kernel,
+                                       ProcessID,
+                                       gcvDB_CONTIGUOUS,
+                                       gcmINT2PTR(handle),
+                                       gcvNULL,
+                                       (gctSIZE_T)Interface->u.WrapUserMemory.bytes));
+    }
+
     Interface->u.WrapUserMemory.node = handle;
+
+    gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
@@ -1933,6 +1974,7 @@ _WrapUserMemory(
         gckVIDMEM_NODE_Dereference(Kernel, nodeObject);
     }
 
+    gcmkFOOTER();
     return status;
 }
 
@@ -2672,12 +2714,7 @@ _Commit(
         {
             gcmkONERROR(gckCOMMAND_Stall(kernel->command, gcvTRUE));
 
-            if (kernel->command->currContext)
-            {
-                gcmkONERROR(gckHARDWARE_UpdateContextProfile(
-                            kernel->hardware,
-                            kernel->command->currContext));
-            }
+            gcmkONERROR(gckHARDWARE_UpdateContextProfile(kernel->hardware));
         }
 #endif
 
@@ -3109,6 +3146,10 @@ gckKERNEL_Dispatch(
             commitMutexAcquired = gcvTRUE;
         }
 
+#if gcdENABLE_MP_SWITCH
+        gcmkONERROR(gckKERNEL_DetectMpModeSwitch(Kernel, Interface->u.Commit.mpMode, &Interface->u.Commit.switchMpMode));
+#endif
+
         gcmkONERROR(_Commit(Device,
                             Kernel->hardware->type,
                             Interface->engine,
@@ -5372,6 +5413,16 @@ gckFENCE_Create(
     gctSIZE_T size = 8;
     gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
 
+#ifdef MSDX
+    gctUINT64 wddmMode = 0;
+
+    if ((gckOS_QueryOption(Os, "wddmMode", &wddmMode) == gcvSTATUS_OK) &&
+        (wddmMode))
+    {
+        allocFlag &= ~gcvALLOC_FLAG_CONTIGUOUS;
+    }
+#endif
+
 #if gcdENABLE_CACHEABLE_COMMAND_BUFFER
     allocFlag |= gcvALLOC_FLAG_CACHEABLE;
 #endif
@@ -5701,7 +5752,7 @@ gckDEVICE_ChipInfo(
             Interface->u.ChipInfo.types[i] = info[i].type;
             Interface->u.ChipInfo.ids[i] = info[i].chipID;
 
-            Interface->u.ChipInfo.coreIndexs[i] = info[i].core;
+            Interface->u.ChipInfo.coreIndexs[i] = i;
         }
 
         Interface->u.ChipInfo.count = Device->coreNum;
@@ -5852,10 +5903,15 @@ gckDEVICE_Dispatch(
         {
             kernel = Device->coreInfoArray[coreIndex].kernel;
         }
-        else
+        else if (type > gcvHARDWARE_INVALID && type < gcvHARDWARE_NUM_TYPES)
         {
             kernel = Device->map[type].kernels[coreIndex];
         }
+        else
+        {
+            status = gcvSTATUS_INVALID_ARGUMENT;
+            return status;
+        }
 
         {
             status = gckKERNEL_Dispatch(kernel, Device, Interface);
@@ -5889,7 +5945,6 @@ gckDEVICE_Profiler_Dispatch(
             gckHARDWARE_QueryContextProfile(
                 kernel->hardware,
                 kernel->profiler.profileCleanRegister,
-                gcmNAME_TO_PTR(Interface->u.RegisterProfileData_part1.context),
                 &Interface->u.RegisterProfileData_part1.Counters,
                 gcvNULL));
 
@@ -5902,7 +5957,6 @@ gckDEVICE_Profiler_Dispatch(
             gckHARDWARE_QueryContextProfile(
                 kernel->hardware,
                 kernel->profiler.profileCleanRegister,
-                gcmNAME_TO_PTR(Interface->u.RegisterProfileData_part2.context),
                 gcvNULL,
                 &Interface->u.RegisterProfileData_part2.Counters));
 
@@ -5915,12 +5969,17 @@ gckDEVICE_Profiler_Dispatch(
 
         Interface->u.GetProfileSetting.profileMode = kernel->profiler.profileMode;
 
+        if (kernel->profiler.profileMode == gcvPROFILER_PROBE_MODE)
+        {
+            Interface->u.GetProfileSetting.probeMode = kernel->profiler.probeMode;
+        }
+
         status = gcvSTATUS_OK;
         break;
 
     case gcvHAL_SET_PROFILE_SETTING:
         /* Set profile setting */
-        kernel->profiler.profileEnable = Interface->u.GetProfileSetting.enable;
+        kernel->profiler.profileEnable = Interface->u.SetProfileSetting.enable;
 
         if(kernel->profiler.profileEnable)
         {
@@ -5935,6 +5994,15 @@ gckDEVICE_Profiler_Dispatch(
             {
                 gcmkONERROR(gckHARDWARE_InitProfiler(kernel->hardware));
             }
+            else if (kernel->profiler.profileMode == gcvPROFILER_PROBE_MODE)
+            {
+                kernel->profiler.probeMode = Interface->u.SetProfileSetting.probeMode;
+            }
+            else
+            {
+                gcmkPRINT("unknown profileMode argument");
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+            }
         }
         else
         {
@@ -6089,3 +6157,41 @@ gckKERNEL_MapInTrustApplicaiton(
 }
 #endif
 
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gckKERNEL_DetectMpModeSwitch(
+    IN gckKERNEL Kernel,
+    IN gceMULTI_PROCESSOR_MODE Mode,
+    OUT gctUINT32 *SwitchMpMode
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gctUINT32 switchMpMode = gcvMP_MODE_NO_SWITCH;
+    gctUINT32 count = 0;
+
+    gcmkHEADER_ARG("Kernel=%p Mode=%x", Kernel, Mode);
+
+    gcmkONERROR(gckOS_SwitchCoreCount(Kernel->os, &count));
+
+    if (count == 1 && Mode != gcvMP_MODE_INDEPENDENT)
+    {
+        switchMpMode = gcvMP_MODE_SWITCH_TO_SINGLE;
+    }
+    else if (count > 1 && Mode == gcvMP_MODE_INDEPENDENT)
+    {
+
+        switchMpMode = gcvMP_MODE_SWITCH_TO_MULTI;
+    }
+
+    *SwitchMpMode = switchMpMode;
+
+    gcmkFOOTER_ARG("*SwitchMpMode=%x", *SwitchMpMode);
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+}
+#endif
+
+
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel.h b/drivers/staging/npu/kernel/gc_hal_kernel.h
index 1bd2d1d35187..3a88df0c8436 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel.h
+++ b/drivers/staging/npu/kernel/gc_hal_kernel.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -1292,12 +1292,12 @@ typedef struct _gcsVIDMEM_BLOCK
 
     /* 1M page count. */
     gctUINT32                   pageCount;
+    gctUINT32                   fixedPageCount;
 
     /* Gpu virtual base of this video memory heap. */
     gctUINT32                   addresses[gcvHARDWARE_NUM_TYPES];
     gctPOINTER                  pageTables[gcvHARDWARE_NUM_TYPES];
 
-    /* TODO: */
     gceVIDMEM_TYPE              type;
 
     /* Virtual chunk. */
@@ -1351,6 +1351,7 @@ typedef struct _gcsVIDMEM_NODE
     gckVIDMEM_NODE              tsNode;
     gctUINT32                   tilingMode;
     gctUINT32                   tsMode;
+    gctUINT32                   tsCacheMode;
     gctUINT64                   clearValue;
 
 #if gcdCAPTURE_ONLY_MODE
@@ -1817,6 +1818,11 @@ struct _gckMMU
 
     gceMMU_INIT_MODE            initMode;
     gctBOOL                     pageTableOver4G;
+
+    gcePAGE_TYPE                flatMappingMode;
+
+    /* If the stlb is allocated when page size is 16M . */
+    gctBOOL                     stlbAllocated[gcdMMU_STLB_16M_ENTRY_NUM];
 };
 
 
@@ -2107,6 +2113,15 @@ gckKERNEL_GetHardwareType(
     OUT gceHARDWARE_TYPE *Type
     );
 
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gckKERNEL_DetectMpModeSwitch(
+    IN gckKERNEL Kernel,
+    IN gceMULTI_PROCESSOR_MODE Mode,
+    OUT gctUINT32 *SwitchMpMode
+    );
+#endif
+
 /******************************************************************************\
 ******************************* gckCONTEXT Object *******************************
 \******************************************************************************/
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_command.c b/drivers/staging/npu/kernel/gc_hal_kernel_command.c
index 2c4e5c3b5a20..2da22ae676f0 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_command.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_command.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -565,10 +565,11 @@ _GetNextPendingPos(
 static gceSTATUS
 _SyncToSystemChannel(
     gckCOMMAND Command,
-    gctUINT64 SyncChannel[2]
+    gctUINT64 SyncChannel[2],
+    gctBOOL BroadcastCommit
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gckKERNEL kernel = Command->kernel;
     gckHARDWARE hardware = kernel->hardware;
     gctUINT8 semaId[128];
@@ -578,6 +579,7 @@ _SyncToSystemChannel(
     gctUINT8_PTR buffer;
     gctUINT32 i;
     gctUINT32 pri;
+    gctBOOL commitEntered = gcvFALSE;
 
     /* Ignore system channel. */
     SyncChannel[0] &= ~((gctUINT64)1ull);
@@ -588,6 +590,13 @@ _SyncToSystemChannel(
         return gcvSTATUS_OK;
     }
 
+    if (BroadcastCommit)
+    {
+        /* Acquire the command queue. */
+        gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
+        commitEntered = gcvTRUE;
+    }
+
     /* Query SendSemaphore command size. */
     gckMCFE_SendSemaphore(hardware, gcvNULL, 0, &reqBytes);
 
@@ -643,6 +652,13 @@ _SyncToSystemChannel(
 
         gcmkONERROR(gckCOMMAND_ExecuteMultiChannel(Command, 0, 0, reqBytes));
 
+        if (BroadcastCommit)
+        {
+            /* Release the command queue. */
+            gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+            commitEntered = gcvFALSE;
+        }
+
         /* Now upload the pending semaphore tracking ring. */
         gcmkONERROR(_GetNextPendingPos(Command, &pos));
 
@@ -660,13 +676,17 @@ _SyncToSystemChannel(
             eventObj,
             gcvTRUE,
             gcvFALSE,
-            gcvFALSE
+            BroadcastCommit
             ));
     }
 
-    return gcvSTATUS_OK;
-
 OnError:
+    if (commitEntered)
+    {
+        /* Release the command queue mutex. */
+        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+    }
+
     return status;
 }
 
@@ -767,7 +787,7 @@ _CheckFlushMcfeMMU(
      * This sync is earlier than in Commit, see comments in Commit.
      * Blindly sync dirty other channels to the system channel here.
      */
-    gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel));
+    gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel, gcvFALSE));
 
     /* Query flush Mcfe MMU cache command bytes. */
     gcmkONERROR(gckHARDWARE_FlushMcfeMMU(Hardware, gcvNULL, &reqBytes));
@@ -846,17 +866,6 @@ _FindSemaIdFromMap(
     return -1;
 }
 
-/* Put together patch list handling variables. */
-typedef struct _gcsPATCH_LIST_VARIABLE
-{
-    /* gcvHAL_PATCH_VIDMEM_TIMESTAMP. */
-    gctUINT64 maxAsyncTimestamp;
-
-    /* gcvHAL_PATCH_MCFE_SEMAPHORE. */
-    gctBOOL semaUsed;
-}
-gcsPATCH_LIST_VARIABLE;
-
 /* Patch item handler typedef. */
 typedef gceSTATUS
 (* PATCH_ITEM_HANDLER)(
@@ -923,7 +932,8 @@ _HandleMCFESemaphorePatch(
 
         if (gcmIS_ERROR(status))
         {
-            gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel));
+            gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel, gcvFALSE));
+
             gcmkONERROR(_GetNextMcfeSemaId(Command, gcvTRUE, &semaId));
         }
 
@@ -1027,6 +1037,15 @@ _HandleTimestampPatch(
     return gcvSTATUS_OK;
 }
 
+static const PATCH_ITEM_HANDLER patchHandler[] =
+{
+    gcvNULL,
+    _HandleVidmemAddressPatch,
+    _HandleMCFESemaphorePatch,
+    _HandleTimestampPatch,
+};
+PATCH_ITEM_HANDLER handler;
+
 static gceSTATUS
 _HandlePatchListSingle(
     IN gckCOMMAND Command,
@@ -1046,15 +1065,6 @@ _HandlePatchListSingle(
     gctUINT32 itemSize = 0;
     gctUINT32 batchCount = 0;
 
-    static const PATCH_ITEM_HANDLER patchHandler[] =
-    {
-        gcvNULL,
-        _HandleVidmemAddressPatch,
-        _HandleMCFESemaphorePatch,
-        _HandleTimestampPatch,
-    };
-    PATCH_ITEM_HANDLER handler;
-
     gcmkHEADER_ARG("Command=%p CommandBuffer=%p PatchList=%p type=%d",
                    Command, CommandBuffer, PatchList, PatchList->type);
 
@@ -2191,14 +2201,13 @@ _CommitWaitLinkOnce(
     IN gctBOOL Shared,
     INOUT gctBOOL *contextSwitched,
     IN gctPOINTER PreemptCommit,
-    IN gctBOOL InPreemptThread
+    IN gctBOOL InPreemptThread,
+    IN gctUINT64 MaxAsyncTimeStamp
     )
 {
     gceSTATUS status;
-    gctBOOL commitEntered = gcvFALSE;
     gctBOOL contextAcquired = gcvFALSE;
     gckHARDWARE hardware;
-    gcsPATCH_LIST_VARIABLE patchListVar = {0, 0};
 
     gcsCONTEXT_PTR contextBuffer;
     gctUINT8_PTR commandBufferLogical = gcvNULL;
@@ -2245,10 +2254,6 @@ _CommitWaitLinkOnce(
 
     gcmkASSERT(Command->feType == gcvHW_FE_WAIT_LINK);
 
-    /* Acquire the command queue. */
-    gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
-    commitEntered = gcvTRUE;
-
     /* Acquire the context switching mutex. */
     gcmkONERROR(gckOS_AcquireMutex(
         Command->os, Command->mutexContext, gcvINFINITE
@@ -2258,10 +2263,6 @@ _CommitWaitLinkOnce(
     /* Extract the gckHARDWARE and gckEVENT objects. */
     hardware = Command->kernel->hardware;
 
-
-    gcmkONERROR(
-        _HandlePatchList(Command, CommandBuffer, &patchListVar));
-
     /* Query the size of LINK command. */
     gcmkONERROR(gckWLFE_Link(
         hardware, gcvNULL, 0, 0, &linkBytes, gcvNULL, gcvNULL
@@ -2308,11 +2309,11 @@ _CommitWaitLinkOnce(
 
     if (gckHARDWARE_IsFeatureAvailable(hardware, gcvFEATURE_FENCE_64BIT) &&
         Command->kernel->asyncCommand &&
-        patchListVar.maxAsyncTimestamp != 0)
+        MaxAsyncTimeStamp != 0)
     {
         gcmkONERROR(_WaitForAsyncCommandStamp(
             Command,
-            patchListVar.maxAsyncTimestamp
+            MaxAsyncTimeStamp
             ));
     }
 
@@ -2878,10 +2879,6 @@ _CommitWaitLinkOnce(
     gcmkONERROR(gckOS_ReleaseMutex(Command->os, Command->mutexContext));
     contextAcquired = gcvFALSE;
 
-    /* Release the command queue. */
-    gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
-    commitEntered = gcvFALSE;
-
     if (status == gcvSTATUS_INTERRUPTED)
     {
         gcmkTRACE(
@@ -2922,12 +2919,6 @@ _CommitWaitLinkOnce(
         gcmkVERIFY_OK(gckOS_ReleaseMutex(Command->os, Command->mutexContext));
     }
 
-    if (commitEntered)
-    {
-        /* Release the command queue mutex. */
-        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
-    }
-
 #ifdef __QNXNTO__
     if (userCommandBufferLogicalMapped)
     {
@@ -2961,13 +2952,9 @@ _CommitAsyncOnce(
     gctUINT32       fenceBytes;
     gctUINT32       oldValue;
     gctUINT32       flushBytes;
-    gcsPATCH_LIST_VARIABLE patchListVar = {0, 0};
 
     gcmkHEADER();
 
-    gcmkVERIFY_OK(
-        _HandlePatchList(Command, CommandBuffer, &patchListVar));
-
     gckOS_AtomicExchange(Command->os,
                          hardware->pageTableDirty[gcvENGINE_BLT],
                          0,
@@ -3106,8 +3093,6 @@ _CommitMultiChannelOnce(
     gctUINT32    commandBufferAddress;
     gckHARDWARE  hardware;
     gctUINT64    bit;
-    gcsPATCH_LIST_VARIABLE patchListVar = {0, 0};
-    gctBOOL commitEntered = gcvFALSE;
 
     gcmkHEADER_ARG("priority=%d channelId=%d videoMemNode=%u size=0x%x patchHead=%p",
                    CommandBuffer->priority, CommandBuffer->channelId,
@@ -3116,15 +3101,8 @@ _CommitMultiChannelOnce(
 
     gcmkASSERT(Command->feType == gcvHW_FE_MULTI_CHANNEL);
 
-    /* Acquire the command queue. */
-    gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
-    commitEntered = gcvTRUE;
-
     hardware = Command->kernel->hardware;
 
-    gcmkVERIFY_OK(
-        _HandlePatchList(Command, CommandBuffer, &patchListVar));
-
     /* Check flush mcfe MMU cache. */
     gcmkONERROR(_CheckFlushMcfeMMU(Command, hardware));
 
@@ -3216,20 +3194,10 @@ _CommitMultiChannelOnce(
     /* This channel is dirty. */
     Command->dirtyChannel[CommandBuffer->priority ? 1 : 0] |= bit;
 
-    /* Release the command queue. */
-    gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
-    commitEntered = gcvFALSE;
-
     gcmkFOOTER_NO();
     return gcvSTATUS_OK;
 
 OnError:
-    if (commitEntered)
-    {
-        /* Release the command queue mutex. */
-        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
-    }
-
     gcmkFOOTER();
     return status;
 }
@@ -3304,6 +3272,8 @@ gckCOMMAND_Commit(
     gcsHAL_COMMAND_LOCATION _cmdLoc;
     gctPOINTER userPtr = gcvNULL;
     gctBOOL needCopy = gcvFALSE;
+    gcsPATCH_LIST_VARIABLE patchListVar = {0, 0};
+    gctBOOL commitEntered = gcvFALSE;
 
     gcmkHEADER_ARG("Command=%p SubCommit=%p delta=%p context=%u pid=%u",
                    Command, SubCommit, delta, SubCommit->context, ProcessId);
@@ -3357,6 +3327,13 @@ gckCOMMAND_Commit(
 
         gcmkONERROR(_ValidCommandBuffer(Command, ProcessId, cmdLoc));
 
+        /* Acquire the command queue. */
+        gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
+        commitEntered = gcvTRUE;
+
+        gcmkVERIFY_OK(
+            _HandlePatchList(Command, cmdLoc, &patchListVar));
+
         if (Command->feType == gcvHW_FE_WAIT_LINK)
         {
             /* Commit command buffers. */
@@ -3368,10 +3345,14 @@ gckCOMMAND_Commit(
                                          Shared,
                                          contextSwitched,
                                          gcvNULL,
-                                         gcvFALSE);
+                                         gcvFALSE,
+                                         patchListVar.maxAsyncTimestamp);
         }
         else if (Command->feType == gcvHW_FE_MULTI_CHANNEL)
         {
+#if gcdENABLE_SW_PREEMPTION
+            gcmkDUMP(Command->os, "Priority: %d", SubCommit->priorityID);
+#endif
             status = _CommitMultiChannelOnce(Command, context, cmdLoc);
         }
         else
@@ -3386,6 +3367,10 @@ gckCOMMAND_Commit(
             gcmkONERROR(status);
         }
 
+        /* Release the command queue. */
+        gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+        commitEntered = gcvFALSE;
+
         /* Do not need context or delta for later commands. */
         context = gcvNULL;
         delta   = gcvNULL;
@@ -3432,7 +3417,7 @@ gckCOMMAND_Commit(
          * Conclusion is that, blindly sync dirty channels is a good choice for
          * now.
          */
-        gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel));
+         gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel, gcvTRUE));
     }
 
     /* Output commit stamp. */
@@ -3443,6 +3428,12 @@ gckCOMMAND_Commit(
     return gcvSTATUS_OK;
 
 OnError:
+    if (commitEntered)
+    {
+        /* Release the command queue mutex. */
+        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+    }
+
     if (!needCopy && userPtr)
     {
         gckOS_UnmapUserPointer(
@@ -4449,11 +4440,11 @@ _CheckBuffer(
     IN LNode* ListHead
     )
 {
-    gctSIZE_T i, j, count;
+    gctINT i, j, count;
     gctUINT32_PTR data = Buffer;
     LNode* node;
 
-    count = Size / 4;
+    count = (gctINT)(Size / 4);
 
     for (i = 0; i < count; i += 2)
     {
@@ -4687,6 +4678,10 @@ gckCOMMAND_DumpExecutingBuffer(
             /* Kernel address of page where stall point stay. */
             entryDump = (gctUINT8_PTR)entryDump + offset;
 
+            gcmkVERIFY_OK(gckVIDMEM_NODE_GetSize(kernel, nodeObject, &bytes));
+
+            bytes -= offset;
+
             gcmkPRINT("%s: %08X sub command:", subCommand[node->type].name, node->address);
 
             _DumpBuffer(entryDump, node->address, bytes);
@@ -4720,6 +4715,101 @@ gckCOMMAND_DumpExecutingBuffer(
 }
 
 #if gcdENABLE_SW_PREEMPTION
+static gceSTATUS
+_PreemptHandlePatchListSingle(
+    IN gckCOMMAND Command,
+    IN gcsHAL_COMMAND_LOCATION * CommandBuffer,
+    IN gcsHAL_PATCH_LIST * PatchList,
+    OUT gcsPATCH_LIST_VARIABLE * PatchListVar
+    )
+{
+    gceSTATUS status;
+    gctUINT32 index = 0;
+    gctUINT32 count = 0;
+    gctUINT32 itemSize = 0;
+    gctUINT32 batchCount = 0;
+    gcsPATCH_ARRAY *patchArray = (gcsPATCH_ARRAY *)gcmUINT64_TO_PTR(PatchList->patchArray);
+
+    gcmkHEADER_ARG("Command=%p CommandBuffer=%p PatchList=%p type=%d",
+                   Command, CommandBuffer, PatchList, PatchList->type);
+
+    if (PatchList->type >= gcmCOUNTOF(_PatchItemSize) || PatchList->type >= gcmCOUNTOF(patchHandler) || patchArray == gcvNULL)
+    {
+        /* Exceeds buffer max size. */
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+
+    itemSize = _PatchItemSize[PatchList->type];
+
+    batchCount = (gctUINT32)(sizeof(gctUINT64) * 32 / itemSize);
+
+    handler = patchHandler[PatchList->type];
+
+    while (index < PatchList->count)
+    {
+        gctUINT i;
+        gctUINT8_PTR ptr;
+
+        /* Determine batch count, don't handle too many in one batch. */
+        count = PatchList->count - index;
+
+        if (count > batchCount)
+        {
+            count = batchCount;
+        }
+
+        /* Advance to next batch. */
+        index += count;
+
+        ptr = (gctUINT8_PTR)patchArray->kArray;
+
+        for (i = 0; i < count; i++)
+        {
+            /* Call handler. */
+            gcmkONERROR(
+                handler(Command, CommandBuffer, ptr, PatchListVar));
+
+            /* Advance to next patch. */
+            ptr += itemSize;
+        }
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    gcmkFOOTER();
+    return status;
+
+}
+
+static gceSTATUS
+_PreemptHandlePatchList(
+    IN gckCOMMAND Command,
+    IN gcsHAL_COMMAND_LOCATION * CommandBuffer,
+    OUT gcsPATCH_LIST_VARIABLE * PatchListVar
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gcsHAL_PATCH_LIST *patchList;
+
+    patchList = (gcsHAL_PATCH_LIST *)gcmUINT64_TO_PTR(CommandBuffer->patchHead);
+
+    while (patchList)
+    {
+        gcmkONERROR(_PreemptHandlePatchListSingle(
+            Command,
+            CommandBuffer,
+            patchList,
+            PatchListVar));
+
+        patchList = (gcsHAL_PATCH_LIST *)gcmUINT64_TO_PTR(patchList->next);
+    }
+
+OnError:
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckCOMMAND_PreemptCommit
@@ -4749,11 +4839,23 @@ gckCOMMAND_PreemptCommit(
     gcsHAL_COMMAND_LOCATION *cmdLoc = PreemptCommit->cmdLoc;
     gckCONTEXT context = PreemptCommit->context;
     gcsSTATE_DELTA_PTR delta = PreemptCommit->delta;
+    gcsPATCH_LIST_VARIABLE patchListVar = {0, 0};
+    gctBOOL commitEntered = gcvFALSE;
 
     gcmkHEADER();
 
+    /* Acquire the command queue. */
+    gcmkONERROR(gckCOMMAND_EnterCommit(Command, gcvFALSE));
+    commitEntered = gcvTRUE;
+
     do
     {
+        gcmkVERIFY_OK(_PreemptHandlePatchList(
+            Command,
+            cmdLoc,
+            &patchListVar
+            ));
+
         if (Command->feType == gcvHW_FE_WAIT_LINK)
         {
             status = _CommitWaitLinkOnce(Command,
@@ -4764,20 +4866,26 @@ gckCOMMAND_PreemptCommit(
                                          PreemptCommit->shared,
                                          &contextSwitched,
                                          PreemptCommit,
-                                         gcvTRUE);
+                                         gcvTRUE,
+                                         0);
 
-            if (status != gcvSTATUS_INTERRUPTED)
-            {
-                gcmkONERROR(status);
-            }
+        }
+        else if (Command->feType == gcvHW_FE_MULTI_CHANNEL)
+        {
+            status = _CommitMultiChannelOnce(Command, context, cmdLoc);
         }
         else
         {
-            gcmkPRINT("Don't enable SW preemption for non-WLFE.\n");
+            gcmkPRINT("Don't enable SW preemption for aysnc FE.\n");
 
             gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
         }
 
+        if (status != gcvSTATUS_INTERRUPTED)
+        {
+            gcmkONERROR(status);
+        }
+
         context = gcvNULL;
         delta   = gcvNULL;
 
@@ -4785,7 +4893,44 @@ gckCOMMAND_PreemptCommit(
     }
     while(cmdLoc);
 
+    /* Release the command queue. */
+    gcmkONERROR(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+    commitEntered = gcvFALSE;
+
+    if (Command->feType == gcvHW_FE_MULTI_CHANNEL)
+    {
+        /*
+         * Semphore synchronization.
+         *
+         * Here we blindly sync dirty other channels to the system channel.
+         * The scenario to sync channels to the system channel:
+         * 1. Need to sync channels who sent semaphores.
+         * 2. Need to sync dirty channels when event(interrupt) is to sent.
+         * 3. Need to sync dirty channels when system channel need run something
+         *    such as flush mmu.
+         *
+         * When power management is on, blindly sync dirty channels is OK because
+         * there's always a event(intrrupt).
+         *
+         * The only condition we sync more than needed is:
+         * a. power manangement is off.
+         * b. no user event is attached when commit.
+         * c. no user event is to be submitted in next ioctl.
+         * That's a rare condition.
+         *
+         * Conclusion is that, blindly sync dirty channels is a good choice for
+         * now.
+         */
+        gcmkONERROR(_SyncToSystemChannel(Command, Command->dirtyChannel, gcvTRUE));
+    }
+
 OnError:
+    if (commitEntered)
+    {
+        /* Release the command queue mutex. */
+        gcmkVERIFY_OK(gckCOMMAND_ExitCommit(Command, gcvFALSE));
+    }
+
     /* Return the status. */
     gcmkFOOTER();
     return status;
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_db.c b/drivers/staging/npu/kernel/gc_hal_kernel_db.c
index 74fc96dfb539..abe5655bf2b8 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_db.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_db.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_event.c b/drivers/staging/npu/kernel/gc_hal_kernel_event.c
index a1d612ac34fd..b1027b46efb1 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_event.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_event.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_heap.c b/drivers/staging/npu/kernel/gc_hal_kernel_heap.c
index 1e5005063dde..7f52b8a8f00c 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_heap.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_heap.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_mmu.c b/drivers/staging/npu/kernel/gc_hal_kernel_mmu.c
index 55aeae0b3421..6fc53b45fd73 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_mmu.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_mmu.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -65,8 +65,12 @@ typedef enum _gceMMU_TYPE
 }
 gceMMU_TYPE;
 
+#define gcd4G_SIZE 0x100000000
+#define gcdMTLB_RESERVED_SIZE (16 << 20)
+
 /* VIP SRAM start virtual address. */
 #define gcdRESERVE_START (4 << 20)
+
 #define gcdRESERVE_ALIGN (4 << 10)
 
 #define gcmENTRY_TYPE(x) (x & 0xF0)
@@ -77,7 +81,7 @@ gceMMU_TYPE;
 
 #define gcdVERTEX_START      (128 << 10)
 
-#define gcdMTLB_RESERVED_SIZE (16 << 20)
+#define gcdFLAT_MAPPING_MODE gcvPAGE_TYPE_16M
 
 typedef struct _gcsMMU_STLB_CHUNK *gcsMMU_STLB_CHUNK_PTR;
 
@@ -652,578 +656,1452 @@ static gcePOOL _GetPageTablePool(IN gckOS Os)
 }
 
 static gceSTATUS
-_FillFlatMapping(
+_GetCurStlbChunk(
+    IN gckMMU Mmu,
+    IN gctUINT32 MtlbIndex,
+    OUT gcsMMU_STLB_CHUNK_PTR *StlbChunk
+    )
+{
+    gcsMMU_STLB_CHUNK_PTR curStlbChunk = (gcsMMU_STLB_CHUNK_PTR)Mmu->staticSTLB;
+
+    while (curStlbChunk)
+    {
+        if ((MtlbIndex >= curStlbChunk->mtlbIndex) &&
+            (MtlbIndex < (curStlbChunk->mtlbIndex + curStlbChunk->mtlbEntryNum)))
+        {
+            break;
+        }
+        curStlbChunk = curStlbChunk->next;
+    }
+
+    *StlbChunk = curStlbChunk;
+
+    return gcvSTATUS_OK;
+}
+
+static gceSTATUS
+gckMMU_FillFlatMappingWithPage16M(
     IN gckMMU Mmu,
     IN gctUINT64 PhysBase,
-    IN gctSIZE_T Size,
+    IN gctUINT32 flatSize,
     IN gctBOOL   reserved,
-    IN gctBOOL   ableToShift,
+    IN gctBOOL   needShiftMapping,
+    IN gctBOOL   specificFlatMapping,
+    IN gctUINT32 reqVirtualBase,
     OUT gctUINT32 *GpuBaseAddress
     )
 {
     gceSTATUS status;
-    gctUINT32 mtlb;
-    gctUINT32 physBase;
     gckKERNEL kernel = Mmu->hardware->kernel;
-    gcsADDRESS_AREA_PTR area = &Mmu->dynamicArea4K;
-    gctBOOL physicalRangeOverlapped = gcvFALSE;
-    gctBOOL virtualRangeOverlapped = gcvFALSE;
-    gctBOOL specificFlatMapping = gcvFALSE;
-    gctBOOL needShiftMapping = gcvFALSE;
-    gctUINT64 flatBase = PhysBase;
-    gctUINT32 flatSize = (gctUINT32) Size;
-    gctUINT64 base = flatBase;
-    gctUINT64 end  = base + flatSize;
-    gctUINT32 reqVirtualBase = 0;
+    gctBOOL mutex = gcvFALSE;
+    gctUINT32 physBaseExt = (gctUINT32) (PhysBase >> 32);
+    gctUINT32 physBase = (gctUINT32) PhysBase;
+    gctUINT32 start = physBase & ~gcdMMU_PAGE_16M_MASK;
+    gctUINT32 end = (gctUINT32) (physBase + flatSize - 1) & ~gcdMMU_PAGE_16M_MASK;
+    gctUINT32 mStart = start >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 mEnd = end >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 mCursor;
+    gctUINT32 sStart = (start & gcdMMU_STLB_16M_MASK) >> gcdMMU_STLB_16M_SHIFT;
+    gctUINT32 sEnd = (end & gcdMMU_STLB_16M_MASK) >> gcdMMU_STLB_16M_SHIFT;
+    gctPHYS_ADDR_T physical;
+    gcsMMU_STLB_CHUNK_PTR newStlbChunk = gcvNULL;
+    gctUINT32 stlbIndex = 0;
+    gctUINT32 totalNewStlbs = 0;
+    gctINT32 firstMtlbEntry = -1;
+    gctUINT32 mtlbCurEntry;
     gctUINT32 flatVirtualBase = 0;
-    gctUINT32 i;
+    gcsMMU_STLB_CHUNK_PTR curStlbChunk = gcvNULL;
+    enum
+    {
+        COLOR_NONE   = 0,
+        COLOR_RED    = 1, /* occupied entry */
+        COLOR_BLUE   = 2, /* empty entry */
+        COLOR_MAX    = COLOR_BLUE,
+    } lastColor = COLOR_NONE;
+    gctUINT32 colorNumber = 0;
 
-    /************************ Get flat mapping type and range. ************************/
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
+    mutex = gcvTRUE;
+
+    if (needShiftMapping)
     {
-        for (i = 0; i < Mmu->gpuPhysicalRangeCount; i++)
+        gctUINT32 mEntries;
+        gctUINT32 sEntries;
+
+        mEntries = ((physBase + flatSize + gcdMMU_PAGE_16M_SIZE - 1) >> gcdMMU_STLB_16M_SHIFT) - (physBase >> gcdMMU_STLB_16M_SHIFT);
+
+        gcmkONERROR(_GetMtlbFreeSpace(Mmu, mEntries, &mStart, &mEnd));
+
+        sStart = mStart % gcdMMU_STLB_16M_ENTRY_NUM;
+        sEntries = mEntries;
+        sEnd = (sStart + sEntries - 1) % gcdMMU_STLB_16M_ENTRY_NUM;
+    }
+
+    if (specificFlatMapping)
+    {
+        start    = reqVirtualBase & ~gcdMMU_PAGE_16M_MASK;
+        end      = (reqVirtualBase + flatSize - 1) & ~gcdMMU_PAGE_16M_MASK;
+        mStart   = start >> gcdMMU_MTLB_SHIFT;
+        mEnd     = end >> gcdMMU_MTLB_SHIFT;
+        sStart   = (start & gcdMMU_STLB_16M_MASK) >> gcdMMU_STLB_16M_SHIFT;
+        sEnd     = (end & gcdMMU_STLB_16M_MASK) >> gcdMMU_STLB_16M_SHIFT;
+    }
+
+    /* No matter direct mapping or shift mapping or specific mapping, store gpu virtual ranges */
+    flatVirtualBase = (mStart << gcdMMU_MTLB_SHIFT)
+                    | (sStart << gcdMMU_STLB_16M_SHIFT)
+                    | (physBase & gcdMMU_PAGE_16M_MASK);
+
+    /* Return GPU virtual base address if necessary */
+    if (GpuBaseAddress)
+    {
+        *GpuBaseAddress = flatVirtualBase;
+    }
+
+    mtlbCurEntry = mStart;
+
+    /* find all new stlbs, part of new flat mapping range may already have stlbs*/
+    while (mtlbCurEntry <= mEnd)
+    {
+        if (*(Mmu->mtlbLogical + mtlbCurEntry) == 0)
         {
-            if (base < Mmu->gpuPhysicalRanges[i].start)
+            if (lastColor != COLOR_BLUE)
             {
-                if (end > Mmu->gpuPhysicalRanges[i].start)
+                if (colorNumber < COLOR_MAX)
                 {
-                    physicalRangeOverlapped = gcvTRUE;
-                    if (Mmu->gpuPhysicalRanges[i].flag == gcvFLATMAP_DIRECT)
-                    {
-                        /* Overlapped part is direct mapping, continue direct mapping */
-                        end = Mmu->gpuPhysicalRanges[i].start;
-                    }
-                    else
-                    {
-                        /* Overlapped part is shift mapping, do entire shift mapping */
-                        needShiftMapping = gcvTRUE;
-                    }
+                    lastColor = COLOR_BLUE;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
-
-                flatSize = (gctUINT32) (end - base);
             }
-            else if (end > Mmu->gpuPhysicalRanges[i].end)
+
+            _GetCurStlbChunk(Mmu, mtlbCurEntry, &curStlbChunk);
+
+            if (!curStlbChunk)
             {
-                if (base < Mmu->gpuPhysicalRanges[i].end)
+                gctUINT32 stlbNum = mtlbCurEntry >> 4;
+                if (Mmu->stlbAllocated[stlbNum] == gcvFALSE)
                 {
-                    physicalRangeOverlapped = gcvTRUE;
-                    if (Mmu->gpuPhysicalRanges[i].flag == gcvFLATMAP_DIRECT)
-                    {
-                        /* Overlapped part is direct mapping, continue direct mapping */
-                        base = Mmu->gpuPhysicalRanges[i].end + 1;
-                    }
-                    else
-                    {
-                        /* Overlapped part is shift mapping, do entire shift mapping */
-                        needShiftMapping = gcvTRUE;
-                    }
-
+                    Mmu->stlbAllocated[stlbNum] = gcvTRUE;
+                    totalNewStlbs++;
                 }
-
-                flatBase = base;
-                flatSize = (gctUINT32) (end - base);
             }
-            else
+
+            if (-1 == firstMtlbEntry)
             {
-                /* it is already inside existing flat mapping ranges. */
-                flatSize = 0;
+                firstMtlbEntry = mtlbCurEntry & (~((1 << 4) - 1));
             }
-
-            if (flatSize == 0)
+        }
+        else
+        {
+            if (lastColor != COLOR_RED)
             {
-                if (GpuBaseAddress)
+                if (colorNumber < COLOR_MAX)
                 {
-                    *GpuBaseAddress = (gctUINT32) PhysBase;
+                    lastColor = COLOR_RED;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
-
-                return gcvSTATUS_OK;
             }
         }
+        mtlbCurEntry++;
     }
 
-    /* overwrite the orignal parameters */
-    PhysBase = flatBase;
-    physBase = (gctUINT32)flatBase;
-
-    mtlb = _MtlbOffset(physBase);
-
-    if (GpuBaseAddress)
+    /* Need allocate a new chunk of stlbs */
+    if (totalNewStlbs)
     {
-        reqVirtualBase = *GpuBaseAddress;
-    }
+        gcePOOL pool = Mmu->pool;
+        gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
 
-    /*
-     * if no partcial physical range overlap to request entire shift mapping,
-     * it is specific shift mapping or directly mapping by default.
-     */
-    if (!needShiftMapping)
-    {
-        flatVirtualBase = reqVirtualBase ? reqVirtualBase : (gctUINT32)flatBase;
-    }
+        gcmkONERROR(
+            gckOS_Allocate(Mmu->os,
+                           sizeof(struct _gcsMMU_STLB_CHUNK),
+                           (gctPOINTER *)&newStlbChunk));
+
+        newStlbChunk->mtlbEntryNum = totalNewStlbs * 16;
+        newStlbChunk->next = gcvNULL;
+        newStlbChunk->videoMem = gcvNULL;
+        newStlbChunk->logical = gcvNULL;
+        newStlbChunk->size = gcdMMU_STLB_16M_SIZE * totalNewStlbs;
+        newStlbChunk->pageCount = 0;
+        newStlbChunk->mtlbIndex = firstMtlbEntry;
 
-    for (i = 0; i < Mmu->gpuAddressRangeCount; i++)
-    {
-        if (_IsRangeInsected(flatVirtualBase, flatSize,
-            Mmu->gpuAddressRanges[i].start,  Mmu->gpuAddressRanges[i].size))
+#if gcdENABLE_CACHEABLE_COMMAND_BUFFER
+        allocFlag |= gcvALLOC_FLAG_CACHEABLE;
+#endif
+
+        if (!Mmu->pageTableOver4G)
         {
-            virtualRangeOverlapped = gcvTRUE;
+            allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
         }
-    }
 
-    /* If gpu virtual range overlapped or gpu physical over 4G, still need entire shift mapping */
-    if ((!physicalRangeOverlapped && virtualRangeOverlapped) ||
-        PhysBase + flatSize - 1 > 0xffffffff)
-    {
-        needShiftMapping = gcvTRUE;
-    }
+        gcmkONERROR(gckKERNEL_AllocateVideoMemory(
+            kernel,
+            64,
+            gcvVIDMEM_TYPE_COMMAND,
+            allocFlag | gcvALLOC_FLAG_4K_PAGES,
+            &newStlbChunk->size,
+            &pool,
+            &newStlbChunk->videoMem));
 
-    if (needShiftMapping && !ableToShift)
-    {
-        /*
-         * Return without mapping any address.
-         * By now, only physBase physSize could run here.
-         */
-        return gcvSTATUS_OK;
+        /* Lock for kernel side CPU access. */
+        gcmkONERROR(gckVIDMEM_NODE_LockCPU(
+            kernel,
+            newStlbChunk->videoMem,
+            gcvFALSE,
+            gcvFALSE,
+            (gctPOINTER *)&newStlbChunk->logical));
+
+        gcmkONERROR(gckOS_ZeroMemory(newStlbChunk->logical, newStlbChunk->size));
+
+        /* Get CPU physical address. */
+        gcmkONERROR(gckVIDMEM_NODE_GetPhysical(
+            kernel,
+            newStlbChunk->videoMem,
+            0,
+            &physical));
+
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Mmu->os,
+            physical,
+            &physical));
+
+        newStlbChunk->physBase = physical;
     }
 
-    specificFlatMapping = (reqVirtualBase && !virtualRangeOverlapped && !physicalRangeOverlapped);
+    mCursor = mStart;
 
-    /************************ Setup flat mapping in dynamic range. ****************/
-    if (area->mappingStart != gcvINVALID_ADDRESS && mtlb >= area->mappingStart && mtlb < area->mappingEnd)
+    while (mCursor <= mEnd)
     {
-        /* This path is useless now, keep it 4K page size */
+        gctPHYS_ADDR_T stlbPhyBase;
+        gctUINT32_PTR stlbLogical;
 
-        gctUINT32_PTR stlbEntry;
+        gcmkASSERT(mCursor < gcdMMU_MTLB_ENTRY_NUM);
 
-        stlbEntry = _StlbEntry(area, physBase);
+        if (*(Mmu->mtlbLogical + mCursor) == 0)
+        {
+            gctUINT32 mtlbEntry;
 
-        /* Must be aligned to page. */
-        gcmkASSERT((flatSize & 0xFFF) == 0);
+            _GetCurStlbChunk(Mmu, mCursor, &curStlbChunk);
+            if (!curStlbChunk)
+            {
+                if (totalNewStlbs)
+                {
+                    curStlbChunk = newStlbChunk;
+                }
+            }
+
+            stlbIndex = (mCursor - curStlbChunk->mtlbIndex) >> 4;
+            stlbPhyBase = curStlbChunk->physBase + (stlbIndex * gcdMMU_STLB_16M_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbIndex * gcdMMU_STLB_16M_SIZE));
+
+            physical  = stlbPhyBase
+                      /* 16MB page size */
+                      | (0x3 << 2)
+                      /* Ignore exception */
+                      | (0 << 1)
+                      /* Present */
+                      | (1 << 0);
+
+            gcmkSAFECASTPHYSADDRT(mtlbEntry, physical);
+
+            _WritePageEntry(Mmu->mtlbLogical + mCursor, mtlbEntry);
 
-        for (i = 0; i < (flatSize / gcdMMU_PAGE_4K_SIZE); i++)
-        {
-            /* Flat mapping in page table. */
-            _WritePageEntry(stlbEntry, _SetPage(physBase + i * gcdMMU_PAGE_4K_SIZE, 0, gcvTRUE));
 #if gcdMMU_TABLE_DUMP
-            gckOS_Print("%s(%d): insert MTLB[%d] STLB[%d]: %08x\n",
+            gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
                 __FUNCTION__, __LINE__,
-                (physBase & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT,
-                ((physBase & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT) + i,
-                _ReadPageEntry(stlbEntry));
+                mStart,
+                _ReadPageEntry(Mmu->mtlbLogical + mCursor));
+
+            gckOS_Print("%s(%d): STLB: logical:%08x -> physical:%08x\n",
+                    __FUNCTION__, __LINE__,
+                    stlbLogical,
+                    stlbPhyBase);
 #endif
-            stlbEntry++;
-        }
 
-#if gcdDUMP_IN_KERNEL
-        {
-            gctPHYS_ADDR_T physical;
-            gctUINT32 data = _SetPage(physBase, 0, gcvTRUE) & ~0xF;
-            gctUINT32 step = (_SetPage(physBase + gcdMMU_PAGE_4K_SIZE, 0, gcvTRUE) & ~0xF) - data;
-            gctUINT32 mask = _SetPage(physBase, 0, gcvTRUE) & 0xF;
+            gcmkDUMP(Mmu->os, "#[mmu-mtlb: flat-mapping, slot: %d]", mCursor);
 
-            physical  = area->stlbPhysical + 4 * _AddressToIndex(area, physBase);
+            gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
+                     (unsigned long long)Mmu->mtlbPhysical + mCursor * 4,
+                     Mmu->mtlbLogical[mCursor], 4);
 
-            gcmkDUMP(Mmu->os,
-                     "#[mmu-stlb: flat-mapping in dynamic: 0x%08X - 0x%08X]",
-                     physBase, physBase - 1 + flatSize);
 
-            gcmkDUMP(Mmu->os,
-                     "@[physical.step 0x%010llX 0x%08X 0x%08lX 0x%08X 0x%08X",
-                     (unsigned long long)physical, data,
-                     (unsigned long)(flatSize / gcdMMU_PAGE_4K_SIZE * sizeof(gctUINT32)),
-                     step, mask);
-        }
+#if gcdDUMP_IN_KERNEL
+            gcmkDUMP(Mmu->os, "#[mmu-stlb: flat-mapping: 0x%08X - 0x%08X]",
+                     start, start + gcdMMU_PAGE_16M_SIZE - 1);
 #endif
 
-        /* Flat mapping in map. */
-        _FillFlatMappingInMap(area, _AddressToIndex(area, physBase), flatSize / gcdMMU_PAGE_4K_SIZE);
+            if (*(stlbLogical + sStart) == 0)
+            {
+                gcmkASSERT(!(start & gcdMMU_PAGE_16M_MASK));
 
-        return gcvSTATUS_OK;
-    }
+                if (reserved)
+                {
+                    /* program NOT_PRESENT | EXCEPTION  for reserved entries */
+                    _WritePageEntry(stlbLogical + sStart, 1 << 1);
+                }
+                else
+                {
+                    _WritePageEntry(stlbLogical + sStart, _SetPage(start, physBaseExt, gcvTRUE));
+                }
+#if gcdMMU_TABLE_DUMP
+                gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
+                    __FUNCTION__, __LINE__,
+                    sStart,
+                    _ReadPageEntry(stlbLogical + sStart));
+#endif
+            }
 
-    /************************ Setup flat mapping in non dynamic range. **************/
-    {
-        gctBOOL mutex = gcvFALSE;
-        gctUINT32 physBaseExt = (gctUINT32) (PhysBase >> 32);
-        gctUINT32 start = physBase & ~gcdMMU_PAGE_1M_MASK;
-        gctUINT32 end = (gctUINT32) (physBase + flatSize - 1) & ~gcdMMU_PAGE_1M_MASK;
-        gctUINT32 mStart = start >> gcdMMU_MTLB_SHIFT;
-        gctUINT32 mEnd = end >> gcdMMU_MTLB_SHIFT;
-        gctUINT32 sStart = (start & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
-        gctUINT32 sEnd = (end & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
-        gctPHYS_ADDR_T physical;
-        gcsMMU_STLB_CHUNK_PTR newStlbChunk = gcvNULL;
-        gctUINT32 stlbIndex = 0;
-        gctUINT32 totalNewStlbs = 0;
-        gctINT32 firstMtlbEntry = -1;
-        gctUINT32 mtlbCurEntry;
-        gcsMMU_STLB_CHUNK_PTR curStlbChunk = gcvNULL;
-        gceFLATMAP_FLAG mapFlag = gcvFLATMAP_DIRECT;
-        enum
-        {
-            COLOR_NONE   = 0,
-            COLOR_RED    = 1, /* occupied entry */
-            COLOR_BLUE   = 2, /* empty entry */
-            COLOR_MAX    = COLOR_BLUE,
-        } lastColor = COLOR_NONE;
-        gctUINT32 colorNumber = 0;
-
-        /* Grab the mutex. */
-        gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
-        mutex = gcvTRUE;
-
-        if (needShiftMapping)
-        {
-            gctUINT32 mEntries;
-            gctUINT32 sEntries;
-
-            mEntries = (flatSize + (1 << gcdMMU_MTLB_SHIFT) - 1) / (1 << gcdMMU_MTLB_SHIFT);
-
-            gcmkONERROR(_GetMtlbFreeSpace(Mmu, mEntries, &mStart, &mEnd));
+            gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+                kernel,
+                curStlbChunk->videoMem,
+                0,
+                curStlbChunk->logical,
+                curStlbChunk->size
+                ));
 
-            sStart = 0;
-            sEntries = (flatSize + gcdMMU_PAGE_1M_SIZE - 1) / gcdMMU_PAGE_1M_SIZE;
-            sEnd = (sEntries - 1) % gcdMMU_STLB_1M_ENTRY_NUM;
-            mapFlag = gcvFLATMAP_SHIFT;
+            curStlbChunk->pageCount++;
         }
 
-        if (specificFlatMapping)
+        /* next page. */
+        start += gcdMMU_PAGE_16M_SIZE;
+        if (start == 0)
         {
-            start    = reqVirtualBase & ~gcdMMU_PAGE_1M_MASK;
-            end      = (reqVirtualBase + flatSize - 1) & ~gcdMMU_PAGE_1M_MASK;
-            mStart   = start >> gcdMMU_MTLB_SHIFT;
-            mEnd     = end >> gcdMMU_MTLB_SHIFT;
-            sStart   = (start & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
-            sEnd     = (end & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
-            mapFlag  = gcvFLATMAP_SHIFT;
+            physBaseExt++;
         }
 
-        /* No matter direct mapping or shift mapping or specific mapping, store gpu virtual ranges */
-        flatVirtualBase = (mStart << gcdMMU_MTLB_SHIFT)
-                        | (sStart << gcdMMU_STLB_1M_SHIFT)
-                        | (physBase & gcdMMU_PAGE_1M_MASK);
+        if (++sStart == gcdMMU_STLB_16M_ENTRY_NUM)
+            sStart = 0;
+
+        ++mCursor;
+    }
 
-        /* Return GPU virtual base address if necessary */
-        if (GpuBaseAddress)
+    if (newStlbChunk)
+    {
+        /* Insert the stlbChunk into staticSTLB. */
+        if (Mmu->staticSTLB == gcvNULL)
         {
-            *GpuBaseAddress = flatVirtualBase;
+            Mmu->staticSTLB = newStlbChunk;
         }
+        else
+        {
+            gcmkASSERT(newStlbChunk != gcvNULL);
+            gcmkASSERT(newStlbChunk->next == gcvNULL);
+            newStlbChunk->next = Mmu->staticSTLB;
+            Mmu->staticSTLB = newStlbChunk;
+        }
+    }
 
-        mtlbCurEntry = mStart;
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
 
-        /* find all new stlbs, part of new flat mapping range may already have stlbs*/
-        while (mtlbCurEntry <= mEnd)
-        {
-            if (*(Mmu->mtlbLogical + mtlbCurEntry) == 0)
-            {
-                if (lastColor != COLOR_BLUE)
+    return gcvSTATUS_OK;
+OnError:
+    /* Roll back the allocation.
+    ** We don't need roll back mtlb programming as gckmONERROR
+    ** is only used during allocation time.
+    */
+    if (newStlbChunk)
+    {
+        if (newStlbChunk->videoMem)
+        {
+            gcmkVERIFY_OK(gckVIDMEM_NODE_Dereference(
+                kernel,
+                newStlbChunk->videoMem
+                ));
+        }
+
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, newStlbChunk));
+    }
+    if (mutex)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    }
+    return status;
+}
+
+static gceSTATUS
+gckMMU_FillFlatMappingWithPage1M(
+    IN gckMMU Mmu,
+    IN gctUINT64 PhysBase,
+    IN gctUINT32 flatSize,
+    IN gctBOOL   reserved,
+    IN gctBOOL   needShiftMapping,
+    IN gctBOOL   specificFlatMapping,
+    IN gctUINT32 reqVirtualBase,
+    OUT gctUINT32 *GpuBaseAddress
+    )
+{
+    gceSTATUS status;
+    gckKERNEL kernel = Mmu->hardware->kernel;
+    gctBOOL mutex = gcvFALSE;
+    gctUINT32 physBaseExt = (gctUINT32) (PhysBase >> 32);
+    gctUINT32 physBase = (gctUINT32) PhysBase;
+    gctUINT32 start = physBase & ~gcdMMU_PAGE_1M_MASK;
+    gctUINT32 end = (gctUINT32) (physBase + flatSize - 1) & ~gcdMMU_PAGE_1M_MASK;
+    gctUINT32 mStart = start >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 mEnd = end >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 sStart = (start & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
+    gctUINT32 sEnd = (end & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
+    gctPHYS_ADDR_T physical;
+    gcsMMU_STLB_CHUNK_PTR newStlbChunk = gcvNULL;
+    gctUINT32 stlbIndex = 0;
+    gctUINT32 totalNewStlbs = 0;
+    gctINT32 firstMtlbEntry = -1;
+    gctUINT32 mtlbCurEntry;
+    gctUINT32 flatVirtualBase = 0;
+    gcsMMU_STLB_CHUNK_PTR curStlbChunk = gcvNULL;
+    enum
+    {
+        COLOR_NONE   = 0,
+        COLOR_RED    = 1, /* occupied entry */
+        COLOR_BLUE   = 2, /* empty entry */
+        COLOR_MAX    = COLOR_BLUE,
+    } lastColor = COLOR_NONE;
+    gctUINT32 colorNumber = 0;
+
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
+    mutex = gcvTRUE;
+
+    if (needShiftMapping)
+    {
+        gctUINT32 mEntries;
+        gctUINT32 sEntries;
+
+        mEntries = (flatSize + (1 << gcdMMU_MTLB_SHIFT) - 1) / (1 << gcdMMU_MTLB_SHIFT);
+
+        gcmkONERROR(_GetMtlbFreeSpace(Mmu, mEntries, &mStart, &mEnd));
+
+        sStart = 0;
+        sEntries = (flatSize + gcdMMU_PAGE_1M_SIZE - 1) / gcdMMU_PAGE_1M_SIZE;
+        sEnd = (sEntries - 1) % gcdMMU_STLB_1M_ENTRY_NUM;
+    }
+
+    if (specificFlatMapping)
+    {
+        start    = reqVirtualBase & ~gcdMMU_PAGE_1M_MASK;
+        end      = (reqVirtualBase + flatSize - 1) & ~gcdMMU_PAGE_1M_MASK;
+        mStart   = start >> gcdMMU_MTLB_SHIFT;
+        mEnd     = end >> gcdMMU_MTLB_SHIFT;
+        sStart   = (start & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
+        sEnd     = (end & gcdMMU_STLB_1M_MASK) >> gcdMMU_STLB_1M_SHIFT;
+    }
+
+    /* No matter direct mapping or shift mapping or specific mapping, store gpu virtual ranges */
+    flatVirtualBase = (mStart << gcdMMU_MTLB_SHIFT)
+                    | (sStart << gcdMMU_STLB_1M_SHIFT)
+                    | (physBase & gcdMMU_PAGE_1M_MASK);
+
+    /* Return GPU virtual base address if necessary */
+    if (GpuBaseAddress)
+    {
+        *GpuBaseAddress = flatVirtualBase;
+    }
+
+    mtlbCurEntry = mStart;
+
+    /* find all new stlbs, part of new flat mapping range may already have stlbs*/
+    while (mtlbCurEntry <= mEnd)
+    {
+        if (*(Mmu->mtlbLogical + mtlbCurEntry) == 0)
+        {
+            if (lastColor != COLOR_BLUE)
+            {
+                if (colorNumber < COLOR_MAX)
                 {
-                    if (colorNumber < COLOR_MAX)
-                    {
-                        lastColor = COLOR_BLUE;
-                        colorNumber++;
-                    }
-                    else
-                    {
-                        gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
-                    }
+                    lastColor = COLOR_BLUE;
+                    colorNumber++;
                 }
-
-                totalNewStlbs++;
-                if (-1 == firstMtlbEntry)
+                else
                 {
-                    firstMtlbEntry = mtlbCurEntry;
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
             }
-            else
+
+            totalNewStlbs++;
+            if (-1 == firstMtlbEntry)
+            {
+                firstMtlbEntry = mtlbCurEntry;
+            }
+        }
+        else
+        {
+            if (lastColor != COLOR_RED)
             {
-                if (lastColor != COLOR_RED)
+                if (colorNumber < COLOR_MAX)
                 {
-                    if (colorNumber < COLOR_MAX)
-                    {
-                        lastColor = COLOR_RED;
-                        colorNumber++;
-                    }
-                    else
-                    {
-                        gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
-                    }
+                    lastColor = COLOR_RED;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
             }
-            mtlbCurEntry++;
         }
+        mtlbCurEntry++;
+    }
 
-        /* Need allocate a new chunk of stlbs */
-        if (totalNewStlbs)
-        {
-            gcePOOL pool = Mmu->pool;
-            gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
+    /* Need allocate a new chunk of stlbs */
+    if (totalNewStlbs)
+    {
+        gcePOOL pool = Mmu->pool;
+        gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
 
-            gcmkONERROR(
-                gckOS_Allocate(Mmu->os,
-                               sizeof(struct _gcsMMU_STLB_CHUNK),
-                               (gctPOINTER *)&newStlbChunk));
-
-            newStlbChunk->mtlbEntryNum = totalNewStlbs;
-            newStlbChunk->next = gcvNULL;
-            newStlbChunk->videoMem = gcvNULL;
-            newStlbChunk->logical = gcvNULL;
-            newStlbChunk->size = gcdMMU_STLB_1M_SIZE * newStlbChunk->mtlbEntryNum;
-            newStlbChunk->pageCount = 0;
-            newStlbChunk->mtlbIndex = firstMtlbEntry;
+        gcmkONERROR(
+            gckOS_Allocate(Mmu->os,
+                           sizeof(struct _gcsMMU_STLB_CHUNK),
+                           (gctPOINTER *)&newStlbChunk));
+
+        newStlbChunk->mtlbEntryNum = totalNewStlbs;
+        newStlbChunk->next = gcvNULL;
+        newStlbChunk->videoMem = gcvNULL;
+        newStlbChunk->logical = gcvNULL;
+        newStlbChunk->size = gcdMMU_STLB_1M_SIZE * newStlbChunk->mtlbEntryNum;
+        newStlbChunk->pageCount = 0;
+        newStlbChunk->mtlbIndex = firstMtlbEntry;
 
 #if gcdENABLE_CACHEABLE_COMMAND_BUFFER
-            allocFlag |= gcvALLOC_FLAG_CACHEABLE;
+        allocFlag |= gcvALLOC_FLAG_CACHEABLE;
 #endif
 
-            if (!Mmu->pageTableOver4G)
-            {
-                allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
-            }
+        if (!Mmu->pageTableOver4G)
+        {
+            allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
+        }
 
-            gcmkONERROR(gckKERNEL_AllocateVideoMemory(
-                kernel,
-                gcdMMU_STLB_1M_SIZE,
-                gcvVIDMEM_TYPE_COMMAND,
-                allocFlag | gcvALLOC_FLAG_4K_PAGES,
-                &newStlbChunk->size,
-                &pool,
-                &newStlbChunk->videoMem));
+        gcmkONERROR(gckKERNEL_AllocateVideoMemory(
+            kernel,
+            64,
+            gcvVIDMEM_TYPE_COMMAND,
+            allocFlag | gcvALLOC_FLAG_4K_PAGES,
+            &newStlbChunk->size,
+            &pool,
+            &newStlbChunk->videoMem));
 
-            /* Lock for kernel side CPU access. */
-            gcmkONERROR(gckVIDMEM_NODE_LockCPU(
-                kernel,
-                newStlbChunk->videoMem,
-                gcvFALSE,
-                gcvFALSE,
-                (gctPOINTER *)&newStlbChunk->logical));
+        /* Lock for kernel side CPU access. */
+        gcmkONERROR(gckVIDMEM_NODE_LockCPU(
+            kernel,
+            newStlbChunk->videoMem,
+            gcvFALSE,
+            gcvFALSE,
+            (gctPOINTER *)&newStlbChunk->logical));
 
-            gcmkONERROR(gckOS_ZeroMemory(newStlbChunk->logical, newStlbChunk->size));
+        gcmkONERROR(gckOS_ZeroMemory(newStlbChunk->logical, newStlbChunk->size));
 
-            /* Get CPU physical address. */
-            gcmkONERROR(gckVIDMEM_NODE_GetPhysical(
-                kernel,
-                newStlbChunk->videoMem,
-                0,
-                &physical));
+        /* Get CPU physical address. */
+        gcmkONERROR(gckVIDMEM_NODE_GetPhysical(
+            kernel,
+            newStlbChunk->videoMem,
+            0,
+            &physical));
 
-            gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
-                Mmu->os,
-                physical,
-                &physical));
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Mmu->os,
+            physical,
+            &physical));
 
-            newStlbChunk->physBase = physical;
-        }
+        newStlbChunk->physBase = physical;
+    }
 
-        while (mStart <= mEnd)
-        {
-            gctUINT32 last = (mStart == mEnd) ? sEnd : (gcdMMU_STLB_1M_ENTRY_NUM - 1);
-            gctPHYS_ADDR_T stlbPhyBase;
-            gctUINT32_PTR stlbLogical;
+    while (mStart <= mEnd)
+    {
+        gctUINT32 last = (mStart == mEnd) ? sEnd : (gcdMMU_STLB_1M_ENTRY_NUM - 1);
+        gctPHYS_ADDR_T stlbPhyBase;
+        gctUINT32_PTR stlbLogical;
 
-            gcmkASSERT(mStart < gcdMMU_MTLB_ENTRY_NUM);
+        gcmkASSERT(mStart < gcdMMU_MTLB_ENTRY_NUM);
 
-            if (*(Mmu->mtlbLogical + mStart) == 0)
-            {
-                gctUINT32 mtlbEntry;
-                curStlbChunk = newStlbChunk;
-                stlbPhyBase = curStlbChunk->physBase + (stlbIndex * gcdMMU_STLB_1M_SIZE);
-                stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbIndex * gcdMMU_STLB_1M_SIZE));
+        if (*(Mmu->mtlbLogical + mStart) == 0)
+        {
+            gctUINT32 mtlbEntry;
+            curStlbChunk = newStlbChunk;
+            stlbPhyBase = curStlbChunk->physBase + (stlbIndex * gcdMMU_STLB_1M_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbIndex * gcdMMU_STLB_1M_SIZE));
 
-                physical  = stlbPhyBase
-                          /* 1MB page size */
-                          | (1 << 3)
-                          /* Ignore exception */
-                          | (0 << 1)
-                          /* Present */
-                          | (1 << 0);
+            physical  = stlbPhyBase
+                      /* 1MB page size */
+                      | (1 << 3)
+                      /* Ignore exception */
+                      | (0 << 1)
+                      /* Present */
+                      | (1 << 0);
 
-                gcmkSAFECASTPHYSADDRT(mtlbEntry, physical);
+            gcmkSAFECASTPHYSADDRT(mtlbEntry, physical);
 
-                _WritePageEntry(Mmu->mtlbLogical + mStart, mtlbEntry);
+            _WritePageEntry(Mmu->mtlbLogical + mStart, mtlbEntry);
 
 #if gcdMMU_TABLE_DUMP
-                gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
-                    __FUNCTION__, __LINE__,
-                    mStart,
-                    _ReadPageEntry(Mmu->mtlbLogical + mStart));
+            gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                mStart,
+                _ReadPageEntry(Mmu->mtlbLogical + mStart));
 
-                gckOS_Print("%s(%d): STLB: logical:%08x -> physical:%08x\n",
-                        __FUNCTION__, __LINE__,
-                        stlbLogical,
-                        stlbPhyBase);
+            gckOS_Print("%s(%d): STLB: logical:%08x -> physical:%08x\n",
+                    __FUNCTION__, __LINE__,
+                    stlbLogical,
+                    stlbPhyBase);
 #endif
 
-                gcmkDUMP(Mmu->os, "#[mmu-mtlb: flat-mapping, slot: %d]", mStart);
+            gcmkDUMP(Mmu->os, "#[mmu-mtlb: flat-mapping, slot: %d]", mStart);
+
+            gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
+                     (unsigned long long)Mmu->mtlbPhysical + mStart * 4,
+                     Mmu->mtlbLogical[mStart], 4);
+
+            ++stlbIndex;
+        }
+        else
+        {
+            gctUINT32 mtlbEntry = _ReadPageEntry(Mmu->mtlbLogical + mStart);
+            gctUINT stlbOffset;
+
+            _GetCurStlbChunk(Mmu, mStart, &curStlbChunk);
+
+            if (!curStlbChunk)
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+
+            stlbOffset = mStart - curStlbChunk->mtlbIndex;
+
+            stlbPhyBase = curStlbChunk->physBase + (stlbOffset * gcdMMU_STLB_1M_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbOffset * gcdMMU_STLB_1M_SIZE));
+            if (stlbPhyBase != (mtlbEntry & gcdMMU_MTLB_ENTRY_STLB_MASK))
+            {
+                gcmkASSERT(0);
+            }
+        }
 
-                gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
-                         (unsigned long long)Mmu->mtlbPhysical + mStart * 4,
-                         Mmu->mtlbLogical[mStart], 4);
+#if gcdDUMP_IN_KERNEL
+        gcmkDUMP(Mmu->os, "#[mmu-stlb: flat-mapping: 0x%08X - 0x%08X]",
+                 start, start + (last - sStart) * gcdMMU_PAGE_1M_SIZE - 1);
+#endif
 
-                ++stlbIndex;
+        while (sStart <= last)
+        {
+            gcmkASSERT(!(start & gcdMMU_PAGE_1M_MASK));
+            if (reserved)
+            {
+                /* program NOT_PRESENT | EXCEPTION  for reserved entries */
+                _WritePageEntry(stlbLogical + sStart, 1 << 1);
             }
             else
             {
-                gctUINT32 mtlbEntry = _ReadPageEntry(Mmu->mtlbLogical + mStart);
-                gctUINT stlbOffset;
+                _WritePageEntry(stlbLogical + sStart, _SetPage(start, physBaseExt, gcvTRUE));
+            }
+#if gcdMMU_TABLE_DUMP
+            gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                sStart,
+                _ReadPageEntry(stlbLogical + sStart));
+#endif
+            /* next page. */
+            start += gcdMMU_PAGE_1M_SIZE;
+            if (start == 0)
+            {
+                physBaseExt++;
+            }
+            sStart++;
+            curStlbChunk->pageCount++;
+        }
 
-                curStlbChunk = (gcsMMU_STLB_CHUNK_PTR)Mmu->staticSTLB;
+#if gcdDUMP_IN_KERNEL
+        {
+            gctUINT32 i = sStart;
+            gctUINT32 data = stlbLogical[i] & ~0xF;
+            gctUINT32 step = (last > i) ? (stlbLogical[i + 1] - stlbLogical[i]) : 0;
+            gctUINT32 mask = stlbLogical[i] & 0xF;
 
-                while (curStlbChunk)
-                {
-                    if ((mStart >= curStlbChunk->mtlbIndex) &&
-                        (mStart < (curStlbChunk->mtlbIndex + curStlbChunk->mtlbEntryNum)))
-                    {
-                        break;
-                    }
-                    curStlbChunk = curStlbChunk->next;
-                }
-                gcmkASSERT(curStlbChunk);
+            gcmkDUMP(Mmu->os,
+                     "@[physical.step 0x%010llX 0x%08X 0x%08X 0x%08X 0x%08X]",
+                     (unsigned long long)stlbPhyBase + i * 4,
+                     data, (last - i) * 4, step, mask);
+        }
+#endif
+
+        gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+            kernel,
+            curStlbChunk->videoMem,
+            0,
+            curStlbChunk->logical,
+            curStlbChunk->size
+            ));
+
+        sStart = 0;
+        ++mStart;
+    }
+
+    gcmkASSERT(totalNewStlbs == stlbIndex);
+
+    if (newStlbChunk)
+    {
+        /* Insert the stlbChunk into staticSTLB. */
+        if (Mmu->staticSTLB == gcvNULL)
+        {
+            Mmu->staticSTLB = newStlbChunk;
+        }
+        else
+        {
+            gcmkASSERT(newStlbChunk != gcvNULL);
+            gcmkASSERT(newStlbChunk->next == gcvNULL);
+            newStlbChunk->next = Mmu->staticSTLB;
+            Mmu->staticSTLB = newStlbChunk;
+        }
+    }
+
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+
+    return gcvSTATUS_OK;
+OnError:
+    /* Roll back the allocation.
+    ** We don't need roll back mtlb programming as gckmONERROR
+    ** is only used during allocation time.
+    */
+    if (newStlbChunk)
+    {
+        if (newStlbChunk->videoMem)
+        {
+            gcmkVERIFY_OK(gckVIDMEM_NODE_Dereference(
+                kernel,
+                newStlbChunk->videoMem
+                ));
+        }
+
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, newStlbChunk));
+    }
+    if (mutex)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    }
+    return status;
+}
+
+static gceSTATUS
+gckMMU_FillFlatMappingWithPage64K(
+    IN gckMMU Mmu,
+    IN gctUINT64 PhysBase,
+    IN gctUINT32 flatSize,
+    IN gctBOOL   reserved,
+    IN gctBOOL   needShiftMapping,
+    IN gctBOOL   specificFlatMapping,
+    IN gctUINT32 reqVirtualBase,
+    OUT gctUINT32 *GpuBaseAddress
+    )
+{
+    gceSTATUS status;
+    gckKERNEL kernel = Mmu->hardware->kernel;
+    gctBOOL mutex = gcvFALSE;
+    gctUINT32 physBaseExt = (gctUINT32) (PhysBase >> 32);
+    gctUINT32 physBase = (gctUINT32) PhysBase;
+    gctUINT32 start = physBase & ~gcdMMU_PAGE_64K_MASK;
+    gctUINT32 end = (gctUINT32) (physBase + flatSize - 1) & ~gcdMMU_PAGE_64K_MASK;
+    gctUINT32 mStart = start >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 mEnd = end >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 sStart = (start & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
+    gctUINT32 sEnd = (end & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
+    gctPHYS_ADDR_T physical;
+    gcsMMU_STLB_CHUNK_PTR newStlbChunk = gcvNULL;
+    gctUINT32 stlbIndex = 0;
+    gctUINT32 totalNewStlbs = 0;
+    gctINT32 firstMtlbEntry = -1;
+    gctUINT32 mtlbCurEntry;
+    gctUINT32 flatVirtualBase = 0;
+    gcsMMU_STLB_CHUNK_PTR curStlbChunk = gcvNULL;
+    enum
+    {
+        COLOR_NONE   = 0,
+        COLOR_RED    = 1, /* occupied entry */
+        COLOR_BLUE   = 2, /* empty entry */
+        COLOR_MAX    = COLOR_BLUE,
+    } lastColor = COLOR_NONE;
+    gctUINT32 colorNumber = 0;
+
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
+    mutex = gcvTRUE;
+
+    if (needShiftMapping)
+    {
+        gctUINT32 mEntries;
+        gctUINT32 sEntries;
 
-                if (!curStlbChunk)
-                    gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        mEntries = (flatSize + (1 << gcdMMU_MTLB_SHIFT) - 1) / (1 << gcdMMU_MTLB_SHIFT);
 
-                stlbOffset = mStart - curStlbChunk->mtlbIndex;
+        gcmkONERROR(_GetMtlbFreeSpace(Mmu, mEntries, &mStart, &mEnd));
 
-                stlbPhyBase = curStlbChunk->physBase + (stlbOffset * gcdMMU_STLB_1M_SIZE);
-                stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbOffset * gcdMMU_STLB_1M_SIZE));
-                if (stlbPhyBase != (mtlbEntry & gcdMMU_MTLB_ENTRY_STLB_MASK))
+        sStart = 0;
+        sEntries = (flatSize + gcdMMU_PAGE_64K_SIZE - 1) / gcdMMU_PAGE_64K_SIZE;
+        sEnd = (sEntries - 1) % gcdMMU_STLB_64K_ENTRY_NUM;
+    }
+
+    if (specificFlatMapping)
+    {
+        start    = reqVirtualBase & ~gcdMMU_PAGE_64K_MASK;
+        end      = (reqVirtualBase + flatSize - 1) & ~gcdMMU_PAGE_64K_MASK;
+        mStart   = start >> gcdMMU_MTLB_SHIFT;
+        mEnd     = end >> gcdMMU_MTLB_SHIFT;
+        sStart   = (start & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
+        sEnd     = (end & gcdMMU_STLB_64K_MASK) >> gcdMMU_STLB_64K_SHIFT;
+    }
+
+    /* No matter direct mapping or shift mapping or specific mapping, store gpu virtual ranges */
+    flatVirtualBase = (mStart << gcdMMU_MTLB_SHIFT)
+                    | (sStart << gcdMMU_STLB_64K_SHIFT)
+                    | (physBase & gcdMMU_PAGE_64K_MASK);
+
+    /* Return GPU virtual base address if necessary */
+    if (GpuBaseAddress)
+    {
+        *GpuBaseAddress = flatVirtualBase;
+    }
+
+    mtlbCurEntry = mStart;
+
+    /* find all new stlbs, part of new flat mapping range may already have stlbs*/
+    while (mtlbCurEntry <= mEnd)
+    {
+        if (*(Mmu->mtlbLogical + mtlbCurEntry) == 0)
+        {
+            if (lastColor != COLOR_BLUE)
+            {
+                if (colorNumber < COLOR_MAX)
                 {
-                    gcmkASSERT(0);
+                    lastColor = COLOR_BLUE;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
             }
 
-#if gcdDUMP_IN_KERNEL
-            /* Start index. */
-            i = sStart;
-
-            gcmkDUMP(Mmu->os, "#[mmu-stlb: flat-mapping: 0x%08X - 0x%08X]",
-                     start, start + (last - sStart) * gcdMMU_PAGE_1M_SIZE - 1);
-#endif
-
-            while (sStart <= last)
+            totalNewStlbs++;
+            if (-1 == firstMtlbEntry)
             {
-                gcmkASSERT(!(start & gcdMMU_PAGE_1M_MASK));
-                if (reserved)
+                firstMtlbEntry = mtlbCurEntry;
+            }
+        }
+        else
+        {
+            if (lastColor != COLOR_RED)
+            {
+                if (colorNumber < COLOR_MAX)
                 {
-                    /* program NOT_PRESENT | EXCEPTION  for reserved entries */
-                    _WritePageEntry(stlbLogical + sStart, 1 << 1);
+                    lastColor = COLOR_RED;
+                    colorNumber++;
                 }
                 else
                 {
-                    _WritePageEntry(stlbLogical + sStart, _SetPage(start, physBaseExt, gcvTRUE));
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
                 }
+            }
+        }
+        mtlbCurEntry++;
+    }
+
+    /* Need allocate a new chunk of stlbs */
+    if (totalNewStlbs)
+    {
+        gcePOOL pool = Mmu->pool;
+        gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
+
+        gcmkONERROR(
+            gckOS_Allocate(Mmu->os,
+                           sizeof(struct _gcsMMU_STLB_CHUNK),
+                           (gctPOINTER *)&newStlbChunk));
+
+        newStlbChunk->mtlbEntryNum = totalNewStlbs;
+        newStlbChunk->next = gcvNULL;
+        newStlbChunk->videoMem = gcvNULL;
+        newStlbChunk->logical = gcvNULL;
+        newStlbChunk->size = gcdMMU_STLB_64K_SIZE * newStlbChunk->mtlbEntryNum;
+        newStlbChunk->pageCount = 0;
+        newStlbChunk->mtlbIndex = firstMtlbEntry;
+
+#if gcdENABLE_CACHEABLE_COMMAND_BUFFER
+        allocFlag |= gcvALLOC_FLAG_CACHEABLE;
+#endif
+
+        if (!Mmu->pageTableOver4G)
+        {
+            allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
+        }
+
+        gcmkONERROR(gckKERNEL_AllocateVideoMemory(
+            kernel,
+            64,
+            gcvVIDMEM_TYPE_COMMAND,
+            allocFlag | gcvALLOC_FLAG_4K_PAGES,
+            &newStlbChunk->size,
+            &pool,
+            &newStlbChunk->videoMem));
+
+        /* Lock for kernel side CPU access. */
+        gcmkONERROR(gckVIDMEM_NODE_LockCPU(
+            kernel,
+            newStlbChunk->videoMem,
+            gcvFALSE,
+            gcvFALSE,
+            (gctPOINTER *)&newStlbChunk->logical));
+
+        gcmkONERROR(gckOS_ZeroMemory(newStlbChunk->logical, newStlbChunk->size));
+
+        /* Get CPU physical address. */
+        gcmkONERROR(gckVIDMEM_NODE_GetPhysical(
+            kernel,
+            newStlbChunk->videoMem,
+            0,
+            &physical));
+
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Mmu->os,
+            physical,
+            &physical));
+
+        newStlbChunk->physBase = physical;
+    }
+
+    while (mStart <= mEnd)
+    {
+        gctUINT32 last = (mStart == mEnd) ? sEnd : (gcdMMU_STLB_64K_ENTRY_NUM - 1);
+        gctPHYS_ADDR_T stlbPhyBase;
+        gctUINT32_PTR stlbLogical;
+
+        gcmkASSERT(mStart < gcdMMU_MTLB_ENTRY_NUM);
+
+        if (*(Mmu->mtlbLogical + mStart) == 0)
+        {
+            gctUINT32 mtlbEntry;
+            curStlbChunk = newStlbChunk;
+            stlbPhyBase = curStlbChunk->physBase + (stlbIndex * gcdMMU_STLB_64K_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbIndex * gcdMMU_STLB_64K_SIZE));
+
+            physical  = stlbPhyBase
+                      /* 64KB page size */
+                      | (1 << 2)
+                      /* Ignore exception */
+                      | (0 << 1)
+                      /* Present */
+                      | (1 << 0);
+
+            gcmkSAFECASTPHYSADDRT(mtlbEntry, physical);
+
+            _WritePageEntry(Mmu->mtlbLogical + mStart, mtlbEntry);
+
 #if gcdMMU_TABLE_DUMP
-                gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
+            gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                mStart,
+                _ReadPageEntry(Mmu->mtlbLogical + mStart));
+
+            gckOS_Print("%s(%d): STLB: logical:%08x -> physical:%08x\n",
                     __FUNCTION__, __LINE__,
-                    sStart,
-                    _ReadPageEntry(stlbLogical + sStart));
+                    stlbLogical,
+                    stlbPhyBase);
 #endif
-                /* next page. */
-                start += gcdMMU_PAGE_1M_SIZE;
-                if (start == 0)
-                {
-                    physBaseExt++;
-                }
-                sStart++;
-                curStlbChunk->pageCount++;
+
+            gcmkDUMP(Mmu->os, "#[mmu-mtlb: flat-mapping, slot: %d]", mStart);
+
+            gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
+                     (unsigned long long)Mmu->mtlbPhysical + mStart * 4,
+                     Mmu->mtlbLogical[mStart], 4);
+
+            ++stlbIndex;
+        }
+        else
+        {
+            gctUINT32 mtlbEntry = _ReadPageEntry(Mmu->mtlbLogical + mStart);
+            gctUINT stlbOffset;
+
+            _GetCurStlbChunk(Mmu, mStart, &curStlbChunk);
+
+            if (!curStlbChunk)
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+
+            stlbOffset = mStart - curStlbChunk->mtlbIndex;
+
+            stlbPhyBase = curStlbChunk->physBase + (stlbOffset * gcdMMU_STLB_64K_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbOffset * gcdMMU_STLB_64K_SIZE));
+            if (stlbPhyBase != (mtlbEntry & gcdMMU_MTLB_ENTRY_STLB_MASK))
+            {
+                gcmkASSERT(0);
             }
+        }
 
 #if gcdDUMP_IN_KERNEL
+        gcmkDUMP(Mmu->os, "#[mmu-stlb: flat-mapping: 0x%08X - 0x%08X]",
+                 start, start + (last - sStart) * gcdMMU_PAGE_64K_SIZE - 1);
+#endif
+
+        while (sStart <= last)
+        {
+            gcmkASSERT(!(start & gcdMMU_PAGE_64K_MASK));
+            if (reserved)
+            {
+                /* program NOT_PRESENT | EXCEPTION  for reserved entries */
+                _WritePageEntry(stlbLogical + sStart, 1 << 1);
+            }
+            else
             {
-                gctUINT32 data = stlbLogical[i] & ~0xF;
-                gctUINT32 step = (last > i) ? (stlbLogical[i + 1] - stlbLogical[i]) : 0;
-                gctUINT32 mask = stlbLogical[i] & 0xF;
-
-                gcmkDUMP(Mmu->os,
-                         "@[physical.step 0x%010llX 0x%08X 0x%08X 0x%08X 0x%08X]",
-                         (unsigned long long)stlbPhyBase + i * 4,
-                         data, (last - i) * 4, step, mask);
+                _WritePageEntry(stlbLogical + sStart, _SetPage(start, physBaseExt, gcvTRUE));
             }
+#if gcdMMU_TABLE_DUMP
+            gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                sStart,
+                _ReadPageEntry(stlbLogical + sStart));
 #endif
+            /* next page. */
+            start += gcdMMU_PAGE_64K_SIZE;
+            if (start == 0)
+            {
+                physBaseExt++;
+            }
+            sStart++;
+            curStlbChunk->pageCount++;
+        }
 
-            gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+#if gcdDUMP_IN_KERNEL
+        {
+            gctUINT32 i = sStart;
+            gctUINT32 data = stlbLogical[i] & ~0xF;
+            gctUINT32 step = (last > i) ? (stlbLogical[i + 1] - stlbLogical[i]) : 0;
+            gctUINT32 mask = stlbLogical[i] & 0xF;
+
+            gcmkDUMP(Mmu->os,
+                     "@[physical.step 0x%010llX 0x%08X 0x%08X 0x%08X 0x%08X]",
+                     (unsigned long long)stlbPhyBase + i * 4,
+                     data, (last - i) * 4, step, mask);
+        }
+#endif
+
+        gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+            kernel,
+            curStlbChunk->videoMem,
+            0,
+            curStlbChunk->logical,
+            curStlbChunk->size
+            ));
+
+        sStart = 0;
+        ++mStart;
+    }
+
+    gcmkASSERT(totalNewStlbs == stlbIndex);
+
+    if (newStlbChunk)
+    {
+        /* Insert the stlbChunk into staticSTLB. */
+        if (Mmu->staticSTLB == gcvNULL)
+        {
+            Mmu->staticSTLB = newStlbChunk;
+        }
+        else
+        {
+            gcmkASSERT(newStlbChunk != gcvNULL);
+            gcmkASSERT(newStlbChunk->next == gcvNULL);
+            newStlbChunk->next = Mmu->staticSTLB;
+            Mmu->staticSTLB = newStlbChunk;
+        }
+    }
+
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+
+    return gcvSTATUS_OK;
+OnError:
+    /* Roll back the allocation.
+    ** We don't need roll back mtlb programming as gckmONERROR
+    ** is only used during allocation time.
+    */
+    if (newStlbChunk)
+    {
+        if (newStlbChunk->videoMem)
+        {
+            gcmkVERIFY_OK(gckVIDMEM_NODE_Dereference(
                 kernel,
-                curStlbChunk->videoMem,
-                0,
-                curStlbChunk->logical,
-                curStlbChunk->size
+                newStlbChunk->videoMem
                 ));
-
-            sStart = 0;
-            ++mStart;
         }
 
-        gcmkASSERT(totalNewStlbs == stlbIndex);
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, newStlbChunk));
+    }
+    if (mutex)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    }
+    return status;
+}
+
+static gceSTATUS
+gckMMU_FillFlatMappingWithPage4K(
+    IN gckMMU Mmu,
+    IN gctUINT64 PhysBase,
+    IN gctUINT32 flatSize,
+    IN gctBOOL   reserved,
+    IN gctBOOL   needShiftMapping,
+    IN gctBOOL   specificFlatMapping,
+    IN gctUINT32 reqVirtualBase,
+    OUT gctUINT32 *GpuBaseAddress
+    )
+{
+    gceSTATUS status;
+    gckKERNEL kernel = Mmu->hardware->kernel;
+    gctBOOL mutex = gcvFALSE;
+    gctUINT32 physBaseExt = (gctUINT32) (PhysBase >> 32);
+    gctUINT32 physBase = (gctUINT32) PhysBase;
+    gctUINT32 start = physBase & ~gcdMMU_PAGE_4K_MASK;
+    gctUINT32 end = (gctUINT32) (physBase + flatSize - 1) & ~gcdMMU_PAGE_4K_MASK;
+    gctUINT32 mStart = start >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 mEnd = end >> gcdMMU_MTLB_SHIFT;
+    gctUINT32 sStart = (start & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+    gctUINT32 sEnd = (end & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+    gctPHYS_ADDR_T physical;
+    gcsMMU_STLB_CHUNK_PTR newStlbChunk = gcvNULL;
+    gctUINT32 stlbIndex = 0;
+    gctUINT32 totalNewStlbs = 0;
+    gctINT32 firstMtlbEntry = -1;
+    gctUINT32 mtlbCurEntry;
+    gctUINT32 flatVirtualBase = 0;
+    gcsMMU_STLB_CHUNK_PTR curStlbChunk = gcvNULL;
+    enum
+    {
+        COLOR_NONE   = 0,
+        COLOR_RED    = 1, /* occupied entry */
+        COLOR_BLUE   = 2, /* empty entry */
+        COLOR_MAX    = COLOR_BLUE,
+    } lastColor = COLOR_NONE;
+    gctUINT32 colorNumber = 0;
+
+    /* Grab the mutex. */
+    gcmkONERROR(gckOS_AcquireMutex(Mmu->os, Mmu->pageTableMutex, gcvINFINITE));
+    mutex = gcvTRUE;
+
+    if (needShiftMapping)
+    {
+        gctUINT32 mEntries;
+        gctUINT32 sEntries;
+
+        mEntries = (flatSize + (1 << gcdMMU_MTLB_SHIFT) - 1) / (1 << gcdMMU_MTLB_SHIFT);
+
+        gcmkONERROR(_GetMtlbFreeSpace(Mmu, mEntries, &mStart, &mEnd));
+
+        sStart = 0;
+        sEntries = (flatSize + gcdMMU_PAGE_4K_SIZE - 1) / gcdMMU_PAGE_4K_SIZE;
+        sEnd = (sEntries - 1) % gcdMMU_STLB_4K_ENTRY_NUM;
+    }
 
-        if (newStlbChunk)
+    if (specificFlatMapping)
+    {
+        start    = reqVirtualBase & ~gcdMMU_PAGE_4K_MASK;
+        end      = (reqVirtualBase + flatSize - 1) & ~gcdMMU_PAGE_4K_MASK;
+        mStart   = start >> gcdMMU_MTLB_SHIFT;
+        mEnd     = end >> gcdMMU_MTLB_SHIFT;
+        sStart   = (start & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+        sEnd     = (end & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT;
+    }
+
+    /* No matter direct mapping or shift mapping or specific mapping, store gpu virtual ranges */
+    flatVirtualBase = (mStart << gcdMMU_MTLB_SHIFT)
+                    | (sStart << gcdMMU_STLB_4K_SHIFT)
+                    | (physBase & gcdMMU_PAGE_4K_MASK);
+
+    /* Return GPU virtual base address if necessary */
+    if (GpuBaseAddress)
+    {
+        *GpuBaseAddress = flatVirtualBase;
+    }
+
+    mtlbCurEntry = mStart;
+
+    /* find all new stlbs, part of new flat mapping range may already have stlbs*/
+    while (mtlbCurEntry <= mEnd)
+    {
+        if (*(Mmu->mtlbLogical + mtlbCurEntry) == 0)
         {
-            /* Insert the stlbChunk into staticSTLB. */
-            if (Mmu->staticSTLB == gcvNULL)
+            if (lastColor != COLOR_BLUE)
             {
-                Mmu->staticSTLB = newStlbChunk;
+                if (colorNumber < COLOR_MAX)
+                {
+                    lastColor = COLOR_BLUE;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
+                }
             }
-            else
+
+            totalNewStlbs++;
+            if (-1 == firstMtlbEntry)
+            {
+                firstMtlbEntry = mtlbCurEntry;
+            }
+        }
+        else
+        {
+            if (lastColor != COLOR_RED)
             {
-                gcmkASSERT(newStlbChunk != gcvNULL);
-                gcmkASSERT(newStlbChunk->next == gcvNULL);
-                newStlbChunk->next = Mmu->staticSTLB;
-                Mmu->staticSTLB = newStlbChunk;
+                if (colorNumber < COLOR_MAX)
+                {
+                    lastColor = COLOR_RED;
+                    colorNumber++;
+                }
+                else
+                {
+                    gcmkPRINT("There is a hole in new flat mapping range, which is not correct");
+                }
             }
         }
+        mtlbCurEntry++;
+    }
 
-        /* Release the mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+    /* Need allocate a new chunk of stlbs */
+    if (totalNewStlbs)
+    {
+        gcePOOL pool = Mmu->pool;
+        gctUINT32 allocFlag = gcvALLOC_FLAG_CONTIGUOUS;
 
-#if gcdENABLE_TRUST_APPLICATION
-        if (Mmu->hardware->options.secureMode == gcvSECURE_IN_TA)
+        gcmkONERROR(
+            gckOS_Allocate(Mmu->os,
+                           sizeof(struct _gcsMMU_STLB_CHUNK),
+                           (gctPOINTER *)&newStlbChunk));
+
+        newStlbChunk->mtlbEntryNum = totalNewStlbs;
+        newStlbChunk->next = gcvNULL;
+        newStlbChunk->videoMem = gcvNULL;
+        newStlbChunk->logical = gcvNULL;
+        newStlbChunk->size = gcdMMU_STLB_4K_SIZE * newStlbChunk->mtlbEntryNum;
+        newStlbChunk->pageCount = 0;
+        newStlbChunk->mtlbIndex = firstMtlbEntry;
+
+#if gcdENABLE_CACHEABLE_COMMAND_BUFFER
+        allocFlag |= gcvALLOC_FLAG_CACHEABLE;
+#endif
+
+        if (!Mmu->pageTableOver4G)
         {
-            gckKERNEL_SecurityMapMemory(Mmu->hardware->kernel, gcvNULL, physBase, flatSize / gcdMMU_PAGE_4K_SIZE, &physBase);
+            allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
         }
+
+        gcmkONERROR(gckKERNEL_AllocateVideoMemory(
+            kernel,
+            64,
+            gcvVIDMEM_TYPE_COMMAND,
+            allocFlag | gcvALLOC_FLAG_4K_PAGES,
+            &newStlbChunk->size,
+            &pool,
+            &newStlbChunk->videoMem));
+
+        /* Lock for kernel side CPU access. */
+        gcmkONERROR(gckVIDMEM_NODE_LockCPU(
+            kernel,
+            newStlbChunk->videoMem,
+            gcvFALSE,
+            gcvFALSE,
+            (gctPOINTER *)&newStlbChunk->logical));
+
+        gcmkONERROR(gckOS_ZeroMemory(newStlbChunk->logical, newStlbChunk->size));
+
+        /* Get CPU physical address. */
+        gcmkONERROR(gckVIDMEM_NODE_GetPhysical(
+            kernel,
+            newStlbChunk->videoMem,
+            0,
+            &physical));
+
+        gcmkVERIFY_OK(gckOS_CPUPhysicalToGPUPhysical(
+            Mmu->os,
+            physical,
+            &physical));
+
+        newStlbChunk->physBase = physical;
+    }
+
+    while (mStart <= mEnd)
+    {
+        gctUINT32 last = (mStart == mEnd) ? sEnd : (gcdMMU_STLB_4K_ENTRY_NUM - 1);
+        gctPHYS_ADDR_T stlbPhyBase;
+        gctUINT32_PTR stlbLogical;
+
+        gcmkASSERT(mStart < gcdMMU_MTLB_ENTRY_NUM);
+
+        if (*(Mmu->mtlbLogical + mStart) == 0)
+        {
+            gctUINT32 mtlbEntry;
+            curStlbChunk = newStlbChunk;
+            stlbPhyBase = curStlbChunk->physBase + (stlbIndex * gcdMMU_STLB_4K_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbIndex * gcdMMU_STLB_4K_SIZE));
+
+            physical  = stlbPhyBase
+                      /* 4KB page size */
+                      | (0 << 3)
+                      /* Ignore exception */
+                      | (0 << 1)
+                      /* Present */
+                      | (1 << 0);
+
+            gcmkSAFECASTPHYSADDRT(mtlbEntry, physical);
+
+            _WritePageEntry(Mmu->mtlbLogical + mStart, mtlbEntry);
+
+#if gcdMMU_TABLE_DUMP
+            gckOS_Print("%s(%d): insert MTLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                mStart,
+                _ReadPageEntry(Mmu->mtlbLogical + mStart));
+
+            gckOS_Print("%s(%d): STLB: logical:%08x -> physical:%08x\n",
+                    __FUNCTION__, __LINE__,
+                    stlbLogical,
+                    stlbPhyBase);
 #endif
 
-        /* Store the gpu physical ranges */
-        Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].start = flatBase;
-        Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].end   = flatBase + flatSize - 1;
-        Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].size  = flatSize;
-        Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].flag  = mapFlag;
-        Mmu->gpuPhysicalRangeCount++;
+            gcmkDUMP(Mmu->os, "#[mmu-mtlb: flat-mapping, slot: %d]", mStart);
 
-        gcmkASSERT(Mmu->gpuPhysicalRangeCount <= gcdMAX_FLAT_MAPPING_COUNT);
+            gcmkDUMP(Mmu->os, "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
+                     (unsigned long long)Mmu->mtlbPhysical + mStart * 4,
+                     Mmu->mtlbLogical[mStart], 4);
 
-        /* Store the gpu virtual ranges */
-        Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].start = flatVirtualBase;
-        Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].end   = flatVirtualBase + flatSize - 1;
-        Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].size  = flatSize;
-        Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].flag  = mapFlag;
-        Mmu->gpuAddressRangeCount++;
+            ++stlbIndex;
+        }
+        else
+        {
+            gctUINT32 mtlbEntry = _ReadPageEntry(Mmu->mtlbLogical + mStart);
+            gctUINT stlbOffset;
 
-        gcmkASSERT(Mmu->gpuAddressRangeCount <= gcdMAX_FLAT_MAPPING_COUNT);
+            curStlbChunk = (gcsMMU_STLB_CHUNK_PTR)Mmu->staticSTLB;
 
-        return gcvSTATUS_OK;
-OnError:
-        /* Roll back the allocation.
-        ** We don't need roll back mtlb programming as gckmONERROR
-        ** is only used during allocation time.
-        */
-        if (newStlbChunk)
+            _GetCurStlbChunk(Mmu, mStart, &curStlbChunk);
+
+            if (!curStlbChunk)
+                gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+
+            stlbOffset = mStart - curStlbChunk->mtlbIndex;
+
+            stlbPhyBase = curStlbChunk->physBase + (stlbOffset * gcdMMU_STLB_4K_SIZE);
+            stlbLogical = (gctUINT32_PTR)((gctUINT8_PTR)curStlbChunk->logical + (stlbOffset * gcdMMU_STLB_4K_SIZE));
+            if (stlbPhyBase != (mtlbEntry & gcdMMU_MTLB_ENTRY_STLB_MASK))
+            {
+                gcmkASSERT(0);
+            }
+        }
+
+#if gcdDUMP_IN_KERNEL
+        gcmkDUMP(Mmu->os, "#[mmu-stlb: flat-mapping: 0x%08X - 0x%08X]",
+                 start, start + (last - sStart) * gcdMMU_PAGE_4K_SIZE - 1);
+#endif
+
+        while (sStart <= last)
         {
-            if (newStlbChunk->videoMem)
+            gcmkASSERT(!(start & gcdMMU_PAGE_4K_MASK));
+            if (reserved)
             {
-                gcmkVERIFY_OK(gckVIDMEM_NODE_Dereference(
-                    kernel,
-                    newStlbChunk->videoMem
-                    ));
+                /* program NOT_PRESENT | EXCEPTION  for reserved entries */
+                _WritePageEntry(stlbLogical + sStart, 1 << 1);
+            }
+            else
+            {
+                _WritePageEntry(stlbLogical + sStart, _SetPage(start, physBaseExt, gcvTRUE));
             }
+#if gcdMMU_TABLE_DUMP
+            gckOS_Print("%s(%d): insert STLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                sStart,
+                _ReadPageEntry(stlbLogical + sStart));
+#endif
+            /* next page. */
+            start += gcdMMU_PAGE_4K_SIZE;
+            if (start == 0)
+            {
+                physBaseExt++;
+            }
+            sStart++;
+            curStlbChunk->pageCount++;
+        }
+
+#if gcdDUMP_IN_KERNEL
+        {
+            gctUINT32 i = sStart;
+            gctUINT32 data = stlbLogical[i] & ~0xF;
+            gctUINT32 step = (last > i) ? (stlbLogical[i + 1] - stlbLogical[i]) : 0;
+            gctUINT32 mask = stlbLogical[i] & 0xF;
 
-            gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, newStlbChunk));
+            gcmkDUMP(Mmu->os,
+                     "@[physical.step 0x%010llX 0x%08X 0x%08X 0x%08X 0x%08X]",
+                     (unsigned long long)stlbPhyBase + i * 4,
+                     data, (last - i) * 4, step, mask);
         }
-        if (mutex)
+#endif
+
+        gcmkONERROR(gckVIDMEM_NODE_CleanCache(
+            kernel,
+            curStlbChunk->videoMem,
+            0,
+            curStlbChunk->logical,
+            curStlbChunk->size
+            ));
+
+        sStart = 0;
+        ++mStart;
+    }
+
+    gcmkASSERT(totalNewStlbs == stlbIndex);
+
+    if (newStlbChunk)
+    {
+        /* Insert the stlbChunk into staticSTLB. */
+        if (Mmu->staticSTLB == gcvNULL)
+        {
+            Mmu->staticSTLB = newStlbChunk;
+        }
+        else
+        {
+            gcmkASSERT(newStlbChunk != gcvNULL);
+            gcmkASSERT(newStlbChunk->next == gcvNULL);
+            newStlbChunk->next = Mmu->staticSTLB;
+            Mmu->staticSTLB = newStlbChunk;
+        }
+    }
+
+    /* Release the mutex. */
+    gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+
+    return gcvSTATUS_OK;
+OnError:
+    /* Roll back the allocation.
+    ** We don't need roll back mtlb programming as gckmONERROR
+    ** is only used during allocation time.
+    */
+    if (newStlbChunk)
+    {
+        if (newStlbChunk->videoMem)
         {
-            /* Release the mutex. */
-            gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
+            gcmkVERIFY_OK(gckVIDMEM_NODE_Dereference(
+                kernel,
+                newStlbChunk->videoMem
+                ));
         }
-        return status;
+
+        gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Mmu->os, newStlbChunk));
+    }
+    if (mutex)
+    {
+        /* Release the mutex. */
+        gcmkVERIFY_OK(gckOS_ReleaseMutex(Mmu->os, Mmu->pageTableMutex));
     }
+    return status;
 }
 
 static gceSTATUS
@@ -1455,7 +2333,7 @@ gckMMU_SetupDynamicSpace(
     gckOS_Free(Mmu->os, (gctPOINTER)nodeArray);
 
 #if gcdENABLE_TRUST_APPLICATION
-    if (gckHARDWARE_IsFeatureAvailable(Mmu->hardware, gcvFEATURE_SECURITY) == gcvSTATUS_TRUE)
+    if (Mmu->hardware->options.secureMode == gcvSECURE_IN_TA)
     {
         /* Setup secure address area when needed. */
         gctUINT32 secureAreaSize = gcdMMU_SECURE_AREA_SIZE;
@@ -1608,7 +2486,7 @@ _Construct(
     gctPHYS_ADDR_T exclusiveBase = 0;
     gctSIZE_T externalSize = 0;
     gctSIZE_T exclusiveSize = 0;
-    gctUINT32 gpuAddress;
+    gctUINT32 gpuAddress = 0;
     gctPHYS_ADDR_T gpuPhysical;
     gcsADDRESS_AREA_PTR area = gcvNULL;
     gcePOOL pool;
@@ -1663,6 +2541,8 @@ _Construct(
 
     gcmkONERROR(gckOS_QueryOption(os, "mmu", &mmuEnabled));
 
+    mmu->flatMappingMode = gcdFLAT_MAPPING_MODE;
+
     if (hardware->mmuVersion == 0)
     {
         area->stlbSize = MmuSize;
@@ -1783,7 +2663,10 @@ _Construct(
             allocFlag |= gcvALLOC_FLAG_4GB_ADDR;
         }
 
-        /* 1K mode is 1024 byte aligned. */
+        /*
+         * mtlb address requires 256 alignment in 4K mode and 1024 alignment in 1K mode (Descriptor only use bit31 ~ bit10 for 1K mode).
+         * stlb address is always 64 byte alignment (mtlb entry uses bit31 ~ bit6 for aligned stlb address).
+         */
         gcmkONERROR(gckKERNEL_AllocateVideoMemory(
                     Kernel,
                     1024,
@@ -1850,10 +2733,18 @@ _Construct(
             gpuAddress = gcdMTLB_RESERVED_SIZE;
         }
 
+#ifndef MSDX
         if (physSize)
+#else
+        gctUINT64 wddmMode = 0;
+
+        if (physSize &&
+            ((gcvSTATUS_OK != gckOS_QueryOption(mmu->os, "wddmMode", &wddmMode)) ||
+             (0 == wddmMode)))
+#endif
         {
             /* Setup user specified flat mapping. */
-            gcmkONERROR(_FillFlatMapping(mmu, gpuAddress, physSize, gcvFALSE, gcvFALSE, gcvNULL));
+            gcmkONERROR(gckMMU_FillFlatMapping(mmu, gpuAddress, physSize, gcvFALSE, gcvFALSE, gcvNULL));
         }
 
 #if !(0 || gcdCAPTURE_ONLY_MODE)
@@ -1883,6 +2774,33 @@ _Construct(
             mmu->gpuAddressRanges[mmu->gpuAddressRangeCount].flag  = gcvFLATMAP_DIRECT;
             mmu->gpuAddressRangeCount++;
         }
+#elif defined(VSIMULATOR_DEBUG)
+        if (!_ReadPageEntry(mmu->mtlbLogical + 255))
+        {
+            gctUINT32 mtlbEntry;
+            /*
+             * Reserved the last mtlb.
+             * 1MB page size, Ingore exception, Not Present.
+             */
+            mtlbEntry = (1 << 3)
+                      | (0 << 1)
+                      | (0 << 0);
+
+            _WritePageEntry(mmu->mtlbLogical + 255, mtlbEntry);
+
+            gcmkDUMP(mmu->os, "#[mmu-mtlb: reserved 16M space, slot: 255]");
+            gcmkDUMP(mmu->os,
+                     "@[physical.fill 0x%010llX 0x%08X 0x%08X]",
+                     (unsigned long long)mmu->mtlbPhysical,
+                     mmu->mtlbLogical[0], 4);
+
+            /* Store the gpu virtual ranges */
+            mmu->gpuAddressRanges[mmu->gpuAddressRangeCount].start = gcdRESERVE_START;
+            mmu->gpuAddressRanges[mmu->gpuAddressRangeCount].end   = gcdRESERVE_START + gcdMTLB_RESERVED_SIZE - 1;
+            mmu->gpuAddressRanges[mmu->gpuAddressRangeCount].size  = gcdMTLB_RESERVED_SIZE;
+            mmu->gpuAddressRanges[mmu->gpuAddressRangeCount].flag  = gcvFLATMAP_DIRECT;
+            mmu->gpuAddressRangeCount++;
+        }
 #endif
 
         if (contiguousSize && gpuContiguousBase != ~0ULL)
@@ -1890,7 +2808,7 @@ _Construct(
             gctUINT32 contiguousBaseAddress = 0;
 
             /* Setup flat mapping for reserved memory (VIDMEM). */
-            gcmkONERROR(_FillFlatMapping(mmu, gpuContiguousBase, contiguousSize, gcvFALSE, gcvTRUE, &contiguousBaseAddress));
+            gcmkONERROR(gckMMU_FillFlatMapping(mmu, gpuContiguousBase, contiguousSize, gcvFALSE, gcvTRUE, &contiguousBaseAddress));
 
             if (mmuEnabled)
             {
@@ -1918,7 +2836,7 @@ _Construct(
             gcmkONERROR(gckOS_CPUPhysicalToGPUPhysical(mmu->os, externalBase, &gpuExternalBase));
 
             /* Setup flat mapping for external memory. */
-            gcmkONERROR(_FillFlatMapping(mmu, gpuExternalBase, externalSize, gcvFALSE, gcvTRUE, &externalBaseAddress));
+            gcmkONERROR(gckMMU_FillFlatMapping(mmu, gpuExternalBase, externalSize, gcvFALSE, gcvTRUE, &externalBaseAddress));
 
             mmu->externalBaseAddress = externalBaseAddress;
         }
@@ -1936,7 +2854,7 @@ _Construct(
             gctUINT32 exclusiveBaseAddress = 0;
 
             /* Setup flat mapping for external memory. */
-            gcmkONERROR(_FillFlatMapping(mmu, exclusiveBase, exclusiveSize, gcvFALSE, gcvTRUE, &exclusiveBaseAddress));
+            gcmkONERROR(gckMMU_FillFlatMapping(mmu, exclusiveBase, exclusiveSize, gcvFALSE, gcvTRUE, &exclusiveBaseAddress));
 
             mmu->exclusiveBaseAddress = exclusiveBaseAddress;
         }
@@ -3036,7 +3954,6 @@ gckMMU_DumpAddressSpace(
 {
     gctUINT i;
     gctUINT next;
-    /* TODO: */
     gcsADDRESS_AREA_PTR area = &Mmu->dynamicArea4K;
     gctUINT32_PTR map = area->mapLogical;
     gctBOOL used = gcvFALSE;
@@ -3110,16 +4027,274 @@ gceSTATUS
 gckMMU_FillFlatMapping(
     IN gckMMU Mmu,
     IN gctUINT64 PhysBase,
-    IN gctSIZE_T Size
+    IN gctSIZE_T Size,
+    IN gctBOOL   Reserved,
+    IN gctBOOL   AbleToShift,
+    OUT gctUINT32 *GpuBaseAddress
     )
 {
     gceSTATUS status;
     gckHARDWARE hardware = Mmu->hardware;
+    gctUINT32 mtlb;
+    gctUINT32 physBase;
+    gcsADDRESS_AREA_PTR area = &Mmu->dynamicArea4K;
+    gctBOOL physicalRangeOverlapped = gcvFALSE;
+    gctBOOL virtualRangeOverlapped = gcvFALSE;
+    gctBOOL specificFlatMapping = gcvFALSE;
+    gctBOOL needShiftMapping = gcvFALSE;
+    gctUINT64 flatBase = PhysBase;
+    gctUINT32 flatSize = (gctUINT32) Size;
+    gctUINT64 base = flatBase;
+    gctUINT64 end  = base + flatSize;
+    gctUINT32 reqVirtualBase = 0;
+    gctUINT32 flatVirtualBase = 0;
+    gceFLATMAP_FLAG mapFlag = gcvFLATMAP_DIRECT;
+    gctUINT32 i;
+#if gcdENABLE_TRUST_APPLICATION
+    gckKERNEL kernel = Mmu->hardware->kernel;
+#endif
+
+    if (!hardware->mmuVersion)
+    {
+        return gcvSTATUS_OK;
+    }
+
+    /************************ Get flat mapping type and range. ************************/
+    {
+        for (i = 0; i < Mmu->gpuPhysicalRangeCount; i++)
+        {
+            if (base < Mmu->gpuPhysicalRanges[i].start)
+            {
+                if (end > Mmu->gpuPhysicalRanges[i].start)
+                {
+                    physicalRangeOverlapped = gcvTRUE;
+                    if (Mmu->gpuPhysicalRanges[i].flag == gcvFLATMAP_DIRECT)
+                    {
+                        /* Overlapped part is direct mapping, continue direct mapping */
+                        end = Mmu->gpuPhysicalRanges[i].start;
+                    }
+                    else
+                    {
+                        /* Overlapped part is shift mapping, do entire shift mapping */
+                        needShiftMapping = gcvTRUE;
+                    }
+                }
+
+                flatSize = (gctUINT32)(end - base);
+            }
+            else if (end > Mmu->gpuPhysicalRanges[i].end)
+            {
+                if (base < Mmu->gpuPhysicalRanges[i].end)
+                {
+                    physicalRangeOverlapped = gcvTRUE;
+                    if (Mmu->gpuPhysicalRanges[i].flag == gcvFLATMAP_DIRECT)
+                    {
+                        /* Overlapped part is direct mapping, continue direct mapping */
+                        base = Mmu->gpuPhysicalRanges[i].end + 1;
+                    }
+                    else
+                    {
+                        /* Overlapped part is shift mapping, do entire shift mapping */
+                        needShiftMapping = gcvTRUE;
+                    }
+
+                }
+
+                flatBase = base;
+                flatSize = (gctUINT32)(end - base);
+            }
+            else
+            {
+                /* it is already inside existing flat mapping ranges. */
+                flatSize = 0;
+            }
+
+            if (flatSize == 0)
+            {
+                if (GpuBaseAddress)
+                {
+                    *GpuBaseAddress = (gctUINT32) PhysBase;
+                }
+
+                return gcvSTATUS_OK;
+            }
+        }
+    }
+
+    /* overwrite the orignal parameters */
+    PhysBase = flatBase;
+    physBase = (gctUINT32)flatBase;
+
+    mtlb = _MtlbOffset(physBase);
 
-    if (hardware->mmuVersion)
+    if (GpuBaseAddress)
+    {
+        reqVirtualBase = *GpuBaseAddress;
+    }
+
+    /*
+     * if no partcial physical range overlap to request entire shift mapping,
+     * it is specific shift mapping or directly mapping by default.
+     */
+    if (!needShiftMapping)
+    {
+        flatVirtualBase = reqVirtualBase ? reqVirtualBase : (gctUINT32)flatBase;
+    }
+
+    for (i = 0; i < Mmu->gpuAddressRangeCount; i++)
+    {
+        if (_IsRangeInsected(flatVirtualBase, flatSize,
+            Mmu->gpuAddressRanges[i].start,  Mmu->gpuAddressRanges[i].size))
+        {
+            virtualRangeOverlapped = gcvTRUE;
+        }
+    }
+
+    /* If gpu virtual range overlapped or gpu physical over 4G, still need entire shift mapping */
+    if ((!physicalRangeOverlapped && virtualRangeOverlapped) ||
+        PhysBase + flatSize - 1 > 0xffffffff)
+    {
+        needShiftMapping = gcvTRUE;
+    }
+
+    if (needShiftMapping && !AbleToShift)
+    {
+        /*
+         * Return without mapping any address.
+         * By now, only physBase physSize could run here.
+         */
+        return gcvSTATUS_OK;
+    }
+
+    if (needShiftMapping || specificFlatMapping)
+    {
+        mapFlag  = gcvFLATMAP_SHIFT;
+    }
+
+    specificFlatMapping = (reqVirtualBase && !virtualRangeOverlapped && !physicalRangeOverlapped);
+
+    /************************ Setup flat mapping in dynamic range. ****************/
+    if (area->mappingStart != gcvINVALID_ADDRESS && mtlb >= area->mappingStart && mtlb < area->mappingEnd)
+    {
+        /* This path is useless now, keep it 4K page size */
+
+        gctUINT32_PTR stlbEntry;
+
+        stlbEntry = _StlbEntry(area, physBase);
+
+        /* Must be aligned to page. */
+        gcmkASSERT((flatSize & 0xFFF) == 0);
+
+        for (i = 0; i < (flatSize / gcdMMU_PAGE_4K_SIZE); i++)
+        {
+            /* Flat mapping in page table. */
+            _WritePageEntry(stlbEntry, _SetPage(physBase + i * gcdMMU_PAGE_4K_SIZE, 0, gcvTRUE));
+#if gcdMMU_TABLE_DUMP
+            gckOS_Print("%s(%d): insert MTLB[%d] STLB[%d]: %08x\n",
+                __FUNCTION__, __LINE__,
+                (physBase & gcdMMU_MTLB_MASK) >> gcdMMU_MTLB_SHIFT,
+                ((physBase & gcdMMU_STLB_4K_MASK) >> gcdMMU_STLB_4K_SHIFT) + i,
+                _ReadPageEntry(stlbEntry));
+#endif
+            stlbEntry++;
+        }
+
+#if gcdDUMP_IN_KERNEL
+        {
+            gctPHYS_ADDR_T physical;
+            gctUINT32 data = _SetPage(physBase, 0, gcvTRUE) & ~0xF;
+            gctUINT32 step = (_SetPage(physBase + gcdMMU_PAGE_4K_SIZE, 0, gcvTRUE) & ~0xF) - data;
+            gctUINT32 mask = _SetPage(physBase, 0, gcvTRUE) & 0xF;
+
+            physical  = area->stlbPhysical + 4 * _AddressToIndex(area, physBase);
+
+            gcmkDUMP(Mmu->os,
+                     "#[mmu-stlb: flat-mapping in dynamic: 0x%08X - 0x%08X]",
+                     physBase, physBase - 1 + flatSize);
+
+            gcmkDUMP(Mmu->os,
+                     "@[physical.step 0x%010llX 0x%08X 0x%08lX 0x%08X 0x%08X",
+                     (unsigned long long)physical, data,
+                     (unsigned long)(flatSize / gcdMMU_PAGE_4K_SIZE * sizeof(gctUINT32)),
+                     step, mask);
+        }
+#endif
+
+        /* Flat mapping in map. */
+        _FillFlatMappingInMap(area, _AddressToIndex(area, physBase), flatSize / gcdMMU_PAGE_4K_SIZE);
+
+        return gcvSTATUS_OK;
+    }
+
+    /************************ Setup flat mapping in non dynamic range. **************/
+    switch (Mmu->flatMappingMode)
+    {
+    case gcvPAGE_TYPE_16M:
+        if (flatSize >= gcdMMU_PAGE_16M_SIZE)
+        {
+            gcmkONERROR(gckMMU_FillFlatMappingWithPage16M(
+                Mmu,
+                PhysBase, flatSize,
+                Reserved, needShiftMapping,
+                specificFlatMapping, reqVirtualBase,
+                GpuBaseAddress));
+
+            break;
+        }
+        /* FALLTHRU */
+    case gcvPAGE_TYPE_1M:
+        gcmkONERROR(gckMMU_FillFlatMappingWithPage1M(
+            Mmu,
+            PhysBase, flatSize,
+            Reserved, needShiftMapping,
+            specificFlatMapping, reqVirtualBase,
+            GpuBaseAddress));
+
+        break;
+    case gcvPAGE_TYPE_64K:
+        gcmkONERROR(gckMMU_FillFlatMappingWithPage64K(
+            Mmu,
+            PhysBase, flatSize,
+            Reserved, needShiftMapping,
+            specificFlatMapping, reqVirtualBase,
+            GpuBaseAddress));
+
+        break;
+    case gcvPAGE_TYPE_4K:
+        gcmkONERROR(gckMMU_FillFlatMappingWithPage4K(
+            Mmu,
+            PhysBase, flatSize,
+            Reserved, needShiftMapping,
+            specificFlatMapping, reqVirtualBase,
+            GpuBaseAddress));
+
+        break;
+    }
+
+#if gcdENABLE_TRUST_APPLICATION
+    if (Mmu->hardware->options.secureMode == gcvSECURE_IN_TA)
     {
-        gcmkONERROR(_FillFlatMapping(Mmu, PhysBase, Size, gcvFALSE, gcvTRUE, gcvNULL));
+        gckKERNEL_SecurityMapMemory(kernel, gcvNULL, physBase, flatSize / gcdMMU_PAGE_4K_SIZE, &physBase);
     }
+#endif
+
+    /* Store the gpu physical ranges */
+    Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].start = flatBase;
+    Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].end   = flatBase + flatSize - 1;
+    Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].size  = flatSize;
+    Mmu->gpuPhysicalRanges[Mmu->gpuPhysicalRangeCount].flag  = mapFlag;
+    Mmu->gpuPhysicalRangeCount++;
+
+    gcmkASSERT(Mmu->gpuPhysicalRangeCount <= gcdMAX_FLAT_MAPPING_COUNT);
+
+    /* Store the gpu virtual ranges */
+    Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].start = flatVirtualBase;
+    Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].end   = flatVirtualBase + flatSize - 1;
+    Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].size  = flatSize;
+    Mmu->gpuAddressRanges[Mmu->gpuAddressRangeCount].flag  = mapFlag;
+    Mmu->gpuAddressRangeCount++;
+
+    gcmkASSERT(Mmu->gpuAddressRangeCount <= gcdMAX_FLAT_MAPPING_COUNT);
 
     return gcvSTATUS_OK;
 
@@ -3249,7 +4424,7 @@ gckMMU_SetupSRAM(
                         &reservedBase
                         ));
 
-                    gcmkONERROR(_FillFlatMapping(
+                    gcmkONERROR(gckMMU_FillFlatMapping(
                         Mmu,
                         reservedBase,
                         reservedSize,
@@ -3288,16 +4463,27 @@ gckMMU_SetupSRAM(
             if (Device->extSRAMSizes[i] &&
                (Device->extSRAMBases[i] != gcvINVALID_PHYSICAL_ADDRESS))
             {
-
-                Device->extSRAMBaseAddresses[i] = 0;
-
                 gcmkONERROR(gckOS_CPUPhysicalToGPUPhysical(
                     Mmu->os,
                     Device->extSRAMBases[i],
                     &Device->extSRAMGPUBases[i]
                     ));
 
-                gcmkONERROR(_FillFlatMapping(
+                if ((Device->extSRAMGPUBases[i] + Device->extSRAMSizes[i] - 1 <= gcvINVALID_ADDRESS)
+                    && (Device->extSRAMGPUBases[i] + Device->extSRAMSizes[i] * 2 > gcvINVALID_ADDRESS))
+                {
+                    Device->extSRAMBaseAddresses[i] = 0xFFFF000 - Device->extSRAMSizes[i] * 2;
+                    if (Device->extSRAMBaseAddresses[i] < 0x1000000)
+                    {
+                        gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
+                    }
+                }
+                else
+                {
+                    Device->extSRAMBaseAddresses[i] = 0;
+                }
+
+                gcmkONERROR(gckMMU_FillFlatMapping(
                     Mmu,
                     Device->extSRAMGPUBases[i],
                     Device->extSRAMSizes[i],
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_power.c b/drivers/staging/npu/kernel/gc_hal_kernel_power.c
index 46f497fbdd77..74e6920ae295 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_power.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_power.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_precomp.h b/drivers/staging/npu/kernel/gc_hal_kernel_precomp.h
index 52822915a871..606e305b443c 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_precomp.h
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_precomp.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_preemption.c b/drivers/staging/npu/kernel/gc_hal_kernel_preemption.c
index dfe039b67335..012af6d295a5 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_preemption.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_preemption.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -60,6 +60,264 @@
 #if gcdENABLE_SW_PREEMPTION
 #define _GC_OBJ_ZONE    gcvZONE_KERNEL
 
+static const gctUINT32 _PatchItemSize[] =
+{
+    0,
+    (gctUINT32)sizeof(gcsHAL_PATCH_VIDMEM_ADDRESS),
+    (gctUINT32)sizeof(gcsHAL_PATCH_MCFE_SEMAPHORE),
+    (gctUINT32)sizeof(gcsHAL_PATCH_VIDMEM_TIMESTAMP),
+};
+
+static gceSTATUS
+_GetPatchListSingle(
+    IN gckCOMMAND Command,
+    IN gcsHAL_COMMAND_LOCATION * CommandBuffer,
+    IN gcsHAL_PATCH_LIST * PatchList,
+    IN gctBOOL NeedCopy
+    )
+{
+    gceSTATUS status;
+    gctPOINTER userPtr = gcvNULL;
+    gctUINT32 index = 0;
+    gctUINT32 count = 0;
+    gctUINT32 itemSize = 0;
+    gctUINT32 batchCount = 0;
+    gcsPATCH_ARRAY *patchArray = gcvNULL;
+    gcsPATCH_ARRAY *patchArrayHead = gcvNULL;
+    gcsPATCH_ARRAY *cursor = gcvNULL;
+    gctPOINTER pointer = gcvNULL;
+    gcsHAL_PATCH_MCFE_SEMAPHORE * patch = gcvNULL;
+
+    gcmkHEADER_ARG("Command=%p CommandBuffer=%p PatchList=%p type=%d",
+                   Command, CommandBuffer, PatchList, PatchList->type);
+
+    if (PatchList->type >= gcmCOUNTOF(_PatchItemSize))
+    {
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+
+    itemSize = _PatchItemSize[PatchList->type];
+
+    batchCount = (gctUINT32)(sizeof(gctUINT64) * 32 / itemSize);
+
+    while (index < PatchList->count)
+    {
+        count = PatchList->count - index;
+
+        if (count > batchCount)
+        {
+            count = batchCount;
+        }
+
+        userPtr = gcmUINT64_TO_PTR(PatchList->patchArray + itemSize * index);
+
+        if (userPtr)
+        {
+            gcmkONERROR(gckOS_Allocate(
+                Command->os,
+                gcmSIZEOF(gcsPATCH_ARRAY),
+                &pointer));
+
+            patchArray = (gcsPATCH_ARRAY *)pointer;
+
+            gckOS_ZeroMemory(patchArray, sizeof(gcsPATCH_ARRAY));
+
+            if (NeedCopy)
+            {
+                status = gckOS_CopyFromUserData(
+                    Command->os,
+                    patchArray->kArray,
+                    userPtr,
+                    itemSize * count
+                    );
+            }
+            else
+            {
+                gctPOINTER kArray = patchArray->kArray;
+
+                status = gckOS_MapUserPointer(
+                    Command->os,
+                    userPtr,
+                    itemSize * count,
+                    (gctPOINTER *)&kArray
+                    );
+            }
+
+            patch = (gcsHAL_PATCH_MCFE_SEMAPHORE *)patchArray->kArray;
+
+            if (gcmIS_ERROR(status))
+            {
+                userPtr = gcvNULL;
+                gcmkONERROR(status);
+            }
+
+            if (index)
+            {
+                cursor->next = patchArray;
+                cursor = cursor->next;
+            }
+            else
+            {
+                cursor = patchArray;
+                patchArrayHead = patchArray;
+            }
+
+
+            if (!NeedCopy)
+            {
+                gcmkVERIFY_OK(gckOS_UnmapUserPointer(
+                    Command->os,
+                    userPtr,
+                    itemSize * count,
+                    patchArray->kArray
+                    ));
+            }
+        }
+
+        index += count;
+    }
+
+    PatchList->patchArray = gcmPTR_TO_UINT64(patchArrayHead);
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (!NeedCopy && userPtr)
+    {
+        gcmkVERIFY_OK(gckOS_UnmapUserPointer(
+            Command->os,
+            userPtr,
+            itemSize * count,
+            patchArray->kArray
+            ));
+
+        userPtr = gcvNULL;
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
+static gceSTATUS
+_GetPatchList(
+    IN gckCOMMAND Command,
+    IN gcsHAL_COMMAND_LOCATION * CommandBuffer
+    )
+{
+    gceSTATUS status;
+    gctBOOL needCopy = gcvFALSE;
+    gcsHAL_PATCH_LIST * kPatchList = gcvNULL;
+    gcsHAL_PATCH_LIST * cursor = gcvNULL;
+    gctPOINTER userPtr = gcmUINT64_TO_PTR(CommandBuffer->patchHead);
+    gctPOINTER pointer = gcvNULL;
+    gctUINT32 index = 0;
+
+    gcmkHEADER_ARG("Command=%p CommandBuffer=%p", Command, CommandBuffer);
+
+    gcmkONERROR(gckOS_QueryNeedCopy(Command->os, 0, &needCopy));
+
+    if (!userPtr)
+    {
+        CommandBuffer->patchHead = 0;
+    }
+
+    while (userPtr)
+    {
+        gctUINT64 next;
+
+        gcmkONERROR(gckOS_Allocate(
+            Command->os,
+            gcmSIZEOF(gcsHAL_PATCH_LIST),
+            &pointer));
+
+        kPatchList = (gcsHAL_PATCH_LIST *)pointer;
+
+        gcmkONERROR(gckOS_ZeroMemory(kPatchList, sizeof(gcsHAL_PATCH_LIST)));
+
+        if (needCopy)
+        {
+            status = gckOS_CopyFromUserData(
+                Command->os,
+                kPatchList,
+                userPtr,
+                sizeof(gcsHAL_PATCH_LIST)
+                );
+        }
+        else
+        {
+            status = gckOS_MapUserPointer(
+                Command->os,
+                userPtr,
+                sizeof(gcsHAL_PATCH_LIST),
+                (gctPOINTER *)&kPatchList
+                );
+        }
+
+        if (gcmIS_ERROR(status))
+        {
+            userPtr = gcvNULL;
+            gcmkONERROR(status);
+        }
+
+        gcmkASSERT(kPatchList->type < gcvHAL_PATCH_TYPE_COUNT);
+
+        gcmkONERROR(
+            _GetPatchListSingle(Command,
+                                CommandBuffer,
+                                kPatchList,
+                                needCopy));
+
+        if (index)
+        {
+            cursor->next = gcmPTR_TO_UINT64(kPatchList);
+            cursor = (gcsHAL_PATCH_LIST *)gcmUINT64_TO_PTR(cursor->next);
+        }
+        else
+        {
+            cursor = kPatchList;
+            CommandBuffer->patchHead = gcmPTR_TO_UINT64(kPatchList);
+        }
+
+        next = kPatchList->next;
+
+        if (!needCopy)
+        {
+            gcmkVERIFY_OK(gckOS_UnmapUserPointer(
+                Command->os,
+                userPtr,
+                sizeof(gcsHAL_PATCH_LIST),
+                kPatchList
+                ));
+        }
+
+        userPtr = gcmUINT64_TO_PTR(next);
+        index++;
+    }
+
+    gcmkFOOTER_NO();
+    return gcvSTATUS_OK;
+
+OnError:
+    if (userPtr)
+    {
+        CommandBuffer->patchHead = 0;
+    }
+
+    if (!needCopy && userPtr)
+    {
+        gcmkVERIFY_OK(gckOS_UnmapUserPointer(
+            Command->os,
+            userPtr,
+            sizeof(gcsHAL_PATCH_LIST),
+            kPatchList
+            ));
+    }
+
+    gcmkFOOTER();
+    return status;
+}
+
 /*******************************************************************************
 **
 **  gckKERNEL_DestroyPreemptCommit
@@ -89,6 +347,10 @@ gckKERNEL_DestroyPreemptCommit(
     gckVIDMEM_NODE nodeObject = gcvNULL;
     gcsQUEUE_PTR eventQueue = gcvNULL;
     gcsQUEUE_PTR nextEventQueue = gcvNULL;
+    gcsPATCH_ARRAY *patchArray = gcvNULL;
+    gcsPATCH_ARRAY *nextPatchArray = gcvNULL;
+    gcsHAL_PATCH_LIST * patchList = gcvNULL;
+    gcsHAL_PATCH_LIST * nextPatchList = gcvNULL;
     gceSTATUS status = gcvSTATUS_OK;
 
     gcmkHEADER_ARG("Kernel=%p PreemptComimt=%p", Kernel, PreemptCommit);
@@ -100,6 +362,28 @@ gckKERNEL_DestroyPreemptCommit(
 
     while (cmdLoc)
     {
+        patchList = (gcsHAL_PATCH_LIST *)gcmUINT64_TO_PTR(cmdLoc->patchHead);
+        while (patchList)
+        {
+            nextPatchList = (gcsHAL_PATCH_LIST *)gcmUINT64_TO_PTR(patchList->next);
+
+
+            patchArray = (gcsPATCH_ARRAY *)gcmUINT64_TO_PTR(patchList->patchArray);
+
+            while (patchArray)
+            {
+                nextPatchArray = patchArray->next;
+
+                gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, patchArray));
+
+                patchArray = nextPatchArray;
+            }
+
+            gcmkVERIFY_OK(gcmkOS_SAFE_FREE(Kernel->os, patchList));
+
+            patchList = nextPatchList;
+        }
+
         gcmkVERIFY_OK(gckVIDMEM_HANDLE_Lookup(
             Kernel,
             PreemptCommit->pid,
@@ -232,6 +516,8 @@ gckKERNEL_ConstructPreemptCommit(
 
     preemptCommit = (gckPREEMPT_COMMIT)pointer;
 
+    gcmkVERIFY_OK(gckOS_ZeroMemory(preemptCommit, sizeof(gcsPREEMPT_COMMIT)));
+
     if (SubCommit->context)
     {
         context = gckKERNEL_QueryPointerFromName(
@@ -270,11 +556,12 @@ gckKERNEL_ConstructPreemptCommit(
 
     cmdLocHead->logical = gcmPTR_TO_UINT64(commandBufferLogical);
 
+    gcmkONERROR(_GetPatchList(Kernel->command, cmdLocHead));
+
     cursor = cmdLocHead;
 
     do
     {
-        gcsHAL_COMMAND_LOCATION * user;
         if (userPtr)
         {
             gcmkONERROR(
@@ -327,6 +614,8 @@ gckKERNEL_ConstructPreemptCommit(
             cursor->next = gcmPTR_TO_UINT64(cmdLoc);
             cursor = (gcsHAL_COMMAND_LOCATION *)gcmUINT64_TO_PTR(cursor->next);
             cursor->logical = gcmPTR_TO_UINT64(commandBufferLogical);
+
+            gcmkONERROR(_GetPatchList(Kernel->command, cmdLoc));
         }
 
         next = cmdLoc->next;
@@ -342,7 +631,6 @@ gckKERNEL_ConstructPreemptCommit(
         }
 
         userPtr = gcmUINT64_TO_PTR(next);
-        user = (gcsHAL_COMMAND_LOCATION *)userPtr;
     }
     while (userPtr);
 
@@ -630,6 +918,8 @@ gckKERNEL_PreparePreemptEvent(
 
     preemptCommit = (gckPREEMPT_COMMIT)pointer;
 
+    gcmkVERIFY_OK(gckOS_ZeroMemory(preemptCommit, sizeof(gcsPREEMPT_COMMIT)));
+
     gcmkVERIFY_OK(gckOS_QueryNeedCopy(Kernel->os, ProcessID, &needCopy));
 
     if (uQueue)
@@ -708,7 +998,7 @@ gckKERNEL_PreparePreemptEvent(
     {
         signal = gcmUINT64_TO_PTR(record->iface.u.Signal.signal);
 
-        if (record->iface.u.Signal.fenceSignal && gcmUINT64_TO_PTR(record->iface.u.Signal.process))
+        if (record->iface.u.Signal.fenceSignal == gcvTRUE && gcmUINT64_TO_PTR(record->iface.u.Signal.process))
         {
             /* User signal. */
             gcmkONERROR(gckOS_UserSignal(
@@ -718,7 +1008,6 @@ gckKERNEL_PreparePreemptEvent(
                 ));
         }
 
-
         /* Next record in the queue. */
         record = gcmUINT64_TO_PTR(record->next);
     }
@@ -730,13 +1019,6 @@ gckKERNEL_PreparePreemptEvent(
     preemptCommit->isEnd       = gcvFALSE;
     preemptCommit->isNop       = gcvFALSE;
 
-    preemptCommit->cmdLoc        = gcvNULL;
-    preemptCommit->mapEntryID    = gcvNULL;
-    preemptCommit->mapEntryIndex = gcvNULL;
-    preemptCommit->recordArray   = gcvNULL;
-    preemptCommit->delta         = gcvNULL;
-    preemptCommit->context       = gcvNULL;
-
     *PreemptCommit = preemptCommit;
 
     gcmkFOOTER_NO();
@@ -1140,6 +1422,7 @@ gckKERNEL_FullPreemption(
             gcmkVERIFY_OK(gckOS_AtomGet(Kernel->os, Kernel->device->atomPriorityID, &curHighestPriorityID));
             if (id < curHighestPriorityID)
             {
+
                 gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->priorityQueueMutex[id]));
                 return gcvSTATUS_OK;
             }
@@ -1160,7 +1443,10 @@ gckKERNEL_FullPreemption(
                             gcmkONERROR(gckCONTEXT_DestroyPrevDelta(preemptCommit->context));
                         }
 
-                        gcmkONERROR(gckCONTEXT_UpdateDelta(preemptCommit->context, preemptCommit->delta));
+                        if (preemptCommit->delta)
+                        {
+                            gcmkONERROR(gckCONTEXT_UpdateDelta(preemptCommit->context, preemptCommit->delta));
+                        }
                     }
 
                     status = gckCOMMAND_PreemptCommit(Kernel->command, preemptCommit);
@@ -1194,7 +1480,11 @@ gckKERNEL_FullPreemption(
         gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->priorityQueueMutex[id]));
     }
 
+    return gcvSTATUS_OK;
+
 OnError:
+    gcmkONERROR(gckOS_ReleaseMutex(Kernel->os, Kernel->priorityQueueMutex[id]));
+
     return status;
 }
 
@@ -1301,7 +1591,6 @@ gckKERNEL_CommandCommitPreemption(
             (priorityID == curHighestPriorityID && Kernel->priorityQueues[priorityID]
             && Kernel->priorityQueues[priorityID]->head))
         {
-
             gcmkONERROR(
                 gckKERNEL_ConstructPreemptCommit(Kernel,
                                                  SubCommit,
@@ -1326,8 +1615,20 @@ gckKERNEL_CommandCommitPreemption(
         }
         else
         {
+            gctUINT32 prevHighestPriorityID = curHighestPriorityID;
+
             gcmkVERIFY_OK(gckOS_AtomSet(Kernel->os, Kernel->device->atomPriorityID, priorityID));
 
+            if (Command->feType == gcvHW_FE_MULTI_CHANNEL
+                && priorityID > prevHighestPriorityID)
+            {
+                gckCOMMAND_Stall(Kernel->command, gcvFALSE);
+            }
+            else
+            {
+                (void)prevHighestPriorityID;
+            }
+
             status = gckCOMMAND_Commit(Command,
                                        SubCommit,
                                        ProcessID,
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_preemption.h b/drivers/staging/npu/kernel/gc_hal_kernel_preemption.h
index 792ae90a8dce..ae372ee851f3 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_preemption.h
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_preemption.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -76,6 +76,14 @@ typedef enum _gcePREEMPTION_MODE
 }
 gcePREEMPTION_MODE;
 
+typedef struct _gcsPATCH_ARRAY
+{
+    gctUINT64 kArray[32];
+
+    struct _gcsPATCH_ARRAY * next;
+}
+gcsPATCH_ARRAY;
+
 /* Preempt commit. */
 typedef struct _gcsPREEMPT_COMMIT * gckPREEMPT_COMMIT;
 typedef struct _gcsPREEMPT_COMMIT
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_security.c b/drivers/staging/npu/kernel/gc_hal_kernel_security.c
index 3c7898e0cdb0..494d9a257a1f 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_security.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_security.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_security_v1.c b/drivers/staging/npu/kernel/gc_hal_kernel_security_v1.c
index 38361eacfc0e..a3fbc10cf809 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_security_v1.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_security_v1.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_video_memory.c b/drivers/staging/npu/kernel/gc_hal_kernel_video_memory.c
index 01c2cc69f517..a410d131ee4a 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_video_memory.c
+++ b/drivers/staging/npu/kernel/gc_hal_kernel_video_memory.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -612,11 +612,7 @@ _FindNode(
 {
     gcuVIDMEM_NODE_PTR node;
     gctUINT32 alignment;
-
-#if gcdENABLE_BANK_ALIGNMENT
     gctUINT32 bankAlignment;
-    gceSTATUS status;
-#endif
 
     if (Memory->sentinel[Bank].VidMem.nextFree == gcvNULL)
     {
@@ -624,30 +620,40 @@ _FindNode(
         return gcvNULL;
     }
 
-#if gcdENABLE_BANK_ALIGNMENT
     /* Walk all free nodes until we have one that is big enough or we have
     ** reached the sentinel. */
     for (node = Memory->sentinel[Bank].VidMem.nextFree;
          node->VidMem.bytes != 0;
          node = node->VidMem.nextFree)
     {
+        gctUINT offset;
+
+        gcmkSAFECASTSIZET(offset, node->VidMem.offset);
+
         if (node->VidMem.bytes < Bytes)
         {
             continue;
         }
 
-        gcmkONERROR(_GetSurfaceBankAlignment(
+#if gcdENABLE_BANK_ALIGNMENT
+        if (gcmIS_ERROR(_GetSurfaceBankAlignment(
             Kernel,
             Type,
             (gctUINT32)(node->VidMem.parent->physicalBase + node->VidMem.offset),
-            &bankAlignment));
+            &bankAlignment)))
+        {
+            return gcvNULL;
+        }
 
         bankAlignment = gcmALIGN(bankAlignment, *Alignment);
+#else
+        bankAlignment = 0;
+#endif
 
         /* Compute number of bytes to skip for alignment. */
         alignment = (*Alignment == 0)
                   ? 0
-                  : (*Alignment - (node->VidMem.offset % *Alignment));
+                  : (*Alignment - (offset & (*Alignment - 1)));
 
         if (alignment == *Alignment)
         {
@@ -662,42 +668,7 @@ _FindNode(
             return node;
         }
     }
-#endif
-
-    /* Walk all free nodes until we have one that is big enough or we have
-       reached the sentinel. */
-    for (node = Memory->sentinel[Bank].VidMem.nextFree;
-         node->VidMem.bytes != 0;
-         node = node->VidMem.nextFree)
-    {
-        gctUINT offset;
-
-        gctINT modulo;
 
-        gcmkSAFECASTSIZET(offset, node->VidMem.offset);
-
-        modulo = gckMATH_ModuloInt(offset, *Alignment);
-
-        /* Compute number of bytes to skip for alignment. */
-        alignment = (*Alignment == 0) ? 0 : (*Alignment - modulo);
-
-        if (alignment == *Alignment)
-        {
-            /* Node is already aligned. */
-            alignment = 0;
-        }
-
-        if (node->VidMem.bytes >= Bytes + alignment)
-        {
-            /* This node is big enough. */
-            *Alignment = alignment;
-            return node;
-        }
-    }
-
-#if gcdENABLE_BANK_ALIGNMENT
-OnError:
-#endif
     /* Not enough memory. */
     return gcvNULL;
 }
@@ -763,6 +734,11 @@ gckVIDMEM_AllocateLinear(
     gcmkVERIFY_ARGUMENT(Node != gcvNULL);
     gcmkVERIFY_ARGUMENT(Type < gcvVIDMEM_TYPE_COUNT);
 
+    if (Alignment && (Alignment & (Alignment - 1)))
+    {
+        gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+
     /* Acquire the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(Memory->os, Memory->mutex, gcvINFINITE));
 
@@ -1299,7 +1275,7 @@ _ConvertPhysical(
         physical -= Kernel->hardware->baseAddress;
 
         /* 2G upper is virtual space, better to move to gckHARDWARE section. */
-        if (physical + Node->Virtual.bytes > 0x80000000)
+        if (Node && (physical + Node->Virtual.bytes > 0x80000000U))
         {
             /* End is above 2G, ie virtual space. */
             status = gcvSTATUS_NOT_SUPPORTED;
@@ -1374,6 +1350,21 @@ gckVIDMEM_MapVidMemBlock(
                                     0,
                                     &physAddr));
 
+    if (!Kernel->hardware->options.enableMMU)
+    {
+        if (physAddr >= ((gctUINT64)1 << 32))
+        {
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        }
+        else
+        {
+            VidMemBlock->addresses[hwType] = (gctUINT32)physAddr;
+
+            gcmkFOOTER_ARG("*Address=0x%08X", VidMemBlock->addresses[hwType]);
+            return gcvSTATUS_OK;
+        }
+    }
+
     status = _ConvertPhysical(Kernel,
                               Kernel->core,
                               gcvNULL,
@@ -1382,10 +1373,27 @@ gckVIDMEM_MapVidMemBlock(
                               &VidMemBlock->addresses[hwType]);
     if (gcmIS_ERROR(status))
     {
+        gctSIZE_T pageCount = VidMemBlock->pageCount;
+
+        /* If physical address is not aligned. */
+        if (physAddr & (gcd1M_PAGE_SIZE - 1))
+        {
+            if (VidMemBlock->contiguous)
+            {
+                pageCount++;
+            }
+            else
+            {
+                gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+            }
+        }
+
+        VidMemBlock->fixedPageCount = (gctUINT32)pageCount;
+
         /* Allocate pages inside the MMU. */
         gcmkONERROR(
             gckMMU_AllocatePagesEx(Kernel->mmu,
-                                   VidMemBlock->pageCount,
+                                   pageCount,
                                    VidMemBlock->type,
                                    gcvPAGE_TYPE_1M,
                                    VidMemBlock->secure,
@@ -1399,7 +1407,7 @@ gckVIDMEM_MapVidMemBlock(
                 gckOS_Map1MPages(os,
                                  Kernel->core,
                                  VidMemBlock->physical,
-                                 VidMemBlock->pageCount,
+                                 pageCount,
                                  VidMemBlock->addresses[hwType],
                                  VidMemBlock->pageTables[hwType],
                                  gcvTRUE,
@@ -1417,6 +1425,7 @@ gckVIDMEM_MapVidMemBlock(
                    VidMemBlock,
                    VidMemBlock->addresses[hwType]);
 
+    gcmkFOOTER();
     return gcvSTATUS_OK;
 
 OnError:
@@ -1429,7 +1438,7 @@ gckVIDMEM_MapVidMemBlock(
                              gcvPAGE_TYPE_1M,
                              VidMemBlock->addresses[hwType],
                              VidMemBlock->pageTables[hwType],
-                             VidMemBlock->pageCount));
+                             VidMemBlock->fixedPageCount));
 
         VidMemBlock->pageTables[hwType] = gcvNULL;
     }
@@ -1460,7 +1469,7 @@ _UnmapVidMemBlock(
                              gcvPAGE_TYPE_1M,
                              VidMemBlock->addresses[HwType],
                              VidMemBlock->pageTables[HwType],
-                             VidMemBlock->pageCount));
+                             VidMemBlock->fixedPageCount));
 
         VidMemBlock->pageTables[HwType] = gcvNULL;
     }
@@ -2213,6 +2222,9 @@ gckVIDMEM_LockVirtual(
 
     gcmkHEADER_ARG("Kernel=%p Node=%p", Kernel, Node);
 
+    gcmkVERIFY_ARGUMENT(Kernel != gcvNULL);
+    gcmkVERIFY_ARGUMENT(Kernel->hardware != gcvNULL);
+
     gcmkVERIFY_OK(
         gckKERNEL_GetHardwareType(Kernel,
                                   &hwType));
@@ -2223,6 +2235,21 @@ gckVIDMEM_LockVirtual(
                                     0,
                                     &physicalAddress));
 
+    if (!Kernel->hardware->options.enableMMU)
+    {
+        if (physicalAddress >= ((gctUINT64)1 << 32))
+        {
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        }
+        else
+        {
+            *Address = (gctUINT32)physicalAddress;
+
+            gcmkFOOTER_ARG("*Address=0x%08X", *Address);
+            return gcvSTATUS_OK;
+        }
+    }
+
 
     /* Increment the lock count. */
     if (Node->Virtual.lockeds[hwType]++ == 0)
@@ -2478,12 +2505,18 @@ gckVIDMEM_UnlockVirtual(
     IN OUT gctBOOL * Asynchroneous
     )
 {
-    gceSTATUS status;
+    gceSTATUS status = gcvSTATUS_OK;
     gceHARDWARE_TYPE hwType;
 
     gcmkHEADER_ARG("Node=0x%x *Asynchroneous=%d",
                    Node, gcmOPT_VALUE(Asynchroneous));
 
+    if (!Kernel->hardware->options.enableMMU)
+    {
+            gcmkFOOTER();
+            return status;
+    }
+
     gcmkVERIFY_OK(
         gckKERNEL_GetHardwareType(Kernel,
                                   &hwType));
@@ -2512,7 +2545,7 @@ gckVIDMEM_UnlockVirtual(
             address = Node->Virtual.addresses[hwType] & ~(4096 - 1);
 
 #if gcdSECURITY
-            if (Node->Virtual.addresses[hwType] > 0x80000000)
+            if (Node->Virtual.addresses[hwType] > 0x80000000U)
             {
                 gcmkONERROR(gckKERNEL_SecurityUnmapMemory(
                     Kernel,
@@ -3282,11 +3315,19 @@ gckVIDMEM_NODE_Lock(
     gceSTATUS status;
     gckOS os = Kernel->os;
     gctBOOL acquired = gcvFALSE;
-    gcuVIDMEM_NODE_PTR node = NodeObject->node;
-    gckVIDMEM_BLOCK vidMemBlock = node->VirtualChunk.parent;
+    gcuVIDMEM_NODE_PTR node;
+    gckVIDMEM_BLOCK vidMemBlock;
 
     gcmkHEADER_ARG("NodeObject=%p", NodeObject);
 
+    if (gcvNULL == NodeObject)
+    {
+        gcmkONERROR(gcvSTATUS_INVALID_OBJECT);
+    }
+
+    node = NodeObject->node;
+    vidMemBlock = node->VirtualChunk.parent;
+
     /* Grab the mutex. */
     gcmkONERROR(gckOS_AcquireMutex(os, NodeObject->mutex, gcvINFINITE));
     acquired = gcvTRUE;
diff --git a/drivers/staging/npu/kernel/inc/gc_feature_database.h b/drivers/staging/npu/kernel/inc/gc_feature_database.h
index ca55e1ce9338..8b5ac364c5bc 100644
--- a/drivers/staging/npu/kernel/inc/gc_feature_database.h
+++ b/drivers/staging/npu/kernel/inc/gc_feature_database.h
@@ -53,7 +53,7 @@
 *****************************************************************************/
 
 
-/*Auto created on 2020-11-03 11:19*/
+/*Auto created on 2021-04-12 17:20*/
 #ifndef _gc_feature_database_h_
 #define _gc_feature_database_h_
 
@@ -101,8 +101,10 @@ typedef struct
     gctUINT32 RESULT_WINDOW_MAX_SIZE;
     gctUINT32 ClusterAliveMask;
     gctUINT32 G2D_DEC400_MINOR;
+    gctUINT32 PS_INSTRUCTION_COUNT;
     gctUINT32 NNMadPerCore;
     gctUINT32 NNCoreCount;
+    gctUINT32 NN_ACTIVE_CORE_COUNT;
     gctUINT32 NNCoreCount_INT8;
     gctUINT32 NNCoreCount_INT16;
     gctUINT32 NNCoreCount_FLOAT16;
@@ -148,6 +150,8 @@ typedef struct
     gctUINT32 MAX_TILE_X_SIZE;
     gctUINT32 NN_CLUSTER_NUM_FOR_POWER_CONTROL;
     gctUINT32 NN_IN_LINES_PER_CYCLE;
+    gctUINT32 VIP_CLUSTER_COUNT;
+    gctUINT32 NN_MP_INTER_CONNECT_RING_COUNT;
     gctUINT32 REG_FastClear:1;
     gctUINT32 REG_SpecialAntiAliasing:1;
     gctUINT32 REG_Pipe3D:1;
@@ -531,6 +535,7 @@ typedef struct
     gctUINT32 ENDIAN_CONTROL:1;
     gctUINT32 G2D_RGB_PLANAR:1;
     gctUINT32 G2D_DEC400EX:1;
+    gctUINT32 G2D_NO_YUV420_SOURCE:1;
     gctUINT32 G2D_YUV420_101010:1;
     gctUINT32 SH_VX2_FLOATING_MAD_FIX:1;
     gctUINT32 TS_FC_VULKAN_SUPPORT:1;
@@ -548,6 +553,13 @@ typedef struct
     gctUINT32 LDST_CONV_4ROUNDING_MODES:1;
     gctUINT32 FULL_PACK_MODE_SUPPORT:1;
     gctUINT32 DEPTH_FLOAT32_SUPPORT:1;
+    gctUINT32 GPU_INSPECTOR_COUNTERS:1;
+    gctUINT32 FP32_TO_FP16_CONV_FIX:1;
+    gctUINT32 IMGLD_COMP_COUNT_FIX:1;
+    gctUINT32 IMGLD_WIDTH_LT16_FIX:1;
+    gctUINT32 TX_FILTER_ROUND_FIX:1;
+    gctUINT32 SH_FP32_FMA_SUPPORT:1;
+    gctUINT32 TX_ETC2_COMPRESSION:1;
     gctUINT32 VG_TS_CULLING:1;
     gctUINT32 VG_FP25:1;
     gctUINT32 VG_AYUV_INPUT_OUTPUT:1;
@@ -654,6 +666,9 @@ typedef struct
     gctUINT32 PRELU_LEAKLY_RELU_CLAMP:1;
     gctUINT32 TPLITE_BFLOAT16:1;
     gctUINT32 PREPROCESS_IMG_BUF_640BYTE_LIMIT:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_FP16:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_BF16:1;
+    gctUINT32 NN_POST_OUT_SUPPORT_FP32:1;
     gctUINT32 TP_KERNEL_1BYTE_ALGIN:1;
     gctUINT32 BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE:1;
     gctUINT32 NN_COMPRESSION_BYPASSS:1;
@@ -667,10 +682,12 @@ typedef struct
     gctUINT32 TILE_ACCESS_CAPABILITY:1;
     gctUINT32 FAST_DP3_PREPROCESSOR:1;
     gctUINT32 DEPTHWISE_SUPPORT_16BIT_FORMAT:1;
-    gctUINT32 SH_SUPPORT_VEC2:1;
-    gctUINT32 NN_SUPPORT_ALU_LUT:1;
+    gctUINT32 NN_SUPPORT_ALU:1;
     gctUINT32 NN_ENHANCED_MAX_POOLING:1;
     gctUINT32 NN_TRANSPOSE_PHASE2:1;
+    gctUINT32 NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD:1;
+    gctUINT32 NN_CONV_CORE_BYPASS:1;
+    gctUINT32 NN_TENSOR_ADD_RELU:1;
     gctUINT32 TPLITE_SUPPORT_TP_DATA_TRANSPOSE:1;
     gctUINT32 NN_SUPPORT_CONV_1D:1;
     gctUINT32 USE_VIPSRAM_FOR_KERNEL_STREAMING:1;
@@ -679,6 +696,8 @@ typedef struct
     gctUINT32 NN_1x1_NON_POOLING_PACKING:1;
     gctUINT32 NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING:1;
     gctUINT32 NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2:1;
+    gctUINT32 TP_REMOVE_FC:1;
+    gctUINT32 VIP_REMOVE_MMU:1;
     gctUINT32 NN_MP_INTER_CONNECT_RING:1;
     gctUINT32 NN_SUPPORT_BATCH:1;
     gctUINT32 NN_2D_AVERAGE_OUTPUT:1;
@@ -736,15 +755,31 @@ typedef struct
     gctUINT32 BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX:1;
     gctUINT32 INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX:1;
     gctUINT32 TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX:1;
-    gctUINT32 NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE:1;
+    gctUINT32 NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX:1;
     gctUINT32 NN_IN_TILE_DATA_IS_ALL_PAD_FIX:1;
     gctUINT32 NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX:1;
+    gctUINT32 CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX:1;
     gctUINT32 TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX:1;
     gctUINT32 NN_KERNEL_1x1_NO_PAD_FIX:1;
     gctUINT32 NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX:1;
     gctUINT32 TP_NOT_FULL_USE_CACHE_LINE_FIX:1;
     gctUINT32 SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX:1;
     gctUINT32 BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX:1;
+    gctUINT32 TP_ASSYM_INT8_FIX:1;
+    gctUINT32 NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX:1;
+    gctUINT32 NN_2ND_IMG_BASE_ADDR_FIX:1;
+    gctUINT32 NN_TP_SYSTEM_FIX:1;
+    gctUINT32 NN_INTILE_YSIZE_128_LIMIT_FIX:1;
+    gctUINT32 SH_CLOCK_GATOR_IDLE_CONDITON_FIX:1;
+    gctUINT32 NN_BURST_COLLECTER_LAST_FLAG_FIX:1;
+    gctUINT32 NN_2ND_IMG_SMALL_3D_TILE_FIX:1;
+    gctUINT32 NN_TILE_YSIZE_127_LIMITATION_FIX:1;
+    gctUINT32 NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX:1;
+    gctUINT32 NN_VIPSRAM_DOUBLE_BUFFER_FIX:1;
+    gctUINT32 NN_JD_DIRECT_MODE_FIX:1;
+    gctUINT32 NN_KERNEL_DIRECT_WRONG_PUSH_FIX:1;
+    gctUINT32 HI_DEFAULT_ENABLE_REORDER_FIX:1;
+    gctUINT32 V83_INTILESIZE_1X1_10BITS_FIX:1;
     gctUINT32 NN_INTERLEVE8:1;
     gctUINT32 NN_FP16_ALU:1;
     gctUINT32 NN_INT16_ALU:1;
@@ -760,15 +795,751 @@ typedef struct
     gctUINT32 IMAGE_PARTIAL_CACHE:1;
 } gcsFEATURE_DATABASE;
 
-#define FEATURE_BIT_START 89
-#define FEATURE_BIT_END 698
+#define FEATURE_BIT_START 93
+#define FEATURE_BIT_END 733
 static gcsFEATURE_DATABASE gChipInfo[] = {
+    /* vip9000nano-di */
+    {
+        0x9000, /* ChipID */
+        0x8302, /* ChipRevision */
+        0x5090009, /* ProductID */
+        0x8000000, /* EcoID */
+        0xe8, /* CustomerID */
+        0x0, /* PatchVersion */
+        "", /* ProductName */
+        0x0, /* FormalRelease */
+        0x40, /* gcFEATURE_VALUE_TempRegisters */
+        0x100, /* gcFEATURE_VALUE_ThreadCount */
+        0x1, /* gcFEATURE_VALUE_NumShaderCores */
+        0x200, /* gcFEATURE_VALUE_InstructionCount */
+        0x140, /* gcFEATURE_VALUE_NumberOfConstants */
+        0x1, /* gcFEATURE_VALUE_CoreCount */
+        0x10, /* gcFEATURE_VALUE_LocalStorageSize */
+        0x0, /* gcFEATURE_VALUE_LocalStorageSize_1 */
+        0x0, /* gcFEATURE_VALUE_LocalStorageSize_2 */
+        0x10, /* gcFEATURE_VALUE_L1CacheSize */
+        0x0, /* gcFEATURE_VALUE_L1CacheSize_1 */
+        0x0, /* gcFEATURE_VALUE_L1CacheSize_2 */
+        0x200, /* gcFEATURE_VALUE_InstructionMemorySize */
+        0x14, /* gcFEATURE_VALUE_ShaderPCLength */
+        0x10, /* gcFEATURE_VALUE_USC_MAX_PAGES */
+        0x0, /* gcFEATURE_VALUE_USC_MAX_PAGES_1 */
+        0x0, /* gcFEATURE_VALUE_USC_MAX_PAGES_2 */
+        0x1, /* gcFEATURE_VALUE_NumPixelPipes */
+        0x2, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS */
+        0x0, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS_1 */
+        0x0, /* gcFEATURE_VALUE_USC_CACHE_CONTROLLERS_2 */
+        0x2, /* gcFEATURE_VALUE_USC_BANKS */
+        0x0, /* gcFEATURE_VALUE_USC_BANKS_1 */
+        0x0, /* gcFEATURE_VALUE_USC_BANKS_2 */
+        0x8, /* gcFEATURE_VALUE_Streams */
+        0x10, /* gcFEATURE_VALUE_VaryingCount */
+        0x400, /* gcFEATURE_VALUE_VertexOutputBufferSize */
+        0x0, /* gcFEATURE_VALUE_BufferSize */
+        0x10, /* gcFEATURE_VALUE_VertexCacheSize */
+        0x0, /* gcFEATURE_VALUE_NumResolvePipes */
+        0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
+        0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
+        0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
+        0x40, /* gcFEATURE_VALUE_NNMadPerCore */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
+        0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
+        0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
+        0x0, /* gcFEATURE_VALUE_NNCoreCount_BFLOAT */
+        0x9, /* gcFEATURE_VALUE_NNInputBufferDepth */
+        0x20, /* gcFEATURE_VALUE_NNAccumBufferDepth */
+        0x400, /* gcFEATURE_VALUE_TPEngine_PwlLUTCount */
+        0x10, /* gcFEATURE_VALUE_TPEngine_PwlLUTSize */
+        0x100000, /* gcFEATURE_VALUE_VIP_SRAM_SIZE */
+        0x1, /* gcFEATURE_VALUE_TPEngine_CoreCount */
+        0x0, /* gcFEATURE_VALUE_AXI_SRAM_SIZE */
+        0x5, /* gcFEATURE_VALUE_NN_INIMAGE_OFFSET_BITS */
+        0x200, /* gcFEATURE_VALUE_TP_REORDER_INIMAGE_SIZE */
+        0x0, /* gcFEATURE_VALUE_TPLite_CoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_PREPROCESSOR_MAX_SEGMENT_PER_CYCLE */
+        0x0, /* gcFEATURE_VALUE_NNFP16_XYDP_X */
+        0x0, /* gcFEATURE_VALUE_NNFP16_XYDP_Y */
+        0x0, /* gcFEATURE_VALUE_NNFP16_ZDP */
+        0x20, /* gcFEATURE_VALUE_NN_LANES_PER_OUT_CYCLE */
+        0x40, /* gcFEATURE_VALUE_MAX_OT_NUMBER */
+        0x80, /* gcFEATURE_VALUE_PHYSICAL_VIP_SRAM_WIDTH_IN_BYTE */
+        0x20, /* gcFEATURE_VALUE_EQUIVALENT_VIP_SRAM_WIDTH_INBYTE */
+        0x8, /* gcFEATURE_VALUE_TP_ZRL_BITS */
+        0x8, /* gcFEATURE_VALUE_NN_ZRL_BITS */
+        0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
+        0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
+        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
+        0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
+        0x1f, /* gcFEATURE_VALUE_NN_X_OFFSET */
+        0x1f, /* gcFEATURE_VALUE_NN_Y_OFFSET */
+        0x100, /* gcFEATURE_VALUE_DDR_KERNEL_BURST_SIZE */
+        0x10, /* gcFEATURE_VALUE_OUTIMAGE_X_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_OUTIMAGE_Y_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_INIMAGE_X_STRIDE_BITS */
+        0x10, /* gcFEATURE_VALUE_IMIMAGE_Y_STRIDE_BITS */
+        0xd, /* gcFEATURE_VALUE_OUTIMAGE_X_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_OUTIMAGE_Y_SIZE_BITS */
+        0xe, /* gcFEATURE_VALUE_OUTIMAGE_Z_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_INIMAGE_X_SIZE_BITS */
+        0xd, /* gcFEATURE_VALUE_INIMAGE_Y_SIZE_BITS */
+        0x80, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
+        0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
+        0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
+        0x0, /* gcFEATURE_BIT_REG_FastClear */
+        0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
+        0x1, /* gcFEATURE_BIT_REG_Pipe3D */
+        0x1, /* gcFEATURE_BIT_REG_DXTTextureCompression */
+        0x0, /* gcFEATURE_BIT_REG_DebugMode */
+        0x1, /* gcFEATURE_BIT_REG_ZCompression */
+        0x0, /* gcFEATURE_BIT_REG_YUV420Filter */
+        0x1, /* gcFEATURE_BIT_REG_MSAA */
+        0x0, /* gcFEATURE_BIT_REG_DC */
+        0x0, /* gcFEATURE_BIT_REG_Pipe2D */
+        0x1, /* gcFEATURE_BIT_REG_ETC1TextureCompression */
+        0x1, /* gcFEATURE_BIT_REG_FastScaler */
+        0x1, /* gcFEATURE_BIT_REG_HighDynamicRange */
+        0x1, /* gcFEATURE_BIT_REG_YUV420Tiler */
+        0x1, /* gcFEATURE_BIT_REG_ModuleCG */
+        0x0, /* gcFEATURE_BIT_REG_MinArea */
+        0x0, /* gcFEATURE_BIT_REG_NoEZ */
+        0x0, /* gcFEATURE_BIT_REG_No422Texture */
+        0x0, /* gcFEATURE_BIT_REG_BufferInterleaving */
+        0x1, /* gcFEATURE_BIT_REG_ByteWrite2D */
+        0x0, /* gcFEATURE_BIT_REG_NoScaler */
+        0x1, /* gcFEATURE_BIT_REG_YUY2Averaging */
+        0x0, /* gcFEATURE_BIT_REG_HalfPECache */
+        0x0, /* gcFEATURE_BIT_REG_HalfTXCache */
+        0x0, /* gcFEATURE_BIT_REG_YUY2RenderTarget */
+        0x0, /* gcFEATURE_BIT_REG_Mem32BitSupport */
+        0x0, /* gcFEATURE_BIT_REG_PipeVG */
+        0x0, /* gcFEATURE_BIT_REG_VGTS */
+        0x0, /* gcFEATURE_BIT_REG_FE20 */
+        0x1, /* gcFEATURE_BIT_REG_ByteWrite3D */
+        0x1, /* gcFEATURE_BIT_REG_RsYuvTarget */
+        0x1, /* gcFEATURE_BIT_REG_FE20BitIndex */
+        0x1, /* gcFEATURE_BIT_REG_FlipY */
+        0x1, /* gcFEATURE_BIT_REG_DualReturnBus */
+        0x1, /* gcFEATURE_BIT_REG_EndiannessConfig */
+        0x1, /* gcFEATURE_BIT_REG_Texture8K */
+        0x1, /* gcFEATURE_BIT_REG_CorrectTextureConverter */
+        0x1, /* gcFEATURE_BIT_REG_SpecialMsaaLod */
+        0x1, /* gcFEATURE_BIT_REG_FastClearFlush */
+        0x1, /* gcFEATURE_BIT_REG_2DPE20 */
+        0x0, /* gcFEATURE_BIT_REG_CorrectAutoDisable */
+        0x1, /* gcFEATURE_BIT_REG_Render8K */
+        0x1, /* gcFEATURE_BIT_REG_TileStatus2Bits */
+        0x1, /* gcFEATURE_BIT_REG_SeparateTileStatusWhenInterleaved */
+        0x1, /* gcFEATURE_BIT_REG_SuperTiled32x32 */
+        0x0, /* gcFEATURE_BIT_REG_VG20 */
+        0x0, /* gcFEATURE_BIT_REG_TSExtendedCommands */
+        0x1, /* gcFEATURE_BIT_REG_CompressionFifoFixed */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions0 */
+        0x0, /* gcFEATURE_BIT_REG_VGFilter */
+        0x0, /* gcFEATURE_BIT_REG_VG21 */
+        0x1, /* gcFEATURE_BIT_REG_ShaderGetsW */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions1 */
+        0x1, /* gcFEATURE_BIT_REG_DefaultReg0 */
+        0x1, /* gcFEATURE_BIT_REG_MC20 */
+        0x0, /* gcFEATURE_BIT_REG_ShaderMSAASideband */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes0 */
+        0x0, /* gcFEATURE_BIT_REG_VAA */
+        0x0, /* gcFEATURE_BIT_REG_BypassInMSAA */
+        0x0, /* gcFEATURE_BIT_REG_HierarchicalZ */
+        0x0, /* gcFEATURE_BIT_REG_NewTexture */
+        0x0, /* gcFEATURE_BIT_REG_A8TargetSupport */
+        0x1, /* gcFEATURE_BIT_REG_CorrectStencil */
+        0x1, /* gcFEATURE_BIT_REG_EnhanceVR */
+        0x1, /* gcFEATURE_BIT_REG_RSUVSwizzle */
+        0x1, /* gcFEATURE_BIT_REG_V2Compression */
+        0x0, /* gcFEATURE_BIT_REG_VGDoubleBuffer */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes1 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes2 */
+        0x0, /* gcFEATURE_BIT_REG_TextureStride */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes3 */
+        0x1, /* gcFEATURE_BIT_REG_CorrectAutoDisable1 */
+        0x0, /* gcFEATURE_BIT_REG_AutoRestartTS */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes4 */
+        0x0, /* gcFEATURE_BIT_REG_L2Windowing */
+        0x1, /* gcFEATURE_BIT_REG_HalfFloatPipe */
+        0x1, /* gcFEATURE_BIT_REG_PixelDither */
+        0x1, /* gcFEATURE_BIT_REG_TwoStencilReference */
+        0x1, /* gcFEATURE_BIT_REG_ExtendedPixelFormat */
+        0x1, /* gcFEATURE_BIT_REG_CorrectMinMaxDepth */
+        0x1, /* gcFEATURE_BIT_REG_DitherAndFilterPlusAlpha2D */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes5 */
+        0x0, /* gcFEATURE_BIT_REG_New2D */
+        0x1, /* gcFEATURE_BIT_REG_NewFloatingPointArithmetic */
+        0x1, /* gcFEATURE_BIT_REG_TextureHorizontalAlignmentSelect */
+        0x1, /* gcFEATURE_BIT_REG_NonPowerOfTwo */
+        0x1, /* gcFEATURE_BIT_REG_LinearTextureSupport */
+        0x1, /* gcFEATURE_BIT_REG_Halti0 */
+        0x0, /* gcFEATURE_BIT_REG_CorrectOverflowVG */
+        0x1, /* gcFEATURE_BIT_REG_NegativeLogFix */
+        0x1, /* gcFEATURE_BIT_REG_ResolveOffset */
+        0x1, /* gcFEATURE_BIT_REG_OkToGateAxiClock */
+        0x1, /* gcFEATURE_BIT_REG_MMU */
+        0x1, /* gcFEATURE_BIT_REG_WideLine */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes6 */
+        0x1, /* gcFEATURE_BIT_REG_FcFlushStall */
+        0x1, /* gcFEATURE_BIT_REG_LineLoop */
+        0x1, /* gcFEATURE_BIT_REG_LogicOp */
+        0x1, /* gcFEATURE_BIT_REG_SeamlessCubeMap */
+        0x1, /* gcFEATURE_BIT_REG_SuperTiledTexture */
+        0x1, /* gcFEATURE_BIT_REG_LinearPE */
+        0x1, /* gcFEATURE_BIT_REG_RectPrimitive */
+        0x0, /* gcFEATURE_BIT_REG_Composition */
+        0x1, /* gcFEATURE_BIT_REG_CorrectAutoDisableCountWidth */
+        0x1, /* gcFEATURE_BIT_REG_PESwizzle */
+        0x1, /* gcFEATURE_BIT_REG_EndEvent */
+        0x1, /* gcFEATURE_BIT_REG_S1S8 */
+        0x1, /* gcFEATURE_BIT_REG_Halti1 */
+        0x0, /* gcFEATURE_BIT_REG_RGB888 */
+        0x1, /* gcFEATURE_BIT_REG_TX_YUVAssembler */
+        0x1, /* gcFEATURE_BIT_REG_DynamicFrequencyScaling */
+        0x0, /* gcFEATURE_BIT_REG_TXFilter */
+        0x1, /* gcFEATURE_BIT_REG_FullDirectFB */
+        0x0, /* gcFEATURE_BIT_REG_OnePass2DFilter */
+        0x1, /* gcFEATURE_BIT_REG_ThreadWalkerInPS */
+        0x1, /* gcFEATURE_BIT_REG_TileFiller */
+        0x1, /* gcFEATURE_BIT_REG_YUVStandard */
+        0x0, /* gcFEATURE_BIT_REG_MultiSourceBlt */
+        0x0, /* gcFEATURE_BIT_REG_YUVConversion */
+        0x1, /* gcFEATURE_BIT_REG_FlushFixed2D */
+        0x1, /* gcFEATURE_BIT_REG_Interleaver */
+        0x1, /* gcFEATURE_BIT_REG_MixedStreams */
+        0x0, /* gcFEATURE_BIT_REG_L2CacheFor2D420 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes7 */
+        0x0, /* gcFEATURE_BIT_REG_NoIndexPattern */
+        0x1, /* gcFEATURE_BIT_REG_TextureTileStatus */
+        0x1, /* gcFEATURE_BIT_REG_DecompressZ16 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes8 */
+        0x1, /* gcFEATURE_BIT_REG_DERotationStallFix */
+        0x0, /* gcFEATURE_BIT_REG_OclOnly */
+        0x1, /* gcFEATURE_BIT_REG_NewFeatures0 */
+        0x1, /* gcFEATURE_BIT_REG_InstructionCache */
+        0x0, /* gcFEATURE_BIT_REG_GeometryShader */
+        0x1, /* gcFEATURE_BIT_REG_TexCompressionSupertiled */
+        0x1, /* gcFEATURE_BIT_REG_Generics */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes9 */
+        0x0, /* gcFEATURE_BIT_REG_FastMSAA */
+        0x0, /* gcFEATURE_BIT_REG_WClip */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes10 */
+        0x1, /* gcFEATURE_BIT_REG_UnifiedSamplers */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes11 */
+        0x1, /* gcFEATURE_BIT_REG_PerformanceCounters */
+        0x1, /* gcFEATURE_BIT_REG_ExtraShaderInstructions2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes12 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes13 */
+        0x1, /* gcFEATURE_BIT_REG_DEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_ACE */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_DEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes14 */
+        0x0, /* gcFEATURE_BIT_REG_PowerOptimizations0 */
+        0x1, /* gcFEATURE_BIT_REG_NewHZ */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes15 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_FEEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_PAEnhancements1 */
+        0x0, /* gcFEATURE_BIT_REG_DENoGamma */
+        0x0, /* gcFEATURE_BIT_REG_PAEnhancements2 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_PEEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_HIEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements5 */
+        0x1, /* gcFEATURE_BIT_REG_FEEnhancements2 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes16 */
+        0x0, /* gcFEATURE_BIT_REG_DEEnhancements5 */
+        0x1, /* gcFEATURE_BIT_REG_TXEnhancements4 */
+        0x0, /* gcFEATURE_BIT_REG_PEEnhancements4 */
+        0x1, /* gcFEATURE_BIT_REG_MCEnhancements1 */
+        0x1, /* gcFEATURE_BIT_REG_Halti2 */
+        0x0, /* gcFEATURE_BIT_REG_DEMirrorRotate */
+        0x1, /* gcFEATURE_BIT_REG_SmallMSAA */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes17 */
+        0x0, /* gcFEATURE_BIT_REG_Rasterizer2 */
+        0x0, /* gcFEATURE_BIT_REG_DualPipeOPF */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV2 */
+        0x0, /* gcFEATURE_BIT_REG_CSCV2 */
+        0x1, /* gcFEATURE_BIT_REG_PAEnhancements3 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes18 */
+        0x0, /* gcFEATURE_BIT_REG_Compression2D */
+        0x0, /* gcFEATURE_BIT_REG_Probe */
+        0x1, /* gcFEATURE_BIT_REG_MediumPrecision */
+        0x0, /* gcFEATURE_BIT_REG_DESupertile */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes19 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements6 */
+        0x1, /* gcFEATURE_BIT_REG_SHEnhancements7 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes20 */
+        0x0, /* gcFEATURE_BIT_REG_DEAddress40 */
+        0x0, /* gcFEATURE_BIT_REG_MiniMMUFix */
+        0x1, /* gcFEATURE_BIT_REG_EEZ */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes21 */
+        0x0, /* gcFEATURE_BIT_REG_ExtraVgCaps */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV15 */
+        0x1, /* gcFEATURE_BIT_REG_BugFixes22 */
+        0x1, /* gcFEATURE_BIT_REG_Halti3 */
+        0x0, /* gcFEATURE_BIT_REG_TessellationShaders */
+        0x0, /* gcFEATURE_BIT_REG_OPF9Tap */
+        0x0, /* gcFEATURE_BIT_REG_MultiSrcV2StrQuad */
+        0x0, /* gcFEATURE_BIT_REG_SeperateSRCAndDstCache */
+        0x1, /* gcFEATURE_BIT_REG_Halti4 */
+        0x1, /* gcFEATURE_BIT_REG_RAWriteDepth */
+        0x0, /* gcFEATURE_BIT_REG_AndroidOnly */
+        0x1, /* gcFEATURE_BIT_REG_HasChipProductReg */
+        0x0, /* gcFEATURE_BIT_REG_TXSupportDEC */
+        0x1, /* gcFEATURE_BIT_REG_S8MSAACompression */
+        0x1, /* gcFEATURE_BIT_REG_BugFixesIn544 */
+        0x0, /* gcFEATURE_BIT_REG_L2CacheRemove */
+        0x1, /* gcFEATURE_BIT_REG_FEAllowRndVtxCnt */
+        0x0, /* gcFEATURE_BIT_REG_CubeMapFL28 */
+        0x1, /* gcFEATURE_BIT_REG_TX6bitFrac */
+        0x1, /* gcFEATURE_BIT_REG_FEAllowStallPrefetchEng */
+        0x0, /* gcFEATURE_BIT_REG_ThirdPartyCompression */
+        0x1, /* gcFEATURE_BIT_REG_RSS8 */
+        0x1, /* gcFEATURE_BIT_REG_MSAACoherencyCheck */
+        0x1, /* gcFEATURE_BIT_REG_Halti5 */
+        0x1, /* gcFEATURE_BIT_REG_Evis */
+        0x0, /* gcFEATURE_BIT_REG_BltEngine */
+        0x0, /* gcFEATURE_BIT_REG_BugFixes23 */
+        0x0, /* gcFEATURE_BIT_REG_BugFixes24 */
+        0x0, /* gcFEATURE_BIT_REG_DEC */
+        0x0, /* gcFEATURE_BIT_REG_VSTileNV12 */
+        0x0, /* gcFEATURE_BIT_REG_VSTileNV12_10BIT */
+        0x0, /* gcFEATURE_BIT_REG_DisableVIP */
+        0x0, /* gcFEATURE_BIT_RenderTarget8 */
+        0x0, /* gcFEATURE_BIT_TxLodFlowCorrection */
+        0x0, /* gcFEATURE_BIT_FaceLod */
+        0x0, /* gcFEATURE_BIT_MultiCoreSemaphoreStallV2 */
+        0x1, /* gcFEATURE_BIT_VMSAA */
+        0x0, /* gcFEATURE_BIT_ChipEnableLink */
+        0x0, /* gcFEATURE_BIT_MULTI_SRC_BLT_1_5_ENHANCEMENT */
+        0x0, /* gcFEATURE_BIT_MULTI_SRC_BLT_BILINEAR_FILTER */
+        0x1, /* gcFEATURE_BIT_RA_HZEZ_CLOCK_CONTROL */
+        0x1, /* gcFEATURE_BIT_CACHE128B256BPERLINE */
+        0x1, /* gcFEATURE_BIT_V4Compression */
+        0x0, /* gcFEATURE_BIT_DE2D_MAJOR_SUPER_TILE */
+        0x0, /* gcFEATURE_BIT_PE2D_MAJOR_SUPER_TILE */
+        0x1, /* gcFEATURE_BIT_PE_32BPC_COLORMASK_FIX */
+        0x1, /* gcFEATURE_BIT_ALPHA_BLENDING_OPT */
+        0x1, /* gcFEATURE_BIT_NEW_GPIPE */
+        0x0, /* gcFEATURE_BIT_PIPELINE_32_ATTRIBUTES */
+        0x0, /* gcFEATURE_BIT_MSAA_SHADING */
+        0x0, /* gcFEATURE_BIT_NO_ANISTRO_FILTER */
+        0x1, /* gcFEATURE_BIT_NO_ASTC */
+        0x0, /* gcFEATURE_BIT_NO_DXT */
+        0x0, /* gcFEATURE_BIT_HWTFB */
+        0x1, /* gcFEATURE_BIT_RA_DEPTH_WRITE_MSAA1X_FIX */
+        0x1, /* gcFEATURE_BIT_EZHZ_CLOCKGATE_FIX */
+        0x1, /* gcFEATURE_BIT_SH_SNAP2PAGE_FIX */
+        0x1, /* gcFEATURE_BIT_SH_HALFDEPENDENCY_FIX */
+        0x1, /* gcFEATURE_BIT_USC_MCFILL_FIX */
+        0x1, /* gcFEATURE_BIT_TPG_TCPERF_FIX */
+        0x1, /* gcFEATURE_BIT_USC_MDFIFO_OVERFLOW_FIX */
+        0x1, /* gcFEATURE_BIT_SH_TEXLD_BARRIER_IN_CS_FIX */
+        0x1, /* gcFEATURE_BIT_RS_NEW_BASEADDR */
+        0x1, /* gcFEATURE_BIT_PE_8bpp_DUALPIPE_FIX */
+        0x0, /* gcFEATURE_BIT_SH_ADVANCED_INSTR */
+        0x1, /* gcFEATURE_BIT_SH_FLAT_INTERPOLATION_DUAL16_FIX */
+        0x1, /* gcFEATURE_BIT_USC_CONTINUOUS_FLUS_FIX */
+        0x0, /* gcFEATURE_BIT_SH_SUPPORT_V4 */
+        0x0, /* gcFEATURE_BIT_SH_SUPPORT_ALPHA_KILL */
+        0x1, /* gcFEATURE_BIT_PE_NO_ALPHA_TEST */
+        0x0, /* gcFEATURE_BIT_TX_LOD_NEAREST_SELECT */
+        0x1, /* gcFEATURE_BIT_SH_FIX_LDEXP */
+        0x1, /* gcFEATURE_BIT_SUPPORT_MOVAI */
+        0x1, /* gcFEATURE_BIT_SH_SNAP2PAGE_MAXPAGES_FIX */
+        0x1, /* gcFEATURE_BIT_PE_RGBA16I_FIX */
+        0x1, /* gcFEATURE_BIT_BLT_8bpp_256TILE_FC_FIX */
+        0x1, /* gcFEATURE_BIT_PE_64bit_FENCE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_FULL_CACHE_FIX */
+        0x1, /* gcFEATURE_BIT_TX_YUV_ASSEMBLER_10BIT */
+        0x1, /* gcFEATURE_BIT_FE_32bit_INDEX_FIX */
+        0x1, /* gcFEATURE_BIT_BLT_64bpp_MASKED_CLEAR_FIX */
+        0x1, /* gcFEATURE_BIT_SECURITY */
+        0x1, /* gcFEATURE_BIT_ROBUSTNESS */
+        0x1, /* gcFEATURE_BIT_USC_ATOMIC_FIX */
+        0x1, /* gcFEATURE_BIT_SH_PSO_MSAA1x_FIX */
+        0x1, /* gcFEATURE_BIT_USC_VX_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_USC_GOS_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_TX_8bit_UVFrac */
+        0x1, /* gcFEATURE_BIT_TX_DESC_CACHE_CLOCKGATE_FIX */
+        0x1, /* gcFEATURE_BIT_RSBLT_MSAA_DECOMPRESSION */
+        0x0, /* gcFEATURE_BIT_TX_INTEGER_COORDINATE */
+        0x1, /* gcFEATURE_BIT_DRAWID */
+        0x1, /* gcFEATURE_BIT_PSIO_SAMPLEMASK_IN_R0ZW_FIX */
+        0x1, /* gcFEATURE_BIT_TX_INTEGER_COORDINATE_V2 */
+        0x0, /* gcFEATURE_BIT_MULTI_CORE_BLOCK_SET_CONFIG */
+        0x0, /* gcFEATURE_BIT_SNAPPAGE_CMD */
+        0x1, /* gcFEATURE_BIT_SH_NO_INDEX_CONST_ON_A0 */
+        0x1, /* gcFEATURE_BIT_SH_NO_ONECONST_LIMIT */
+        0x1, /* gcFEATURE_BIT_SH_IMG_LDST_ON_TEMP */
+        0x1, /* gcFEATURE_BIT_COMPUTE_ONLY */
+        0x1, /* gcFEATURE_BIT_SH_IMG_LDST_CLAMP */
+        0x1, /* gcFEATURE_BIT_SH_ICACHE_ALLOC_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_ICACHE_PREFETCH */
+        0x0, /* gcFEATURE_BIT_PE2D_SEPARATE_CACHE */
+        0x1, /* gcFEATURE_BIT_PE_MSAA_OQ_FIX */
+        0x1, /* gcFEATURE_BIT_PSIO_MSAA_CL_FIX */
+        0x1, /* gcFEATURE_BIT_USC_DEFER_FILL_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATE_FIX */
+        0x0, /* gcFEATURE_BIT_FE_NEED_DUMMYDRAW */
+        0x0, /* gcFEATURE_BIT_PE2D_LINEAR_YUV420_OUTPUT */
+        0x0, /* gcFEATURE_BIT_PE2D_LINEAR_YUV420_10BIT */
+        0x0, /* gcFEATURE_BIT_MULTI_CLUSTER */
+        0x0, /* gcFEATURE_BIT_SH_MULTI_WG_PACK */
+        0x0, /* gcFEATURE_BIT_SH_DUAL16_SAMPLEMASK_ZW */
+        0x0, /* gcFEATURE_BIT_TPG_TRIVIAL_MODE_FIX */
+        0x0, /* gcFEATURE_BIT_TX_ASTC_MULTISLICE_FIX */
+        0x0, /* gcFEATURE_BIT_FE_ROBUST_FIX */
+        0x0, /* gcFEATURE_BIT_SH_GPIPE_ACCESS_FULLTEMPS */
+        0x0, /* gcFEATURE_BIT_PSIO_INTERLOCK */
+        0x1, /* gcFEATURE_BIT_PA_WIDELINE_FIX */
+        0x0, /* gcFEATURE_BIT_WIDELINE_HELPER_FIX */
+        0x0, /* gcFEATURE_BIT_G2D_3rd_PARTY_COMPRESSION_1_1 */
+        0x0, /* gcFEATURE_BIT_TX_FLUSH_L1CACHE */
+        0x1, /* gcFEATURE_BIT_PE_DITHER_FIX2 */
+        0x0, /* gcFEATURE_BIT_SH_TEXLD_U_FIX */
+        0x0, /* gcFEATURE_BIT_MC_FCCACHE_BYTEMASK */
+        0x0, /* gcFEATURE_BIT_SH_MULTI_WG_PACK_FIX */
+        0x0, /* gcFEATURE_BIT_PE_ADVANCE_BLEND_PART0 */
+        0x0, /* gcFEATURE_BIT_FE_PATCHLIST_FETCH_FIX */
+        0x1, /* gcFEATURE_BIT_RA_CG_FIX */
+        0x0, /* gcFEATURE_BIT_DEC400 */
+        0x0, /* gcFEATURE_BIT_LS_SUPPORT_PERCOMP_DEPENDENCY */
+        0x0, /* gcFEATURE_BIT_MULTI_CORE_BLOCK_SET_CONFIG2 */
+        0x0, /* gcFEATURE_BIT_PE_VMSAA_COVERAGE_CACHE_FIX */
+        0x1, /* gcFEATURE_BIT_SECURITY_AHB */
+        0x0, /* gcFEATURE_BIT_MULTICORE_SEMAPHORESTALL_V3 */
+        0x0, /* gcFEATURE_BIT_SMALLBATCH */
+        0x0, /* gcFEATURE_BIT_SH_CMPLX */
+        0x0, /* gcFEATURE_BIT_SH_IDIV0_SWZL_EHS */
+        0x0, /* gcFEATURE_BIT_TX_LERP_LESS_BIT */
+        0x0, /* gcFEATURE_BIT_SH_GM_ENDIAN */
+        0x0, /* gcFEATURE_BIT_SH_GM_USC_UNALLOC */
+        0x0, /* gcFEATURE_BIT_SH_END_OF_BB */
+        0x0, /* gcFEATURE_BIT_TX_BORDER_CLAMP_FIX */
+        0x0, /* gcFEATURE_BIT_SH_IMG_LD_LASTPIXEL_FIX */
+        0x0, /* gcFEATURE_BIT_ASYNC_BLT */
+        0x0, /* gcFEATURE_BIT_ASYNC_FE_FENCE_FIX */
+        0x1, /* gcFEATURE_BIT_PSCS_THROTTLE */
+        0x0, /* gcFEATURE_BIT_SEPARATE_LS */
+        0x0, /* gcFEATURE_BIT_WIDELINE_TRIANGLE_EMU */
+        0x0, /* gcFEATURE_BIT_FENCE_32BIT */
+        0x0, /* gcFEATURE_BIT_FENCE_64BIT */
+        0x0, /* gcFEATURE_BIT_PE_DEPTH_ONLY_OQFIX */
+        0x0, /* gcFEATURE_BIT_TX_SEAMLESS_CUBE */
+        0x0, /* gcFEATURE_BIT_TX_SNORM_SUPPORT */
+        0x0, /* gcFEATURE_BIT_SH_SCATTER_GATHER */
+        0x0, /* gcFEATURE_BIT_HWMANAGED_LS */
+        0x0, /* gcFEATURE_BIT_SH_IMAGE_ENABLE_FIX */
+        0x1, /* gcFEATURE_BIT_MSAA_FRAGMENT_OPERATION */
+        0x0, /* gcFEATURE_BIT_PE_TILE_CACHE_FLUSH_FIX */
+        0x0, /* gcFEATURE_BIT_BLT_YUV_OUTPUT */
+        0x1, /* gcFEATURE_BIT_SH_IO_CG_FIX */
+        0x0, /* gcFEATURE_BIT_PE_SWIZZLE */
+        0x0, /* gcFEATURE_BIT_SH_ROBUSTNESS_FIX */
+        0x0, /* gcFEATURE_BIT_USC_ATOMIC_FIX2 */
+        0x0, /* gcFEATURE_BIT_PE_A8B8G8R8 */
+        0x0, /* gcFEATURE_BIT_MULTIVIEW_RENDER */
+        0x0, /* gcFEATURE_BIT_FE_DRAW_DIRECT */
+        0x0, /* gcFEATURE_BIT_TX_VKBORDER_MODE */
+        0x0, /* gcFEATURE_BIT_TX_UNNORMALIZED_COORD */
+        0x0, /* gcFEATURE_BIT_PA_LINECLIP_FIX */
+        0x0, /* gcFEATURE_BIT_TX_8bit_UVFrac_ROUNDING_FIX */
+        0x0, /* gcFEATURE_BIT_MP_ARCH */
+        0x0, /* gcFEATURE_BIT_TX_NO_FIXED_FILTER */
+        0x0, /* gcFEATURE_BIT_SHARE_Z */
+        0x0, /* gcFEATURE_BIT_DE_2D_FAST_CLEAR */
+        0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
+        0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
+        0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
+        0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
+        0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
+        0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
+        0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
+        0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
+        0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
+        0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
+        0x0, /* gcFEATURE_BIT_MSAA_FLOAT_64BIT */
+        0x0, /* gcFEATURE_BIT_INDIRECT_COMPUTE_ZERODIM_FIX */
+        0x0, /* gcFEATURE_BIT_Q_CHANNEL_SUPPORT */
+        0x0, /* gcFEATURE_BIT_MMU_PAGE_DESCRIPTOR */
+        0x0, /* gcFEATURE_BIT_YUV_LINEAR_TO_TILE_ROTATE */
+        0x0, /* gcFEATURE_BIT_VEC2_IMULIMAD32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_VEC4_IMULIMAD32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_VEC2_IDIVIMOD16_SUPPORT */
+        0x0, /* gcFEATURE_BIT_DST_TEX_I2F_F2I_INST_DEPRECATE */
+        0x0, /* gcFEATURE_BIT_ALU_FP16_INSTRUCTIONS */
+        0x0, /* gcFEATURE_BIT_DUAL16_14BIT_PC_SUPPORT */
+        0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
+        0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
+        0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
+        0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
+        0x0, /* gcFEATURE_BIT_VG_FP25 */
+        0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
+        0x0, /* gcFEATURE_BIT_VG_DOUBLE_IMAGE */
+        0x0, /* gcFEATURE_BIT_VG_RECTANGLE_STRIPE_MODE */
+        0x0, /* gcFEATURE_BIT_VG_MMU */
+        0x0, /* gcFEATURE_BIT_VG_IM_FILTER */
+        0x0, /* gcFEATURE_BIT_VG_IM_YUV_PACKET */
+        0x0, /* gcFEATURE_BIT_VG_IM_YUV_PLANAR */
+        0x0, /* gcFEATURE_BIT_VG_PE_YUV_PACKET */
+        0x0, /* gcFEATURE_BIT_VG_COLOR_PRECISION_8_BIT */
+        0x0, /* gcFEATURE_BIT_VG_RESOLVE_ENGINE */
+        0x0, /* gcFEATURE_BIT_VG_PE_COLOR_KEY */
+        0x0, /* gcFEATURE_BIT_VG_IM_INDEX_FORMAT */
+        0x0, /* gcFEATURE_BIT_VG_RESOLUTION_8K */
+        0x0, /* gcFEATURE_BIT_VG_IMAGE_16K */
+        0x0, /* gcFEATURE_BIT_VG_FORMAT_ARGB2222 */
+        0x0, /* gcFEATURE_BIT_G2D_DEC400 */
+        0x0, /* gcFEATURE_BIT_DC_OVERLAY_SCALING */
+        0x0, /* gcFEATURE_BIT_DC_SOURCE_ROTATION */
+        0x0, /* gcFEATURE_BIT_DC_TILED */
+        0x0, /* gcFEATURE_BIT_DC_YUV_L1 */
+        0x0, /* gcFEATURE_BIT_DC_D30_OUTPUT */
+        0x0, /* gcFEATURE_BIT_DC_MMU */
+        0x0, /* gcFEATURE_BIT_DC_COMPRESSION */
+        0x0, /* gcFEATURE_BIT_DC_QOS */
+        0x1, /* gcFEATURE_BIT_VIP_HW_FINAL_RELEASE */
+        0x1, /* gcFEATURE_BIT_NN_SINGLEPORT_ACCUMBUFFER */
+        0x1, /* gcFEATURE_BIT_NN_STRIDE_SUPPORT */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE1 */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE2 */
+        0x0, /* gcFEATURE_BIT_TP_SIMPLE_INT16 */
+        0x1, /* gcFEATURE_BIT_TP_REAL_INT16 */
+        0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
+        0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
+        0x1, /* gcFEATURE_BIT_TP_LRN */
+        0x1, /* gcFEATURE_BIT_TP_REORDER */
+        0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
+        0x1, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
+        0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
+        0x0, /* gcFEATURE_BIT_AI_GPU */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_ABSDIFF */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_BITREPLACE */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_BOXFILTER */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_CORDIAC */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_DP32 */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_FILTER */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_IADD */
+        0x0, /* gcFEATURE_BIT_EVIS_NO_SELECTADD */
+        0x0, /* gcFEATURE_BIT_EVIS_LERP_7OUTPUT */
+        0x0, /* gcFEATURE_BIT_EVIS_ACCSQ_8OUTPUT */
+        0x1, /* gcFEATURE_BIT_EVIS_VX2 */
+        0x1, /* gcFEATURE_BIT_TP_ENGINE */
+        0x1, /* gcFEATURE_BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_TENSOR_ADD_MUL */
+        0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_INT16XINT8 */
+        0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_8BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_SOFTMAX */
+        0x0, /* gcFEATURE_BIT_NN_23BITS_POST_MULTIPLIER_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_TP_23BITS_POST_MULTIPLIER_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_CONV_INT16X8BIT_VIP_V7 */
+        0x0, /* gcFEATURE_BIT_NN_REMOVE_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_40BIT_BIAS */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_USC */
+        0x0, /* gcFEATURE_BIT_NN_ZDP6 */
+        0x0, /* gcFEATURE_BIT_NN_XYDP9 */
+        0x1, /* gcFEATURE_BIT_NN_FIRST_PIXEL_POOLING */
+        0x1, /* gcFEATURE_BIT_NN_ZDP3 */
+        0x0, /* gcFEATURE_BIT_NN_XYDP6 */
+        0x1, /* gcFEATURE_BIT_SWTILING_PHASE3 */
+        0x0, /* gcFEATURE_BIT_MCFE */
+        0x0, /* gcFEATURE_BIT_USC_STAY_LRU */
+        0x1, /* gcFEATURE_BIT_COEF_COMPRESSION_ENHANCEMENT */
+        0x1, /* gcFEATURE_BIT_TP_COEF_COMPRESSION_ENHANCEMENT */
+        0x1, /* gcFEATURE_BIT_NN_COEF_DECOMPRESS_PERF2X */
+        0x1, /* gcFEATURE_BIT_TP_SMALLBATCH_PHASE1 */
+        0x1, /* gcFEATURE_BIT_OCB_COUNTER */
+        0x0, /* gcFEATURE_BIT_SCALER */
+        0x0, /* gcFEATURE_BIT_SCALER_4K */
+        0x0, /* gcFEATURE_BIT_INPUT_4BIT */
+        0x1, /* gcFEATURE_BIT_NN_NO_Z_LOCATION_OFFSET */
+        0x1, /* gcFEATURE_BIT_OCB_REMAP_PHYSICAL_ADDRESS */
+        0x1, /* gcFEATURE_BIT_NN_SLOW_OUTPUT */
+        0x1, /* gcFEATURE_BIT_NO_NARROW_POST_PROCESS_PIPE */
+        0x1, /* gcFEATURE_BIT_TP_NN_PROBE */
+        0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_SUPPORT */
+        0x1, /* gcFEATURE_BIT_NN_XYDP0 */
+        0x1, /* gcFEATURE_BIT_NN_WRITE_WITHOUT_USC */
+        0x1, /* gcFEATURE_BIT_NN_HW_LIMITATION_NATIVE_KER_1x2_2x1 */
+        0x1, /* gcFEATURE_BIT_NN_SMALLBATCH_PHASE1 */
+        0x1, /* gcFEATURE_BIT_NN_SLICE_PADDING_TO_64BYTE_ALIGN */
+        0x0, /* gcFEATURE_BIT_NN_DW_1x1_CONV_MERGE */
+        0x1, /* gcFEATURE_BIT_TP_BFLOAT16 */
+        0x0, /* gcFEATURE_BIT_TP_23BITS_POST_MULTIPLIER */
+        0x1, /* gcFEATURE_BIT_NN_TRANSPOSE */
+        0x0, /* gcFEATURE_BIT_NN_ZDP_TRANSPOSE_CH9_ONLY */
+        0x1, /* gcFEATURE_BIT_USE_SINGLE_PORT_VIPSRAM */
+        0x1, /* gcFEATURE_BIT_NN_LEAKY_RELU */
+        0x1, /* gcFEATURE_BIT_NN_PRELU */
+        0x1, /* gcFEATURE_BIT_NN_PER_CHANNEL_QUANT */
+        0x1, /* gcFEATURE_BIT_NN_PER_CHANNEL_QUANT_ASYM */
+        0x1, /* gcFEATURE_BIT_NN_ASYMMETRIC_INT8 */
+        0x1, /* gcFEATURE_BIT_NN_FLOAT_POST_MULT */
+        0x1, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
+        0x1, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
+        0x1, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x1, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
+        0x1, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
+        0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
+        0x1, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
+        0x0, /* gcFEATURE_BIT_TP_3_USC */
+        0x1, /* gcFEATURE_BIT_BFP_COEF_AUTO_PAD_INCOMPLETE_ZERO_IN_KZ_PLANE */
+        0x1, /* gcFEATURE_BIT_NN_NATIVE_STRIDE_TWO */
+        0x1, /* gcFEATURE_BIT_NN_TENSOR_ADD */
+        0x0, /* gcFEATURE_BIT_NN_FLOAT32_IO */
+        0x1, /* gcFEATURE_BIT_TP_FLOAT32_IO */
+        0x0, /* gcFEATURE_BIT_NN_SMALL_BATCH_PHASE2 */
+        0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
+        0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
+        0x1, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
+        0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
+        0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
+        0x1, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
+        0x1, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
+        0x1, /* gcFEATURE_BIT_NN_SUPPORT_DUMMY_TILE */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_KERNEL_1BYTE_ALIGN */
+        0x1, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
+        0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
+        0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
+        0x0, /* gcFEATURE_BIT_NN_JOB_CANCELATION */
+        0x0, /* gcFEATURE_BIT_NN_DISTRIBUTED_VIPSRAM */
+        0x0, /* gcFEATURE_BIT_NN_FC_ENHANCEMENT */
+        0x0, /* gcFEATURE_BIT_VIP_DEC400 */
+        0x1, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_REQ_SLOWARBITRATION_FIX */
+        0x0, /* gcFEATURE_BIT_IMAGE_PARTIAL_CACHE_FIX */
+        0x0, /* gcFEATURE_BIT_FULLCACHE_KERNELHEAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
+        0x1, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
+        0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
+        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
+        0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
+        0x1, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
+        0x1, /* gcFEATURE_BIT_COEF_DELTA_CORD_OVERFLOW_ZRL_8BIT_FIX */
+        0x1, /* gcFEATURE_BIT_USC_INDIVIDUAL_PORT_WRT_EARLY_EVICT_DATA_CORRUPT_FIX */
+        0x1, /* gcFEATURE_BIT_LOW_EFFICIENCY_OF_ID_WRITE_IMGBUF_FIX */
+        0x1, /* gcFEATURE_BIT_KERNEL_VIP_SRAM_READ_BW_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_USC_BOTTLENECK_FIX */
+        0x0, /* gcFEATURE_BIT_KERNEL_PER_CORE_LESS_THAN_THIRD_COEF_BUFF_DEPTH_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_NUM_BIGGER_THAN_1024_FIX */
+        0x1, /* gcFEATURE_BIT_KERNEL_SIZE_WASTE_IN_PARTIAL_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_COMMAND_KERNEL_REQUEST_CONFICT_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
+        0x1, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
+        0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
+        0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
+        0x1, /* gcFEATURE_BIT_IMG_CAHCE_MODE_MUST_0_IN_IMG_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
+        0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
+        0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
+        0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
+        0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
+        0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
+        0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x0, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x0, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x0, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
+        0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
+        0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
+        0x1, /* gcFEATURE_BIT_NN_INT8_SCALE */
+        0x1, /* gcFEATURE_BIT_NN_POWER_ISOLATION */
+        0x0, /* gcFEATURE_BIT_ZRL_7BIT */
+        0x0, /* gcFEATURE_BIT_NN_SMALLBATCH */
+        0x0, /* gcFEATURE_BIT_TP_SMALLBATCH */
+        0x1, /* gcFEATURE_BIT_ZRL_8BIT */
+        0x0, /* gcFEATURE_BIT_DDR_BURST_LEN_256B */
+        0x1, /* gcFEATURE_BIT_XY_OFFSET_LIMITATION_FIX */
+        0x0, /* gcFEATURE_BIT_NN_NONZERO_MIRROR_BORDER */
+        0x1, /* gcFEATURE_BIT_IMAGE_PARTIAL_CACHE */
+    },
     /* vipnano-qi */
     {
         0x8000, /* ChipID */
         0x7004, /* ChipRevision */
         0x45080009, /* ProductID */
-        0x1, /* EcoID */
+        0x0, /* EcoID */
         0x7d, /* CustomerID */
         0x0, /* PatchVersion */
         "", /* ProductName */
@@ -806,8 +1577,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -834,8 +1607,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x5, /* gcFEATURE_VALUE_NN_ZRL_BITS */
         0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
         0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
         0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
         0x7, /* gcFEATURE_VALUE_NN_X_OFFSET */
@@ -853,6 +1626,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -1236,6 +2011,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -1253,6 +2029,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -1289,7 +2072,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
         0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
         0x1, /* gcFEATURE_BIT_TP_LRN */
-        0x1, /* gcFEATURE_BIT_TP_REORDER */
+        0x0, /* gcFEATURE_BIT_TP_REORDER */
         0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
         0x0, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
         0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
@@ -1359,6 +2142,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -1372,10 +2158,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -1384,6 +2172,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -1394,13 +2184,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
         0x0, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
-        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_TP_REORDER_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
         0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
         0x0, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
-        0x0, /* gcFEATURE_BIT_HI_REORDER_FIX */
-        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
         0x0, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
         0x0, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
@@ -1410,7 +2200,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
         0x0, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
         0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
-        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x0, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
         0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
         0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
         0x0, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
@@ -1426,7 +2216,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -1441,15 +2231,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -1469,7 +2275,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x8000, /* ChipID */
         0x7004, /* ChipRevision */
         0x45080009, /* ProductID */
-        0x0, /* EcoID */
+        0x1, /* EcoID */
         0x7d, /* CustomerID */
         0x0, /* PatchVersion */
         "", /* ProductName */
@@ -1507,8 +2313,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -1554,6 +2362,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -1937,6 +2747,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -1954,6 +2765,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -1990,7 +2808,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_TP_ROI_POOLING */
         0x1, /* gcFEATURE_BIT_TP_MAX_POOLING_STRIDE1 */
         0x1, /* gcFEATURE_BIT_TP_LRN */
-        0x0, /* gcFEATURE_BIT_TP_REORDER */
+        0x1, /* gcFEATURE_BIT_TP_REORDER */
         0x1, /* gcFEATURE_BIT_TF_QUANTIZATION */
         0x0, /* gcFEATURE_BIT_NN_NONZERO_BORDER */
         0x0, /* gcFEATURE_BIT_NN_MIRROR_BORDER */
@@ -2060,6 +2878,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -2073,10 +2894,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -2085,6 +2908,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -2095,13 +2920,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_PER3DTILE_BUBBLE_FIX */
         0x0, /* gcFEATURE_BIT_NN_CACHELINE_MODE_PERF_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONV1x1_PERF_FIX */
-        0x0, /* gcFEATURE_BIT_TP_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_TP_REORDER_FIX */
         0x0, /* gcFEATURE_BIT_NN_CONVOUT_FIFO_DEPTH_FIX */
         0x1, /* gcFEATURE_BIT_NN_ZXDP3_KERNEL_READ_CONFLICT_FIX */
         0x0, /* gcFEATURE_BIT_NN_ZDP3_NO_COMPRESS_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_PERF_FIX */
-        0x1, /* gcFEATURE_BIT_HI_REORDER_FIX */
-        0x1, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
+        0x0, /* gcFEATURE_BIT_HI_REORDER_FIX */
+        0x0, /* gcFEATURE_BIT_INCORRECT_WR_REQ_TO_USC_BETWEEN_REORDER_AND_NORMAL_LAYER_FIX */
         0x0, /* gcFEATURE_BIT_TP_REORDER_LAYER_SUSPEND_FIX */
         0x0, /* gcFEATURE_BIT_NN_ASYNC_COPY_MERGE_FIX */
         0x0, /* gcFEATURE_BIT_USC_INVALIDATE_CACHE_LINE_FIX */
@@ -2111,7 +2936,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_ZDP_INIMAGE_SIZE_FIX */
         0x0, /* gcFEATURE_BIT_IDLE_BEFORE_FLUSH_COMPLETE_FIX */
         0x1, /* gcFEATURE_BIT_NO_FLUSH_USC_FIX */
-        0x0, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_SMALL_BATCH_FLOPS_RESET_FIX */
         0x0, /* gcFEATURE_BIT_SMALL_BATCH_DISBLE_FIX */
         0x1, /* gcFEATURE_BIT_OUTPUT_CONVERT_UINT8_INT8_TO_UINT16_INT16_FIX */
         0x0, /* gcFEATURE_BIT_IMAGE_NOT_PACKED_IN_SRAM_FIX */
@@ -2127,7 +2952,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -2142,15 +2967,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x1, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -2208,8 +3049,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -2236,8 +3079,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x5, /* gcFEATURE_VALUE_NN_ZRL_BITS */
         0x80, /* gcFEATURE_VALUE_LATENCY_HIDING_AT_FULL_AXI_BW */
         0x10, /* gcFEATURE_VALUE_AXI_BUS_WIDTH */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
-        0xf, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_X_SIZE */
+        0xb, /* gcFEATURE_VALUE_NN_KERNEL_Y_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_FC_KERNEL_Y_SIZE */
         0xfffff, /* gcFEATURE_VALUE_NN_KERNEL_Z_SIZE */
         0xf, /* gcFEATURE_VALUE_NN_X_OFFSET */
@@ -2255,6 +3098,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -2638,6 +3483,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -2655,6 +3501,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -2761,6 +3614,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -2774,10 +3630,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -2786,6 +3644,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -2828,7 +3688,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x0, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -2843,15 +3703,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x0, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -2909,8 +3785,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x4, /* gcFEATURE_VALUE_NNCoreCount */
+        0x4, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x4, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x4, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -2956,6 +3834,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -3333,12 +4213,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
         0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
         0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
-        0x0, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
         0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
         0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -3356,6 +4237,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -3462,6 +4350,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -3475,10 +4366,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -3487,6 +4380,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -3534,9 +4429,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
         0x0, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
-        0x0, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
-        0x0, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
         0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
         0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
@@ -3544,15 +4439,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x0, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -3610,8 +4521,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -3657,6 +4570,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x3, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -4034,12 +4949,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_DE_TILESTATUS_ROTATION_FIX */
         0x0, /* gcFEATURE_BIT_TX_CLEAR_PENDING_FIX */
         0x0, /* gcFEATURE_BIT_HI1_L2_CACHE */
-        0x0, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_EVICT_CTRL_FIFO_FLOP_RESET_FIX */
         0x0, /* gcFEATURE_BIT_FORMAT_10BIT_CROSS_4K */
         0x0, /* gcFEATURE_BIT_FORMAT_P010LSB_I010 */
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -4057,6 +4973,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -4163,6 +5086,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -4176,10 +5102,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -4188,6 +5116,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -4235,9 +5165,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
         0x0, /* gcFEATURE_BIT_TP_ACCESS_VIPSRAM_OT_IS_ONE_FIX */
-        0x0, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_EVIS2_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_OUTIMAGE_X_BITWIDTH_LIMIT_FOR_NN_TRANSPOSE_FIX */
-        0x0, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
+        0x1, /* gcFEATURE_BIT_USC_ASYNC_CP_RTN_FLOP_RESET_FIX */
         0x1, /* gcFEATURE_BIT_IMG_ADDR_NOT_WRAP_IF_OVER_OCB_ADDR_FIX */
         0x1, /* gcFEATURE_BIT_NEGATIVE_POST_SHIFT_FIX */
         0x1, /* gcFEATURE_BIT_INIMAGE_2DTILE_NOT_LESS_160PIXEL_FIX */
@@ -4245,15 +5175,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x0, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x0, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x0, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x0, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -4311,8 +5257,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x8, /* gcFEATURE_VALUE_NNCoreCount */
+        0x8, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x8, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -4358,6 +5306,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -4741,6 +5691,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -4758,6 +5709,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -4864,6 +5822,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -4877,10 +5838,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -4889,6 +5852,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -4931,7 +5896,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -4946,15 +5911,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x1, /* gcFEATURE_BIT_NN_INT16_ALU */
@@ -5012,8 +5993,10 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x100, /* gcFEATURE_VALUE_RESULT_WINDOW_MAX_SIZE */
         0x0, /* gcFEATURE_VALUE_ClusterAliveMask */
         0x0, /* gcFEATURE_VALUE_G2D_DEC400_MINOR */
+        0x0, /* gcFEATURE_VALUE_PS_INSTRUCTION_COUNT */
         0x40, /* gcFEATURE_VALUE_NNMadPerCore */
         0x2, /* gcFEATURE_VALUE_NNCoreCount */
+        0x2, /* gcFEATURE_VALUE_NN_ACTIVE_CORE_COUNT */
         0x2, /* gcFEATURE_VALUE_NNCoreCount_INT8 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_INT16 */
         0x0, /* gcFEATURE_VALUE_NNCoreCount_FLOAT16 */
@@ -5059,6 +6042,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x40, /* gcFEATURE_VALUE_MAX_TILE_X_SIZE */
         0x1, /* gcFEATURE_VALUE_NN_CLUSTER_NUM_FOR_POWER_CONTROL */
         0x0, /* gcFEATURE_VALUE_NN_IN_LINES_PER_CYCLE */
+        0x1, /* gcFEATURE_VALUE_VIP_CLUSTER_COUNT */
+        0x0, /* gcFEATURE_VALUE_NN_MP_INTER_CONNECT_RING_COUNT */
         0x0, /* gcFEATURE_BIT_REG_FastClear */
         0x0, /* gcFEATURE_BIT_REG_SpecialAntiAliasing */
         0x1, /* gcFEATURE_BIT_REG_Pipe3D */
@@ -5442,6 +6427,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_ENDIAN_CONTROL */
         0x0, /* gcFEATURE_BIT_G2D_RGB_PLANAR */
         0x0, /* gcFEATURE_BIT_G2D_DEC400EX */
+        0x0, /* gcFEATURE_BIT_G2D_NO_YUV420_SOURCE */
         0x0, /* gcFEATURE_BIT_G2D_YUV420_101010 */
         0x0, /* gcFEATURE_BIT_SH_VX2_FLOATING_MAD_FIX */
         0x0, /* gcFEATURE_BIT_TS_FC_VULKAN_SUPPORT */
@@ -5459,6 +6445,13 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_LDST_CONV_4ROUNDING_MODES */
         0x0, /* gcFEATURE_BIT_FULL_PACK_MODE_SUPPORT */
         0x0, /* gcFEATURE_BIT_DEPTH_FLOAT32_SUPPORT */
+        0x0, /* gcFEATURE_BIT_GPU_INSPECTOR_COUNTERS */
+        0x0, /* gcFEATURE_BIT_FP32_TO_FP16_CONV_FIX */
+        0x0, /* gcFEATURE_BIT_IMGLD_COMP_COUNT_FIX */
+        0x1, /* gcFEATURE_BIT_IMGLD_WIDTH_LT16_FIX */
+        0x0, /* gcFEATURE_BIT_TX_FILTER_ROUND_FIX */
+        0x0, /* gcFEATURE_BIT_SH_FP32_FMA_SUPPORT */
+        0x0, /* gcFEATURE_BIT_TX_ETC2_COMPRESSION */
         0x0, /* gcFEATURE_BIT_VG_TS_CULLING */
         0x0, /* gcFEATURE_BIT_VG_FP25 */
         0x0, /* gcFEATURE_BIT_VG_AYUV_INPUT_OUTPUT */
@@ -5565,6 +6558,9 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_PRELU_LEAKLY_RELU_CLAMP */
         0x0, /* gcFEATURE_BIT_TPLITE_BFLOAT16 */
         0x0, /* gcFEATURE_BIT_PREPROCESS_IMG_BUF_640BYTE_LIMIT */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_BF16 */
+        0x0, /* gcFEATURE_BIT_NN_POST_OUT_SUPPORT_FP32 */
         0x0, /* gcFEATURE_BIT_TP_KERNEL_1BYTE_ALGIN */
         0x0, /* gcFEATURE_BIT_BFLOAT_COEF_COMPRESSION_ZERO_COEFBIT14_INVERSE */
         0x0, /* gcFEATURE_BIT_NN_COMPRESSION_BYPASSS */
@@ -5578,10 +6574,12 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TILE_ACCESS_CAPABILITY */
         0x0, /* gcFEATURE_BIT_FAST_DP3_PREPROCESSOR */
         0x0, /* gcFEATURE_BIT_DEPTHWISE_SUPPORT_16BIT_FORMAT */
-        0x0, /* gcFEATURE_BIT_SH_SUPPORT_VEC2 */
-        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU_LUT */
+        0x0, /* gcFEATURE_BIT_NN_SUPPORT_ALU */
         0x0, /* gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING */
         0x0, /* gcFEATURE_BIT_NN_TRANSPOSE_PHASE2 */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD */
+        0x0, /* gcFEATURE_BIT_NN_CONV_CORE_BYPASS */
+        0x0, /* gcFEATURE_BIT_NN_TENSOR_ADD_RELU */
         0x0, /* gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV_1D */
         0x0, /* gcFEATURE_BIT_USE_VIPSRAM_FOR_KERNEL_STREAMING */
@@ -5590,6 +6588,8 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_NN_1x1_NON_POOLING_PACKING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_CONV1x1_AND_NATIVE_CONV_STRIDE2 */
+        0x0, /* gcFEATURE_BIT_TP_REMOVE_FC */
+        0x0, /* gcFEATURE_BIT_VIP_REMOVE_MMU */
         0x0, /* gcFEATURE_BIT_NN_MP_INTER_CONNECT_RING */
         0x0, /* gcFEATURE_BIT_NN_SUPPORT_BATCH */
         0x0, /* gcFEATURE_BIT_NN_2D_AVERAGE_OUTPUT */
@@ -5632,7 +6632,7 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_TP_REORDER_INTILE_X_SIZE_512_FIX */
         0x1, /* gcFEATURE_BIT_IMG_POP_PIPELINE_PAUSE_FIX */
         0x0, /* gcFEATURE_BIT_FULLCACHE_KERNEL_INTERLEAVE_FIX */
-        0x0, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
+        0x1, /* gcFEATURE_BIT_V8_SINGLE_PORT_ACCUMULATION_BUFFER_RW_CONFICT_ZERO_SKIP_PERF_FIX */
         0x0, /* gcFEATURE_BIT_V8_ACCUMLATION_READ_OUT_HAS_BUBBLES_PERF_FIX */
         0x1, /* gcFEATURE_BIT_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX */
         0x1, /* gcFEATURE_BIT_DR_JD_DIFF_CONDITION_FOR_CACHELINE_MODE_PRE_FIX */
@@ -5647,15 +6647,31 @@ static gcsFEATURE_DATABASE gChipInfo[] = {
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_DUMMY_DATA_WASTE_CYCLES_FIX */
         0x1, /* gcFEATURE_BIT_INIMG_NOT_64BYTE_ALIGN_CACHELINE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_FLOAT_LAST_PIXEL_NEGATIVE_0_FIX */
-        0x1, /* gcFEATURE_BIT_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE */
+        0x1, /* gcFEATURE_BIT_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX */
         0x1, /* gcFEATURE_BIT_NN_IN_TILE_DATA_IS_ALL_PAD_FIX */
         0x0, /* gcFEATURE_BIT_NN_TP_INSTR_COMPLETE_IN_SAME_CYCLE_WITH_WAIT_EVENT_FIX */
+        0x1, /* gcFEATURE_BIT_CORE_IMAGE_TRANSER_NOT_EFFICIENT_BETWEEN_PARTITION_FIX */
         0x1, /* gcFEATURE_BIT_TP_FC_KERNEL_STREAM_MUST_LESS_THAN_OR_EQUAL_TO_64BYTE_WHEN_1BYTE_ALGINE_FIX */
         0x0, /* gcFEATURE_BIT_NN_KERNEL_1x1_NO_PAD_FIX */
         0x1, /* gcFEATURE_BIT_NN_DEPTHWISE_AFTER_16BIT_LAYER_LIMIT_FIX */
         0x0, /* gcFEATURE_BIT_TP_NOT_FULL_USE_CACHE_LINE_FIX */
         0x0, /* gcFEATURE_BIT_SH_MOVAI_MOVAR_UNUSED_COMPONENTS_WRITE_DIRTY_DATA_FIX */
         0x0, /* gcFEATURE_BIT_BURST_COLLECT_CONSUMES_MC_DATA_WIDTH_PER_CYCLE_FIX */
+        0x1, /* gcFEATURE_BIT_TP_ASSYM_INT8_FIX */
+        0x1, /* gcFEATURE_BIT_NN_PAD_SLICE_ERROR_WHEN_TRANSPSE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX */
+        0x0, /* gcFEATURE_BIT_NN_TP_SYSTEM_FIX */
+        0x1, /* gcFEATURE_BIT_NN_INTILE_YSIZE_128_LIMIT_FIX */
+        0x1, /* gcFEATURE_BIT_SH_CLOCK_GATOR_IDLE_CONDITON_FIX */
+        0x1, /* gcFEATURE_BIT_NN_BURST_COLLECTER_LAST_FLAG_FIX */
+        0x1, /* gcFEATURE_BIT_NN_2ND_IMG_SMALL_3D_TILE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_TILE_YSIZE_127_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_CONV_1D_16BIT_FORMAT_INTILE_SIZE_LIMITATION_FIX */
+        0x1, /* gcFEATURE_BIT_NN_VIPSRAM_DOUBLE_BUFFER_FIX */
+        0x0, /* gcFEATURE_BIT_NN_JD_DIRECT_MODE_FIX */
+        0x1, /* gcFEATURE_BIT_NN_KERNEL_DIRECT_WRONG_PUSH_FIX */
+        0x1, /* gcFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX */
+        0x1, /* gcFEATURE_BIT_V83_INTILESIZE_1X1_10BITS_FIX */
         0x0, /* gcFEATURE_BIT_NN_INTERLEVE8 */
         0x0, /* gcFEATURE_BIT_NN_FP16_ALU */
         0x0, /* gcFEATURE_BIT_NN_INT16_ALU */
diff --git a/drivers/staging/npu/kernel/inc/gc_hal.h b/drivers/staging/npu/kernel/inc/gc_hal.h
index bf58ba518eeb..59fdff211baf 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -807,7 +807,7 @@ gckOS_Delay(
     IN gctUINT32 Delay
     );
 
-/* Delay a number of microseconds. */
+/* Delay a number of milliseconds. */
 gceSTATUS
 gckOS_Udelay(
     IN gckOS Os,
@@ -1145,6 +1145,14 @@ gckOS_GetPolicyID(
     OUT gctUINT32_PTR AXIConfig
     );
 
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gckOS_SwitchCoreCount(
+    IN gckOS Os,
+    OUT gctUINT32 *Count
+    );
+#endif
+
 /******************************************************************************\
 ************************** Android Native Fence Sync ***************************
 \******************************************************************************/
@@ -2157,7 +2165,10 @@ gceSTATUS
 gckMMU_FillFlatMapping(
     IN gckMMU Mmu,
     IN gctUINT64 PhysBase,
-    IN gctSIZE_T Size
+    IN gctSIZE_T Size,
+    IN gctBOOL   Reserved,
+    IN gctBOOL   AbleToShift,
+    OUT gctUINT32 *GpuBaseAddress
     );
 
 gceSTATUS
@@ -2180,15 +2191,13 @@ gceSTATUS
 gckHARDWARE_QueryContextProfile(
     IN gckHARDWARE Hardware,
     IN gctBOOL Reset,
-    IN gckCONTEXT Context,
     OUT gcsPROFILER_COUNTERS_PART1 * Counters_part1,
     OUT gcsPROFILER_COUNTERS_PART2 * Counters_part2
     );
 
 gceSTATUS
 gckHARDWARE_UpdateContextProfile(
-    IN gckHARDWARE Hardware,
-    IN gckCONTEXT Context
+    IN gckHARDWARE Hardware
     );
 
 gceSTATUS
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_base.h b/drivers/staging/npu/kernel/inc/gc_hal_base.h
index de65b571c7ed..b925be20fecc 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_base.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_base.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -104,6 +104,7 @@ typedef struct _gcsUSER_MEMORY_DESC *   gcsUSER_MEMORY_DESC_PTR;
 typedef struct _gcsNN_FIXED_FEATURE
 {
     gctUINT  vipCoreCount;
+    gctUINT  vipRingCount;
     gctUINT  nnMadPerCore;
     gctUINT  nnInputBufferDepth;
     gctUINT  nnAccumBufferDepth;
@@ -584,7 +585,7 @@ gcoHAL_QueryChipAxiBusWidth(
 gceSTATUS
 gcoHAL_QueryMultiGPUAffinityConfig(
     IN gceHARDWARE_TYPE Type,
-    OUT gceMULTI_GPU_MODE *Mode,
+    OUT gceMULTI_PROCESSOR_MODE *Mode,
     OUT gctUINT32_PTR CoreIndex
     );
 
@@ -1086,12 +1087,31 @@ gcoHAL_SetLastCommitStatus(
     IN gctBOOL Pending
     );
 
+gceSTATUS
+gcoHAL_CommitDone(
+    IN gcoHAL Hal
+    );
+
 gceSTATUS
 gcoHAL_IsFlatMapped(
     IN gctPHYS_ADDR_T PhysicalAddress,
     OUT gctUINT32 *Address
     );
 
+gceSTATUS
+gcoHAL_QueryMCFESemaphoreCapacity(
+    IN gcoHAL Hal,
+    OUT gctUINT32 * Capacity
+    );
+
+
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gcoHAL_SwitchMpMode(
+    gcoHAL Hal
+    );
+#endif
+
 /******************************************************************************\
 ********************************** gcoOS Object *********************************
 \******************************************************************************/
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_debug_zones.h b/drivers/staging/npu/kernel/inc/gc_hal_debug_zones.h
index 6d56d0c537b2..b64fe4c5bde8 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_debug_zones.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_debug_zones.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_driver.h b/drivers/staging/npu/kernel/inc/gc_hal_driver.h
index 1ae5d0fe86da..4ef7121030bf 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_driver.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_driver.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_driver_vg.h b/drivers/staging/npu/kernel/inc/gc_hal_driver_vg.h
index 090b1a232a30..6c652069e7f1 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_driver_vg.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_driver_vg.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_drm.h b/drivers/staging/npu/kernel/inc/gc_hal_drm.h
index a336ee8de0ac..e9c508f2bfd7 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_drm.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_drm.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -139,11 +139,17 @@ struct drm_viv_gem_timestamp {
 #define DRM_VIV_GEM_TS_NORMAL       0x02
 #define DRM_VIV_GEM_TS_COMPRESSED   0x03
 
+/* ts cache mode. */
+#define DRM_VIV_GEM_TS_CACHE_MODE_64B     0x00
+#define DRM_VIV_GEM_TS_CACHE_MODE_128B    0x01
+#define DRM_VIV_GEM_TS_CACHE_MODE_256B    0x02
+
 struct drm_viv_gem_set_tiling {
     __u32 handle;
     __u32 tiling_mode;
 
     __u32 ts_mode;
+    __u32 ts_cache_mode;
     __u64 clear_value;
 };
 
@@ -152,6 +158,7 @@ struct drm_viv_gem_get_tiling {
     __u32 tiling_mode;
 
     __u32 ts_mode;
+    __u32 ts_cache_mode;
     __u64 clear_value;
 };
 
@@ -195,7 +202,10 @@ struct drm_viv_gem_ref_node {
 #define DRM_IOCTL_VIV_GEM_REF_NODE      DRM_IOWR(DRM_COMMAND_BASE + DRM_VIV_GEM_REF_NODE, struct drm_viv_gem_ref_node)
 
 #ifdef __KERNEL__
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+#define drm_gem_object_unreference_unlocked drm_gem_object_put
+#define drm_dev_unref drm_dev_put
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
 #define drm_gem_object_unreference_unlocked drm_gem_object_put_unlocked
 #define drm_dev_unref drm_dev_put
 #endif
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_dump.h b/drivers/staging/npu/kernel/inc/gc_hal_dump.h
index f64c0fe4a05a..c3ba3d99bf91 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_dump.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_dump.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_eglplatform.h b/drivers/staging/npu/kernel/inc/gc_hal_eglplatform.h
index 76b232872220..cd16a9d98a1b 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_eglplatform.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_eglplatform.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_eglplatform_type.h b/drivers/staging/npu/kernel/inc/gc_hal_eglplatform_type.h
index 4882df85d447..cff1f58bdfc6 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_eglplatform_type.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_eglplatform_type.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_engine.h b/drivers/staging/npu/kernel/inc/gc_hal_engine.h
index 2d2263901b83..1b84e535f2db 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_engine.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_engine.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -124,6 +124,13 @@ typedef struct _gcoBUFOBJ *             gcoBUFOBJ;
 #define gcdATTRIBUTE_COUNT              32
 #define gcdVERTEXARRAY_POOL_CAPACITY    32
 
+#define gcdSTREAM_POOL_SIZE      128
+#define gcdSTREAM_GROUP_SIZE     16
+#define gcdSTREAM_SIGNAL_NUM \
+    (\
+        (gcdSTREAM_POOL_SIZE + gcdSTREAM_GROUP_SIZE - 1) / gcdSTREAM_GROUP_SIZE \
+    )
+
 #define gcvPORGRAM_STAGE_GPIPE (gcvPROGRAM_STAGE_VERTEX_BIT | \
                                 gcvPROGRAM_STAGE_TCS_BIT    | \
                                 gcvPROGRAM_STAGE_TES_BIT    | \
@@ -1600,6 +1607,8 @@ typedef struct _gcsVX_IMAGE_INFO
 #if gcdVX_OPTIMIZER
     gctUINT32       uniformData[3][4];
 #endif
+    /* the uniform data type of save nbg */
+    gctUINT32       uniformSaveDataType;
 }
 gcsVX_IMAGE_INFO;
 typedef struct _gcsVX_DISTRIBUTION_INFO * gcsVX_DISTRIBUTION_INFO_PTR;
@@ -2433,6 +2442,9 @@ typedef struct _gcsATTRIBUTE
     /* Divisor of the attribute */
     gctUINT             divisor;
 
+    /* Offset of the attribute */
+    gctUINT             offset;
+
     /* Pointer to the attribute data. */
     gctCONST_POINTER    pointer;
 
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_engine_vg.h b/drivers/staging/npu/kernel/inc/gc_hal_engine_vg.h
index 122fade078c2..cd2f39e01ab4 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_engine_vg.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_engine_vg.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_enum.h b/drivers/staging/npu/kernel/inc/gc_hal_enum.h
index 2f94e1dd97be..4d6b1777f0f5 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_enum.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_enum.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -920,13 +920,6 @@ typedef enum _gceMULTI_GPU_RENDERING_MODE
 }
 gceMULTI_GPU_RENDERING_MODE;
 
-typedef enum _gceMULTI_GPU_MODE
-{
-    gcvMULTI_GPU_MODE_COMBINED    = 0,
-    gcvMULTI_GPU_MODE_INDEPENDENT = 1
-}
-gceMULTI_GPU_MODE;
-
 typedef enum _gceMACHINECODE
 {
     gcvMACHINECODE_ANTUTU0 = 0x0,
@@ -1002,8 +995,10 @@ gceMCFE_CHANNEL_TYPE;
 
 typedef enum _gcePAGE_TYPE
 {
-    gcvPAGE_TYPE_1M,
     gcvPAGE_TYPE_4K,
+    gcvPAGE_TYPE_64K,
+    gcvPAGE_TYPE_1M,
+    gcvPAGE_TYPE_16M,
 }
 gcePAGE_TYPE;
 
@@ -1734,20 +1729,29 @@ typedef enum _gceBUFOBJ_TYPE
 
 typedef enum _gceBUFOBJ_USAGE
 {
-    gcvBUFOBJ_USAGE_STREAM_DRAW = 1,
-    gcvBUFOBJ_USAGE_STREAM_READ,
-    gcvBUFOBJ_USAGE_STREAM_COPY,
-    gcvBUFOBJ_USAGE_STATIC_DRAW,
-    gcvBUFOBJ_USAGE_STATIC_READ,
-    gcvBUFOBJ_USAGE_STATIC_COPY,
-    gcvBUFOBJ_USAGE_DYNAMIC_DRAW,
-    gcvBUFOBJ_USAGE_DYNAMIC_READ,
-    gcvBUFOBJ_USAGE_DYNAMIC_COPY,
-
+    gcvBUFOBJ_USAGE_NONE                                = 0x0,
+    gcvBUFOBJ_USAGE_STREAM_DRAW                         = 0x1,
+    gcvBUFOBJ_USAGE_STREAM_READ                         = 0x2,
+    gcvBUFOBJ_USAGE_STREAM_COPY                         = 0x3,
+    gcvBUFOBJ_USAGE_STATIC_DRAW                         = 0x4,
+    gcvBUFOBJ_USAGE_STATIC_READ                         = 0x5,
+    gcvBUFOBJ_USAGE_STATIC_COPY                         = 0x6,
+    gcvBUFOBJ_USAGE_DYNAMIC_DRAW                        = 0x7,
+    gcvBUFOBJ_USAGE_DYNAMIC_READ                        = 0x8,
+    gcvBUFOBJ_USAGE_DYNAMIC_COPY                        = 0x9,
+
+    /* Use 8bits to save the usage. */
+    gcvBUFOBJ_USAGE_MASK                                = 0xFF,
+
+    /* Some special flags. */
     /* special patch for optimaize performance,
     ** no fence and duplicate stream to ensure data correct
     */
-    gcvBUFOBJ_USAGE_DISABLE_FENCE_DYNAMIC_STREAM = 256
+    gcvBUFOBJ_USAGE_FLAG_DISABLE_FENCE_DYNAMIC_STREAM   = 0x100,
+
+    /* This buffer object is used by driver, so we need to copy the data to the logical memory. */
+    gcvBUFOBJ_USAGE_FLAG_DATA_USED_BY_DRIVER            = 0x200,
+
 } gceBUFOBJ_USAGE;
 
 /**
@@ -2120,55 +2124,57 @@ enum
     gcvPLATFORM_FLAG_IMX_MM           = 1 << 1,
 };
 
-/* No special needs. */
-#define gcvALLOC_FLAG_NONE                  0x00000000
-
-/* Physical contiguous. */
-#define gcvALLOC_FLAG_CONTIGUOUS            0x00000001
-/* Physical non contiguous. */
-#define gcvALLOC_FLAG_NON_CONTIGUOUS        0x00000002
-
-/* Should not swap out. */
-#define gcvALLOC_FLAG_NON_PAGED             0x00000004
-
-/* CPU access explicitly needed. */
-#define gcvALLOC_FLAG_CPU_ACCESS            0x00000008
-/* Can be remapped as cacheable. */
-#define gcvALLOC_FLAG_CACHEABLE             0x00000010
-
-/* Need 32bit address. */
-#define gcvALLOC_FLAG_4GB_ADDR              0x00000020
-
-/* Secure buffer. */
-#define gcvALLOC_FLAG_SECURITY              0x00000040
-/* Can be exported as dmabuf-fd */
-#define gcvALLOC_FLAG_DMABUF_EXPORTABLE     0x00000080
-/* Do not try slow pools (gcvPOOL_VIRTUAL) */
-#define gcvALLOC_FLAG_FAST_POOLS            0x00000100
-
-/* Only accessed by GPU */
-#define gcvALLOC_FLAG_NON_CPU_ACCESS        0x00000200
-
-/* Import DMABUF. */
-#define gcvALLOC_FLAG_DMABUF                0x00001000
-/* Import USERMEMORY. */
-#define gcvALLOC_FLAG_USERMEMORY            0x00002000
-/* Import an External Buffer. */
-#define gcvALLOC_FLAG_EXTERNAL_MEMORY       0x00004000
-/* Import linux reserved memory. */
-#define gcvALLOC_FLAG_LINUX_RESERVED_MEM    0x00008000
-
-/* 1M pages unit allocation. */
-#define gcvALLOC_FLAG_1M_PAGES              0x00010000
-
-/* Non 1M pages unit allocation. */
-#define gcvALLOC_FLAG_4K_PAGES              0x00020000
-
-/* Real allocation happens when GPU page fault. */
-#define gcvALLOC_FLAG_ALLOC_ON_FAULT        0x01000000
-/* Alloc with memory limit. */
-#define gcvALLOC_FLAG_MEMLIMIT              0x02000000
+#if gcdUSE_CAPBUF
+typedef enum _gceCAPBUF_META_TYPE
+{
+    gcvCAPBUF_META_TYPE_BASE = 0,
+    gcvCAPBUF_META_TYPE_STATE_BUFFER = 0,
+    gcvCAPBUF_META_TYPE_DRAW_ID,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM,
+    gcvCAPBUF_META_TYPE_VIP_SRAM,
+    gcvCAPBUF_META_TYPE_AXI_SRAM,
+    gcvCAPBUF_META_TYPE_PPU_PARAMETERS,
+    gcvCAPBUF_META_TYPE_VIP_SRAM_REMAP,
+    gcvCAPBUF_META_TYPE_AXI_SRAM_REMAP,
+    gcvCAPBUF_META_TYPE_IMAGE_PHYSICAL_ADDRESS,
+    gcvCAPBUF_META_TYPE_SH_INST_ADDRESS,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM_ARGS_LOCAL_ADDRESS_SPACE,
+    gcvCAPBUF_META_TYPE_SH_UNIFORM_ARGS_CONSTANT_ADDRESS_SPACE,
+    /* Keep it at the end of the list. */
+    gcvCAPBUF_META_TYPE_COUNT
+}
+gceCAPBUF_META_TYPE;
+
+typedef enum _gceCAPBUF_SH_UNIFROM_ARGS
+{
+    gcvCAPBUF_SH_UNIFORM_ARGS_INVALID = 0,
+    gcvCAPBUF_SH_UNIFORM_ARGS_IMAGE_PHYSICAL_ADDRESS,
+    gcvCAPBUF_SH_UNIFORM_ARGS_LOCAL_ADDRESS_SPACE,
+    gcvCAPBUF_SH_UNIFORM_ARGS_CONSTANT_ADDRESS_SPACE,
+    /* Keep it at the end of the list. */
+    gcvCAPBUF_SH_UNIFORM_ARGS_COUNT
+}
+gceCAPBUF_SH_UNIFORM_ARGS;
+
+typedef enum _gceCAPBUF_PPU_PARAMETERS_INDEX
+{
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_X = 0,
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_Y,
+    gcvCAPBUF_PPU_GLOBAL_OFFSET_Z,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_X,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_Y,
+    gcvCAPBUF_PPU_GLOBAL_SCALE_Z,
+    gcvCAPBUF_PPU_GROUP_SIZE_X,
+    gcvCAPBUF_PPU_GROUP_SIZE_Y,
+    gcvCAPBUF_PPU_GROUP_SIZE_Z,
+    gcvCAPBUF_PPU_GROUP_COUNT_X,
+    gcvCAPBUF_PPU_GROUP_COUNT_Y,
+    gcvCAPBUF_PPU_GROUP_COUNT_Z,
+    gcvCAPBUF_PPU_PARAMETERS_COUNT
+}
+gceCAPBUF_PPU_GLOBALE_OFFSET_INDEX;
 
+#endif
 
 /* GL_VIV internal usage */
 #ifndef GL_MAP_BUFFER_OBJ_VIV
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_kernel_buffer.h b/drivers/staging/npu/kernel/inc/gc_hal_kernel_buffer.h
index 4bab2a582dfa..94a7ad5e1934 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_kernel_buffer.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_kernel_buffer.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_mem.h b/drivers/staging/npu/kernel/inc/gc_hal_mem.h
index aa0104aef959..0ce6bafc943d 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_mem.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_mem.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_metadata.h b/drivers/staging/npu/kernel/inc/gc_hal_metadata.h
index c3a567d356d6..9485be72be7a 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_metadata.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_metadata.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_options.h b/drivers/staging/npu/kernel/inc/gc_hal_options.h
index 7bcdac95805c..c17ba428a873 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_options.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_options.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -205,7 +205,7 @@ This define enables the use of VM for gckCommand and fence buffers.
         When set to 1, will dump TP/NN command buffer when GPU/VIP hang.
 */
 #ifndef gcdDUMP_TPNN_SUBCOMMAND
-#   define gcdDUMP_TPNN_SUBCOMMAND              0
+#   define gcdDUMP_TPNN_SUBCOMMAND              1
 #endif
 
 /*
@@ -336,15 +336,6 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_FSCALE_VAL_ADJUST          1
 #endif
 
-/*
-    gcdCAPTURE_ONLY_MODE
-        When non-zero, driver is built with capture only mode.
-        1) Set DDR address range in capture file with contiguousBase and contiguoutsSize.
-           Video memory allocation will go through reserved pool with capture only mode.
-        2) Set SRAM address range in capture file with sRAMBases, sRAMSizes and extSRAMBases, extSRAMSizes.
-           Video memory querion will go through reserved pool with capture only mode.
-        3) TODO: SRAM video memory allocation.
-*/
 #ifndef gcdCAPTURE_ONLY_MODE
 #   define gcdCAPTURE_ONLY_MODE                 0
 #endif
@@ -1441,6 +1432,15 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_SW_PREEMPTION 0
 #endif
 
+/*
+    gcdSUPPORT_DEVICE_TREE_SOURCE
+        To suppor device tree feature if set to 1, disable by default.
+        Only works on linux OS.
+*/
+#ifndef gcdSUPPORT_DEVICE_TREE_SOURCE
+#   define gcdSUPPORT_DEVICE_TREE_SOURCE        0
+#endif
+
 /*
     gcdENABLE_PER_DEVICE_PM
         Enable per device power management if set to 2, all the hardware cores will be one device.
@@ -1452,7 +1452,33 @@ This define enables the use of VM for gckCommand and fence buffers.
 #   define gcdENABLE_PER_DEVICE_PM 0
 #endif
 
+/*
+    gcdUSE_CAPBUF
+ */
+#ifndef gcdUSE_CAPBUF
+#   define gcdUSE_CAPBUF 1
+#endif
+
+/*
+    gcdENABLE_MP_SWITCH
+        Enable multi-processor mode dynamic switch, the processor count is determined by specific conditions.
+        Only support Linux OS currently.
+*/
+#ifndef gcdENABLE_MP_SWITCH
+#   define gcdENABLE_MP_SWITCH 0
+#endif
+
+/*
+    gcdANON_FILE_FOR_ALLOCATOR
+        Enable this macro can replace the /dev/zero by anon_inode:[galcore] in /proc/<pid>/maps.
+        Without the macro, run 'cat /proc/<pid>/maps' will print "/dev/zero".
+*/
+#ifndef gcdANON_FILE_FOR_ALLOCATOR
+#   define gcdANON_FILE_FOR_ALLOCATOR 0
+#endif
+
 #endif /* __gc_hal_options_h_ */
 
 
 
+
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_profiler.h b/drivers/staging/npu/kernel/inc/gc_hal_profiler.h
index f10d4faef7bf..539bfc48f1f1 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_profiler.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_profiler.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -223,17 +223,36 @@ extern "C" {
 #define PPS_SOURCE           (PPS_FUNCTIONCOUNT    + 1)
 /* End of MISC Counter IDs. */
 
+#define VPG(x) (gcoPROFILER_getVPGConst(x))
+
+enum gceVPG
+{
+    VPHEADER,
+    INFO,
+    FRAME,
+    TIME,
+    ES11,
+    ES20,
+    VG11,
+    HW,
+    MULTI_GPU,
+    PROG,
+    ES11DRAW,
+    ES20DRAW,
+    MEM,
+    PVS,
+    PPS,
+    ES11_TIME,
+    ES20_TIME,
+    ES30,
+    ES30_DRAW,
+    ES30_TIME,
+    FINISH,
+    END,
+};
 
 /* Category Constants. */
-#define VPHEADER        0x010000
-#define VPG_INFO        0x020000
-#define VPG_TIME        0x030000
-#define VPG_MEM         0x040000
-#define VPG_ES11        0x050000
-#define VPG_ES30        0x060000
-#define VPG_VG11        0x070000
 #define VPG_HAL         0x080000
-#define VPG_HW          0x090000
 #define VPG_GPU         0x0a0000
 #define VPG_VS          0x0b0000
 #define VPG_PS          0x0c0000
@@ -244,17 +263,8 @@ extern "C" {
 #define VPG_PE          0x110000
 #define VPG_MC          0x120000
 #define VPG_AXI         0x130000
-#define VPG_PROG        0x140000
-#define VPG_PVS         0x150000
-#define VPG_PPS         0x160000
-#define VPG_ES11_TIME   0x170000
-#define VPG_ES30_TIME   0x180000
-#define VPG_FRAME       0x190000
-#define VPG_ES11_DRAW   0x200000
-#define VPG_ES30_DRAW   0x210000
 #define VPG_VG11_TIME   0x220000
 #define VPG_FE          0x230000
-#define VPG_MULTI_GPU   0x240000
 #define VPNG_FE         0x250000
 #define VPNG_VS         0x260000
 #define VPNG_PS         0x270000
@@ -269,49 +279,48 @@ extern "C" {
 #define VPNG_L2         0x300000
 #define VPNG_NN         0x310000
 #define VPNG_TP         0x320000
-#define VPG_FINISH      0x330000
-#define VPG_END         0xff0000
 
 /* Info. */
-#define VPC_INFOCOMPANY         (VPG_INFO + 1)
+#define VPC_INFOCOMPANY         (VPG(INFO) + 1)
 #define VPC_INFOVERSION         (VPC_INFOCOMPANY + 1)
 #define VPC_INFORENDERER        (VPC_INFOVERSION + 1)
 #define VPC_INFOREVISION        (VPC_INFORENDERER + 1)
 #define VPC_INFODRIVER          (VPC_INFOREVISION + 1)
 #define VPC_INFODRIVERMODE      (VPC_INFODRIVER + 1)
 #define VPC_INFOSCREENSIZE      (VPC_INFODRIVERMODE + 1)
+#define VPC_INFOASICMODE        (VPC_INFOSCREENSIZE + 1)
 
 /* Counter Constants. */
-#define VPC_ELAPSETIME          (VPG_TIME + 1)
+#define VPC_ELAPSETIME          (VPG(TIME) + 1)
 #define VPC_CPUTIME             (VPC_ELAPSETIME + 1)
 
-#define VPC_MEMMAXRES           (VPG_MEM + 1)
+#define VPC_MEMMAXRES           (VPG(MEM) + 1)
 #define VPC_MEMSHARED           (VPC_MEMMAXRES + 1)
 #define VPC_MEMUNSHAREDDATA     (VPC_MEMSHARED + 1)
 #define VPC_MEMUNSHAREDSTACK    (VPC_MEMUNSHAREDDATA + 1)
 
 /* OpenGL ES11 Statics Counter IDs. */
-#define    VPC_ES11CALLS            (VPG_ES11 +    ES11_CALLS)
-#define    VPC_ES11DRAWCALLS        (VPG_ES11 +    ES11_DRAWCALLS)
-#define    VPC_ES11STATECHANGECALLS (VPG_ES11 +    ES11_STATECHANGECALLS)
-#define    VPC_ES11POINTCOUNT       (VPG_ES11 +    ES11_POINTCOUNT)
-#define    VPC_ES11LINECOUNT        (VPG_ES11 +    ES11_LINECOUNT)
-#define    VPC_ES11TRIANGLECOUNT    (VPG_ES11 +    ES11_TRIANGLECOUNT)
+#define    VPC_ES11CALLS            (VPG(ES11) +    ES11_CALLS)
+#define    VPC_ES11DRAWCALLS        (VPG(ES11) +    ES11_DRAWCALLS)
+#define    VPC_ES11STATECHANGECALLS (VPG(ES11) +    ES11_STATECHANGECALLS)
+#define    VPC_ES11POINTCOUNT       (VPG(ES11) +    ES11_POINTCOUNT)
+#define    VPC_ES11LINECOUNT        (VPG(ES11) +    ES11_LINECOUNT)
+#define    VPC_ES11TRIANGLECOUNT    (VPG(ES11) +    ES11_TRIANGLECOUNT)
 
 /* OpenGL ES30 Statistics Counter IDs. */
-#define    VPC_ES30CALLS            (VPG_ES30 +    ES30_CALLS)
-#define    VPC_ES30DRAWCALLS        (VPG_ES30 +    ES30_DRAWCALLS)
-#define    VPC_ES30STATECHANGECALLS (VPG_ES30 +    ES30_STATECHANGECALLS)
-#define    VPC_ES30POINTCOUNT       (VPG_ES30 +    ES30_POINTCOUNT)
-#define    VPC_ES30LINECOUNT        (VPG_ES30 +    ES30_LINECOUNT)
-#define    VPC_ES30TRIANGLECOUNT    (VPG_ES30 +    ES30_TRIANGLECOUNT)
+#define    VPC_ES30CALLS            (VPG(ES30) +    ES30_CALLS)
+#define    VPC_ES30DRAWCALLS        (VPG(ES30) +    ES30_DRAWCALLS)
+#define    VPC_ES30STATECHANGECALLS (VPG(ES30) +    ES30_STATECHANGECALLS)
+#define    VPC_ES30POINTCOUNT       (VPG(ES30) +    ES30_POINTCOUNT)
+#define    VPC_ES30LINECOUNT        (VPG(ES30) +    ES30_LINECOUNT)
+#define    VPC_ES30TRIANGLECOUNT    (VPG(ES30) +    ES30_TRIANGLECOUNT)
 
 /* OpenVG Statistics Counter IDs. */
-#define    VPC_VG11CALLS            (VPG_VG11 +    VG11_CALLS)
-#define    VPC_VG11DRAWCALLS        (VPG_VG11 +    VG11_DRAWCALLS)
-#define    VPC_VG11STATECHANGECALLS (VPG_VG11 +    VG11_STATECHANGECALLS)
-#define    VPC_VG11FILLCOUNT        (VPG_VG11 +    VG11_FILLCOUNT)
-#define    VPC_VG11STROKECOUNT      (VPG_VG11 +    VG11_STROKECOUNT)
+#define    VPC_VG11CALLS            (VPG(VG11) +    VG11_CALLS)
+#define    VPC_VG11DRAWCALLS        (VPG(VG11) +    VG11_DRAWCALLS)
+#define    VPC_VG11STATECHANGECALLS (VPG(VG11) +    VG11_STATECHANGECALLS)
+#define    VPC_VG11FILLCOUNT        (VPG(VG11) +    VG11_FILLCOUNT)
+#define    VPC_VG11STROKECOUNT      (VPG(VG11) +    VG11_STROKECOUNT)
 
 /* HAL Counters. */
 #define VPC_HALVERTBUFNEWBYTEALLOC      (VPG_HAL + HAL_VERTBUFNEWBYTEALLOC)
@@ -638,27 +647,27 @@ extern "C" {
 #define TOTAL_MODULE_NUMBER              12
 
 /* PROGRAM: Shader program counters. */
-#define VPC_PVSINSTRCOUNT           (VPG_PVS + PVS_INSTRCOUNT)
-#define VPC_PVSALUINSTRCOUNT        (VPG_PVS + PVS_ALUINSTRCOUNT)
-#define VPC_PVSTEXINSTRCOUNT        (VPG_PVS + PVS_TEXINSTRCOUNT)
-#define VPC_PVSATTRIBCOUNT          (VPG_PVS + PVS_ATTRIBCOUNT)
-#define VPC_PVSUNIFORMCOUNT         (VPG_PVS + PVS_UNIFORMCOUNT)
-#define VPC_PVSFUNCTIONCOUNT        (VPG_PVS + PVS_FUNCTIONCOUNT)
-#define VPC_PVSSOURCE               (VPG_PVS + PVS_SOURCE)
-
-#define VPC_PPSINSTRCOUNT           (VPG_PPS + PPS_INSTRCOUNT)
-#define VPC_PPSALUINSTRCOUNT        (VPG_PPS + PPS_ALUINSTRCOUNT)
-#define VPC_PPSTEXINSTRCOUNT        (VPG_PPS + PPS_TEXINSTRCOUNT)
-#define VPC_PPSATTRIBCOUNT          (VPG_PPS + PPS_ATTRIBCOUNT)
-#define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
-#define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
-#define VPC_PPSSOURCE               (VPG_PPS + PPS_SOURCE)
-
-#define VPC_PROGRAMHANDLE           (VPG_PROG + 1)
-
-#define VPC_ES30_DRAW_NO            (VPG_ES30_DRAW + 1)
+#define VPC_PVSINSTRCOUNT           (VPG(PVS) + PVS_INSTRCOUNT)
+#define VPC_PVSALUINSTRCOUNT        (VPG(PVS) + PVS_ALUINSTRCOUNT)
+#define VPC_PVSTEXINSTRCOUNT        (VPG(PVS) + PVS_TEXINSTRCOUNT)
+#define VPC_PVSATTRIBCOUNT          (VPG(PVS) + PVS_ATTRIBCOUNT)
+#define VPC_PVSUNIFORMCOUNT         (VPG(PVS) + PVS_UNIFORMCOUNT)
+#define VPC_PVSFUNCTIONCOUNT        (VPG(PVS) + PVS_FUNCTIONCOUNT)
+#define VPC_PVSSOURCE               (VPG(PVS) + PVS_SOURCE)
+
+#define VPC_PPSINSTRCOUNT           (VPG(PPS) + PPS_INSTRCOUNT)
+#define VPC_PPSALUINSTRCOUNT        (VPG(PPS) + PPS_ALUINSTRCOUNT)
+#define VPC_PPSTEXINSTRCOUNT        (VPG(PPS) + PPS_TEXINSTRCOUNT)
+#define VPC_PPSATTRIBCOUNT          (VPG(PPS) + PPS_ATTRIBCOUNT)
+#define VPC_PPSUNIFORMCOUNT         (VPG(PPS) + PPS_UNIFORMCOUNT)
+#define VPC_PPSFUNCTIONCOUNT        (VPG(PPS) + PPS_FUNCTIONCOUNT)
+#define VPC_PPSSOURCE               (VPG(PPS) + PPS_SOURCE)
+
+#define VPC_PROGRAMHANDLE           (VPG(PROG) + 1)
+
+#define VPC_ES30_DRAW_NO            (VPG(ES30_DRAW) + 1)
 #define VPC_ES11_DRAW_NO            (VPG_ES11_DRAW + 1)
-#define VPC_ES30_GPU_NO             (VPG_MULTI_GPU + 1)
+#define VPC_ES30_GPU_NO             (VPG(MULTI_GPU) + 1)
 
 
 #define   MODULE_FRONT_END_COUNTER_NUM                    0x5
@@ -987,6 +996,8 @@ struct gcsCounterBuffer
     gctPOINTER                  logicalAddress;
     gceCOUNTER_OPTYPE           opType;
     gctUINT32                   opID;
+    gctUINT32                   opCount[4];
+    gctUINT32                   currentShaderId[6];
     gctUINT32                   startPos;
     gctUINT32                   endPos;
     gctUINT32                   dataSize;
@@ -996,6 +1007,22 @@ struct gcsCounterBuffer
     gcsCounterBuffer_PTR        prev;
 };
 
+typedef struct _gcoPROBE         gcoPROBE;
+struct _gcoPROBE
+{
+    gctUINT32                   address;
+    gctUINT32                   offset;
+};
+
+typedef struct _gcoMODULE         gcoMODULE;
+struct _gcoMODULE
+{
+    gctUINT32                   name;
+    gctUINT32                   address;
+    gctUINT32                   numProbe;
+    gcoPROBE                    probe[256];
+};
+
 typedef struct _gcoPROFILER *        gcoPROFILER;
 
 struct _gcoPROFILER
@@ -1003,11 +1030,13 @@ struct _gcoPROFILER
     gctBOOL                     enable;
     gctBOOL                     enablePrint;
     gctBOOL                     disableProbe;
-    gctBOOL                     probeMode;
+
     gctBOOL                     vipProbe;
 
     gctFILE                     file;
     gctCHAR*                    fileName;
+    gceProfilerMode             profilerMode;
+    gceProbeMode                probeMode;
 
     gcsCounterBuffer_PTR        counterBuf;
     gctUINT32                   bufferCount;
@@ -1035,12 +1064,21 @@ typedef struct _gcsPROBESTATES
 
 typedef struct _gckPROFILER
 {
-    /* Profile mode */
-    gceProfilerMode             profileMode;
     /* Enable profiling */
     gctBOOL                     profileEnable;
+    /* Profile mode */
+    gceProfilerMode             profileMode;
+    /* Probe mode */
+    gceProbeMode                probeMode;
     /* Clear profile register or not*/
     gctBOOL                     profileCleanRegister;
+    /* Profile counter */
+    gcsPROFILER_COUNTERS_PART1  latestProfiler_part1;
+    gcsPROFILER_COUNTERS_PART1  histroyProfiler_part1;
+    gcsPROFILER_COUNTERS_PART1  preProfiler_part1;
+    gcsPROFILER_COUNTERS_PART2  latestProfiler_part2;
+    gcsPROFILER_COUNTERS_PART2  histroyProfiler_part2;
+    gcsPROFILER_COUNTERS_PART2  preProfiler_part2;
 }gckPROFILER;
 
 /* Construct a Profiler object per context. */
@@ -1095,6 +1133,30 @@ gcoPROFILER_GetProbeNumber(
     OUT gctUINT32 *TotalProbeNumber
     );
 
+gctUINT32 gcoPROFILER_getMuduleNum(
+    IN gcoPROFILER Profiler
+    );
+
+gctUINT32 gcoPROFILER_getMuduleProbeNum(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 index
+    );
+
+gctUINT32 gcoPROFILER_getModuleAddress(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 ModuleIndex
+    );
+
+gctUINT32 gcoPROFILER_getProbeAddress(
+    IN gcoPROFILER Profiler,
+    IN gctUINT32 ModuleIndex,
+    IN gctUINT32 ProbeIndex
+    );
+
+gctUINT32 gcoPROFILER_getCounterBufferSize(
+    IN gcoPROFILER Profiler
+    );
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_raster.h b/drivers/staging/npu/kernel/inc/gc_hal_raster.h
index 1daf4a6fbeb9..464244d40763 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_raster.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_raster.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -1028,6 +1028,18 @@ gco2D_SetTargetTileStatus(
     IN gctUINT32 GpuAddress
     );
 
+gceSTATUS
+gco2D_SetSourceCacheMode(
+    IN gco2D Engine,
+    IN gceCACHE_MODE CacheMode
+    );
+
+gceSTATUS
+gco2D_SetTargetCacheMode(
+    IN gco2D Engine,
+    IN gceCACHE_MODE CacheMode
+    );
+
 gceSTATUS
 gco2D_QueryU32(
     IN gco2D Engine,
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_security_interface.h b/drivers/staging/npu/kernel/inc/gc_hal_security_interface.h
index d5953dde64d8..8b1d887620f4 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_security_interface.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_security_interface.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_statistics.h b/drivers/staging/npu/kernel/inc/gc_hal_statistics.h
index 1f3ba068271d..fb046cc5ef62 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_statistics.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_statistics.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_types.h b/drivers/staging/npu/kernel/inc/gc_hal_types.h
index 455355e2b096..096afd7d18e5 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_types.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_types.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_version.h b/drivers/staging/npu/kernel/inc/gc_hal_version.h
index a3fb4dac1408..dd06d0988f97 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_version.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_version.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -60,11 +60,11 @@
 
 #define gcvVERSION_MINOR        4
 
-#define gcvVERSION_PATCH        4
+#define gcvVERSION_PATCH        6
 
-#define gcvVERSION_BUILD     310723
+#define gcvVERSION_BUILD     345497
 
-#define gcvVERSION_STRING    "6.4.4.3.310723AAA"
+#define gcvVERSION_STRING    "6.4.6.2.5.3.2"
 
 #endif /* __gc_hal_version_h_ */
 
diff --git a/drivers/staging/npu/kernel/inc/gc_hal_vg.h b/drivers/staging/npu/kernel/inc/gc_hal_vg.h
index 667759de2f34..0113f688cc4e 100644
--- a/drivers/staging/npu/kernel/inc/gc_hal_vg.h
+++ b/drivers/staging/npu/kernel/inc/gc_hal_vg.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/probeStatistics_Driver.h b/drivers/staging/npu/kernel/inc/probeStatistics_Driver.h
new file mode 100644
index 000000000000..94aa0e2461db
--- /dev/null
+++ b/drivers/staging/npu/kernel/inc/probeStatistics_Driver.h
@@ -0,0 +1,1674 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2021 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2021 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+
+#define MDUID_PPA                                               0xe0000
+#define MDUID_SE                                                0x30000
+#define MDUID_APPINFO                                           0x1f0000
+#define MDUID_RA                                                0x40000
+#define MDUID_PA                                                0x20000
+#define MDUID_VS                                                0x10000
+#define MDUID_TCS                                               0x100000
+#define MDUID_TES                                               0x110000
+#define MDUID_GS                                                0x120000
+#define MDUID_PSCS                                              0x50000
+#define MDUID_HI                                                0xa0000
+#define MDUID_MC                                                0x80000
+#define MDUID_TX                                                0x60000
+#define MDUID_FE                                                0x00000
+#define MDUID_USC                                               0x140000
+#define MDUID_WD                                                0xd0000
+#define MDUID_CHIPINFO                                          0x1e0000
+#define MDUID_FPA                                               0xf0000
+#define MDUID_PE                                                0x70000
+#define MDUID_TFB                                               0x130000
+#define MDUID_DIR                                               0x150000
+
+#define MDUSEL_APPINFO_ProbeState_OpNum                         0x0401
+#define MDUSEL_APPINFO_ProbeState_OpTyp                         0x0402
+#define MDUSEL_APPINFO_ProbeState_DrawNum                       0x0403
+#define MDUSEL_APPINFO_ProbeState_BlitNum                       0x0404
+#define MDUSEL_APPINFO_ProbeState_ComputeNum                    0x0405
+#define MDUSEL_APPINFO_ProbeState_ResolveNum                    0x0406
+#define MDUSEL_APPINFO_ProbeState_VsId                          0x0407
+#define MDUSEL_APPINFO_ProbeState_TcsId                         0x0408
+#define MDUSEL_APPINFO_ProbeState_TesId                         0x0409
+#define MDUSEL_APPINFO_ProbeState_GsId                          0x040A
+#define MDUSEL_APPINFO_ProbeState_PsId                          0x040B
+#define MDUSEL_APPINFO_ProbeState_CsId                          0x040C
+
+#define MDUSEL_APPINFO_NUM                                      12
+
+#define MDUSEL_CHIPINFO_ProbeState_ChipID                       0x0001
+#define MDUSEL_CHIPINFO_ProbeState_ChipVer                      0x0002
+#define MDUSEL_CHIPINFO_ProbeState_PID                          0x0003
+#define MDUSEL_CHIPINFO_ProbeState_CID                          0x0004
+
+#define MDUSEL_CHIPINFO_NUM                                     4
+
+DefineModule(FE, 0x00000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+
+DefineModule(WD, 0xd0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x30);
+DefineProbe(0x31);
+DefineProbe(0x32);
+DefineProbe(0x33);
+DefineProbe(0x34);
+DefineProbe(0x35);
+DefineProbe(0x36);
+DefineProbe(0x37);
+DefineProbe(0x38);
+DefineProbe(0x39);
+DefineProbe(0x3a);
+DefineProbe(0x3b);
+DefineProbe(0x50);
+DefineProbe(0x51);
+DefineProbe(0x52);
+DefineProbe(0x53);
+DefineProbe(0x54);
+DefineProbe(0x55);
+DefineProbe(0x56);
+DefineProbe(0x57);
+DefineProbe(0x58);
+DefineProbe(0x59);
+DefineProbe(0x5a);
+DefineProbe(0x5b);
+DefineProbe(0x5c);
+DefineProbe(0x5d);
+DefineProbe(0x5e);
+DefineProbe(0x5f);
+DefineProbe(0x60);
+DefineProbe(0x61);
+DefineProbe(0x62);
+DefineProbe(0x63);
+DefineProbe(0x64);
+DefineProbe(0x65);
+DefineProbe(0x66);
+DefineProbe(0x80);
+DefineProbe(0x81);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(TFB, 0x130000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x15);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+
+DefineModule(PPA, 0xe0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(FPA, 0xf0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+
+DefineModule(PA, 0x20000);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+DefineProbe(0xc10);
+DefineProbe(0xc11);
+DefineProbe(0xc12);
+DefineProbe(0xc13);
+DefineProbe(0xc14);
+DefineProbe(0xc15);
+DefineProbe(0xc16);
+DefineProbe(0xc17);
+DefineProbe(0xc18);
+DefineProbe(0xc19);
+DefineProbe(0xc1a);
+
+DefineModule(SE, 0x30000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+
+DefineModule(RA, 0x40000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0x10);
+DefineProbe(0x1b);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+
+DefineModule(VS, 0x10000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x405);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TCS, 0x100000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TES, 0x110000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(GS, 0x120000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x12);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x405);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(PSCS, 0x50000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x28);
+DefineProbe(0x80);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x403);
+DefineProbe(0x406);
+DefineProbe(0x407);
+DefineProbe(0x408);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0x82a);
+DefineProbe(0x82b);
+DefineProbe(0x82c);
+DefineProbe(0x82d);
+DefineProbe(0x82e);
+DefineProbe(0x82f);
+DefineProbe(0x830);
+DefineProbe(0x831);
+DefineProbe(0x832);
+DefineProbe(0x833);
+DefineProbe(0x834);
+DefineProbe(0x835);
+DefineProbe(0x836);
+DefineProbe(0x837);
+DefineProbe(0x838);
+DefineProbe(0x839);
+DefineProbe(0x83a);
+DefineProbe(0x83b);
+DefineProbe(0x83c);
+DefineProbe(0x83d);
+DefineProbe(0x83e);
+DefineProbe(0x83f);
+DefineProbe(0x840);
+DefineProbe(0x841);
+DefineProbe(0x842);
+DefineProbe(0x843);
+DefineProbe(0x844);
+DefineProbe(0x845);
+DefineProbe(0x846);
+DefineProbe(0x847);
+DefineProbe(0x848);
+DefineProbe(0x849);
+DefineProbe(0x84a);
+DefineProbe(0x84b);
+DefineProbe(0x84c);
+DefineProbe(0x84d);
+DefineProbe(0x84e);
+DefineProbe(0x84f);
+DefineProbe(0x850);
+DefineProbe(0x851);
+DefineProbe(0x852);
+DefineProbe(0x853);
+DefineProbe(0x854);
+DefineProbe(0x855);
+DefineProbe(0x856);
+DefineProbe(0x857);
+DefineProbe(0x858);
+DefineProbe(0x859);
+DefineProbe(0x85a);
+DefineProbe(0x85b);
+DefineProbe(0x85c);
+DefineProbe(0x85d);
+DefineProbe(0x85e);
+DefineProbe(0x85f);
+DefineProbe(0x860);
+DefineProbe(0x861);
+DefineProbe(0x862);
+DefineProbe(0x863);
+DefineProbe(0x864);
+DefineProbe(0x865);
+DefineProbe(0x866);
+DefineProbe(0x867);
+DefineProbe(0x868);
+DefineProbe(0x869);
+DefineProbe(0x86a);
+DefineProbe(0x86b);
+DefineProbe(0x86c);
+DefineProbe(0x86d);
+DefineProbe(0x86e);
+DefineProbe(0x86f);
+DefineProbe(0x870);
+DefineProbe(0x871);
+DefineProbe(0x872);
+DefineProbe(0x873);
+DefineProbe(0x874);
+DefineProbe(0x875);
+DefineProbe(0x876);
+DefineProbe(0x877);
+DefineProbe(0x878);
+DefineProbe(0x879);
+DefineProbe(0x87a);
+DefineProbe(0x87b);
+DefineProbe(0x87c);
+DefineProbe(0x87d);
+DefineProbe(0x87e);
+DefineProbe(0x87f);
+DefineProbe(0x880);
+DefineProbe(0x881);
+DefineProbe(0x882);
+DefineProbe(0x883);
+DefineProbe(0x884);
+DefineProbe(0x885);
+DefineProbe(0x886);
+DefineProbe(0x887);
+DefineProbe(0x888);
+DefineProbe(0x889);
+DefineProbe(0x88a);
+DefineProbe(0x88b);
+DefineProbe(0x88c);
+DefineProbe(0x88d);
+DefineProbe(0x88e);
+DefineProbe(0x88f);
+DefineProbe(0x890);
+DefineProbe(0x891);
+DefineProbe(0x892);
+DefineProbe(0x893);
+DefineProbe(0x894);
+DefineProbe(0x895);
+DefineProbe(0x896);
+DefineProbe(0x897);
+DefineProbe(0x898);
+DefineProbe(0x899);
+DefineProbe(0x89a);
+DefineProbe(0x89b);
+DefineProbe(0x89c);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+
+DefineModule(TX, 0x60000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0x28);
+DefineProbe(0x29);
+DefineProbe(0x2a);
+DefineProbe(0x2b);
+DefineProbe(0x2c);
+DefineProbe(0x2d);
+DefineProbe(0x2e);
+DefineProbe(0x2f);
+DefineProbe(0x30);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0x825);
+DefineProbe(0x826);
+DefineProbe(0x827);
+DefineProbe(0x828);
+DefineProbe(0x829);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+
+DefineModule(PE, 0x70000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x401);
+DefineProbe(0x402);
+DefineProbe(0x403);
+DefineProbe(0x404);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+
+DefineModule(USC, 0x140000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x13);
+DefineProbe(0x14);
+DefineProbe(0x15);
+DefineProbe(0x16);
+DefineProbe(0x17);
+DefineProbe(0x18);
+DefineProbe(0x19);
+DefineProbe(0x1a);
+DefineProbe(0x1b);
+DefineProbe(0x1c);
+DefineProbe(0x1d);
+DefineProbe(0x1e);
+DefineProbe(0x1f);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0xc00);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+DefineProbe(0xc0f);
+DefineProbe(0xc10);
+DefineProbe(0xc11);
+DefineProbe(0xc12);
+DefineProbe(0xc13);
+DefineProbe(0xc14);
+DefineProbe(0xc15);
+DefineProbe(0xc16);
+DefineProbe(0xc17);
+DefineProbe(0xc18);
+DefineProbe(0xc19);
+DefineProbe(0xc1a);
+DefineProbe(0xc1b);
+
+DefineModule(MC, 0x80000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x10);
+DefineProbe(0x11);
+DefineProbe(0x12);
+DefineProbe(0x20);
+DefineProbe(0x21);
+DefineProbe(0x22);
+DefineProbe(0x23);
+DefineProbe(0x24);
+DefineProbe(0x25);
+DefineProbe(0x26);
+DefineProbe(0x27);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+
+DefineModule(HI, 0xa0000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+DefineProbe(0xc);
+DefineProbe(0xd);
+DefineProbe(0xe);
+DefineProbe(0xf);
+DefineProbe(0x40);
+DefineProbe(0x41);
+DefineProbe(0x42);
+DefineProbe(0x46);
+DefineProbe(0x47);
+DefineProbe(0x48);
+DefineProbe(0x49);
+DefineProbe(0x4a);
+DefineProbe(0x4b);
+DefineProbe(0x52);
+DefineProbe(0x53);
+DefineProbe(0xfe);
+DefineProbe(0xff);
+DefineProbe(0x801);
+DefineProbe(0x802);
+DefineProbe(0x803);
+DefineProbe(0x804);
+DefineProbe(0x805);
+DefineProbe(0x806);
+DefineProbe(0x807);
+DefineProbe(0x808);
+DefineProbe(0x809);
+DefineProbe(0x80a);
+DefineProbe(0x80b);
+DefineProbe(0x80c);
+DefineProbe(0x80d);
+DefineProbe(0x80e);
+DefineProbe(0x80f);
+DefineProbe(0x810);
+DefineProbe(0x811);
+DefineProbe(0x812);
+DefineProbe(0x813);
+DefineProbe(0x814);
+DefineProbe(0x815);
+DefineProbe(0x816);
+DefineProbe(0x817);
+DefineProbe(0x818);
+DefineProbe(0x819);
+DefineProbe(0x81a);
+DefineProbe(0x81b);
+DefineProbe(0x81c);
+DefineProbe(0x81d);
+DefineProbe(0x81e);
+DefineProbe(0x81f);
+DefineProbe(0x820);
+DefineProbe(0x821);
+DefineProbe(0x822);
+DefineProbe(0x823);
+DefineProbe(0x824);
+DefineProbe(0xc01);
+DefineProbe(0xc02);
+DefineProbe(0xc03);
+DefineProbe(0xc04);
+DefineProbe(0xc05);
+DefineProbe(0xc06);
+DefineProbe(0xc07);
+DefineProbe(0xc08);
+DefineProbe(0xc09);
+DefineProbe(0xc0a);
+DefineProbe(0xc0b);
+DefineProbe(0xc0c);
+DefineProbe(0xc0d);
+DefineProbe(0xc0e);
+
+DefineModule(DIR, 0x150000);
+DefineProbe(0x1);
+DefineProbe(0x2);
+DefineProbe(0x3);
+DefineProbe(0x4);
+DefineProbe(0x5);
+DefineProbe(0x6);
+DefineProbe(0x7);
+DefineProbe(0x8);
+DefineProbe(0x9);
+DefineProbe(0xa);
+DefineProbe(0xb);
+
+
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_base_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_base_shared.h
index dcb8e11ccd70..ba2f6912f85f 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_base_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_base_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_shared.h
index 14db7e0b4e13..f143c8af8625 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -689,6 +689,13 @@ typedef struct _gcsHAL_COMMIT
     /* Brother cores in user device of current commit process. */
     gctUINT32                   broCoreMask;
 
+#if gcdENABLE_MP_SWITCH
+    /* Multi-processor mode. */
+    gctUINT32                   mpMode;
+
+    /* Switch multi-processor mode. */
+    gctUINT32                   switchMpMode;
+#endif
 
 #if gcdENABLE_SW_PREEMPTION
     /* If user need to merge the delta. */
@@ -843,6 +850,8 @@ typedef struct _gcsHAL_GET_PROFILE_SETTING
     OUT gctBOOL                 enable;
     /* Profile mode */
     OUT gceProfilerMode         profileMode;
+    /* Probe mode */
+    OUT gceProbeMode            probeMode;
 }
 gcsHAL_GET_PROFILE_SETTING;
 
@@ -853,6 +862,8 @@ typedef struct _gcsHAL_SET_PROFILE_SETTING
     IN gctBOOL                  enable;
     /* Profile mode */
     IN gceProfilerMode          profileMode;
+    /* Probe mode */
+    IN gceProbeMode             probeMode;
 }
 gcsHAL_SET_PROFILE_SETTING;
 
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_vg_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_vg_shared.h
index 3c7472c9c5d5..07691f9ab399 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_vg_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_driver_vg_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -234,7 +234,7 @@ typedef struct _gcsTASK_FREE_VIDEO_MEMORY
     IN gceTASK                  id;
 
     /* Allocated video memory. */
-    IN gctUINT32                node;
+    IN gctUINT64                node;
 }
 gcsTASK_FREE_VIDEO_MEMORY;
 
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_enum_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_enum_shared.h
index baf9de383842..e5a35f2220e3 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_enum_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_enum_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -259,6 +259,7 @@ typedef enum _gceFEATURE
     gcvFEATURE_2D_10BIT_OUTPUT_LINEAR,
     gcvFEATURE_2D_YUV420_OUTPUT_LINEAR,
     gcvFEATURE_ACE,
+    gcvFEATURE_NO_YUV420_SOURCE,/* unsupported source with three planes */
     gcvFEATURE_COLOR_COMPRESSION,
     gcvFEATURE_32BPP_COMPONENT_TEXTURE_CHANNEL_SWIZZLE,
     gcvFEATURE_64BPP_HW_CLEAR_SUPPORT,
@@ -648,6 +649,20 @@ typedef enum _gceFEATURE
     gcvFEATURE_PE_A8B8G8R8, /* For PE support A8B8G8R8 format feature*/
     gcvFEATURE_DEPTHWISE_NEIGHBOR_IMG_DATA_TRANSFER_NOT_EFFICIENT_FIX,
 
+    /* FP16 enhancement-related features. */
+    gcvFEATURE_DST_TEX_I2F_F2I_INST_DEPRECATE,
+    gcvFEATURE_ALU_FP16_INST_SUPPORT,
+    gcvFEATURE_DUAL16_14BIT_PC_SUPPORT,
+    gcvFEATURE_LDST_CONV_4ROUNDING_MODES,
+    gcvFEATURE_FULL_PACK_MODE_SUPPORT,
+    gcvFEATURE_FP32_TO_FP16_CONV_FIX,
+
+    gcvFEATURE_SH_HAS_IMGLD_COMP_COUNT_FIX,
+    gcvFEATURE_SH_SUPPORT_FP32_FMA,
+
+    gcvFEATURE_SH_SUPPORT_VEC2_INT_MULMAD,
+    gcvFEATURE_SH_SUPPORT_VEC4_INT_MULMAD,
+
     /* AIGPU feature. */
     gcvFEATURE_AI_GPU,
     gcvFEATURE_NN_FAST_FIRST_PIXEL_POOLING,
@@ -689,7 +704,7 @@ typedef enum _gceFEATURE
 
     /* TP reorder the int tile x should be less than 512 */
     gcFEATURE_TP_REORDER_INTILE_X_SIZE_512_FIX,
-    gcFEATURE_NN_WASET_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE,
+    gcFEATURE_NN_WASTE_COEF_READ_WRITE_BANDWIDTH_128BYTE_VIPSRAM_IN_FULL_PATIAL_CACHE_MODE_FIX,
     gcFEATURE_BIT_BFP_COEF_AUTO_PAD_INCOMPLETE_ZERO_IN_KZ_PLANE,
     gcvFEATURE_NN_FLOAT32_IO,
     gcvFEATURE_TP_FLOAT32_IO,
@@ -733,6 +748,22 @@ typedef enum _gceFEATURE
     gcFEATURE_BIT_NN_ENHANCED_MAX_POOLING,
     gcvFEATURE_NN_1x1_NON_POOLING_PACKING,
     gcFEATURE_BIT_NN_SUPPORT_BOTH_CONV_NATIVE_STRIDE2_AND_POOLING,
+    gcFEATURE_BIT_NN_SUPPORT_ALU,
+    gcvFEATURE_BIT_NN_TRANSPOSE_PHASE2,
+    gcvFEATURE_BIT_NN_FC_ENHANCEMENT,
+    gcFEATURE_BIT_NN_2ND_IMG_BASE_ADDR_FIX,
+    gcFEATURE_BIT_NN_TENSOR_ADD_FIELD_MOVE_TO_EXT_CMD,
+
+    gcvFEATURE_IMGLD_WIDTH_LT16_FIX,
+    gcvFEATURE_BIT_GPU_INSPECTOR_COUNTERS,
+
+    gcvFEATURE_VIP_REMOVE_MMU,
+    gcFEATURE_BIT_TPLITE_SUPPORT_TP_DATA_TRANSPOSE,
+    gcvFEATURE_BIT_NN_JD_DIRECT_MODE_FIX,
+    gcFEATURE_BIT_NN_CONV_CORE_BYPASS,
+    gcvFEATURE_BIT_TP_REMOVE_FC,
+
+    gcvFEATURE_BIT_HI_DEFAULT_ENABLE_REORDER_FIX,
 
     /* Insert features above this comment only. */
     gcvFEATURE_COUNT                /* Not a feature. */
@@ -818,6 +849,7 @@ typedef enum _gceSURF_TYPE
     gcvSURF_3D                      = 0x200000, /* It's 3d surface */
     gcvSURF_DMABUF_EXPORTABLE       = 0x400000, /* master node can be exported as dma-buf fd */
     gcvSURF_CACHE_MODE_128          = 0x800000,
+    gcvSURF_TILED                   = 0x1000000, /* force create tile buffer, as we will convert it to supertile according to related hardware feature by default */
 
     gcvSURF_TEXTURE_LINEAR               = gcvSURF_TEXTURE
                                          | gcvSURF_LINEAR,
@@ -1433,6 +1465,7 @@ typedef enum _gceCORE
 #if gcdDEC_ENABLE_AHB
     gcvCORE_DEC,
 #endif
+    gcvCORE_2D1,
     gcvCORE_COUNT
 }
 gceCORE;
@@ -1982,11 +2015,35 @@ gceSYNC_VIDEO_MEMORY_REASON;
 
 typedef enum _gceProfilerMode
 {
-    gcvPROFILER_PROBE_MODE = 0,
-    gcvPROFILER_AHB_MODE   = 1,
+    gcvPROFILER_UNKNOWN_MODE = 0,
+    gcvPROFILER_PROBE_MODE,
+    gcvPROFILER_AHB_MODE,
 }
 gceProfilerMode;
 
+typedef enum _gceProbeMode
+{
+    gcvPROFILER_UNKNOWN_PROBE = 0,
+    gcvPROFILER_GPU_PROBE,
+    gcvPROFILER_VIP_PROBE,
+}
+gceProbeMode;
+
+typedef enum _gceMULTI_PROCESSOR_MODE
+{
+    gcvMP_MODE_COMBINED    = 0,
+    gcvMP_MODE_INDEPENDENT = 1
+}
+gceMULTI_PROCESSOR_MODE;
+
+typedef enum _gceSwitchMpMode
+{
+    gcvMP_MODE_NO_SWITCH = 0,
+    gcvMP_MODE_SWITCH_TO_SINGLE,
+    gcvMP_MODE_SWITCH_TO_MULTI,
+}
+gceSwitchMpMode;
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_profiler_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_profiler_shared.h
index 4a919236b0a2..e608aace7018 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_profiler_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_profiler_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -60,6 +60,11 @@
 extern "C" {
 #endif
 
+#define ANDROID_PROFILER_COUNTERS   1
+#define APP_INFO   1
+#define FPGA_INFO   0
+#define RECORD_COUNTER_ADDRESS  0
+
 /* HW profile information. */
 typedef struct _gcsPROFILER_COUNTERS_PART1
 {
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_types_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_types_shared.h
index 47c79994087c..9e878eccca03 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_types_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_types_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -127,7 +127,11 @@ extern "C" {
 
 #if defined(ANDROID) && defined(__BIONIC_FORTIFY)
 #if defined(__clang__)
-#       define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline))
+#if (__clang_major__ >= 10)
+#           define gcmINLINE            __inline__ __attribute__ ((always_inline))
+#       else
+#           define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline))
+#       endif
 #   else
 #       define gcmINLINE            __inline__ __attribute__ ((always_inline)) __attribute__ ((gnu_inline)) __attribute__ ((artificial))
 #   endif
@@ -297,7 +301,56 @@ gcuFLOAT_UINT32;
 #define gcvNEGONE_X             ((gctFIXED_POINT) 0xFFFF0000)
 #define gcvTWO_X                ((gctFIXED_POINT) 0x00020000)
 
-
+/* No special needs. */
+#define gcvALLOC_FLAG_NONE                  0x00000000
+
+/* Physical contiguous. */
+#define gcvALLOC_FLAG_CONTIGUOUS            0x00000001
+/* Physical non contiguous. */
+#define gcvALLOC_FLAG_NON_CONTIGUOUS        0x00000002
+
+/* Should not swap out. */
+#define gcvALLOC_FLAG_NON_PAGED             0x00000004
+
+/* CPU access explicitly needed. */
+#define gcvALLOC_FLAG_CPU_ACCESS            0x00000008
+/* Can be remapped as cacheable. */
+#define gcvALLOC_FLAG_CACHEABLE             0x00000010
+
+/* Need 32bit address. */
+#define gcvALLOC_FLAG_4GB_ADDR              0x00000020
+
+/* Secure buffer. */
+#define gcvALLOC_FLAG_SECURITY              0x00000040
+/* Can be exported as dmabuf-fd */
+#define gcvALLOC_FLAG_DMABUF_EXPORTABLE     0x00000080
+/* Do not try slow pools (gcvPOOL_VIRTUAL) */
+#define gcvALLOC_FLAG_FAST_POOLS            0x00000100
+
+/* Only accessed by GPU */
+#define gcvALLOC_FLAG_NON_CPU_ACCESS        0x00000200
+/* Do not be moved */
+#define gcvALLOC_FLAG_NO_EVICT              0x00000400
+
+/* Import DMABUF. */
+#define gcvALLOC_FLAG_DMABUF                0x00001000
+/* Import USERMEMORY. */
+#define gcvALLOC_FLAG_USERMEMORY            0x00002000
+/* Import an External Buffer. */
+#define gcvALLOC_FLAG_EXTERNAL_MEMORY       0x00004000
+/* Import linux reserved memory. */
+#define gcvALLOC_FLAG_LINUX_RESERVED_MEM    0x00008000
+
+/* 1M pages unit allocation. */
+#define gcvALLOC_FLAG_1M_PAGES              0x00010000
+
+/* Non 1M pages unit allocation. */
+#define gcvALLOC_FLAG_4K_PAGES              0x00020000
+
+/* Real allocation happens when GPU page fault. */
+#define gcvALLOC_FLAG_ALLOC_ON_FAULT        0x01000000
+/* Alloc with memory limit. */
+#define gcvALLOC_FLAG_MEMLIMIT              0x02000000
 
 #define gcmFIXEDCLAMP_NEG1_TO_1(_x) \
     (((_x) < gcvNEGONE_X) \
@@ -764,6 +817,26 @@ gcs2D_PROFILE;
         (((gctUINT32)(x) & (gctUINT32)0x00FF0000U) << 8)  | \
         (((gctUINT32)(x) & (gctUINT32)0xFF000000U) >> 8)))
 
+/*******************************************************************************
+**
+** gcmBSWAP16IN32EX
+**
+**      Return a value with whole 16 bit swapped of a 32 bit data type.
+*/
+#  define gcmBSWAP16IN32EX(x) ((gctUINT32)(\
+        (((gctUINT32)(x) & (gctUINT32)0x0000FFFFU) << 16)  | \
+        (((gctUINT32)(x) & (gctUINT32)0xFFFF0000U) >> 16)))
+
+/*******************************************************************************
+**
+** gcmBSWAP32IN64
+**
+**      Return a value with whole 32 bit swapped of a 64 bit data type.
+*/
+#  define gcmBSWAP32IN64(x) ((gctUINT64)(\
+        (((gctUINT64)(x) & (gctUINT64)0x00000000FFFFFFFFULL) << 32) | \
+        (((gctUINT64)(x) & (gctUINT64)0xFFFFFFFF00000000ULL) >> 32)))
+
 /*******************************************************************************
 ***** Database ****************************************************************/
 
@@ -982,6 +1055,17 @@ typedef struct _gcsHAL_PATCH_VIDMEM_TIMESTAMP
 }
 gcsHAL_PATCH_VIDMEM_TIMESTAMP;
 
+/* Put together patch list handling variables. */
+typedef struct _gcsPATCH_LIST_VARIABLE
+{
+    /* gcvHAL_PATCH_VIDMEM_TIMESTAMP. */
+    gctUINT64 maxAsyncTimestamp;
+
+    /* gcvHAL_PATCH_MCFE_SEMAPHORE. */
+    gctBOOL semaUsed;
+}
+gcsPATCH_LIST_VARIABLE;
+
 /*
     gcvFEATURE_DATABASE_DATE_MASK
 
diff --git a/drivers/staging/npu/kernel/inc/shared/gc_hal_vg_shared.h b/drivers/staging/npu/kernel/inc/shared/gc_hal_vg_shared.h
index e948b030583e..22a85408064d 100644
--- a/drivers/staging/npu/kernel/inc/shared/gc_hal_vg_shared.h
+++ b/drivers/staging/npu/kernel/inc/shared/gc_hal_vg_shared.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/kernel/makefile.linux b/drivers/staging/npu/kernel/makefile.linux
index 03c2a72329a2..fb39e03ac5ef 100755
--- a/drivers/staging/npu/kernel/makefile.linux
+++ b/drivers/staging/npu/kernel/makefile.linux
@@ -2,7 +2,7 @@
 #
 #    The MIT License (MIT)
 #
-#    Copyright (c) 2014 - 2020 Vivante Corporation
+#    Copyright (c) 2014 - 2021 Vivante Corporation
 #
 #    Permission is hereby granted, free of charge, to any person obtaining a
 #    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 #
 #    The GPL License (GPL)
 #
-#    Copyright (C) 2014 - 2020 Vivante Corporation
+#    Copyright (C) 2014 - 2021 Vivante Corporation
 #
 #    This program is free software; you can redistribute it and/or
 #    modify it under the terms of the GNU General Public License
@@ -86,7 +86,6 @@ CFLAGS += $(INCLUDE) -Werror -ansi
 
 OBJECTS = $(OBJ_DIR)/gc_hal_kernel_command.o \
           $(OBJ_DIR)/gc_hal_kernel_db.o \
-          $(OBJ_DIR)/gc_hal_kernel_debug.o \
           $(OBJ_DIR)/gc_hal_kernel_event.o \
           $(OBJ_DIR)/gc_hal_kernel_heap.o \
           $(OBJ_DIR)/gc_hal_kernel.o \
diff --git a/drivers/staging/npu/os/libGAL.def.mak b/drivers/staging/npu/os/libGAL.def.mak
index f3ca37432f2d..058dbe764c47 100755
--- a/drivers/staging/npu/os/libGAL.def.mak
+++ b/drivers/staging/npu/os/libGAL.def.mak
@@ -1,6 +1,6 @@
 ##############################################################################
 #
-#    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+#    Copyright (c) 2005 - 2021 by Vivante Corp.  All rights reserved.
 #
 #    The material in this file is confidential and contains trade secrets
 #    of Vivante Corporation. This is proprietary information owned by
@@ -51,6 +51,7 @@ EXPORTS
     gcoOS_DestroySignal
     gcoOS_DeviceControl
     gcoOS_EnableDebugBuffer
+    gcoOS_QueryCurrentProcessName
     gcoOS_Flush
     gcoOS_Free
     gcoOS_FreeLibrary
@@ -281,7 +282,9 @@ EXPORTS
     gcoHAL_GetPriority
     gcoHAL_GetLastCommitStatus
     gcoHAL_SetLastCommitStatus
+    gcoHAL_CommitDone
     gcoHAL_IsFlatMapped
+    gcoHAL_QueryMCFESemaphoreCapacity
 
 !IF "$(VIVANTE_ENABLE_3D)" == "1"
     gcoHAL_QueryShaderCaps
@@ -696,6 +699,8 @@ EXPORTS
     gcoCLHardware_Construct
 
     ; gcoPROFILER
+	gcoPROFILER_getVersion;
+	gcoPROFILER_getVPGConst
     gcoPROFILER_Construct
     gcoPROFILER_Destroy
     gcoPROFILER_Initialize
@@ -769,7 +774,7 @@ EXPORTS
     gcoVX_SetImageInfo
     gcoVX_BindKernel
     gcoVX_BindUniform
-	gcoVX_GetUniformBase
+    gcoVX_GetUniformBase
     gcoVX_InvokeKernel
     gcoVX_Commit
     gcoVX_AllocateMemory
@@ -797,6 +802,10 @@ EXPORTS
     gcoVX_SetRemapAddress
     gcoVX_ProgrammYUV2RGBScale
     gcoVX_CaptureState
+    gcoVX_StartCAPBUF
+    gcoVX_EndCAPBUF
+    gcoVX_QueryCAPBUFMetaData
+    gcoVX_FreeCAPBUFMetaQueryBuffer
     gcoVX_CreateHW
     gcoVX_DestroyHW
     gcoVX_VerifyHardware
@@ -807,15 +816,16 @@ EXPORTS
     gcoVX_SetHardwareType
     gcoVX_MultiGPUSync
     gcoVX_QueryNNClusters
-
-	DWLSetupApbFilter
-	DWLReadAxiFeHwCfg
-	DWLConfigAxiFe
-	DWLConfigAxiFeChns
-	DWLEnableAxiFe
-	DWLReadAxiFeStat
-	DWLDisableAxiFe
-	DWLResetAxiFe
+    gcoVX_QueryNNRingCount
+
+    DWLSetupApbFilter
+    DWLReadAxiFeHwCfg
+    DWLConfigAxiFe
+    DWLConfigAxiFeChns
+    DWLEnableAxiFe
+    DWLReadAxiFeStat
+    DWLDisableAxiFe
+    DWLResetAxiFe
 
 !IF "$(VSIMULATOR_DEBUG)" == "1"
     gcoOS_UpdateSimulatorCallback
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
index 91c3a6b022c6..55071ecc5934 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_array.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
index 91a04744ba17..dca6bb88340d 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dma.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -66,6 +66,11 @@
 #endif
 #include <linux/slab.h>
 #include <linux/platform_device.h>
+#if defined(CONFIG_X86)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+#include <asm/set_memory.h>
+#endif
+#endif
 
 #define _GC_OBJ_ZONE    gcvZONE_OS
 
@@ -256,17 +261,33 @@ _DmaGetSGT(
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
+    if (Allocator->os->iommu)
+    {
+        phys_addr_t phys;
+        for (i = 0; i < numPages; i++)
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,1,0)
+            phys = iommu_iova_to_phys(Allocator->os->iommu->domain, mdlPriv->dmaHandle + (i + skipPages) * PAGE_SIZE);
+#else
+            gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+#endif
+            pages[i] = pfn_to_page(phys >> PAGE_SHIFT);
+        }
+    }
+    else
+    {
 #if !defined(phys_to_page)
-    page = virt_to_page(mdlPriv->kvaddr);
+        page = virt_to_page(mdlPriv->kvaddr);
 #elif LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
-    page = phys_to_page(mdlPriv->dmaHandle);
+        page = phys_to_page(mdlPriv->dmaHandle);
 #else
-    page = phys_to_page(dma_to_phys(&Allocator->os->device->platform->device->dev, mdlPriv->dmaHandle));
+        page = phys_to_page(dma_to_phys(&Allocator->os->device->platform->device->dev, mdlPriv->dmaHandle));
 #endif
 
-    for (i = 0; i < numPages; ++i)
-    {
-        pages[i] = nth_page(page, i + skipPages);
+        for (i = 0; i < numPages; ++i)
+        {
+            pages[i] = nth_page(page, i + skipPages);
+        }
     }
 
     if (sg_alloc_table_from_pages(sgt, pages, numPages, offset, Bytes, GFP_KERNEL) < 0)
@@ -414,11 +435,7 @@ _DmaUnmapUser(
                 );
     }
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-    down_write(&current->mm->mmap_sem);
-	#endif
+    down_write(&current_mm_mmap_sem);
     if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
@@ -427,12 +444,11 @@ _DmaUnmapUser(
                 __FUNCTION__, __LINE__
                 );
     }
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-    up_write(&current->mm->mmap_sem);
-	#endif
+    up_write(&current_mm_mmap_sem);
 #endif
+
+    MdlMap->vma = NULL;
+    MdlMap->vmaAddr = NULL;
 }
 
 static gceSTATUS
@@ -449,30 +465,25 @@ _DmaMapUser(
     gcmkHEADER_ARG("Allocator=%p Mdl=%p Cacheable=%d", Allocator, Mdl, Cacheable);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+#if gcdANON_FILE_FOR_ALLOCATOR
+    userLogical = (gctPOINTER)vm_mmap(Allocator->anon_file,
+#else
     userLogical = (gctPOINTER)vm_mmap(gcvNULL,
+#endif
                     0L,
                     Mdl->numPages * PAGE_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED | MAP_NORESERVE,
                     0);
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-	down_write(&current->mm->mmap_sem);
-	#endif
-
+    down_write(&current_mm_mmap_sem);
     userLogical = (gctPOINTER)do_mmap_pgoff(gcvNULL,
                     0L,
                     Mdl->numPages * PAGE_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED,
                     0);
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-    up_write(&current->mm->mmap_sem);
-	#endif
+    up_write(&current_mm_mmap_sem);
 #endif
 
     gcmkTRACE_ZONE(
@@ -489,13 +500,13 @@ _DmaMapUser(
             __FUNCTION__, __LINE__
             );
 
+        userLogical = gcvNULL;
+
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-    down_write(&current->mm->mmap_lock);
-#else
-	down_write(&current->mm->mmap_sem);
-#endif
+
+    down_write(&current_mm_mmap_sem);
+
     do
     {
         struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)userLogical);
@@ -517,16 +528,14 @@ _DmaMapUser(
         MdlMap->vma = vma;
     }
     while (gcvFALSE);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-#else
-    up_write(&current->mm->mmap_sem);
-#endif
+
+    up_write(&current_mm_mmap_sem);
 
 OnError:
     if (gcmIS_ERROR(status) && userLogical)
     {
-        _DmaUnmapUser(Allocator, Mdl, userLogical, Mdl->numPages * PAGE_SIZE);
+        MdlMap->vmaAddr = userLogical;
+        _DmaUnmapUser(Allocator, Mdl, MdlMap, Mdl->numPages * PAGE_SIZE);
     }
     gcmkFOOTER();
     return status;
@@ -665,6 +674,15 @@ _DmaAlloctorInit(
 #endif
                           ;
 
+    if (Os->iommu)
+    {
+        /* Add some flags to ensure successful memory allocation */
+        allocator->capability |= gcvALLOC_FLAG_NON_CONTIGUOUS;
+        allocator->capability |= gcvALLOC_FLAG_1M_PAGES;
+        allocator->capability |= gcvALLOC_FLAG_CACHEABLE;
+        allocator->capability |= gcvALLOC_FLAG_MEMLIMIT;
+    }
+
     *Allocator = allocator;
 
     return gcvSTATUS_OK;
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
index ce64a0a53ea7..ddb026850f42 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_dmabuf.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -67,8 +67,6 @@
 #include <linux/dma-buf.h>
 #include <linux/platform_device.h>
 
-MODULE_IMPORT_NS(DMA_BUF);
-
 #define _GC_OBJ_ZONE gcvZONE_OS
 
 /* Descriptor of a dma_buf imported. */
@@ -239,6 +237,13 @@ _DmabufAttach(
         gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
     }
 
+    if (os->device->args.enableMmu == 0 &&
+        os->iommu == gcvNULL &&
+        sgt->nents != 1)
+    {
+        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+    }
+
     /* Prepare page array. */
     /* Get number of pages. */
     for_each_sg(sgt->sgl, s, sgt->orig_nents, i)
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
index 3ca3644ef86a..38b39c3d16b2 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_gfp.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -681,7 +681,6 @@ _GFPAlloc(
     for (i = 0; i < NumPages; i++)
     {
         struct page *page;
-        gctPHYS_ADDR_T phys = 0U;
 
         if (contiguous)
         {
@@ -693,9 +692,7 @@ _GFPAlloc(
         }
 
         SetPageReserved(page);
-
-        phys = page_to_phys(page);
-
+        
         /*for amlogic board, the page phys maybe start from 0x0000-0000*/
         /*BUG_ON(!phys);*/
 
@@ -1010,11 +1007,7 @@ _GFPUnmapUser(
                 );
     }
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-    down_write(&current->mm->mmap_sem);
-	#endif
+    down_write(&current_mm_mmap_sem);
     if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr, Size) < 0)
     {
         gcmkTRACE_ZONE(
@@ -1023,14 +1016,11 @@ _GFPUnmapUser(
                 __FUNCTION__, __LINE__
                 );
     }
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-    up_write(&current->mm->mmap_sem);
-	#endif
+    up_write(&current_mm_mmap_sem);
 #endif
 
     MdlMap->vma = NULL;
+    MdlMap->vmaAddr = NULL;
 }
 
 static gceSTATUS
@@ -1047,29 +1037,25 @@ _GFPMapUser(
     gcmkHEADER_ARG("Allocator=%p Mdl=%p Cacheable=%d", Allocator, Mdl, Cacheable);
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+#if gcdANON_FILE_FOR_ALLOCATOR
+    userLogical = (gctPOINTER)vm_mmap(Allocator->anon_file,
+#else
     userLogical = (gctPOINTER)vm_mmap(NULL,
+#endif
                     0L,
                     Mdl->numPages * PAGE_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED | MAP_NORESERVE,
                     0);
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-    down_write(&current->mm->mmap_sem);
-	#endif
+    down_write(&current_mm_mmap_sem);
     userLogical = (gctPOINTER)do_mmap_pgoff(NULL,
                     0L,
                     Mdl->numPages * PAGE_SIZE,
                     PROT_READ | PROT_WRITE,
                     MAP_SHARED,
                     0);
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-    up_write(&current->mm->mmap_sem);
-	#endif
+    up_write(&current_mm_mmap_sem);
 #endif
 
     gcmkTRACE_ZONE(
@@ -1093,11 +1079,8 @@ _GFPMapUser(
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-#else
-    down_write(&current->mm->mmap_sem);
-#endif
+    down_write(&current_mm_mmap_sem);
+
     do
     {
         struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)userLogical);
@@ -1117,11 +1100,8 @@ _GFPMapUser(
         MdlMap->vma = vma;
     }
     while (gcvFALSE);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-#else
-    up_write(&current->mm->mmap_sem);
-#endif
+
+    up_write(&current_mm_mmap_sem);
 
     if (gcmIS_SUCCESS(status))
     {
@@ -1132,7 +1112,8 @@ _GFPMapUser(
 OnError:
     if (gcmIS_ERROR(status) && userLogical)
     {
-        _GFPUnmapUser(Allocator, Mdl, userLogical, Mdl->numPages * PAGE_SIZE);
+        MdlMap->vmaAddr = userLogical;
+        _GFPUnmapUser(Allocator, Mdl, MdlMap, Mdl->numPages * PAGE_SIZE);
     }
     gcmkFOOTER();
     return status;
@@ -1380,6 +1361,11 @@ _GFPAlloctorInit(
     gckALLOCATOR allocator = gcvNULL;
     struct gfp_alloc *priv = gcvNULL;
 
+    if (Os->iommu)
+    {
+        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+    }
+
     gcmkONERROR(
         gckALLOCATOR_Construct(Os, &GFPAllocatorOperations, &allocator));
 
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
index 36e68331dc0f..e69815f55bc5 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_reserved_mem.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -212,6 +212,11 @@ reserved_mem_attach(
 
     Mdl->priv = res;
 
+    if ((res->start + res->size) < 0xFFFFFFFF)
+    {
+        Allocator->capability |= gcvALLOC_FLAG_4GB_ADDR;
+    }
+
     return gcvSTATUS_OK;
 }
 
@@ -312,21 +317,16 @@ reserved_mem_unmap_user(
         printk("%s: vm_munmap failed\n", __func__);
     }
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-    down_write(&current->mm->mmap_sem);
-	#endif
+    down_write(&current_mm_mmap_sem);
     if (do_munmap(current->mm, (unsigned long)MdlMap->vmaAddr - res->offset_in_page, res->size) < 0)
     {
         printk("%s: do_munmap failed\n", __func__);
     }
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-    up_write(&current->mm->mmap_sem);
-	#endif
+    up_write(&current_mm_mmap_sem);
 #endif
+
+    MdlMap->vma = NULL;
+    MdlMap->vmaAddr = NULL;
 }
 
 static gceSTATUS
@@ -350,21 +350,17 @@ reserved_mem_map_user(
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+#if gcdANON_FILE_FOR_ALLOCATOR
+    userLogical = (gctPOINTER)vm_mmap(Allocator->anon_file, 0L, res->size,
+#else
     userLogical = (gctPOINTER)vm_mmap(NULL, 0L, res->size,
+#endif
                 PROT_READ | PROT_WRITE, MAP_SHARED | MAP_NORESERVE, 0);
 #else
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-	#else
-	down_write(&current->mm->mmap_sem);
-	#endif
-	userLogical = (gctPOINTER)do_mmap_pgoff(NULL, 0L, res->size,
-				PROT_READ | PROT_WRITE, MAP_SHARED, 0);
-	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-	#else
-	up_write(&current->mm->mmap_sem);
-	#endif
+    down_write(&current_mm_mmap_sem);
+    userLogical = (gctPOINTER)do_mmap_pgoff(NULL, 0L, res->size,
+                PROT_READ | PROT_WRITE, MAP_SHARED, 0);
+    up_write(&current_mm_mmap_sem);
 #endif
 
     gcmkTRACE_ZONE(
@@ -381,13 +377,13 @@ reserved_mem_map_user(
             __FUNCTION__, __LINE__
             );
 
+        userLogical = gcvNULL;
+
         gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
     }
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_write(&current->mm->mmap_lock);
-#else
-    down_write(&current->mm->mmap_sem);
-#endif
+
+    down_write(&current_mm_mmap_sem);
+
     do
     {
         struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)userLogical);
@@ -409,16 +405,14 @@ reserved_mem_map_user(
         MdlMap->vma = vma;
     }
     while (gcvFALSE);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_write(&current->mm->mmap_lock);
-#else
-    up_write(&current->mm->mmap_sem);
-#endif
+
+    up_write(&current_mm_mmap_sem);
 
 OnError:
     if (gcmIS_ERROR(status) && userLogical)
     {
-        reserved_mem_unmap_user(Allocator, Mdl, userLogical, res->size);
+        MdlMap->vmaAddr = userLogical + res->offset_in_page;
+        reserved_mem_unmap_user(Allocator, Mdl, MdlMap, res->size);
     }
 Out:
     gcmkFOOTER();
@@ -447,16 +441,14 @@ reserved_mem_map_kernel(
         return gcvSTATUS_INVALID_ARGUMENT;
     }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
 #if gcdENABLE_BUFFERABLE_VIDEO_MEMORY
-    vaddr = memremap(res->start + Offset, Bytes, MEMREMAP_WC);
+    vaddr = ioremap_wc(res->start + Offset, Bytes);
 #else
-    vaddr = memremap(res->start + Offset, Bytes, MEMREMAP_WT);
-#endif
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
-    vaddr = memremap(res->start + Offset, Bytes, MEMREMAP_WT);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+    vaddr = ioremap(res->start + Offset, Bytes);
 #else
     vaddr = ioremap_nocache(res->start + Offset, Bytes);
+#endif
 #endif
 
     if (!vaddr)
@@ -480,11 +472,8 @@ reserved_mem_unmap_kernel(
         return gcvSTATUS_NOT_SUPPORTED;
     }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
-    memunmap((void *)Logical);
-#else
     iounmap((void *)Logical);
-#endif
+
     return gcvSTATUS_OK;
 }
 
@@ -591,8 +580,7 @@ _ReservedMemoryAllocatorInit(
     allocator->capability = gcvALLOC_FLAG_LINUX_RESERVED_MEM
                           | gcvALLOC_FLAG_CONTIGUOUS
                           | gcvALLOC_FLAG_CPU_ACCESS
-                          | gcvALLOC_FLAG_NON_CPU_ACCESS
-                          | gcvALLOC_FLAG_4GB_ADDR;
+                          | gcvALLOC_FLAG_NON_CPU_ACCESS;
 
     *Allocator = allocator;
 
diff --git a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
index 58dcbaa83c77..f4cb89ebe8b2 100644
--- a/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
+++ b/drivers/staging/npu/os/linux/kernel/allocator/default/gc_hal_kernel_allocator_user_memory.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -93,7 +93,6 @@ struct um_desc
         struct
         {
             struct page **pages;
-            struct sg_table sgt;
         };
 
         /* UM_PFN_MAP. */
@@ -104,6 +103,8 @@ struct um_desc
         };
     };
 
+    struct sg_table sgt;
+
     /* contiguous chunks, does not include padding pages. */
     int chunk_count;
 
@@ -111,20 +112,48 @@ struct um_desc
     unsigned long user_vaddr;
     size_t size;
     unsigned long offset;
+    dma_addr_t dmaHandle;
 
     size_t pageCount;
     size_t extraPage;
 };
 
-static int import_physical_map(struct um_desc *um, unsigned long phys)
+static int import_physical_map(gckOS Os, struct um_desc *um, unsigned long phys)
 {
     um->type = UM_PHYSICAL_MAP;
     um->physical = phys & PAGE_MASK;
     um->chunk_count = 1;
+
+    if (Os->iommu)
+    {
+        dma_addr_t dmaHandle;
+        unsigned long pfn = phys >> PAGE_SHIFT;
+
+        if (pfn_valid(pfn))
+        {
+            dmaHandle = dma_map_page(galcore_device, pfn_to_page(pfn), 0, um->size, DMA_BIDIRECTIONAL);
+        }
+        else
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+            dmaHandle = dma_map_resource(galcore_device, phys, um->size, DMA_BIDIRECTIONAL, 0);
+#else
+            dmaHandle = dma_map_page(galcore_device, pfn_to_page(pfn), 0, um->size, DMA_BIDIRECTIONAL);
+#endif
+        }
+
+        if (dma_mapping_error(galcore_device, dmaHandle))
+        {
+            return gcvSTATUS_OUT_OF_MEMORY;
+        }
+
+        um->dmaHandle = dmaHandle;
+    }
+
     return 0;
 }
 
-static int import_page_map(struct um_desc *um,
+static int import_page_map(gckOS Os, struct um_desc *um,
                 unsigned long addr, size_t page_count, size_t size)
 {
     int i;
@@ -141,20 +170,22 @@ static int import_page_map(struct um_desc *um,
     if (!pages)
         return -ENOMEM;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_read(&current->mm->mmap_lock);
-#else
-    down_read(&current->mm->mmap_sem);
-#endif
+    down_read(&current_mm_mmap_sem);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) && LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+    result = get_user_pages_longterm(
+#else
     result = get_user_pages(
+#endif
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
             current,
             current->mm,
 #endif
             addr & PAGE_MASK,
             page_count,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+            FOLL_WRITE | FOLL_LONGTERM,
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0) || defined(CONFIG_PPC)
             FOLL_WRITE,
 #else
             1,
@@ -162,11 +193,8 @@ static int import_page_map(struct um_desc *um,
 #endif
             pages,
             NULL);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_read(&current->mm->mmap_lock);
-#else
-    up_read(&current->mm->mmap_sem);
-#endif
+
+    up_read(&current_mm_mmap_sem);
 
     if (result < page_count)
     {
@@ -215,6 +243,11 @@ static int import_page_map(struct um_desc *um,
         goto error;
     }
 
+    if (Os->iommu)
+    {
+        um->dmaHandle = sg_dma_address(um->sgt.sgl);
+    }
+
     dma_sync_sg_for_cpu(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_FROM_DEVICE);
 
     um->type = UM_PAGE_MAP;
@@ -238,28 +271,23 @@ static int import_page_map(struct um_desc *um,
 }
 
 
-static int import_pfn_map(struct um_desc *um,
+static int import_pfn_map(gckOS Os, struct um_desc *um,
                 unsigned long addr, size_t pfn_count)
 {
     int i;
     struct vm_area_struct *vma;
     unsigned long *pfns;
     int *refs;
+    struct page **pages = gcvNULL;
+    int result = 0;
+    size_t pageCount = 0;
 
     if (!current->mm)
         return -ENOTTY;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	down_read(&current->mm->mmap_lock);
-#else
-    down_read(&current->mm->mmap_sem);
-#endif
+    down_read(&current_mm_mmap_sem);
     vma = find_vma(current->mm, addr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-	up_read(&current->mm->mmap_lock);
-#else
-    up_read(&current->mm->mmap_sem);
-#endif
+    up_read(&current_mm_mmap_sem);
 
     if (!vma)
         return -ENOTTY;
@@ -277,10 +305,21 @@ static int import_pfn_map(struct um_desc *um,
         return -ENOMEM;
     }
 
+    pages = kzalloc(pfn_count * sizeof(void *), GFP_KERNEL | gcdNOWARN);
+    if (!pages)
+    {
+        kfree(pfns);
+        kfree(refs);
+        return -ENOMEM;
+    }
+
     for (i = 0; i < pfn_count; i++)
     {
         spinlock_t *ptl;
         pgd_t *pgd;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (5,9,0)
+        p4d_t *p4d;
+#endif
         pud_t *pud;
         pmd_t *pmd;
         pte_t *pte;
@@ -295,10 +334,16 @@ static int import_pfn_map(struct um_desc *um,
 #elif (defined(CONFIG_CPU_CSKYV2)) \
     && LINUX_VERSION_CODE >= KERNEL_VERSION (4,11,0)
         pud = pud_offset((p4d_t*)pgd, addr);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION (5,12,0)
-		pud = pud_offset((p4d_t*)pgd, addr);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (5,9,0)
+        p4d = p4d_offset(pgd, addr);
+        if (p4d_none(READ_ONCE(*p4d)))
+            goto err;
+
+        pud = pud_offset(p4d, addr);
 #else
         pud = pud_offset(pgd, addr);
+#endif
 #endif
         if (pud_none(*pud) || pud_bad(*pud))
             goto err;
@@ -308,11 +353,6 @@ static int import_pfn_map(struct um_desc *um,
             goto err;
 
         pte = pte_offset_map_lock(current->mm, pmd, addr, &ptl);
-        if (!pte)
-        {
-            spin_unlock(ptl);
-            goto err;
-        }
 
         if (!pte_present(*pte))
         {
@@ -333,6 +373,8 @@ static int import_pfn_map(struct um_desc *um,
         {
             struct page *page = pfn_to_page(pfns[i]);
             refs[i] = get_page_unless_zero(page);
+            pages[i] = page;
+            pageCount++;
         }
     }
 
@@ -345,6 +387,48 @@ static int import_pfn_map(struct um_desc *um,
         }
     }
 
+    if (pageCount == pfn_count)
+    {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+        result = sg_alloc_table_from_pages(&um->sgt, pages, pfn_count,
+                        addr & ~PAGE_MASK, pfn_count * PAGE_SIZE, GFP_KERNEL | gcdNOWARN);
+
+#else
+        result = alloc_sg_list_from_pages(&um->sgt.sgl, pages, pfn_count,
+                        addr & ~PAGE_MASK, pfn_count * PAGE_SIZE, &um->sgt.nents);
+
+        um->sgt.orig_nents = um->sgt.nents;
+#endif
+        if (unlikely(result < 0))
+        {
+            printk("[galcore]: %s: sg_alloc_table_from_pages failed\n", __FUNCTION__);
+            goto err;
+        }
+
+        result = dma_map_sg(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_TO_DEVICE);
+
+        if (unlikely(result != um->sgt.nents))
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+            sg_free_table(&um->sgt);
+#else
+            kfree(um->sgt.sgl);
+#endif
+            printk("[galcore]: %s: dma_map_sg failed\n", __FUNCTION__);
+            goto err;
+        }
+
+        if (Os->iommu)
+        {
+            um->dmaHandle = sg_dma_address(um->sgt.sgl);
+        }
+    }
+
+    kfree(pages);
+    pages = gcvNULL;
+
     um->type = UM_PFN_MAP;
     um->pfns = pfns;
     um->refs = refs;
@@ -357,6 +441,9 @@ static int import_pfn_map(struct um_desc *um,
     if (refs)
         kfree(refs);
 
+    if (pages)
+        kfree(pages);
+
     return -ENOTTY;
 }
 
@@ -385,7 +472,7 @@ _Import(
     gcmkVERIFY_ARGUMENT(Memory != gcvNULL || Physical != ~0ULL);
     gcmkVERIFY_ARGUMENT(Size > 0);
 
-    memory = (Physical != gcvINVALID_PHYSICAL_ADDRESS) ? Physical : (gctSIZE_T)Memory;
+    memory = (Physical != gcvINVALID_PHYSICAL_ADDRESS) ? Physical : untagged_addr((gctSIZE_T)Memory);
 
     /* Get the number of required pages. */
     end = (memory + Size + PAGE_SIZE - 1) >> PAGE_SHIFT;
@@ -424,7 +511,9 @@ _Import(
             vaddr += PAGE_SIZE;
         }
 
+        down_read(&current_mm_mmap_sem);
         vma = find_vma(current->mm, memory);
+        up_read(&current_mm_mmap_sem);
 
         if (!vma)
         {
@@ -440,6 +529,7 @@ _Import(
         vm_flags = vma->vm_flags;
         vaddr = vma->vm_end;
 
+        down_read(&current_mm_mmap_sem);
         while (vaddr < memory + Size)
         {
             vma = find_vma(current->mm, vaddr);
@@ -447,32 +537,35 @@ _Import(
             if (!vma)
             {
                 /* No such memory. */
+                up_read(&current_mm_mmap_sem);
                 gcmkONERROR(gcvSTATUS_INVALID_ARGUMENT);
             }
 
             if ((vma->vm_flags & VM_PFNMAP) != (vm_flags & VM_PFNMAP))
             {
                 /* Can not support different map type: both PFN and PAGE detected. */
+                up_read(&current_mm_mmap_sem);
                 gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
             }
 
             vaddr = vma->vm_end;
         }
+        up_read(&current_mm_mmap_sem);
     }
 
     if (Physical != gcvINVALID_PHYSICAL_ADDRESS)
     {
-        result = import_physical_map(UserMemory, Physical);
+        result = import_physical_map(Os, UserMemory, Physical);
     }
     else
     {
         if (vm_flags & VM_PFNMAP)
         {
-            result = import_pfn_map(UserMemory, memory, pageCount);
+            result = import_pfn_map(Os, UserMemory, memory, pageCount);
         }
         else
         {
-            result = import_page_map(UserMemory, memory, pageCount, Size);
+            result = import_page_map(Os, UserMemory, memory, pageCount, Size);
         }
     }
 
@@ -588,11 +681,30 @@ _UserMemoryAttach(
     return status;
 }
 
-static void release_physical_map(struct um_desc *um)
+static void release_physical_map(gckOS Os, struct um_desc *um)
 {
+    if (Os->iommu)
+    {
+        unsigned long pfn = um->physical >> PAGE_SHIFT;
+
+        if (pfn_valid(pfn))
+        {
+            dma_unmap_page(galcore_device, um->dmaHandle, um->size, DMA_BIDIRECTIONAL);
+        }
+        else
+        {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
+            dma_unmap_resource(galcore_device, um->physical, um->size, DMA_BIDIRECTIONAL, 0);
+#else
+            dma_unmap_page(galcore_device, um->dmaHandle, um->size, DMA_BIDIRECTIONAL);
+#endif
+        }
+
+        um->dmaHandle = 0;
+    }
 }
 
-static void release_page_map(struct um_desc *um)
+static void release_page_map(gckOS Os, struct um_desc *um)
 {
     int i;
     dma_sync_sg_for_device(galcore_device,
@@ -603,6 +715,8 @@ static void release_page_map(struct um_desc *um)
 
     dma_unmap_sg(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_FROM_DEVICE);
 
+    um->dmaHandle = 0;
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
     && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
     sg_free_table(&um->sgt);
@@ -623,11 +737,25 @@ static void release_page_map(struct um_desc *um)
     kfree(um->pages);
 }
 
-static void release_pfn_map(struct um_desc *um)
+static void release_pfn_map(gckOS Os, struct um_desc *um)
 {
 
     int i;
 
+    if (Os->iommu)
+    {
+        dma_unmap_sg(galcore_device, um->sgt.sgl, um->sgt.nents, DMA_FROM_DEVICE);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (3,6,0) \
+    && (defined(ARCH_HAS_SG_CHAIN) || defined(CONFIG_ARCH_HAS_SG_CHAIN))
+        sg_free_table(&um->sgt);
+#else
+        kfree(um->sgt.sgl);
+#endif
+    }
+
+    um->dmaHandle = 0;
+
     for (i = 0; i < um->pageCount; i++)
     {
         if (pfn_valid(um->pfns[i]))
@@ -665,13 +793,13 @@ _UserMemoryFree(
         switch (userMemory->type)
         {
         case UM_PHYSICAL_MAP:
-            release_physical_map(userMemory);
+            release_physical_map(os, userMemory);
             break;
         case UM_PAGE_MAP:
-            release_page_map(userMemory);
+            release_page_map(os, userMemory);
             break;
         case UM_PFN_MAP:
-            release_pfn_map(userMemory);
+            release_pfn_map(os, userMemory);
             break;
         }
 
@@ -745,7 +873,7 @@ _UserMemoryCache(
     struct um_desc *um = Mdl->priv;
     enum dma_data_direction dir;
 
-    if (um->type != UM_PAGE_MAP)
+    if (um->type == UM_PHYSICAL_MAP)
     {
         _MemoryBarrier();
         return gcvSTATUS_OK;
@@ -799,7 +927,14 @@ _UserMemoryPhysical(
     {
         if (index < userMemory->pageCount + userMemory->extraPage)
         {
-            *Physical = page_to_phys(os->paddingPage);
+            if (os->iommu)
+            {
+                *Physical = os->iommu->paddingPageDmaHandle;
+            }
+            else
+            {
+                *Physical = page_to_phys(os->paddingPage);
+            }
         }
         else
         {
@@ -808,17 +943,24 @@ _UserMemoryPhysical(
     }
     else
     {
-        switch (userMemory->type)
+        if (os->iommu)
         {
-        case UM_PHYSICAL_MAP:
-            *Physical = userMemory->physical + (gctPHYS_ADDR_T)index * PAGE_SIZE;
-            break;
-        case UM_PAGE_MAP:
-            *Physical = page_to_phys(userMemory->pages[index]);
-            break;
-        case UM_PFN_MAP:
-            *Physical = (gctPHYS_ADDR_T)userMemory->pfns[index] << PAGE_SHIFT;
-            break;
+            *Physical = userMemory->dmaHandle + (gctPHYS_ADDR_T)index * PAGE_SIZE;
+        }
+        else
+        {
+            switch (userMemory->type)
+            {
+            case UM_PHYSICAL_MAP:
+                *Physical = userMemory->physical + (gctPHYS_ADDR_T)index * PAGE_SIZE;
+                break;
+            case UM_PAGE_MAP:
+                *Physical = page_to_phys(userMemory->pages[index]);
+                break;
+            case UM_PFN_MAP:
+                *Physical = (gctPHYS_ADDR_T)userMemory->pfns[index] << PAGE_SHIFT;
+                break;
+            }
         }
     }
 
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.c
index d788c3a718eb..fff1c43186b5 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -107,6 +107,17 @@ _AllocatorDebugfsCleanup(
 /***************************************************************************\
 ************************ Allocator management *******************************
 \***************************************************************************/
+#if gcdANON_FILE_FOR_ALLOCATOR
+static int tmp_mmap(struct file *fp, struct vm_area_struct *vma)
+{
+    return 0;
+}
+static const struct file_operations tmp_fops =
+{
+    .mmap = tmp_mmap,
+};
+
+#endif
 
 gceSTATUS
 gckOS_ImportAllocators(
@@ -117,6 +128,13 @@ gckOS_ImportAllocators(
     gctUINT i;
     gckALLOCATOR allocator;
 
+#if gcdANON_FILE_FOR_ALLOCATOR
+    struct file * anon_file = gcvNULL;
+    gctINT32 ufd = 0;
+    ufd = anon_inode_getfd("[galcore]", &tmp_fops, gcvNULL, O_RDWR);
+    anon_file = fget(ufd);
+#endif
+
     _AllocatorDebugfsInit(Os);
 
     INIT_LIST_HEAD(&Os->allocatorList);
@@ -137,7 +155,9 @@ gckOS_ImportAllocators(
             }
 
             allocator->name = allocatorArray[i].name;
-
+#if gcdANON_FILE_FOR_ALLOCATOR
+            allocator->anon_file = anon_file;
+#endif
             list_add_tail(&allocator->link, &Os->allocatorList);
         }
     }
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.h
index ff058f5dffac..20e5a2b27615 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_allocator.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -456,6 +456,10 @@ typedef struct _gcsALLOCATOR
     void                      (*destructor)(struct _gcsALLOCATOR *);
 
     struct list_head          link;
+#if gcdANON_FILE_FOR_ALLOCATOR
+    /*Anonymous file for map to user. */
+    struct file *             anon_file;
+#endif
 }
 gcsALLOCATOR;
 
diff --git a/drivers/staging/npu/kernel/gc_hal_kernel_debug.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.c
similarity index 98%
rename from drivers/staging/npu/kernel/gc_hal_kernel_debug.c
rename to drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.c
index 290f608fb813..2c4463df1b6f 100644
--- a/drivers/staging/npu/kernel/gc_hal_kernel_debug.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -62,11 +62,12 @@
 
 static gceSTATUS _lastError  = gcvSTATUS_OK;
 static gctUINT32 _debugLevel = gcvLEVEL_ERROR;
+extern int aml_debuglevel;
 /*
 _debugZones config value
 Please Reference define in gc_hal_base.h
 */
-static gctUINT32 _debugZones = gcdZONE_NONE;
+static gctUINT32 _debugZones = gcdZONE_ALL;/*gcdZONE_NONE ==> gcdZONE_ALL*/
 
 /******************************************************************************\
 ********************************* Debug Switches *******************************
@@ -540,6 +541,7 @@ gckOS_DebugTrace(
     ...
     )
 {
+    _debugLevel = aml_debuglevel;
     if (Level > _debugLevel)
     {
         return;
@@ -581,6 +583,7 @@ gckOS_DebugTraceZone(
     ...
     )
 {
+    _debugLevel = aml_debuglevel;
     if ((Level > _debugLevel) || !(Zone & _debugZones))
     {
         return;
@@ -953,9 +956,6 @@ gckOS_DebugStatus2Name(
 ***** Kernel Dump **************************************************************
 *******************************************************************************/
 
-/*
- * TODO: Dump to file is only valid in linux currently.
- */
 #ifndef gcmkDUMP_STRING
 #  define gcmkDUMP_STRING(os, s)    gcmkOUTPUT_STRING((s))
 #endif
@@ -1304,9 +1304,3 @@ gckOS_DumpBuffer(
         _DumpDataBuffer(Os, Type, Buffer, Address, Size);
     }
 }
-
-
-/*******************************************************************************
-***** Binary Trace *************************************************************
-*******************************************************************************/
-
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.h
index e33305b8d22a..a41838026076 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debug.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -59,7 +59,7 @@
 #include <gc_hal_kernel_linux.h>
 #include <linux/spinlock.h>
 #include <linux/time.h>
-#include <linux/stdarg.h>
+#include <stdarg.h>
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,14,0)
 #include <linux/nmi.h>
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.c
index 46c3b06efd2d..897257ddbf7d 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.h
index 9a1b01634461..dc0257fff5d2 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_debugfs.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -53,7 +53,7 @@
 *****************************************************************************/
 
 
-#include <linux/stdarg.h>
+#include <stdarg.h>
 
 #ifndef __gc_hal_kernel_debugfs_h_
 #define __gc_hal_kernel_debugfs_h_
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.c
index 389b21473c6a..d18b2b0a2ae5 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -66,11 +66,6 @@
 
 #define _GC_OBJ_ZONE    gcvZONE_DEVICE
 
-#define DEBUG_FILE          "galcore_trace"
-#define PARENT_FILE         "gpu"
-
-#define gcdDEBUG_FS_WARN    "Experimental debug entry, may be removed in future release, do NOT rely on it!\n"
-
 static gckGALDEVICE galDevice;
 
 extern gcTA globalTA[16];
@@ -315,411 +310,181 @@ int gc_meminfo_show(void* m, void* data)
     return len;
 }
 
-static const char * vidmemTypeStr[gcvVIDMEM_TYPE_COUNT] =
+int gc_load_show(void* m, void* data)
 {
-    "Generic",
-    "Index",
-    "Vertex",
-    "Texture",
-    "RenderTarget",
-    "Depth",
-    "Bitmap",
-    "TileStatus",
-    "Image",
-    "Mask",
-    "Scissor",
-    "HZ",
-    "ICache",
-    "TxDesc",
-    "Fence",
-    "TFBHeader",
-    "Command",
-};
-
-static const char * poolStr[gcvPOOL_NUMBER_OF_POOLS] =
-{
-    "Unknown",
-    "Default",
-    "Local",
-    "Internal",
-    "External",
-    "Unified",
-    "System",
-    "Sram",
-    "Virtual",
-    "User",
-    "Insram",
-    "Exsram",
-    "Exclusive",
-};
-
-static int
-_ShowDummyRecord(
-    IN void *File,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    return 0;
-}
-
-static int
-_ShowVideoMemoryRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    gctUINT32 handle;
-    gckVIDMEM_NODE nodeObject;
-    gctPHYS_ADDR_T physical;
-    gctINT32 refCount = 0;
-    gctINT32 lockCount = 0;
-    gceSTATUS status;
     int len = 0;
+    gctUINT32 i = 0;
+    gceSTATUS status = gcvSTATUS_OK;
+    gckGALDEVICE device = galDevice;
+    gceCHIPPOWERSTATE statesStored, state;
+    gctUINT32 load[gcvCORE_3D_MAX + 1] = {0};
+    gctUINT32 hi_total_cycle_count[gcvCORE_3D_MAX + 1] = {0};
+    gctUINT32 hi_total_idle_cycle_count[gcvCORE_3D_MAX + 1] = {0};
+    static gctBOOL profilerEnable[gcvCORE_3D_MAX + 1] = {gcvFALSE};
+
 #ifdef CONFIG_DEBUG_FS
     void* ptr = m;
 #else
     char* ptr = (char*)m;
 #endif
 
-    len = fs_printf(ptr, "Video Memory Node:\n");
-    len += fs_printf(ptr + len, "  handle         nodeObject       size         type     pool     physical  ref lock\n");
+    if (!device)
+        return -ENXIO;
 
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
+    for (i = 0; i <= gcvCORE_3D_MAX; i++)
     {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
-
-        while (r != NULL)
+        if (device->kernels[i])
         {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
-
-            if (record->type != gcvDB_VIDEO_MEMORY)
-            {
-                continue;
-            }
-
-            handle = gcmPTR2INT32(record->data);
-
-            status = gckVIDMEM_HANDLE_Lookup2(
-                record->kernel,
-                Database,
-                handle,
-                &nodeObject
-                );
-
-            if (gcmIS_ERROR(status))
+            if (device->kernels[i]->hardware)
             {
-                len += fs_printf(ptr + len, "%6u Invalid Node\n", handle);
-                continue;
-            }
-
-            gcmkONERROR(gckVIDMEM_NODE_GetPhysical(record->kernel, nodeObject, 0, &physical));
-            gcmkONERROR(gckVIDMEM_NODE_GetReference(record->kernel, nodeObject, &refCount));
-            gcmkONERROR(gckVIDMEM_NODE_GetLockCount(record->kernel, nodeObject, &lockCount));
-
-            len += fs_printf(ptr + len, "%#8x %#18lx %10lu %12s %8s %#12llx %4d %4d\n",
-                handle,
-                (unsigned long)nodeObject,
-                (unsigned long)record->bytes,
-                vidmemTypeStr[nodeObject->type],
-                poolStr[nodeObject->pool],
-                physical,
-                refCount,
-                lockCount
-                );
-        }
-    }
+                gckHARDWARE Hardware = device->kernels[i]->hardware;
+                gctBOOL powerManagement = Hardware->options.powerManagement;
 
-OnError:
-    return len;
-}
+                if (powerManagement)
+                {
+                    gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                        Hardware, gcvFALSE
+                        ));
+                }
 
-static int
-_ShowCommandBufferRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    return 0;
-}
+                gcmkONERROR(gckHARDWARE_QueryPowerState(
+                    Hardware, &statesStored
+                    ));
 
-static int
-_ShowNonPagedRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
+                gcmkONERROR(gckHARDWARE_SetPowerState(
+                    Hardware, gcvPOWER_ON_AUTO
+                    ));
 
-    len = fs_printf(ptr, "NonPaged Memory:\n");
-    len += fs_printf(ptr + len, "  name              vaddr       size\n");
+                if (!profilerEnable[i])
+                {
+                    gcmkONERROR(gckHARDWARE_SetGpuProfiler(
+                        Hardware,
+                        gcvTRUE
+                        ));
 
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
-    {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
+                    gcmkONERROR(gckHARDWARE_InitProfiler(Hardware));
 
-        while (r != NULL)
-        {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
+                    profilerEnable[i] = gcvTRUE;
+                }
 
-            if (record->type != gcvDB_NON_PAGED)
-            {
-                continue;
+                Hardware->waitCount = 200 * 100;
             }
-
-            len += fs_printf(ptr + len, "%6u %#18lx %10lu\n",
-                gcmPTR2INT32(record->physical),
-                (unsigned long)record->data,
-                (unsigned long)record->bytes
-                );
         }
     }
-    return len;
-}
 
-static int
-_ShowContiguousRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    return 0;
-}
-
-static int
-_ShowSignalRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
-
-    len = fs_printf(ptr, "User signal:\n");
-
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
+    for (i = 0; i <= gcvCORE_3D_MAX; i++)
     {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
-
-        while (r != NULL)
+        if (device->kernels[i])
         {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
-
-            if (record->type != gcvDB_SIGNAL)
+            if (device->kernels[i]->hardware)
             {
-                continue;
+                gcmkONERROR(gckHARDWARE_CleanCycleCount(device->kernels[i]->hardware));
             }
-
-            len += fs_printf(ptr + len, "%#10x\n", gcmPTR2INT32(record->data));
         }
     }
-    return len;
-}
-
-static int
-_ShowLockRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    gceSTATUS status;
-    gctUINT32 handle;
-    gckVIDMEM_NODE nodeObject;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
-
-    len = fs_printf(ptr, "Video Memory Lock:\n");
-    len += fs_printf(ptr + len, "  handle         nodeObject              vaddr\n");
 
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
+    for (i = 0; i <= gcvCORE_3D_MAX; i++)
     {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
-
-        while (r != NULL)
+        if (device->kernels[i])
         {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
-
-            if (record->type != gcvDB_VIDEO_MEMORY_LOCKED)
+            if (device->kernels[i]->hardware)
             {
-                continue;
+                gcmkONERROR(gckHARDWARE_QueryCycleCount(device->kernels[i]->hardware, &hi_total_cycle_count[i], &hi_total_idle_cycle_count[i]));
             }
-
-            handle = gcmPTR2INT32(record->data);
-
-            status = gckVIDMEM_HANDLE_Lookup2(
-                record->kernel,
-                Database,
-                handle,
-                &nodeObject
-                );
-
-            if (gcmIS_ERROR(status))
-            {
-                nodeObject = gcvNULL;
-            }
-
-            len += fs_printf(ptr + len, "%#8x %#18lx %#18lx\n",
-                handle,
-                (unsigned long)nodeObject,
-                (unsigned long)record->physical
-                );
         }
     }
-    return len;
-}
-
-static int
-_ShowContextRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
 
-    len = fs_printf(ptr, "Context:\n");
-
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
+    for (i = 0; i <= gcvCORE_3D_MAX; i++)
     {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
-
-        while (r != NULL)
+        if (device->kernels[i])
         {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
-
-            if (record->type != gcvDB_CONTEXT)
+            if (device->kernels[i]->hardware)
             {
-                continue;
-            }
+                gckHARDWARE Hardware = device->kernels[i]->hardware;
+                gctBOOL powerManagement = Hardware->options.powerManagement;
 
-            len += fs_printf(ptr + len, "%6u\n", gcmPTR2INT32(record->data));
-        }
-    }
-    return len;
-}
+                switch(statesStored)
+                {
+                case gcvPOWER_OFF:
+                    state = gcvPOWER_OFF_BROADCAST;
+                    break;
+                case gcvPOWER_IDLE:
+                    state = gcvPOWER_IDLE_BROADCAST;
+                    break;
+                case gcvPOWER_SUSPEND:
+                    state = gcvPOWER_SUSPEND_BROADCAST;
+                    break;
+                case gcvPOWER_ON:
+                    state = gcvPOWER_ON_AUTO;
+                    break;
+                default:
+                    state = statesStored;
+                    break;
+                }
 
-static int
-_ShowMapMemoryRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
+                Hardware->waitCount = 200;
 
-    len = fs_printf(ptr, "Map Memory:\n");
-    len += fs_printf(ptr + len, "  name              vaddr       size\n");
+                if (powerManagement)
+                {
+                    gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                        Hardware, gcvTRUE
+                        ));
+                }
 
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
-    {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
+                gcmkONERROR(gckHARDWARE_SetPowerState(
+                    Hardware, state
+                    ));
 
-        while (r != NULL)
-        {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
+                load[i] = (hi_total_cycle_count[i] - hi_total_idle_cycle_count[i]) * 100 / hi_total_cycle_count[i];
 
-            if (record->type != gcvDB_MAP_MEMORY)
-            {
-                continue;
+                len += fs_printf(ptr, "core      : %d\n", i);
+                len += fs_printf(ptr + len, "load      : %d%%\n",load[i]);
+                len += fs_printf(ptr + len, "\n");
             }
-
-            len += fs_printf(ptr + len, "%#6lx %#18lx %10lu\n",
-                (unsigned long)record->physical,
-                (unsigned long)record->data,
-                (unsigned long)record->bytes
-                );
         }
     }
-    return len;
-}
 
-static int
-_ShowMapUserMemoryRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    return 0;
+OnError:
+    return len;
 }
 
-static int
-_ShowShbufRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
+static const char * vidmemTypeStr[gcvVIDMEM_TYPE_COUNT] =
 {
-    gctUINT i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
-
-    len = fs_printf(ptr, "ShBuf:\n");
-
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
-    {
-        gcsDATABASE_RECORD_PTR r = Database->list[i];
-
-        while (r != NULL)
-        {
-            gcsDATABASE_RECORD_PTR record = r;
-            r = r->next;
-
-            if (record->type != gcvDB_SHBUF)
-            {
-                continue;
-            }
-
-            len += fs_printf(ptr + len, "%#8x\n", gcmPTR2INT32(record->data));
-        }
-    }
-    return len;
-}
+    "Generic",
+    "Index",
+    "Vertex",
+    "Texture",
+    "RenderTarget",
+    "Depth",
+    "Bitmap",
+    "TileStatus",
+    "Image",
+    "Mask",
+    "Scissor",
+    "HZ",
+    "ICache",
+    "TxDesc",
+    "Fence",
+    "TFBHeader",
+    "Command",
+};
 
-#if gcdENABLE_SW_PREEMPTION
-static int
-_ShowPriorityRecord(
-    IN void *m,
-    IN gcsDATABASE_PTR Database
-    )
+static const char * poolStr[gcvPOOL_NUMBER_OF_POOLS] =
 {
-    return 0;
-}
-#endif
+    "Unknown",
+    "Default",
+    "Local",
+    "Internal",
+    "External",
+    "Unified",
+    "System",
+    "Sram",
+    "Virtual",
+    "User",
+    "Insram",
+    "Exsram",
+    "Exclusive",
+};
 
 static int
 _ShowCounters(
@@ -915,73 +680,7 @@ _ShowDataBaseOldFormat(
 }
 
 static int
-_ShowDatabase(
-    IN void *File,
-    IN gcsDATABASE_PTR Database
-    )
-{
-    gctINT pid;
-    gctUINT i;
-    char name[24];
-     int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = File;
-#else
-    char* ptr = (char*)File;
-#endif
-    gctBOOL hasType[gcvDB_NUM_TYPES] = {0,};
-    int (* showFuncs[])(void *, gcsDATABASE_PTR) =
-    {
-        _ShowDummyRecord,
-        _ShowVideoMemoryRecord,
-        _ShowCommandBufferRecord,
-        _ShowNonPagedRecord,
-        _ShowContiguousRecord,
-        _ShowSignalRecord,
-        _ShowLockRecord,
-        _ShowContextRecord,
-        _ShowDummyRecord,
-        _ShowMapMemoryRecord,
-        _ShowMapUserMemoryRecord,
-        _ShowShbufRecord,
-#if gcdENABLE_SW_PREEMPTION
-        _ShowPriorityRecord,
-#endif
-    };
-
-    gcmSTATIC_ASSERT(gcmCOUNTOF(showFuncs) == gcvDB_NUM_TYPES,
-                     "DB type mismatch");
-
-    /* Process ID and name */
-    pid = Database->processID;
-    gcmkVERIFY_OK(gckOS_GetProcessNameByPid(pid, gcmSIZEOF(name), name));
-
-    len = fs_printf(ptr, "--------------------------------------------------------------------------------\n");
-    len += fs_printf(ptr + len, "Process: %-8d %s\n", pid, name);
-
-    for (i = 0; i < gcmCOUNTOF(Database->list); i++)
-    {
-        gcsDATABASE_RECORD_PTR record = Database->list[i];
-
-        while (record != NULL)
-        {
-            hasType[record->type] = gcvTRUE;
-            record = record->next;
-        }
-    }
-
-    for (i = 0; i < gcvDB_NUM_TYPES; i++)
-    {
-        if (hasType[i])
-        {
-            len += showFuncs[i](ptr + len, Database);
-        }
-    }
-    return len;
-}
-
-static int
-gc_db_old_show(void *m, void *data)
+gc_db_old_show(void *m, void *data, gctBOOL all)
 {
     gcsDATABASE_PTR database;
     gctINT i;
@@ -1012,14 +711,17 @@ gc_db_old_show(void *m, void *data)
     /* Idle time since last call */
     len = fs_printf(ptr, "GPU Idle: %llu ns\n",  idleTime);
 
-    /* Walk the databases. */
-    for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
+    if (all)
     {
-        for (database = kernel->db->db[i];
-             database != gcvNULL;
-             database = database->next)
+        /* Walk the databases. */
+        for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
         {
-            len += _ShowDataBaseOldFormat(ptr + len, database);
+            for (database = kernel->db->db[i];
+                 database != gcvNULL;
+                 database = database->next)
+            {
+                len += _ShowDataBaseOldFormat(ptr + len, database);
+            }
         }
     }
 
@@ -1030,52 +732,9 @@ gc_db_old_show(void *m, void *data)
 }
 
 static int
-gc_db_show(void *m, void *data)
+gc_db_show(void *m, void *data, gctBOOL all)
 {
-    gcsDATABASE_PTR database;
-    gctINT i;
-    static gctUINT64 idleTime = 0;
-    gckGALDEVICE device = galDevice;
-    gckKERNEL kernel = _GetValidKernel(device);
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
-
-    if (!kernel)
-        return -ENXIO;
-
-    /* Acquire the database mutex. */
-    gcmkVERIFY_OK(
-        gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE));
-
-    if (kernel->db->idleTime)
-    {
-        /* Record idle time if DB upated. */
-        idleTime = kernel->db->idleTime;
-        kernel->db->idleTime = 0;
-    }
-
-    /* Idle time since last call */
-    len = fs_printf(ptr, "GPU Idle: %llu ns\n",  idleTime);
-
-    /* Walk the databases. */
-    for (i = 0; i < gcmCOUNTOF(kernel->db->db); ++i)
-    {
-        for (database = kernel->db->db[i];
-             database != gcvNULL;
-             database = database->next)
-        {
-            len += _ShowDatabase(ptr + len, database);
-        }
-    }
-
-    /* Release the database mutex. */
-    gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex));
-
-    return len;
+    return 0;
 }
 
 static int
@@ -1097,7 +756,8 @@ gc_version_show(void *m, void *data)
     if (!platform)
         return -ENXIO;
 
-    len = fs_printf(ptr, "%s built at %s\n",  gcvVERSION_STRING, HOST);
+#ifdef CONFIG_DEBUG_FS
+    len = fs_printf(ptr, "version: %s \n",  gcvVERSION_STRING);
 
     if (platform->name)
     {
@@ -1107,6 +767,9 @@ gc_version_show(void *m, void *data)
     {
         len += fs_printf(ptr + len, "Code path: %s\n", __FILE__);
     }
+#else
+    len = fs_printf(ptr, "%s\n",  gcvVERSION_STRING);
+#endif
 
     return len;
 }
@@ -1206,42 +869,165 @@ _DumpState(
 **  Suspend: Time GPU stays in gcvPOWER_SUSPEND.
 */
 static int dumpCore = 0;
+static gctBOOL dumpAllCore = gcvFALSE;
 
 static int
 gc_dump_trigger_show(void *m, void *data)
 {
     int len = 0;
+
+#if gcdENABLE_3D
 #ifdef CONFIG_DEBUG_FS
     void* ptr = m;
 #else
     char* ptr = (char*)m;
 #endif
 
-#if gcdENABLE_3D
     gckGALDEVICE device = galDevice;
     gckKERNEL kernel = gcvNULL;
+    gckHARDWARE Hardware = gcvNULL;
+    gctBOOL powerManagement = gcvFALSE;
+    gceSTATUS status = gcvSTATUS_OK;
+    gceCHIPPOWERSTATE statesStored, state;
+
+    if (((dumpCore < gcvCORE_MAJOR) || (dumpCore >= gcvCORE_COUNT)) && (!dumpAllCore))
+    {
+        return -ENXIO;
+    }
 
-    if (dumpCore >= gcvCORE_MAJOR && dumpCore < gcvCORE_COUNT)
+    len += fs_printf(ptr + len, "Dump one core: For example, dump core 0: echo 0 > /sys/kernel/debug/gc/dump_trigger; cat /sys/kernel/debug/gc/dump_trigger\n");
+    len += fs_printf(ptr + len, "Dump all cores: echo all > /sys/kernel/debug/gc/dump_trigger; cat /sys/kernel/debug/gc/dump_trigger\n");
+    len += fs_printf(ptr + len, "The dump will be in [dmesg].\n");
+
+    if (dumpAllCore)
     {
-        kernel = device->kernels[dumpCore];
+        gctINT8 i = 0;
+
+        for (i = 0; i < gcvCORE_COUNT; ++i)
+        {
+            if (!device->kernels[i])
+            {
+                continue;
+            }
+
+            kernel = device->kernels[i];
+            Hardware = kernel->hardware;
+            powerManagement = Hardware->options.powerManagement;
+
+            if (powerManagement)
+            {
+                gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                    Hardware, gcvFALSE
+                    ));
+            }
+
+            gcmkONERROR(gckHARDWARE_QueryPowerState(
+                Hardware, &statesStored
+                ));
+
+            gcmkONERROR(gckHARDWARE_SetPowerState(
+                Hardware, gcvPOWER_ON_AUTO
+                ));
+
+            _DumpState(kernel);
+
+            switch(statesStored)
+            {
+            case gcvPOWER_OFF:
+                state = gcvPOWER_OFF_BROADCAST;
+                break;
+            case gcvPOWER_IDLE:
+                state = gcvPOWER_IDLE_BROADCAST;
+                break;
+            case gcvPOWER_SUSPEND:
+                state = gcvPOWER_SUSPEND_BROADCAST;
+                break;
+            case gcvPOWER_ON:
+                state = gcvPOWER_ON_AUTO;
+                break;
+            default:
+                state = statesStored;
+                break;
+            }
+
+            if (powerManagement)
+            {
+                gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                    Hardware, gcvTRUE
+                    ));
+            }
+
+            gcmkONERROR(gckHARDWARE_SetPowerState(
+                Hardware, state
+                ));
+
+        }
     }
+    else
+    {
+        if (device->kernels[dumpCore])
+        {
+            kernel = device->kernels[dumpCore];
+        }
+        else
+        {
+            len += fs_printf(ptr + len, "Dump core from invalid coreid.\n");
+            goto OnError;
+        }
 
-    if (!kernel)
-        return -ENXIO;
+        Hardware = kernel->hardware;
+        powerManagement = Hardware->options.powerManagement;
 
-#endif
+        if (powerManagement)
+        {
+            gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                Hardware, gcvFALSE
+                ));
+        }
 
-    len = fs_printf(ptr, gcdDEBUG_FS_WARN);
+        gcmkONERROR(gckHARDWARE_QueryPowerState(
+            Hardware, &statesStored
+            ));
 
-#if gcdENABLE_3D
-    //len += fs_printf(ptr + len, "Get dump from /proc/kmsg or /sys/kernel/debug/gc/galcore_trace\n");
+        gcmkONERROR(gckHARDWARE_SetPowerState(
+            Hardware, gcvPOWER_ON_AUTO
+            ));
 
-    if (kernel)
-    {
         _DumpState(kernel);
+
+        switch(statesStored)
+        {
+        case gcvPOWER_OFF:
+            state = gcvPOWER_OFF_BROADCAST;
+            break;
+        case gcvPOWER_IDLE:
+            state = gcvPOWER_IDLE_BROADCAST;
+            break;
+        case gcvPOWER_SUSPEND:
+            state = gcvPOWER_SUSPEND_BROADCAST;
+            break;
+        case gcvPOWER_ON:
+            state = gcvPOWER_ON_AUTO;
+            break;
+        default:
+            state = statesStored;
+            break;
+        }
+
+        if (powerManagement)
+        {
+            gcmkONERROR(gckHARDWARE_EnablePowerManagement(
+                Hardware, gcvTRUE
+                ));
+        }
+
+        gcmkONERROR(gckHARDWARE_SetPowerState(
+            Hardware, state
+            ));
     }
-#endif
 
+OnError:
+#endif
     return len;
 }
 
@@ -1250,7 +1036,8 @@ static int dumpProcess = 0;
 static int
 _ShowVideoMemoryOldFormat(
     void *File,
-    gcsDATABASE_PTR Database
+    gcsDATABASE_PTR Database,
+    gctBOOL All
     )
 {
     gctUINT i = 0;
@@ -1284,187 +1071,54 @@ _ShowVideoMemoryOldFormat(
                Database->vidMem.maxBytes,
                Database->vidMem.totalBytes);
 
-    for (i = 1; i < gcvVIDMEM_TYPE_COUNT; i++)
-    {
-        len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   vidmemTypeStr[i],
-                   Database->vidMemType[i].bytes,
-                   Database->vidMemType[i].maxBytes,
-                   Database->vidMemType[i].totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
-
-    /* Print surface pool counters. */
-    len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-               "All-Pools",
-               Database->vidMem.bytes,
-               Database->vidMem.maxBytes,
-               Database->vidMem.totalBytes);
-
-    for (i = 1; i < gcvPOOL_NUMBER_OF_POOLS; i++)
-    {
-        len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   poolStr[i],
-                   Database->vidMemPool[i].bytes,
-                   Database->vidMemPool[i].maxBytes,
-                   Database->vidMemPool[i].totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
-
-    /* Print other counters. */
-    for (i = 0; i < gcmCOUNTOF(otherCounterNames); i++)
-    {
-        len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   otherCounterNames[i],
-                   otherCounters[i]->bytes,
-                   otherCounters[i]->maxBytes,
-                   otherCounters[i]->totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
-    return len;
-}
-
-static int
-_ShowVideoMemory(
-    void *File,
-    gcsDATABASE_PTR Database
-    )
-{
-    gctUINT i = 0;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = File;
-#else
-    char* ptr = (char*)File;
-#endif
-
-    static const char * otherCounterNames[] = {
-        "AllocNonPaged",
-        "MapMemory",
-    };
-
-    gcsDATABASE_COUNTERS * otherCounters[] = {
-        &Database->nonPaged,
-        &Database->mapMemory,
-    };
-
-    len = fs_printf(ptr, "%-16s %16s %16s %16s\n", "", "Current", "Maximum", "Total");
-
-    /* Print surface type counters. */
-    len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-               "All-Types",
-               Database->vidMem.bytes,
-               Database->vidMem.maxBytes,
-               Database->vidMem.totalBytes);
-
-    for (i = 1; i < gcvVIDMEM_TYPE_COUNT; i++)
-    {
-        len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   vidmemTypeStr[i],
-                   Database->vidMemType[i].bytes,
-                   Database->vidMemType[i].maxBytes,
-                   Database->vidMemType[i].totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
-
-    /* Print surface pool counters. */
-    len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-               "All-Pools",
-               Database->vidMem.bytes,
-               Database->vidMem.maxBytes,
-               Database->vidMem.totalBytes);
-
-    for (i = 1; i < gcvPOOL_NUMBER_OF_POOLS; i++)
+    if (All)
     {
-        len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   poolStr[i],
-                   Database->vidMemPool[i].bytes,
-                   Database->vidMemPool[i].maxBytes,
-                   Database->vidMemPool[i].totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
+        for (i = 1; i < gcvVIDMEM_TYPE_COUNT; i++)
+        {
+            len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
+                       vidmemTypeStr[i],
+                       Database->vidMemType[i].bytes,
+                       Database->vidMemType[i].maxBytes,
+                       Database->vidMemType[i].totalBytes);
+        }
+        /*seq_puts(File, "\n");*/
+        len += fs_printf(ptr + len, "\n");
 
-    /* Print other counters. */
-    for (i = 0; i < gcmCOUNTOF(otherCounterNames); i++)
-    {
+        /* Print surface pool counters. */
         len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
-                   otherCounterNames[i],
-                   otherCounters[i]->bytes,
-                   otherCounters[i]->maxBytes,
-                   otherCounters[i]->totalBytes);
-    }
-    /*seq_puts(File, "\n");*/
-    len += fs_printf(ptr + len, "\n");
-    return len;
-}
-
-static int gc_vidmem_old_show(void *m, void *unused)
-{
-    gceSTATUS status;
-    gcsDATABASE_PTR database;
-    gckGALDEVICE device = galDevice;
-    char name[64];
-    int i;
-    int len = 0;
-#ifdef CONFIG_DEBUG_FS
-    void* ptr = m;
-#else
-    char* ptr = (char*)m;
-#endif
-
-    gckKERNEL kernel = _GetValidKernel(device);
-
-    if (!kernel)
-        return -ENXIO;
-
-    if (dumpProcess == 0)
-    {
-        /* Acquire the database mutex. */
-        gcmkVERIFY_OK(
-        gckOS_AcquireMutex(kernel->os, kernel->db->dbMutex, gcvINFINITE));
+                   "All-Pools",
+                   Database->vidMem.bytes,
+                   Database->vidMem.maxBytes,
+                   Database->vidMem.totalBytes);
 
-        for (i = 0; i < gcmCOUNTOF(kernel->db->db); i++)
+        for (i = 1; i < gcvPOOL_NUMBER_OF_POOLS; i++)
         {
-            for (database = kernel->db->db[i];
-                 database != gcvNULL;
-                 database = database->next)
-            {
-                gckOS_GetProcessNameByPid(database->processID, gcmSIZEOF(name), name);
-                len += fs_printf(ptr + len, "VidMem Usage (Process %u: %s):\n", database->processID, name);
-                len += _ShowVideoMemoryOldFormat(ptr + len, database);
-                /*seq_puts(m, "\n");*/
-                len += fs_printf(ptr + len, "\n");
-            }
+            len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
+                       poolStr[i],
+                       Database->vidMemPool[i].bytes,
+                       Database->vidMemPool[i].maxBytes,
+                       Database->vidMemPool[i].totalBytes);
         }
+        /*seq_puts(File, "\n");*/
+        len += fs_printf(ptr + len, "\n");
 
-        /* Release the database mutex. */
-        gcmkVERIFY_OK(gckOS_ReleaseMutex(kernel->os, kernel->db->dbMutex));
-    }
-    else
-    {
-        /* Find the database. */
-        status = gckKERNEL_FindDatabase(kernel, dumpProcess, gcvFALSE, &database);
-
-        if (gcmIS_ERROR(status))
+        /* Print other counters. */
+        for (i = 0; i < gcmCOUNTOF(otherCounterNames); i++)
         {
-            len += fs_printf(ptr + len, "ERROR: process %d not found\n", dumpProcess);
-            return len;
+            len += fs_printf(ptr + len, "%-16s %16llu %16llu %16llu\n",
+                       otherCounterNames[i],
+                       otherCounters[i]->bytes,
+                       otherCounters[i]->maxBytes,
+                       otherCounters[i]->totalBytes);
         }
-
-        gckOS_GetProcessNameByPid(dumpProcess, gcmSIZEOF(name), name);
-        len += fs_printf(ptr + len, "VidMem Usage (Process %d: %s):\n", dumpProcess, name);
-        len += _ShowVideoMemoryOldFormat(ptr + len, database);
+        /*seq_puts(File, "\n");*/
+        len += fs_printf(ptr + len, "\n");
     }
 
     return len;
 }
 
-static int gc_vidmem_show(void *m, void *unused)
+static int gc_vidmem_old_show(void *m, void *unused, gctBOOL all)
 {
     gceSTATUS status;
     gcsDATABASE_PTR database;
@@ -1497,7 +1151,7 @@ static int gc_vidmem_show(void *m, void *unused)
             {
                 gckOS_GetProcessNameByPid(database->processID, gcmSIZEOF(name), name);
                 len += fs_printf(ptr + len, "VidMem Usage (Process %u: %s):\n", database->processID, name);
-                len += _ShowVideoMemory(ptr + len, database);
+                len += _ShowVideoMemoryOldFormat(ptr + len, database, all);
                 /*seq_puts(m, "\n");*/
                 len += fs_printf(ptr + len, "\n");
             }
@@ -1519,12 +1173,17 @@ static int gc_vidmem_show(void *m, void *unused)
 
         gckOS_GetProcessNameByPid(dumpProcess, gcmSIZEOF(name), name);
         len += fs_printf(ptr + len, "VidMem Usage (Process %d: %s):\n", dumpProcess, name);
-        len += _ShowVideoMemory(ptr + len, database);
+        len += _ShowVideoMemoryOldFormat(ptr + len, database, all);
     }
 
     return len;
 }
 
+static int gc_vidmem_show(void *m, void *unused, gctBOOL all)
+{
+    return 0;
+}
+
 #ifdef CONFIG_DEBUG_FS
 static inline int strtoint_from_user(const char __user *s,
                         size_t count, int *res)
@@ -1556,9 +1215,50 @@ static int gc_vidmem_write(const char __user *buf, size_t count, void* data)
 
 static int gc_dump_trigger_write(const char __user *buf, size_t count, void* data)
 {
-    return strtoint_from_user(buf, count, &dumpCore);
+    char str[1 + sizeof(long) * 8 + 1 + 1];
+
+    size_t len = min(count, sizeof(str) - 1);
+
+    if (copy_from_user(str, buf, len))
+        return -EFAULT;
+
+    str[len] = '\0';
+
+    if (str[0] == 'a' && str[1] == 'l' && str[2] == 'l')
+    {
+        dumpAllCore = gcvTRUE;
+        return count;
+    }
+    else
+    {
+        dumpAllCore = gcvFALSE;
+        return strtoint_from_user(buf, count, &dumpCore);
+    }
+}
+
+#if gcdENABLE_MP_SWITCH
+static int gc_switch_core_count(void* m, void* data)
+{
+    return 0;
+}
+
+static int gc_switch_core_count_write(const char __user *buf, size_t count, void* data)
+{
+    gckGALDEVICE device = galDevice;
+    int coreCount = 0;
+    int ret;
+
+    ret = strtoint_from_user(buf, count, &coreCount);
+
+    if (ret && coreCount)
+    {
+        device->platform->coreCount = coreCount;
+    }
+
+    return ret;
 }
 #endif
+#endif
 
 static int gc_clk_show(void* m, void* data)
 {
@@ -1709,7 +1409,7 @@ static int gc_chipinfo_write(const char __user *ubuf, size_t count, void* data)
 }
 
 
-static gctUINT32 clkScale[2] = {0, 0};
+static gctINT clkScale[2] = {0, 0};
 
 static int _set_clk(const char* buf)
 {
@@ -1758,9 +1458,13 @@ static int _set_clk(const char* buf)
         }
     }
 
-    sscanf(data, "%d %d %d", &dumpCore, &clkScale[0], &clkScale[1]);
-
-    printk("Change core:%d MC scale:%d SH scale:%d\n", dumpCore, clkScale[0], clkScale[1]);
+    if (3 == sscanf(data, "%d %d %d", &dumpCore, &clkScale[0], &clkScale[1])) {
+        printk("Change core:%d MC scale:%d SH scale:%d\n",
+                dumpCore, clkScale[0], clkScale[1]);
+    } else {
+        printk("usage: echo \"0 32 32\" > clk\n");
+        return 0;
+    }
 
     if (device->kernels[dumpCore])
     {
@@ -1779,7 +1483,22 @@ static int _set_clk(const char* buf)
 #ifdef CONFIG_DEBUG_FS
 static int gc_clk_write(const char __user *buf, size_t count, void* data)
 {
-    _set_clk(buf);
+    size_t ret;
+    char _buf[100];
+
+    if (count > 100)
+    {
+        printk("Error: input buffer too large\n");
+    }
+
+    ret = copy_from_user(_buf, buf, count);
+    if (ret != 0)
+    {
+        printk("Error: lost data: %d\n", (int)ret);
+        return ret;
+    }
+
+    _set_clk(_buf);
 
     return count;
 }
@@ -1804,11 +1523,11 @@ int gc_idle_show_debugfs(struct seq_file* m, void* data)
 }
 int gc_db_old_show_debugfs(struct seq_file* m, void* data)
 {
-    return gc_db_old_show((void*)m , data);
+    return gc_db_old_show((void*)m , data, gcvTRUE);
 }
 int gc_db_show_debugfs(struct seq_file* m, void* data)
 {
-    return gc_db_show((void*)m , data);
+    return gc_db_show((void*)m , data, gcvTRUE);
 }
 int gc_version_show_debugfs(struct seq_file* m, void* data)
 {
@@ -1816,11 +1535,11 @@ int gc_version_show_debugfs(struct seq_file* m, void* data)
 }
 int gc_vidmem_old_show_debugfs(struct seq_file* m, void* data)
 {
-    return gc_vidmem_old_show((void*)m , data);
+    return gc_vidmem_old_show((void*)m , data, gcvTRUE);
 }
 int gc_vidmem_show_debugfs(struct seq_file* m, void* data)
 {
-    return gc_vidmem_show((void*)m , data);
+    return gc_vidmem_show((void*)m , data, gcvTRUE);
 }
 int gc_dump_trigger_show_debugfs(struct seq_file* m, void* data)
 {
@@ -1831,6 +1550,21 @@ int gc_clk_show_debugfs(struct seq_file* m, void* data)
     return gc_clk_show((void*)m , data);
 }
 
+#if gcdENABLE_MP_SWITCH
+int gc_switch_core_count_debugfs(struct seq_file* m, void* data)
+{
+    return gc_switch_core_count((void*)m , data);
+}
+#endif
+
+#if VIVANTE_PROFILER
+int gc_load_show_debugfs(struct seq_file* m, void* data)
+{
+    return gc_load_show((void*)m , data);
+}
+#endif
+
+
 int gc_dump_param_show_debugfs(struct seq_file* m, void* data)
 {
     return gc_dump_param_show((void*)m , data);
@@ -1844,6 +1578,7 @@ int gc_chipinfo_write_debugfs(const char __user *ubuf, size_t count, void* data)
     return gc_chipinfo_write(ubuf, count, data );
 }
 
+
 static gcsINFO InfoList[] =
 {
     {"info", gc_info_show_debugfs},
@@ -1857,8 +1592,14 @@ static gcsINFO InfoList[] =
     {"vidmem64x", gc_vidmem_show_debugfs, gc_vidmem_write},
     {"dump_trigger", gc_dump_trigger_show_debugfs, gc_dump_trigger_write},
     {"clk", gc_clk_show_debugfs, gc_clk_write},
-    {"dump_param",gc_dump_param_show_debugfs},
+	{"dump_param",gc_dump_param_show_debugfs},
     {"chipinfo",gc_chipinfo_show_debugfs, gc_chipinfo_write_debugfs},
+#if gcdENABLE_MP_SWITCH
+    {"core_count", gc_switch_core_count_debugfs, gc_switch_core_count_write},
+#endif
+#if VIVANTE_PROFILER
+    {"load", gc_load_show_debugfs},
+#endif
 };
 #else
 static ssize_t info_show(struct device *dev, struct device_attribute* attr, char *buf)
@@ -1887,13 +1628,13 @@ DEVICE_ATTR_RO(idle);
 
 static ssize_t database_show(struct device *dev, struct device_attribute* attr, char *buf)
 {
-    return gc_db_old_show((void*)buf, NULL);
+    return gc_db_old_show((void*)buf, NULL, gcvFALSE);
 }
 DEVICE_ATTR_RO(database);
 
 static ssize_t database64x_show(struct device *dev, struct device_attribute* attr, char *buf)
 {
-    return gc_db_show((void*)buf, NULL);
+    return gc_db_show((void*)buf, NULL, gcvFALSE);
 }
 DEVICE_ATTR_RO(database64x);
 
@@ -1903,9 +1644,15 @@ static ssize_t version_show(struct device *dev, struct device_attribute* attr, c
 }
 DEVICE_ATTR_RO(version);
 
+static ssize_t load_show(struct device *dev, struct device_attribute* attr, char *buf)
+{
+    return gc_load_show((void*)buf, NULL);
+}
+DEVICE_ATTR_RO(load);
+
 static ssize_t vidmem_show(struct device *dev, struct device_attribute* attr, char *buf)
 {
-    return gc_vidmem_old_show((void*)buf, NULL);
+    return gc_vidmem_old_show((void*)buf, NULL, gcvFALSE);
 }
 static ssize_t vidmem_store(struct device *dev, struct device_attribute* attr, const char *buf, size_t count)
 {
@@ -1916,7 +1663,7 @@ DEVICE_ATTR_RW(vidmem);
 
 static ssize_t vidmem64x_show(struct device *dev, struct device_attribute* attr, char *buf)
 {
-    return gc_vidmem_show((void*)buf, NULL);
+    return gc_vidmem_show((void*)buf, NULL, gcvFALSE);
 }
 static ssize_t vidmem64x_store(struct device *dev, struct device_attribute* attr, const char *buf, size_t count)
 {
@@ -1974,6 +1721,7 @@ _DebugfsInit(
 #ifdef CONFIG_DEBUG_FS
     gckDEBUGFS_DIR dir = &Device->debugfsDir;
 
+    //gcmkONERROR(gckDEBUGFS_DIR_Init(dir, gcvNULL, "gc"));
 	gcmkONERROR(gckDEBUGFS_DIR_Init(dir, gcvNULL, "galcore"));
     gcmkONERROR(gckDEBUGFS_DIR_CreateFiles(dir, InfoList, gcmCOUNTOF(InfoList), Device));
 #else
@@ -2154,6 +1902,12 @@ _SetupContiguousVidMem(
             }
         }
     }
+    else if (device->os->iommu)
+    {
+        /* Disable contiguous memory pool. */
+        device->contiguousVidMem = gcvNULL;
+        device->contiguousSize   = 0;
+    }
     else
     {
         /* Create the contiguous memory heap. */
@@ -2328,6 +2082,7 @@ static const char *isrNames[] =
 #if gcdDEC_ENABLE_AHB
     "galcore:dec"
 #endif
+    "galcore:2d-1",
 };
 
 static int isrRoutinePoll(void *ctxt)
@@ -2783,8 +2538,8 @@ gckGALDEVICE_Construct(
                     gcmkONERROR(gcvSTATUS_OUT_OF_RESOURCES);
                 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
-                device->registerBases[i] = (gctPOINTER)memremap(physical, device->requestedRegisterMemSizes[i], MEMREMAP_WT);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+                device->registerBases[i] = (gctPOINTER)ioremap(physical, device->requestedRegisterMemSizes[i]);
 #else
                 device->registerBases[i] = (gctPOINTER)ioremap_nocache(physical, device->requestedRegisterMemSizes[i]);
 #endif
@@ -3319,11 +3074,8 @@ gckGALDEVICE_Destroy(
                 /* Unmap register memory. */
                 if (Device->requestedRegisterMemBases[i] != 0)
                 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
-                    memunmap(Device->registerBases[i]);
-#else
                     iounmap(Device->registerBases[i]);
-#endif
+
                     release_mem_region(Device->requestedRegisterMemBases[i],
                             Device->requestedRegisterMemSizes[i]);
                 }
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.h
index 19edef7efb50..d3aa5fdecc38 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_device.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_driver.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_driver.c
index a7447633dda9..fb17e16e919e 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_driver.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_driver.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -57,20 +57,25 @@
 #include <linux/slab.h>
 #include <linux/miscdevice.h>
 #include <linux/uaccess.h>
+
 #include <linux/fs.h>
 #include <linux/sysfs.h>
-#include <linux/platform_device.h>
 #include <linux/proc_fs.h>
 #include <linux/delay.h>
+
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_driver.h"
 
+#include <linux/platform_device.h>
+
 /* Zone used for header/footer. */
 #define _GC_OBJ_ZONE    gcvZONE_DRIVER
 
 MODULE_DESCRIPTION("Vivante Graphics Driver");
 MODULE_LICENSE("Dual MIT/GPL");
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+MODULE_IMPORT_NS(VFS_internal_I_am_really_a_filesystem_and_am_NOT_a_driver);
+#endif
 
 static struct class* gpuClass = NULL;
 
@@ -196,10 +201,15 @@ static uint recovery = 1;
 module_param(recovery, uint, 0644);
 MODULE_PARM_DESC(recovery, "Recover GPU from stuck (1: Enable, 0: Disable)");
 
-/* Middle needs about 40KB buffer, Maximal may need more than 200KB buffer. */
+/*
+ * Level of stuck dump content, 0 ~ 5.
+ * 0: Disable. 1: Dump nearby memory. 2: Dump user command.
+ * 3: Commit stall besides level2. 4: Dump kernel command buffer besides level3.
+ * 5: Dump all the cores with level4.
+ */
 static uint stuckDump = 0;
 module_param(stuckDump, uint, 0644);
-MODULE_PARM_DESC(stuckDump, "Level of stuck dump content (1: Minimal, 2: Middle, 3: Maximal)");
+MODULE_PARM_DESC(stuckDump, "Level of stuck dump content.");
 
 static int showArgs = 0;
 module_param(showArgs, int, 0644);
@@ -229,7 +239,7 @@ static uint type = 0;
 module_param(type, uint, 0664);
 MODULE_PARM_DESC(type, "0 - Char Driver (Default), 1 - Misc Driver");
 
-static uint userClusterMasks[gcdMAX_MAJOR_CORE_COUNT] = {[0 ... gcdMAX_MAJOR_CORE_COUNT - 1] = 0};
+static uint userClusterMasks[gcdMAX_MAJOR_CORE_COUNT] = {[0 ... gcdMAX_MAJOR_CORE_COUNT - 1] = 0xff};
 module_param_array(userClusterMasks, uint, NULL, 0644);
 MODULE_PARM_DESC(userClusterMasks, "Array of user defined per-core cluster enable mask");
 
@@ -247,6 +257,10 @@ static int smallBatch = 1;
 module_param(smallBatch, int, 0644);
 MODULE_PARM_DESC(smallBatch, "Enable/disable GPU small batch feature, enable by default");
 
+int aml_debuglevel = 0;
+module_param(aml_debuglevel, int, 0644);
+MODULE_PARM_DESC(aml_debuglevel, "aml_debug_level");
+
 static int allMapInOne = 1;
 module_param(allMapInOne, int, 0644);
 MODULE_PARM_DESC(allMapInOne, "Mapping kernel video memory to user, 0 means mapping every time, otherwise only mapping one time");
@@ -298,11 +312,25 @@ static uint isrPoll = 0;
 module_param(isrPoll, uint, 0644);
 MODULE_PARM_DESC(isrPoll, "Bits isr polling for per-core, default 0'1b means disable, 1'1b means auto enable isr polling mode");
 
+static uint softReset = 1;
+module_param(softReset, uint, 0644);
+MODULE_PARM_DESC(softReset, "Disable soft reset when insert the driver if set it to 0, enabled by default.");
+
 #if USE_LINUX_PCIE
 static int bar = 1;
 module_param(bar, int, 0644);
 MODULE_PARM_DESC(bar, "PCIE Bar index of GC core");
 
+static int bar2D = 1;
+module_param(bar2D, int, 0644);
+MODULE_PARM_DESC(bar2D, "PCIE Bar index of GC 2D core");
+
+static int barVG = 1;
+module_param(barVG, int, 0644);
+MODULE_PARM_DESC(barVG, "PCIE Bar index of GC VG core");
+
+
+
 static int bars[gcvCORE_COUNT] = {[0 ... gcvCORE_COUNT - 1] = -1};
 module_param_array(bars, int, NULL, 0644);
 MODULE_PARM_DESC(bars, "Array of bar index of PCIE platform for multi-GPU");
@@ -324,10 +352,6 @@ static int gpu3DMinClock = 1;
 static int contiguousRequested = 0;
 static ulong bankSize = 0;
 
-static gcsMODULE_PARAMETERS moduleParam;
-
-
-
 /*============the control format should as: (control-domain:control-value)==========*/
 static int kcmp(const char *buff,const char *token,int lenth)
 {
@@ -368,7 +392,8 @@ static ssize_t show_class_control(struct class *class,
 	{
 		platform->ops->getPowerStatus(platform,&status);
 	}
-	return snprintf(buf, PAGE_SIZE, "customid:%d,status:%d\n",galDevice->kernels[0]->hardware->identity.customerID,status);
+
+	return snprintf(buf, PAGE_SIZE, "customid:%d,status:%d,ddk_version:%s\n",galDevice->kernels[0]->hardware->identity.customerID,status,gcvVERSION_STRING);
 }
 /*============the control format should as: (control-domain:control-value)==========*/
 
@@ -492,6 +517,7 @@ static struct class_attribute gal_class_attrs[] = {
 /*=========================some sysfs functions,class end=======================================*/
 
 
+
 static void
 _InitModuleParam(
     gcsMODULE_PARAMETERS * ModuleParam
@@ -515,22 +541,21 @@ _InitModuleParam(
 #endif
     }
 
-    /* Check legacy style. */
-#if USE_LINUX_PCIE
-    if (bar != -1)
-    {
-        if (p->bars[gcvCORE_MAJOR] == -1)
-        {
-            p->bars[gcvCORE_MAJOR] = bar;
-        }
-    }
-#endif
-
     if (irqLine != -1)
     {
         p->irqs[gcvCORE_MAJOR]          = irqLine;
         p->registerBases[gcvCORE_MAJOR] = registerMemBase;
         p->registerSizes[gcvCORE_MAJOR] = registerMemSize;
+            /* Check legacy style. */
+#if USE_LINUX_PCIE
+        if (bar != -1)
+        {
+            if (p->bars[gcvCORE_MAJOR] == -1)
+            {
+                p->bars[gcvCORE_MAJOR] = bar;
+            }
+        }
+#endif
     }
 
     if (irqLine2D != -1)
@@ -538,6 +563,15 @@ _InitModuleParam(
         p->irqs[gcvCORE_2D]          = irqLine2D;
         p->registerBases[gcvCORE_2D] = registerMemBase2D;
         p->registerSizes[gcvCORE_2D] = registerMemSize2D;
+#if USE_LINUX_PCIE
+        if (bar2D != -1)
+        {
+            if (p->bars[gcvCORE_2D] == -1)
+            {
+                p->bars[gcvCORE_2D] = bar2D;
+            }
+        }
+#endif
     }
 
     if (irqLineVG != -1)
@@ -545,6 +579,16 @@ _InitModuleParam(
         p->irqs[gcvCORE_VG]          = irqLineVG;
         p->registerBases[gcvCORE_VG] = registerMemBaseVG;
         p->registerSizes[gcvCORE_VG] = registerMemSizeVG;
+#if USE_LINUX_PCIE
+        if (barVG != -1)
+        {
+            if (p->bars[gcvCORE_VG] == -1)
+            {
+                p->bars[gcvCORE_VG] = barVG;
+            }
+        }
+#endif
+
     }
 
 #if gcdDEC_ENABLE_AHB
@@ -597,7 +641,7 @@ _InitModuleParam(
 
     for (i = 0; i < gcdMAX_MAJOR_CORE_COUNT; i++)
     {
-        userClusterMasks[i] = p->userClusterMasks[i];
+        p->userClusterMasks[i] = userClusterMasks[i];
     }
 
     p->sRAMRequested = sRAMRequested;
@@ -610,6 +654,8 @@ _InitModuleParam(
     p->recovery        = recovery;
     p->powerManagement = powerManagement;
 
+    p->softReset = softReset;
+
     p->enableMmu = mmu;
     p->fastClear = fastClear;
 
@@ -621,7 +667,8 @@ _InitModuleParam(
     p->smallBatch      = smallBatch;
 
     p->stuckDump   = stuckDump;
-    p->gpuProfiler = gpuProfiler;
+	
+	p->gpuProfiler = gpuProfiler;
 
     p->deviceType  = type;
     p->showArgs    = showArgs;
@@ -649,11 +696,11 @@ _InitModuleParam(
 
 static void
 _SyncModuleParam(
-    const gcsMODULE_PARAMETERS * ModuleParam
+    gcsMODULE_PARAMETERS * ModuleParam
     )
 {
     gctUINT i, j;
-    gcsMODULE_PARAMETERS *p = &moduleParam;
+    gcsMODULE_PARAMETERS *p = ModuleParam;
 
     for (i = 0; i < gcvCORE_COUNT; i++)
     {
@@ -670,6 +717,8 @@ _SyncModuleParam(
 
 #if USE_LINUX_PCIE
     bar               = p->bars[gcvCORE_MAJOR];
+    bar2D               = p->bars[gcvCORE_2D];
+    barVG               = p->bars[gcvCORE_VG];
 #endif
     irqLine           = p->irqs[gcvCORE_MAJOR];
     registerMemBase   = (ulong)p->registerBases[gcvCORE_MAJOR];
@@ -748,12 +797,13 @@ _SyncModuleParam(
     smallBatch      = p->smallBatch;
 
     stuckDump   = p->stuckDump;
-    gpuProfiler = p->gpuProfiler;
+	
+	gpuProfiler = p->gpuProfiler;
 
     type        = p->deviceType;
     showArgs    = p->showArgs;
 
-    mmuPageTablePool = p->mmuDynamicMap;
+    mmuPageTablePool = p->mmuPageTablePool;
     mmuDynamicMap = p->mmuDynamicMap;
     allMapInOne = p->allMapInOne;
     isrPoll = p->isrPoll;
@@ -792,6 +842,14 @@ gckOS_DumpParam(
     {
         printk("  bar               = %d\n",      bar);
     }
+    if (bar2D != -1)
+    {
+        printk("  bar2D             = %d\n",      bar2D);
+    }
+    if (barVG != -1)
+    {
+        printk("  barVG             = %d\n",      barVG);
+    }
 #endif
 #if gcdDEC_ENABLE_AHB
     printk("  registerMemBaseDEC300 = 0x%08lX\n", registerMemBaseDEC300);
@@ -1271,9 +1329,16 @@ static struct file_operations driver_fops =
     .open       = drv_open,
     .release    = drv_release,
     .unlocked_ioctl = drv_ioctl,
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5,8,18)
+
 #ifdef HAVE_COMPAT_IOCTL
     .compat_ioctl = drv_ioctl,
 #endif
+
+#else
+    .compat_ioctl = drv_ioctl,
+#endif
 };
 
 static struct miscdevice gal_device = {
@@ -1299,7 +1364,7 @@ static int drv_init(void)
     }
 
     /* Create the GAL device. */
-    status = gckGALDEVICE_Construct(platform, &moduleParam, &device);
+    status = gckGALDEVICE_Construct(platform, &platform->params, &device);
 
     if (gcmIS_ERROR(status))
     {
@@ -1362,7 +1427,7 @@ static int drv_init(void)
         }
 
         /* Create the device class. */
-        device_class = class_create(THIS_MODULE, "npu");
+		device_class = class_create(THIS_MODULE, "npu");
 
         if (IS_ERR(device_class))
         {
@@ -1464,8 +1529,8 @@ static int __devinit gpu_probe(struct platform_device *pdev)
 #endif
 {
     int ret = -ENODEV;
-    bool getPowerFlag = gcvFALSE;
 	int i = 0;
+    bool getPowerFlag = gcvFALSE;
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
     static u64 dma_mask = DMA_BIT_MASK(40);
 #else
@@ -1488,14 +1553,22 @@ static int __devinit gpu_probe(struct platform_device *pdev)
 		printk("nn is disable,should not do probe continue\n");
 		return ret;
 	}
+
     platform->device = pdev;
     galcore_device = &pdev->dev;
 
+    if (!mmu)
+    {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+        dma_mask = DMA_BIT_MASK(32);
+#else
+        dma_mask = DMA_32BIT_MASK;
+#endif
+    }
+
     galcore_device->dma_mask = &dma_mask;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0)
-        galcore_device->coherent_dma_mask = dma_mask;
-#endif
+    galcore_device->coherent_dma_mask = dma_mask;
 
     if (platform->ops->getPower)
     {
@@ -1508,11 +1581,11 @@ static int __devinit gpu_probe(struct platform_device *pdev)
     }
 
     /* Gather module parameters. */
-    _InitModuleParam(&moduleParam);
+    _InitModuleParam(&platform->params);
 
 #if gcdCAPTURE_ONLY_MODE
-    contiguousBaseCap = moduleParam.contiguousBase;
-    contiguousSizeCap = moduleParam.contiguousSize;
+    contiguousBaseCap = platform->params.contiguousBase;
+    contiguousSizeCap = platform->params.contiguousSize;
 
     gcmkPRINT("Capture only mode is enabled in Hal Kernel.");
 
@@ -1525,45 +1598,45 @@ static int __devinit gpu_probe(struct platform_device *pdev)
     {
         for (j = 0; j < gcvSRAM_INTER_COUNT; j++)
         {
-            sRAMBaseCap[i][j] = moduleParam.sRAMBases[i][j];
-            sRAMSizeCap[i][j] = moduleParam.sRAMSizes[i][j];
+            sRAMBaseCap[i][j] = platform->params.sRAMBases[i][j];
+            sRAMSizeCap[i][j] = platform->params.sRAMSizes[i][j];
         }
     }
 
     for (i = 0; i < gcvSRAM_EXT_COUNT; i++)
     {
-        extSRAMBaseCap[i] = moduleParam.extSRAMBases[i];
-        extSRAMSizeCap[i] = moduleParam.extSRAMSizes[i];
+        extSRAMBaseCap[i] = platform->params.extSRAMBases[i];
+        extSRAMSizeCap[i] = platform->params.extSRAMSizes[i];
     }
 #endif
 
     if (platform->ops->adjustParam)
     {
         /* Override default module param. */
-        platform->ops->adjustParam(platform, &moduleParam);
+        platform->ops->adjustParam(platform, &platform->params);
     }
 
 #if gcdCAPTURE_ONLY_MODE
-    moduleParam.contiguousBase = contiguousBaseCap;
-    moduleParam.contiguousSize = contiguousSizeCap;
+    platform->params.contiguousBase = contiguousBaseCap;
+    platform->params.contiguousSize = contiguousSizeCap;
 
     for (i = 0; i < gcvCORE_COUNT; i++)
     {
         for (j = 0; j < gcvSRAM_INTER_COUNT; j++)
         {
-            moduleParam.sRAMBases[i][j] = sRAMBaseCap[i][j];
-            moduleParam.sRAMSizes[i][j] = sRAMSizeCap[i][j];
+            platform->params.sRAMBases[i][j] = sRAMBaseCap[i][j];
+            platform->params.sRAMSizes[i][j] = sRAMSizeCap[i][j];
         }
     }
 
     for (i = 0; i < gcvSRAM_EXT_COUNT; i++)
     {
-        moduleParam.extSRAMBases[i] = extSRAMBaseCap[i];
-        moduleParam.extSRAMSizes[i] = extSRAMSizeCap[i];
+        platform->params.extSRAMBases[i] = extSRAMBaseCap[i];
+        platform->params.extSRAMSizes[i] = extSRAMSizeCap[i];
     }
 #endif
     /* Update module param because drv_init() uses them directly. */
-    _SyncModuleParam(&moduleParam);
+    _SyncModuleParam(&platform->params);
 
     if (powerManagement == 0)
     {
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_drm.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_drm.c
index 885925c2aeb2..3fdc880f5689 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_drm.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_drm.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -55,7 +55,14 @@
 
 #if gcdENABLE_DRM
 
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,9,0)
+#include <drm/drm_drv.h>
+#include <drm/drm_file.h>
+#include <drm/drm_ioctl.h>
+#else
 #include <drm/drmP.h>
+#endif
 #include <drm/drm_gem.h>
 #include <linux/dma-buf.h>
 #include "gc_hal_kernel_linux.h"
@@ -75,6 +82,16 @@ struct viv_gem_object {
     gctBOOL               cacheable;
 };
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+void viv_gem_free_object(struct drm_gem_object *gem_obj);
+struct dma_buf *viv_gem_prime_export(struct drm_gem_object *gem_obj, int flags);
+
+static const struct drm_gem_object_funcs viv_gem_object_funcs = {
+    .free = viv_gem_free_object,
+    .export = viv_gem_prime_export,
+};
+#endif
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5,4,0)
 struct dma_buf *viv_gem_prime_export(struct drm_gem_object *gem_obj,
                 int flags)
@@ -134,6 +151,9 @@ struct drm_gem_object *viv_gem_prime_import(struct drm_device *drm,
     /* ioctl output */
     gem_obj = kzalloc(sizeof(struct viv_gem_object), GFP_KERNEL);
     drm_gem_private_object_init(drm, gem_obj, dmabuf->size);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+    gem_obj->funcs = &viv_gem_object_funcs;
+#endif
     viv_obj = container_of(gem_obj, struct viv_gem_object, base);
     viv_obj->node_handle = iface.u.WrapUserMemory.node;
     viv_obj->node_object = nodeObject;
@@ -213,6 +233,9 @@ static int viv_ioctl_gem_create(struct drm_device *drm, void *data,
     /* ioctl output */
     gem_obj = kzalloc(sizeof(struct viv_gem_object), GFP_KERNEL);
     drm_gem_private_object_init(drm, gem_obj, (size_t)alignSize);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,11,0)
+    gem_obj->funcs = &viv_gem_object_funcs;
+#endif
     ret = drm_gem_handle_create(file, gem_obj, &args->handle);
 
     viv_obj = container_of(gem_obj, struct viv_gem_object, base);
@@ -478,9 +501,10 @@ static int viv_ioctl_gem_set_tiling(struct drm_device *drm, void *data,
     }
     viv_obj = container_of(gem_obj, struct viv_gem_object, base);
 
-    viv_obj->node_object->tilingMode = args->tiling_mode;
-    viv_obj->node_object->tsMode     = args->ts_mode;
-    viv_obj->node_object->clearValue = args->clear_value;
+    viv_obj->node_object->tilingMode    = args->tiling_mode;
+    viv_obj->node_object->tsMode        = args->ts_mode;
+    viv_obj->node_object->tsCacheMode   = args->ts_cache_mode;
+    viv_obj->node_object->clearValue    = args->clear_value;
 
 OnError:
     if (gem_obj)
@@ -513,9 +537,10 @@ static int viv_ioctl_gem_get_tiling(struct drm_device *drm, void *data,
     }
     viv_obj = container_of(gem_obj, struct viv_gem_object, base);
 
-    args->tiling_mode = viv_obj->node_object->tilingMode;
-    args->ts_mode     = viv_obj->node_object->tsMode;
-    args->clear_value = viv_obj->node_object->clearValue;
+    args->tiling_mode   = viv_obj->node_object->tilingMode;
+    args->ts_mode       = viv_obj->node_object->tsMode;
+    args->ts_cache_mode = viv_obj->node_object->tsCacheMode;
+    args->clear_value   = viv_obj->node_object->clearValue;
 
 OnError:
     if (gem_obj)
@@ -794,14 +819,18 @@ static struct drm_driver viv_drm_driver = {
 #endif
     .open = viv_drm_open,
     .postclose = viv_drm_postclose,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,11,0)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,7,0)
     .gem_free_object_unlocked = viv_gem_free_object,
 #else
     .gem_free_object    = viv_gem_free_object,
+#endif
 #endif
     .prime_handle_to_fd = drm_gem_prime_handle_to_fd,
     .prime_fd_to_handle = drm_gem_prime_fd_to_handle,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,11,0)
     .gem_prime_export   = viv_gem_prime_export,
+#endif
     .gem_prime_import   = viv_gem_prime_import,
     .ioctls             = viv_ioctls,
     .num_ioctls         = DRM_VIV_NUM_IOCTLS,
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_iommu.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_iommu.c
index 36be9bbe483b..ea63eaea8b1e 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_iommu.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_iommu.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -61,61 +61,6 @@
 
 #define _GC_OBJ_ZONE gcvZONE_OS
 
-typedef struct _gcsIOMMU
-{
-    struct iommu_domain * domain;
-    struct device *       device;
-}
-gcsIOMMU;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
-static int
-_IOMMU_Fault_Handler(
-    struct iommu_domain * Domain,
-    struct device * Dev,
-    unsigned long DomainAddress,
-    int flags,
-    void * args
-    )
-#else
-static int
-_IOMMU_Fault_Handler(
-    struct iommu_domain * Domain,
-    struct device * Dev,
-    unsigned long DomainAddress,
-    int flags
-    )
-#endif
-{
-    return 0;
-}
-
-static int
-_FlatMapping(
-    IN gckIOMMU Iommu
-    )
-{
-    gceSTATUS status = gcvSTATUS_OK;
-    gctUINT32 physical;
-
-    gcmkHEADER_ARG("Iommu=%p", Iommu);
-
-    for (physical = 0; physical < 0x80000000; physical += PAGE_SIZE)
-    {
-        gcmkTRACE_ZONE(
-            gcvLEVEL_INFO, gcvZONE_OS,
-            "Map %x => %x bytes = %d",
-            physical, physical, PAGE_SIZE
-            );
-
-        gcmkONERROR(gckIOMMU_Map(Iommu, physical, physical, PAGE_SIZE));
-    }
-
-OnError:
-    gcmkFOOTER();
-    return status;
-}
-
 void
 gckIOMMU_Destory(
     IN gckOS Os,
@@ -124,18 +69,13 @@ gckIOMMU_Destory(
 {
     gcmkHEADER_ARG("Os=%p Iommu=%p", Os, Iommu);
 
-    if (Iommu->domain && Iommu->device)
-    {
-        iommu_attach_device(Iommu->domain, Iommu->device);
-    }
-
-    if (Iommu->domain)
-    {
-        iommu_domain_free(Iommu->domain);
-    }
-
     if (Iommu)
     {
+        if (Iommu->paddingPageDmaHandle)
+        {
+            dma_unmap_page(Iommu->device, Iommu->paddingPageDmaHandle, PAGE_SIZE, DMA_FROM_DEVICE);
+        }
+
         gcmkOS_SAFE_FREE(Os, Iommu);
     }
 
@@ -151,41 +91,74 @@ gckIOMMU_Construct(
     gceSTATUS status = gcvSTATUS_OK;
     gckIOMMU iommu = gcvNULL;
     struct device *dev;
+    dma_addr_t dmaHandle;
+    gctUINT64 phys;
+    struct iommu_domain * domain;
+    gctUINT32 gfp = GFP_KERNEL;
 
     gcmkHEADER_ARG("Os=%p", Os);
 
     dev = &Os->device->platform->device->dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+    domain = iommu_get_domain_for_dev(dev);
+#else
+    domain = gcvNULL;
+#endif
 
-    gcmkONERROR(gckOS_Allocate(Os, gcmSIZEOF(gcsIOMMU), (gctPOINTER *)&iommu));
+    if (domain)
+    {
+        struct page *page;
 
-    gckOS_ZeroMemory(iommu, gcmSIZEOF(gcsIOMMU));
+        page = alloc_page(gfp);
+        if (!page)
+        {
+            gcmkONERROR(gcvSTATUS_OUT_OF_MEMORY);
+        }
+
+        phys = page_to_phys(page);
+
+        dmaHandle = dma_map_page(dev, page, 0, PAGE_SIZE, DMA_TO_DEVICE);
+
+        if (dmaHandle)
+        {
+            dma_unmap_page(dev, dmaHandle, PAGE_SIZE, DMA_FROM_DEVICE);
+        }
+
+        __free_page(page);
 
-    iommu->domain = iommu_domain_alloc(&platform_bus_type);
+        /* Iommu bypass */
+        if (phys == dmaHandle)
+        {
+            *Iommu = gcvNULL;
 
-    if (!iommu->domain)
+            gcmkFOOTER();
+            return status;
+        }
+    }
+    /* Don't enable iommu */
+    else
     {
-        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "iommu_domain_alloc() fail");
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        *Iommu = gcvNULL;
+
+        gcmkFOOTER();
+        return status;
     }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
-    iommu_set_fault_handler(iommu->domain, _IOMMU_Fault_Handler, dev);
-#else
-    iommu_set_fault_handler(iommu->domain, _IOMMU_Fault_Handler);
-#endif
+    gcmkONERROR(gckOS_Allocate(Os, gcmSIZEOF(gcsIOMMU), (gctPOINTER *)&iommu));
+
+    gckOS_ZeroMemory(iommu, gcmSIZEOF(gcsIOMMU));
 
-    if (iommu_attach_device(iommu->domain, dev))
+    if (Os->paddingPage)
     {
-        gcmkTRACE_ZONE(gcvLEVEL_INFO, gcvZONE_OS, "iommu_attach_device() fail");
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
+        iommu->paddingPageDmaHandle = dma_map_page(dev, Os->paddingPage, 0, PAGE_SIZE, DMA_TO_DEVICE);
     }
 
+    iommu->domain = domain;
     iommu->device = dev;
 
-    _FlatMapping(iommu);
-
     *Iommu = iommu;
 
+    gcmkPRINT("[galcore]: Enable IOMMU\n");
 OnError:
     if (gcmIS_ERROR(status))
     {
@@ -195,42 +168,3 @@ gckIOMMU_Construct(
     gcmkFOOTER();
     return status;
 }
-
-gceSTATUS
-gckIOMMU_Map(
-    IN gckIOMMU Iommu,
-    IN gctUINT32 DomainAddress,
-    IN gctUINT32 Physical,
-    IN gctUINT32 Bytes
-    )
-{
-    gceSTATUS status = gcvSTATUS_OK;
-
-    gcmkHEADER_ARG("DomainAddress=%#X, Physical=%#X, Bytes=%d",
-                   DomainAddress, Physical, Bytes);
-
-    if (iommu_map(Iommu->domain, DomainAddress, Physical, Bytes, 0))
-    {
-        gcmkONERROR(gcvSTATUS_NOT_SUPPORTED);
-    }
-
-OnError:
-    gcmkFOOTER();
-    return status;
-}
-
-gceSTATUS
-gckIOMMU_Unmap(
-    IN gckIOMMU Iommu,
-    IN gctUINT32 DomainAddress,
-    IN gctUINT32 Bytes
-    )
-{
-    gcmkHEADER();
-
-    iommu_unmap(Iommu->domain, DomainAddress, Bytes);
-
-    gcmkFOOTER_NO();
-    return gcvSTATUS_OK;
-}
-
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.c
index fac6ca090bcc..bd0468ede7e7 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.h
index 43968428b64f..82c4e5cc5275 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_linux.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -67,6 +67,10 @@
 #include <linux/vmalloc.h>
 #include <linux/dma-mapping.h>
 #include <linux/kthread.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+#include <linux/iommu.h>
+#include <linux/iova.h>
+#endif
 
 #include <linux/idr.h>
 
@@ -165,13 +169,39 @@
 
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,8,0)
+#define current_mm_mmap_sem current->mm->mmap_lock
+#else
+#define current_mm_mmap_sem current->mm->mmap_sem
+#endif
+
+#ifndef untagged_addr
+#define untagged_addr(addr) (addr)
+#endif
+
 int get_nna_status(struct platform_device *dev);
 
+
 extern struct device *galcore_device;
 
 /******************************************************************************\
 ********************************** Structures **********************************
 \******************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+/* Just to compile without error */
+struct iommu_domain
+{
+    void *priv;
+}
+#endif
+
+typedef struct _gcsIOMMU
+{
+    struct iommu_domain * domain;
+    struct device *       device;
+    dma_addr_t            paddingPageDmaHandle;
+}
+gcsIOMMU;
 typedef struct _gcsIOMMU * gckIOMMU;
 
 typedef struct _gcsINTEGER_DB * gcsINTEGER_DB_PTR;
@@ -349,7 +379,6 @@ is_vmalloc_addr(
 }
 #endif
 
-#ifdef CONFIG_IOMMU_SUPPORT
 void
 gckIOMMU_Destory(
     IN gckOS Os,
@@ -362,20 +391,4 @@ gckIOMMU_Construct(
     OUT gckIOMMU * Iommu
     );
 
-gceSTATUS
-gckIOMMU_Map(
-    IN gckIOMMU Iommu,
-    IN gctUINT32 DomainAddress,
-    IN gctUINT32 Physical,
-    IN gctUINT32 Bytes
-    );
-
-gceSTATUS
-gckIOMMU_Unmap(
-    IN gckIOMMU Iommu,
-    IN gctUINT32 DomainAddress,
-    IN gctUINT32 Bytes
-    );
-#endif
-
 #endif /* __gc_hal_kernel_linux_h_ */
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_math.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_math.c
index b0c62bfa2c87..7d89f2076ac6 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_math.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_math.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_mutex.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_mutex.h
index 9f83847cf173..e745e183d955 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_mutex.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_mutex.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.c
index 9ed7067a6f29..794173d157d2 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -74,6 +74,10 @@
 #include <linux/anon_inodes.h>
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
+#include <linux/io.h>
+#endif
+
 #if gcdLINUX_SYNC_FILE
 #  include <linux/file.h>
 #  include "gc_hal_kernel_sync.h"
@@ -458,6 +462,9 @@ _QueryProcessPageTable(
         struct vm_area_struct *vma;
         spinlock_t *ptl;
         pgd_t *pgd;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (5,9,0)
+        p4d_t *p4d;
+#endif
         pud_t *pud;
         pmd_t *pmd;
         pte_t *pte;
@@ -465,18 +472,9 @@ _QueryProcessPageTable(
         if (!current->mm)
             return gcvSTATUS_NOT_FOUND;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-		down_read(&current->mm->mmap_lock);
-#else
-        down_read(&current->mm->mmap_sem);
-#endif
+        down_read(&current_mm_mmap_sem);
         vma = find_vma(current->mm, logical);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
-		up_read(&current->mm->mmap_lock);
-#else
-        up_read(&current->mm->mmap_sem);
-#endif
-
+        up_read(&current_mm_mmap_sem);
 
         /* To check if mapped to user. */
         if (!vma)
@@ -492,10 +490,16 @@ _QueryProcessPageTable(
 #elif (defined(CONFIG_CPU_CSKYV2)) \
     && LINUX_VERSION_CODE >= KERNEL_VERSION (4,11,0)
         pud = pud_offset((p4d_t*)pgd, logical);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION (5,12,0)
-		pud = pud_offset((p4d_t*)pgd, logical);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION (5,9,0)
+        p4d = p4d_offset(pgd, logical);
+        if (p4d_none(READ_ONCE(*p4d)))
+            return gcvSTATUS_NOT_FOUND;
+
+        pud = pud_offset(p4d, logical);
 #else
         pud = pud_offset(pgd, logical);
+#endif
 #endif
         if (pud_none(*pud) || pud_bad(*pud))
             return gcvSTATUS_NOT_FOUND;
@@ -505,11 +509,6 @@ _QueryProcessPageTable(
             return gcvSTATUS_NOT_FOUND;
 
         pte = pte_offset_map_lock(current->mm, pmd, logical, &ptl);
-        if (!pte)
-        {
-            spin_unlock(ptl);
-            return gcvSTATUS_NOT_FOUND;
-        }
 
         if (!pte_present(*pte))
         {
@@ -786,22 +785,18 @@ gckOS_Construct(
 
     spin_lock_init(&os->registerAccessLock);
 
-    gckOS_ImportAllocators(os);
 
-#if defined(CONFIG_IOMMU_SUPPORT)
-    if (0)
+    /* Check iommu. */
+    if (gcmIS_ERROR(gckIOMMU_Construct(os, &os->iommu)))
     {
-        /* Only use IOMMU when internal MMU is not enabled. */
-        if (gcmIS_ERROR(gckIOMMU_Construct(os, &os->iommu)))
-        {
-            gcmkTRACE_ZONE(
-                gcvLEVEL_INFO, gcvZONE_OS,
-                "%s(%d): Fail to setup IOMMU",
-                __FUNCTION__, __LINE__
-                );
-        }
+        gcmkTRACE_ZONE(
+            gcvLEVEL_INFO, gcvZONE_OS,
+            "%s(%d): Fail to setup IOMMU",
+            __FUNCTION__, __LINE__
+            );
     }
-#endif
+
+    gckOS_ImportAllocators(os);
 
 #if gcdDUMP_IN_KERNEL
     mutex_init(&os->dumpFilpMutex);
@@ -877,12 +872,10 @@ gckOS_Destroy(
 
     gckOS_FreeAllocators(Os);
 
-#ifdef CONFIG_IOMMU_SUPPORT
     if (Os->iommu)
     {
         gckIOMMU_Destory(Os, Os->iommu);
     }
-#endif
 
     /* Mark the gckOS object as unknown. */
     Os->object.type = gcvOBJ_UNKNOWN;
@@ -2477,8 +2470,8 @@ gckOS_MapPhysical(
         {
             /* Map memory as cached memory. */
             request_mem_region(physical, Bytes, "MapRegion");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,5,0)
-            logical = (gctPOINTER) memremap(physical, Bytes, MEMREMAP_WT);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+            logical = (gctPOINTER) ioremap(physical, Bytes);
 #else
             logical = (gctPOINTER) ioremap_nocache(physical, Bytes);
 #endif
@@ -3692,7 +3685,7 @@ gckOS_MapPagesEx(
     while (PageCount-- > 0)
     {
         gctUINT i;
-        gctPHYS_ADDR_T phys = ~0U;
+        gctPHYS_ADDR_T phys = ~0ULL;
 
         gcmALLOCATOR_Physical(allocator, mdl, offset, &phys);
 
@@ -3707,25 +3700,6 @@ gckOS_MapPagesEx(
             phys |= ((gctPHYS_ADDR_T)policyID << 36);
         }
 
-#ifdef CONFIG_IOMMU_SUPPORT
-        if (Os->iommu)
-        {
-            /* remove LSB. */
-            phys &= PAGE_MASK;
-
-            gcmkTRACE_ZONE(
-                gcvLEVEL_INFO, gcvZONE_OS,
-                "%s(%d): Setup mapping in IOMMU %x => %x",
-                __FUNCTION__, __LINE__,
-                Address + offset, phys
-                );
-
-            /* When use IOMMU, GPU use system PAGE_SIZE. */
-            gcmkONERROR(gckIOMMU_Map(
-                Os->iommu, Address + offset, phys, PAGE_SIZE));
-        }
-        else
-#endif
         {
             /* remove LSB. */
             phys &= ~(4096ull - 1);
@@ -3790,14 +3764,6 @@ gckOS_UnmapPages(
     IN gctUINT32 Address
     )
 {
-#ifdef CONFIG_IOMMU_SUPPORT
-    if (Os->iommu)
-    {
-        gcmkVERIFY_OK(gckIOMMU_Unmap(
-            Os->iommu, Address, PageCount * 4096));
-    }
-#endif
-
     return gcvSTATUS_OK;
 }
 
@@ -3818,7 +3784,6 @@ gckOS_Map1MPages(
     PLINUX_MDL mdl;
     gctUINT32* table;
     gctUINT32  offset = 0;
-
     gctSIZE_T bytes = PageCount * 4;
     gckALLOCATOR allocator;
 
@@ -3865,7 +3830,7 @@ gckOS_Map1MPages(
 
     while (PageCount-- > 0)
     {
-        gctPHYS_ADDR_T phys = ~0U;
+        gctPHYS_ADDR_T phys = ~0ULL;
 
         gcmALLOCATOR_Physical(allocator, mdl, offset, &phys);
 
@@ -3881,14 +3846,15 @@ gckOS_Map1MPages(
         }
 
         /* Get the start physical of 1M page. */
-        phys &= ~((1 << 20) - 1);
+        phys &= ~(gcd1M_PAGE_SIZE - 1);
 
-        gcmkONERROR(
-            gckMMU_SetPage(Os->device->kernels[Core]->mmu,
+        gcmkONERROR(gckMMU_SetPage(
+            Os->device->kernels[Core]->mmu,
             phys,
             gcvPAGE_TYPE_1M,
             Writable,
-            table++));
+            table++
+            ));
 
         offset += gcd1M_PAGE_SIZE;
     }
@@ -4286,15 +4252,12 @@ gckOS_WriteMemory(
             gcmkONERROR(gcvSTATUS_INVALID_ADDRESS);
         }
     }
-    else if (virt_addr_valid(Address) || is_vmalloc_addr(Address))
+    else
     {
+        /* don't check the virtual address, maybe it come from io memory or reserved memory */
         /* Kernel address. */
         *(gctUINT32 *)Address = Data;
     }
-    else
-    {
-        gcmkONERROR(gcvSTATUS_INVALID_ADDRESS);
-    }
 
 OnError:
     gcmkFOOTER();
@@ -7532,6 +7495,10 @@ gckOS_QueryOption(
     {
         *Value = device->args.enableNN;
     }
+    else if (!strcmp(Option, "softReset"))
+    {
+        *Value = device->args.softReset;
+    }
     else
     {
         status = gcvSTATUS_NOT_SUPPORTED;
@@ -7809,3 +7776,25 @@ gckOS_GetPolicyID(
 
     return status;
 }
+
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+gckOS_SwitchCoreCount(
+    IN gckOS Os,
+    OUT gctUINT32 *Count
+    )
+{
+    gceSTATUS status = gcvSTATUS_OK;
+    gcsPLATFORM * platform = Os->device->platform;
+
+    gcmkHEADER_ARG("Os=%p", Os);
+
+    status = (platform && platform->ops->switchCoreCount)
+           ? platform->ops->switchCoreCount(platform, Count)
+           : gcvSTATUS_OK;
+
+    gcmkFOOTER_ARG("*Count=%d", *Count);
+    return status;
+}
+#endif
+
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.h
index d07a0244785d..06cb411188f8 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_os.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform.h
index 9f0bb88dd57a..4f78b86ce9b7 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -124,7 +124,7 @@ typedef struct _gcsMODULE_PARAMETERS
     /* Debug or other information. */
     gctUINT                 stuckDump;
 	gctINT                  gpuProfiler;
-
+    gctUINT                 softReset;
     /* device type, 0 for char device, 1 for misc device. */
     gctUINT                 deviceType;
     gctUINT                 showArgs;
@@ -312,7 +312,6 @@ typedef struct _gcsPLATFORM_OPERATIONS
     **
     ** syncMemory
     **
-    ** sync invisible memory by dma if support.
     */
     gceSTATUS
     (*syncMemory)(
@@ -345,33 +344,44 @@ typedef struct _gcsPLATFORM_OPERATIONS
         IN gctUINT32  powerLevel
         );
 
-/*******************************************************************************
-**
-**  _ExternalCacheOperation
-**
-**  External device cache operation, if support. If the core has any additional caches
-**  they must be invalidated after this function returns. If the core does not
-**  have any addional caches the externalCacheOperation in the platform->ops should
-**  remain NULL. The function may be called by multiple thread, so need to add mutex
-**  in the callback when there is shared resource.
-**
-**  INPUT:
-**
-**      gckOS Os
-**          Pointer to an gckOS object.
-**
-**      gceCACHEOPERATION Operation
-**          Cache Operation: gcvCACHE_FLUSH, gcvCACHE_CLEAN or gcvCACHE_INVALIDATE.
-**
-**  OUTPUT:
-**
-**      Nothing.
-*/
+
+    /*******************************************************************************
+    **
+    **  _ExternalCacheOperation
+    **
+    **  External device cache operation, if support. If the core has any additional caches
+    **  they must be invalidated after this function returns. If the core does not
+    **  have any addional caches the externalCacheOperation in the platform->ops should
+    **  remain NULL. The function may be called by multiple thread, so need to add mutex
+    **  in the callback when there is shared resource.
+    **
+    **  INPUT:
+    **      gceCACHEOPERATION Operation
+    **          Cache Operation: gcvCACHE_FLUSH, gcvCACHE_CLEAN or gcvCACHE_INVALIDATE.
+    **
+    **  OUTPUT:
+    **
+    **      Nothing.
+    */
     void
     (*externalCacheOperation)(
         IN gcsPLATFORM *Platform,
         IN gceCACHEOPERATION Operation
     );
+
+#if gcdENABLE_MP_SWITCH
+    /*******************************************************************************
+    ** switchCoreCount
+    **
+    ** Switch the core count according to specific conditions.
+    **
+    */
+    gceSTATUS
+    (*switchCoreCount)(
+        IN gcsPLATFORM *Platform,
+        OUT gctUINT32 *Count
+    );
+#endif
 }
 gcsPLATFORM_OPERATIONS;
 
@@ -383,13 +393,17 @@ struct _gcsPLATFORM
     const char *name;
     gcsPLATFORM_OPERATIONS* ops;
 
-    /* TODO: Remove AXI-SRAM size from feature database. */
     gckDEVICE dev;
 
     /* PLATFORM specific flags */
     gctUINT32  flagBits;
 
+    /* Real-time core count. */
+    gctUINT32  coreCount;
+
     void*                   priv;
+    /* Module special parameters */
+    gcsMODULE_PARAMETERS params;
 };
 
 int gckPLATFORM_Init(struct platform_driver *pdrv, gcsPLATFORM **platform);
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform_amlogic.c
similarity index 62%
rename from drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.c
rename to drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform_amlogic.c
index 62de70280cc6..4f08f90dbcdf 100644
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_platform_amlogic.c
@@ -1,16 +1,57 @@
 /****************************************************************************
 *
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
+*    The MIT License (MIT)
 *
-*    The material in this file is confidential and contains trade secrets
-*    of Vivante Corporation. This is proprietary information owned by
-*    Vivante Corporation. No part of this work may be disclosed,
-*    reproduced, copied, transmitted, or used in any way for any purpose,
-*    without the express written permission of Vivante Corporation.
+*    Copyright (c) 2014 - 2018 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2018 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
 *
 *****************************************************************************/
 
-
 #include <linux/io.h>
 #include <linux/kernel.h>
 #include <linux/clk.h>
@@ -28,6 +69,7 @@
 #include <dt-bindings/clock/amlogic,g12a-clkc.h>
 #endif
 
+#define NN_PD_0X99 16
 /*======== power version 0 hardware reg begin ===========*/
 #define AO_RTI_BASE           0xff800000
 #define AO_RTI_GEN_PWR_SLEEP0 (AO_RTI_BASE + (0x3a<<2))
@@ -38,8 +80,8 @@
 #define P_PWRCTRL_ISO_EN1      0xfe007818
 #define P_PWRCTRL_PWR_OFF1     0xfe00781c
 
-static    uint32_t HHI_NANOQ_MEM_PD_REG0 = 0xff63c10c;
-static    uint32_t HHI_NANOQ_MEM_PD_REG1 = 0xff63c110;
+static	uint32_t HHI_NANOQ_MEM_PD_REG0 = 0xff63c10c;
+static	uint32_t HHI_NANOQ_MEM_PD_REG1 = 0xff63c110;
 static  uint32_t RESET_LEVEL2 = 0xffd01088;
 
 static  uint32_t NN_clk = 0xff63c1c8;
@@ -51,6 +93,8 @@ module_param(hardwareResetNum, int, 0644);
 static int nanoqFreq = 800000000;
 module_param(nanoqFreq, int, 0644);
 
+static gctUINT32 powerStatus = 0;
+
 gceSTATUS _InitDtsRegValue(IN gcsPLATFORM *Platform)
 {
     int ret = 0;
@@ -62,28 +106,28 @@ gceSTATUS _InitDtsRegValue(IN gcsPLATFORM *Platform)
     if (res)
     {
         HHI_NANOQ_MEM_PD_REG0 = (unsigned long)res->start;
-        printk("reg resource 2, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
+/*        printk("reg resource 2, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);*/
     }
 
     res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
     if (res)
     {
         HHI_NANOQ_MEM_PD_REG1 = (unsigned long)res->start;
-        printk("reg resource 3, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
+/*        printk("reg resource 3, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);*/
     }
 
     res = platform_get_resource(pdev, IORESOURCE_MEM, 4);
     if (res)
     {
         RESET_LEVEL2 = (unsigned long)res->start;
-        printk("reg resource 4, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
+/*        printk("reg resource 4, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);*/
     }
 
     res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "NN_CLK");
     if (res)
     {
         NN_clk = (unsigned long)res->start;
-        printk("reg resource NN_CLK, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
+/*        printk("reg resource NN_CLK, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);*/
     }
 
     ret = of_property_read_u32(pdev->dev.of_node,"nn_power_version",&nn_power_version);
@@ -97,8 +141,6 @@ gceSTATUS _AdjustParam(IN gcsPLATFORM *Platform,OUT gcsMODULE_PARAMETERS *Args)
     struct platform_device *pdev = Platform->device;
     int irqLine = platform_get_irq_byname(pdev, "galcore");
 
-    if (irqLine >= 0)
-        printk("galcore irq number is %d.\n", irqLine);
     if (irqLine < 0) {
         printk("get galcore irq resource error\n");
         irqLine = platform_get_irq(pdev, 0);
@@ -113,7 +155,7 @@ gceSTATUS _AdjustParam(IN gcsPLATFORM *Platform,OUT gcsMODULE_PARAMETERS *Args)
     if (res)
     {
         Args->registerBases[0] = (gctPHYS_ADDR_T)res->start;
-        Args->registerSizes[0] = (gctSIZE_T)(res->end - res->start+1);
+        Args->registerSizes[0] = 0x20000;
     }
     else
     {
@@ -128,7 +170,7 @@ gceSTATUS _AdjustParam(IN gcsPLATFORM *Platform,OUT gcsMODULE_PARAMETERS *Args)
         Args->extSRAMBases[0] = (gctPHYS_ADDR_T)res->start;
 
         Args->contiguousBase = 0;
-        Args->contiguousSize = (gctSIZE_T)(res->end - res->start+1);
+        Args->contiguousSize = 0x200000;/*(gctSIZE_T)(res->end - res->start+1);*/
     }
     else
     {
@@ -250,27 +292,27 @@ void Getpower_88(struct platform_device *pdev)
 }
 void Getpower_99(struct platform_device *pdev)
 {
-    uint32_t readReg = 0;
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg & 0xfffeffff);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
+	uint32_t readReg = 0;
+	_RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
+	readReg = (readReg & 0xfffeffff);
+	_RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
 
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
+	_RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
+	_RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
 
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg & 0xffffefff);
-    _RegWrite(RESET_LEVEL2, readReg);
+	_RegRead(RESET_LEVEL2,&readReg);
+	readReg = (readReg & 0xffffefff);
+	_RegWrite(RESET_LEVEL2, readReg);
 
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg & 0xfffeffff);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
+	_RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
+	readReg = (readReg & 0xfffeffff);
+	_RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
 
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg | (0x1<<12));
-    _RegWrite(RESET_LEVEL2, readReg);
+	_RegRead(RESET_LEVEL2,&readReg);
+	readReg = (readReg | (0x1<<12));
+	_RegWrite(RESET_LEVEL2, readReg);
 
-    set_clock(pdev);
+	set_clock(pdev);
 }
 void Getpower_a1(struct platform_device *pdev)
 {
@@ -278,6 +320,12 @@ void Getpower_a1(struct platform_device *pdev)
     set_clock(pdev);
     return;
 }
+void Getpower_be(struct platform_device *pdev)
+{
+    /*C2 added power domain, it will get domain power when prob*/
+    set_clock(pdev);
+    return;
+}
 
 /* Downpower: disable nna power for platform */
 
@@ -297,28 +345,33 @@ void Downpower_88(void)
 }
 void Downpower_99(void)
 {
-    unsigned int readReg=0;
+	unsigned int readReg=0;
 
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg & (~(0x1<<12)));
-    _RegWrite(RESET_LEVEL2, readReg);
+	_RegRead(RESET_LEVEL2,&readReg);
+	readReg = (readReg & (~(0x1<<12)));
+	_RegWrite(RESET_LEVEL2, readReg);
 
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg | 0x10000);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
+	_RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
+	readReg = (readReg | 0x10000);
+	_RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
 
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0xffffffff);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0xffffffff);
+	_RegWrite(HHI_NANOQ_MEM_PD_REG0, 0xffffffff);
+	_RegWrite(HHI_NANOQ_MEM_PD_REG1, 0xffffffff);
 
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg | 0x10000);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
+	_RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
+	readReg = (readReg | 0x10000);
+	_RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
 }
 void Downpower_a1(void)
 {
     /*C1 added power domain, it will down domain power when rmmod */
     return;
 }
+void Downpower_be(void)
+{
+    /*C2 added power domain, it will down domain power when rmmod */
+    return;
+}
 
 /* Runtime power manage */
 void Runtime_getpower_88(struct platform_device *pdev)
@@ -351,9 +404,25 @@ void Runtime_downpower_a1(struct platform_device *pdev)
     pm_runtime_disable(&pdev->dev);
 }
 
+void Runtime_getpower_be(struct platform_device *pdev)
+{
+    int ret;
+
+    pm_runtime_enable(&pdev->dev);
+    ret = pm_runtime_get_sync(&pdev->dev);
+    if (ret < 0) printk("===runtime getpower error===\n");
+    set_clock(pdev);
+}
+void Runtime_downpower_be(struct platform_device *pdev)
+{
+
+    pm_runtime_put_sync(&pdev->dev);
+    pm_runtime_disable(&pdev->dev);
+}
 gceSTATUS _GetPower(IN gcsPLATFORM *Platform)
 {
     struct platform_device *pdev = Platform->device;
+    powerStatus = POWER_IDLE;
     _InitDtsRegValue(Platform);
     switch (nn_power_version)
     {
@@ -367,9 +436,14 @@ gceSTATUS _GetPower(IN gcsPLATFORM *Platform)
         case 3:
             Getpower_99(pdev);
             break;
+        case 4:
+            nanoqFreq=666*1024*1024;
+            Getpower_be(pdev);
+            break;
         default:
             printk("not find power_version\n");
     }
+    powerStatus = POWER_ON;
     return gcvSTATUS_OK;
 }
 
@@ -389,9 +463,14 @@ gceSTATUS  _SetPower(IN gcsPLATFORM * Platform,IN gceCORE GPU,IN gctBOOL Enable)
             case 3:
                 Runtime_downpower_99();
                 break;
+            case 4:
+                Runtime_downpower_be(pdev);
+                break;
             default:
                 printk("not find power_version\n");
+                break;
         }
+        powerStatus = POWER_OFF;
     }
     else
     {
@@ -406,9 +485,14 @@ gceSTATUS  _SetPower(IN gcsPLATFORM * Platform,IN gceCORE GPU,IN gctBOOL Enable)
             case 3:
                 Runtime_getpower_99(pdev);
                 break;
+            case 4:
+                Runtime_getpower_be(pdev);
+                break;
             default:
                 printk("not find power_version\n");
+                break;
         }
+        powerStatus = POWER_ON;
     }
     return gcvSTATUS_OK;
 }
@@ -416,6 +500,7 @@ gceSTATUS  _SetPower(IN gcsPLATFORM * Platform,IN gceCORE GPU,IN gctBOOL Enable)
 gceSTATUS _Reset(IN gcsPLATFORM * Platform, IN gceCORE GPU)
 {
     struct platform_device *pdev = Platform->device;
+    powerStatus = POWER_RESET;
     switch (nn_power_version)
     {
         case 1:
@@ -433,8 +518,14 @@ gceSTATUS _Reset(IN gcsPLATFORM * Platform, IN gceCORE GPU)
             mdelay(10);
             Getpower_99(pdev);
             break;
+        case 4:
+            Runtime_downpower_be(pdev);
+            mdelay(10);
+            Runtime_getpower_be(pdev);
+            break;
         default:
             printk("not find power_version\n");
+            break;
     }
     mdelay(2);
     printk("====>>>>npu hardware reset end!\n");
@@ -444,6 +535,7 @@ gceSTATUS _Reset(IN gcsPLATFORM * Platform, IN gceCORE GPU)
         printk("hardwareResetNum is too large over 10000,just set zero\n");
         hardwareResetNum = 0;
     }
+    powerStatus = POWER_ON;
     return gcvSTATUS_OK;
 }
 
@@ -460,9 +552,55 @@ gceSTATUS _DownPower(IN gcsPLATFORM *Platform)
         case 3:
             Downpower_99();
             break;
+        case 4:
+            Downpower_be();
+            break;
         default:
             printk("not find power_version\n");
+            break;
+    }
+    powerStatus = POWER_OFF;
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS
+_GetPowerStatus(IN gcsPLATFORM *Platform,OUT gctUINT32_PTR  pstat)
+{
+    *pstat = powerStatus;
+    return gcvSTATUS_OK;
+}
+
+gceSTATUS _SetPolicy(IN gcsPLATFORM *Platform,IN gctUINT32  powerLevel)
+{
+    //printk("nn_power_version:%d\n",nn_power_version);
+    switch (nn_power_version)
+    {
+        case 1:
+            nanoqFreq=666*1024*1024;
+            break;
+        case 2:
+            nanoqFreq=800000000;
+            break;
+        case 3:
+            nanoqFreq=800000000;
+            break;
+        case 4:
+            nanoqFreq=666*1024*1024;
+            break;
+        default:
+            nanoqFreq=800000000;
+            break;
+    }
+
+    if (powerLevel == 2)
+    {
+        nanoqFreq = nanoqFreq/2;
+    }
+    else if(powerLevel == 3)
+    {
+        nanoqFreq = nanoqFreq/4;
     }
+    printk("nanoqFreq:%d\n",nanoqFreq);
     return gcvSTATUS_OK;
 }
 
@@ -473,6 +611,8 @@ static gcsPLATFORM_OPERATIONS default_ops =
     .reset = _Reset,
     .putPower = _DownPower,
     .setPower = _SetPower,
+    .getPowerStatus = _GetPowerStatus,
+    .setPolicy = _SetPolicy,
 };
 
 static gcsPLATFORM default_platform =
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel.c
index 7447c62e830e..aa061058be95 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel_emulator.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel_emulator.c
index 7d97d7103777..85621de94a92 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel_emulator.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_security_channel_emulator.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.c b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.c
index 521ecca777cf..bfd0d86fda0f 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.c
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.h b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.h
index 8e1c45a5957a..0789f100a4aa 100644
--- a/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.h
+++ b/drivers/staging/npu/os/linux/kernel/gc_hal_kernel_sync.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_amlogic.c b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_amlogic.c
index 16befb4fe21b..1b28b437ed22 100644
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_amlogic.c
+++ b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_amlogic.c
@@ -170,7 +170,7 @@ gceSTATUS _AdjustParam(IN gcsPLATFORM *Platform,OUT gcsMODULE_PARAMETERS *Args)
         Args->extSRAMBases[0] = (gctPHYS_ADDR_T)res->start;
 
         Args->contiguousBase = 0;
-        Args->contiguousSize = (gctSIZE_T)(res->end - res->start+1);
+		Args->contiguousSize = 0x200000;/*(gctSIZE_T)(res->end - res->start+1);*/
     }
     else
     {
@@ -415,7 +415,6 @@ void Runtime_getpower_be(struct platform_device *pdev)
 }
 void Runtime_downpower_be(struct platform_device *pdev)
 {
-
     pm_runtime_put_sync(&pdev->dev);
     pm_runtime_disable(&pdev->dev);
 }
@@ -572,7 +571,6 @@ _GetPowerStatus(IN gcsPLATFORM *Platform,OUT gctUINT32_PTR  pstat)
 
 gceSTATUS _SetPolicy(IN gcsPLATFORM *Platform,IN gctUINT32  powerLevel)
 {
-    //printk("nn_power_version:%d\n",nn_power_version);
     switch (nn_power_version)
     {
         case 1:
@@ -596,7 +594,7 @@ gceSTATUS _SetPolicy(IN gcsPLATFORM *Platform,IN gctUINT32  powerLevel)
     {
         nanoqFreq = nanoqFreq/2;
     }
-    else if(powerLevel == 3)
+    else if (powerLevel == 3)
     {
         nanoqFreq = nanoqFreq/4;
     }
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.config b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.config
deleted file mode 100755
index a01a43fcd211..000000000000
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_c308x.config
+++ /dev/null
@@ -1,4 +0,0 @@
-ifeq ($(USE_LINUX_PCIE), 1)
-EXTRA_CFLAGS +=-DgcdIRQ_SHARED
-endif
-EXTRA_CFLAGS += -DNO_DMA_COHERENT=1
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.c b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.c
deleted file mode 100644
index 2cf543110743..000000000000
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.c
+++ /dev/null
@@ -1,453 +0,0 @@
-/****************************************************************************
-*
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
-*
-*    The material in this file is confidential and contains trade secrets
-*    of Vivante Corporation. This is proprietary information owned by
-*    Vivante Corporation. No part of this work may be disclosed,
-*    reproduced, copied, transmitted, or used in any way for any purpose,
-*    without the express written permission of Vivante Corporation.
-*
-*****************************************************************************/
-
-
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include <linux/delay.h>
-
-#include "gc_hal_kernel_linux.h"
-#include "gc_hal_kernel_platform.h"
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0))
-#include <dt-bindings/clock/g12a-clkc.h>
-#else
-#include <dt-bindings/clock/amlogic,g12a-clkc.h>
-#endif
-
-/*======== power version 0 hardware reg begin ===========*/
-#define AO_RTI_BASE           0xff800000
-#define AO_RTI_GEN_PWR_SLEEP0 (AO_RTI_BASE + (0x3a<<2))
-#define AO_RTI_GEN_PWR_ISO0   (AO_RTI_BASE + (0x3b<<2))
-
-
-/*======== power version 1 hardware reg begin ===========*/
-#define P_PWRCTRL_ISO_EN1      0xfe007818
-#define P_PWRCTRL_PWR_OFF1     0xfe00781c
-
-static    uint32_t HHI_NANOQ_MEM_PD_REG0 = 0xff63c10c;
-static    uint32_t HHI_NANOQ_MEM_PD_REG1 = 0xff63c110;
-static  uint32_t RESET_LEVEL2 = 0xffd01088;
-
-static  uint32_t NN_clk = 0xff63c1c8;
-static  uint32_t nn_power_version = 0;
-
-
-static int hardwareResetNum = 0;
-module_param(hardwareResetNum, int, 0644);
-static int nanoqFreq = 800000000;
-module_param(nanoqFreq, int, 0644);
-
-gceSTATUS _InitDtsRegValue(IN gcsPLATFORM *Platform)
-{
-    int ret = 0;
-    struct resource *res = NULL;
-    struct platform_device *pdev = Platform->device;
-
-
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
-    if (res)
-    {
-        HHI_NANOQ_MEM_PD_REG0 = (unsigned long)res->start;
-        printk("reg resource 2, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
-    }
-
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
-    if (res)
-    {
-        HHI_NANOQ_MEM_PD_REG1 = (unsigned long)res->start;
-        printk("reg resource 3, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
-    }
-
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 4);
-    if (res)
-    {
-        RESET_LEVEL2 = (unsigned long)res->start;
-        printk("reg resource 4, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
-    }
-
-    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "NN_CLK");
-    if (res)
-    {
-        NN_clk = (unsigned long)res->start;
-        printk("reg resource NN_CLK, start: %lx,end: %lx\n",(unsigned long)res->start,(unsigned long)res->end);
-    }
-
-    ret = of_property_read_u32(pdev->dev.of_node,"nn_power_version",&nn_power_version);
-    printk("npu_version: %d\n",nn_power_version);
-    return gcvSTATUS_OK;
-}
-
-gceSTATUS _AdjustParam(IN gcsPLATFORM *Platform,OUT gcsMODULE_PARAMETERS *Args)
-{
-    struct resource *res = NULL;
-    struct platform_device *pdev = Platform->device;
-    int irqLine = platform_get_irq_byname(pdev, "galcore");
-
-    if (irqLine >= 0)
-        printk("galcore irq number is %d.\n", irqLine);
-    if (irqLine < 0) {
-        printk("get galcore irq resource error\n");
-        irqLine = platform_get_irq(pdev, 0);
-        printk("galcore irq number is %d\n", irqLine);
-        if (irqLine < 0)
-            return gcvSTATUS_OUT_OF_RESOURCES;
-    }
-    Args->irqs[gcvCORE_MAJOR] = irqLine;
-
-    /*================read reg value from dts===============*/
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-    if (res)
-    {
-        Args->registerBases[0] = (gctPHYS_ADDR_T)res->start;
-        Args->registerSizes[0] = (gctSIZE_T)(res->end - res->start+1);
-    }
-    else
-    {
-        printk("no memory resource 0\n");
-        Args->registerBases[0] = 0xFF100000;
-        Args->registerSizes[0] = 2 << 10;
-    }
-
-    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-    if (res)
-    {
-        Args->extSRAMBases[0] = (gctPHYS_ADDR_T)res->start;
-
-        Args->contiguousBase = 0;
-        Args->contiguousSize = (gctSIZE_T)(res->end - res->start+1);
-    }
-    else
-    {
-        printk("no memory resource 1\n");
-        Args->contiguousBase = 0;
-        Args->contiguousSize = 0x400000;
-    }
-    return gcvSTATUS_OK;
-}
-
-gceSTATUS _RegWrite(uint32_t reg, uint32_t writeval)
-{
-    void __iomem *vaddr = NULL;
-    reg = round_down(reg, 0x3);
-
-    vaddr = ioremap(reg, 0x4);
-    writel(writeval, vaddr);
-    iounmap(vaddr);
-
-    return gcvSTATUS_OK;
-}
-
-gceSTATUS _RegRead(uint32_t reg,uint32_t *readval)
-{
-    void __iomem *vaddr = NULL;
-    reg = round_down(reg, 0x3);
-    vaddr = ioremap(reg, 0x4);
-    *readval = readl(vaddr);
-    iounmap(vaddr);
-    return gcvSTATUS_OK;
-}
-gceSTATUS get_nna_status(struct platform_device *dev)
-{
-    int ret = 0;
-    uint32_t readReg = 0;
-    uint32_t nn_ef[2];
-    struct platform_device *pdev = dev;
-
-    ret = of_property_read_u32_array(pdev->dev.of_node,"nn_efuse", &nn_ef[0], 2);
-    if (ret == 0)
-    {
-        _RegRead(nn_ef[0],&readReg);
-        readReg = (readReg & nn_ef[1]);
-        if (readReg == 0)
-            return gcvSTATUS_OK;
-        else
-            return gcvSTATUS_MISMATCH;
-    }
-    else
-    {
-        return gcvSTATUS_OK;
-    }
-}
-//us
-void delay(uint32_t time)
-{
-    int i = 0,j = 0;
-    for (j=0;j<1000;j++)
-    {
-        for (i = 0;i<time;i++);
-    }
-}
-/********To Do: add dynamic set clock function*********/
-
-void Getpower_88(void)
-{
-    uint32_t readReg = 0;
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg & 0xfffcffff);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
-
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
-
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg & 0xffffefff);
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg & 0xfffcffff);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
-
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg | (0x1<<12));
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegWrite(NN_clk, 0x7000700);
-}
-
-void Getpower_99(void)
-{
-    uint32_t readReg = 0;
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg & 0xfffeffff);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
-
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
-
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg & 0xffffefff);
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg & 0xfffeffff);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
-
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg | (0x1<<12));
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegWrite(NN_clk, 0x7000700);
-}
-void Getpower_a1(void)
-{
-    uint32_t readReg = 0;
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg & (~(1<<3)));
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegRead(P_PWRCTRL_PWR_OFF1,&readReg);
-    readReg = (readReg & (~(1<<3)));
-    _RegWrite(P_PWRCTRL_PWR_OFF1, readReg);
-
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
-
-    _RegRead(P_PWRCTRL_ISO_EN1,&readReg);
-    readReg = (readReg & (~(1<<3)));
-    _RegWrite(P_PWRCTRL_ISO_EN1, readReg);
-
-    _RegRead(RESET_LEVEL2,&readReg);
-    readReg = (readReg | (1<<3));
-    _RegWrite(RESET_LEVEL2, readReg);
-
-    _RegWrite(NN_clk, 0x3000300);
-}
-gceSTATUS _GetPower(IN gcsPLATFORM *Platform)
-{
-    _InitDtsRegValue(Platform);
-    switch (nn_power_version)
-    {
-        case 1:
-            Getpower_a1();
-            break;
-        case 2:
-            Getpower_88();
-            break;
-        case 3:
-            Getpower_99();
-            break;
-        default:
-            printk("not find power_version\n");
-    }
-    return gcvSTATUS_OK;
-}
-
-void Downpower_88(void)
-{
-    uint32_t readReg = 0;
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg | 0x30000);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
-
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0xffffffff);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0xffffffff);
-
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg | 0x30000);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
-}
-void Downpower_99(void)
-{
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0xffffffff);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0xffffffff);
-}
-void Downpower_a1(void)
-{
-    uint32_t readReg=0;
-    _RegRead(P_PWRCTRL_ISO_EN1,&readReg);
-    readReg = (readReg | (1<<3));
-    _RegWrite(P_PWRCTRL_ISO_EN1, readReg);
-
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0xffffffff);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0xffffffff);
-
-    _RegRead(P_PWRCTRL_PWR_OFF1,&readReg);
-    readReg = (readReg | (1<<3));
-    _RegWrite(P_PWRCTRL_PWR_OFF1, readReg);
-}
-gceSTATUS _DownPower(IN gcsPLATFORM *Platform)
-{
-    switch (nn_power_version)
-    {
-        case 1:
-            Downpower_a1();
-            break;
-        case 2:
-            Downpower_88();
-            break;
-        case 3:
-            Downpower_99();
-            break;
-        default:
-            printk("not find power_version\n");
-    }
-    return gcvSTATUS_OK;
-}
-
-gceSTATUS _Reset(IN gcsPLATFORM * Platform, IN gceCORE GPU)
-{
-    switch (nn_power_version)
-    {
-        case 1:
-            Downpower_a1();
-            mdelay(10);
-            Getpower_a1();
-            break;
-        case 2:
-            Downpower_88();
-            mdelay(10);
-            Getpower_88();
-            break;
-        case 3:
-            Downpower_99();
-            mdelay(10);
-            Getpower_99();
-            break;
-        default:
-            printk("not find power_version\n");
-    }
-    mdelay(2);
-    printk("====>>>>npu hardware reset end!\n");
-    hardwareResetNum++;
-    if (hardwareResetNum > 10000)
-    {
-        printk("hardwareResetNum is too large over 10000,just set zero\n");
-        hardwareResetNum = 0;
-    }
-    return gcvSTATUS_OK;
-}
-
-
-gceSTATUS  _SetPower(IN gcsPLATFORM * Platform,IN gceCORE GPU,IN gctBOOL Enable)
-{
-    if (Enable == 0)
-    {
-        switch (nn_power_version)
-        {
-            case 1:
-                Downpower_a1();
-                break;
-            case 2:
-                Downpower_88();
-                break;
-            case 3:
-                Downpower_99();
-                break;
-            default:
-                printk("not find power_version\n");
-        }
-    }
-    else
-    {
-        switch (nn_power_version)
-        {
-            case 1:
-                Getpower_a1();
-                break;
-            case 2:
-                Getpower_88();
-                break;
-            case 3:
-                Getpower_99();
-                break;
-            default:
-                printk("not find power_version\n");
-        }
-    }
-    return gcvSTATUS_OK;
-}
-static gcsPLATFORM_OPERATIONS default_ops =
-{
-    .adjustParam   = _AdjustParam,
-    .getPower  = _GetPower,
-    .reset = _Reset,
-    .putPower = _DownPower,
-    .setPower = _SetPower,
-};
-
-static gcsPLATFORM default_platform =
-{
-    .name = __FILE__,
-    .ops  = &default_ops,
-};
-
-
-static struct platform_device *default_dev;
-
-static const struct of_device_id galcore_dev_match[] = {
-    {
-        .compatible = "amlogic, galcore"
-    },
-    { },
-};
-
-int gckPLATFORM_Init(struct platform_driver *pdrv, gcsPLATFORM **platform)
-{
-    pdrv->driver.of_match_table = galcore_dev_match;
-
-    *platform = &default_platform;
-    /*  default_dev = platform;  hot plug just not support  */
-    return 0;
-}
-
-int gckPLATFORM_Terminate(gcsPLATFORM *platform)
-{
-    if (default_dev) {
-        platform_device_unregister(default_dev);
-        default_dev = NULL;
-    }
-
-    return 0;
-}
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.config b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.config
deleted file mode 100755
index a01a43fcd211..000000000000
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_pico.config
+++ /dev/null
@@ -1,4 +0,0 @@
-ifeq ($(USE_LINUX_PCIE), 1)
-EXTRA_CFLAGS +=-DgcdIRQ_SHARED
-endif
-EXTRA_CFLAGS += -DNO_DMA_COHERENT=1
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.c b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.c
deleted file mode 100644
index b173d0957967..000000000000
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/****************************************************************************
-*
-*    Copyright (c) 2005 - 2020 by Vivante Corp.  All rights reserved.
-*
-*    The material in this file is confidential and contains trade secrets
-*    of Vivante Corporation. This is proprietary information owned by
-*    Vivante Corporation. No part of this work may be disclosed,
-*    reproduced, copied, transmitted, or used in any way for any purpose,
-*    without the express written permission of Vivante Corporation.
-*
-*****************************************************************************/
-
-
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <dt-bindings/clock/amlogic,g12a-clkc.h>
-#include <linux/clk.h>
-#include <linux/clk-provider.h>
-#include "gc_hal_kernel_linux.h"
-#include "gc_hal_kernel_platform.h"
-
-/*========add by zxw for g12b hardware reg define========*/
-#define AO_RTI_BASE           0xff800000
-#define AO_RTI_GEN_PWR_SLEEP0 (AO_RTI_BASE + (0x3a<<2))   //0xff8000e8
-#define AO_RTI_GEN_PWR_ISO0   (AO_RTI_BASE + (0x3b<<2))   //0xff8000ec
-
-#define HHI_BASE_ADDR         0xff63c000
-#define HHI_NANOQ_MEM_PD_REG0 (HHI_BASE_ADDR+(0x43<<2))
-#define HHI_NANOQ_MEM_PD_REG1 (HHI_BASE_ADDR+(0x44<<2))
-
-#define MAX_NANOQ_FREQ        800000000
-
-gceSTATUS
-_AdjustParam(
-    IN gcsPLATFORM *Platform,
-    OUT gcsMODULE_PARAMETERS *Args
-    )
-{
-    struct platform_device *pdev = Platform->device;
-    int irqLine = platform_get_irq_byname(pdev, "galcore");
-
-    printk("galcore irq number is %d.\n", irqLine);
-    if (irqLine< 0) {
-        printk("get galcore irq resource error\n");
-        irqLine = platform_get_irq(pdev, 0);
-        printk("galcore irq number is %d\n", irqLine);
-    }
-    if (irqLine < 0) return gcvSTATUS_OUT_OF_RESOURCES;
-
-    Args->irqs[gcvCORE_MAJOR] = irqLine;
-
-    Args->contiguousBase = 0;
-    Args->contiguousSize = 0x01000000;
-
-    Args->extSRAMBases[0] = 0xFF000000;
-
-    Args->registerBases[0] = 0xFF100000;
-    Args->registerSizes[0] = 0x20000;
-
-    return gcvSTATUS_OK;
-}
-
-int _RegWrite(unsigned int reg, unsigned int writeval)
-{
-    void __iomem *vaddr;
-    reg = round_down(reg, 0x3);
-
-    vaddr = ioremap(reg, 0x4);
-    writel(writeval, vaddr);
-    iounmap(vaddr);
-
-    return 0;
-}
-
-int _RegRead(unsigned int reg,unsigned int *readval)
-{
-    void __iomem *vaddr;
-    reg = round_down(reg, 0x3);
-    vaddr = ioremap(reg, 0x4);
-    *readval = readl(vaddr);
-    iounmap(vaddr);
-    return 0;
-}
-//us
-void delay(unsigned int time)
-{
-    int i,j;
-    for(j=0;j<1000;j++)
-    {
-        for(i = 0;i<time;i++);
-    }
-}
-
-static void set_clock(struct platform_device *pdev)
-{
-    struct clk *npu_axi_clk = NULL;
-    struct clk *npu_core_clk = NULL;
-    npu_axi_clk = clk_get(&pdev->dev, "cts_vipnanoq_axi_clk_composite");
-    if (IS_ERR(npu_axi_clk))
-    {
-        printk("%s: get npu_axi_clk error!!!\n", __func__);
-        return;
-    }
-    else
-    {
-        clk_prepare_enable(npu_axi_clk);
-    }
-    clk_set_rate(npu_axi_clk, MAX_NANOQ_FREQ);
-
-    npu_core_clk = clk_get(&pdev->dev, "cts_vipnanoq_core_clk_composite");
-    if (IS_ERR(npu_core_clk))
-    {
-        printk("%s: get npu_core_clk error!!!\n", __func__);
-        return;
-    }
-    else
-    {
-        clk_prepare_enable(npu_core_clk);
-    }
-    clk_set_rate(npu_core_clk, MAX_NANOQ_FREQ);
-    return;
-}
-gceSTATUS
-_GetPower(IN gcsPLATFORM *Platform)
-{
-    unsigned int readReg=0;
-    _RegRead(AO_RTI_GEN_PWR_SLEEP0,&readReg);
-    readReg = (readReg & 0xfffcffff);
-    _RegWrite(AO_RTI_GEN_PWR_SLEEP0, readReg);
-    _RegRead(AO_RTI_GEN_PWR_ISO0,&readReg);
-    readReg = (readReg & 0xfffcffff);
-    _RegWrite(AO_RTI_GEN_PWR_ISO0, readReg);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG0, 0x0);
-    _RegWrite(HHI_NANOQ_MEM_PD_REG1, 0x0);
-    set_clock(Platform->device);
-    delay(500);
-    return gcvSTATUS_OK;
-}
-
-static struct _gcsPLATFORM_OPERATIONS default_ops =
-{
-    .adjustParam   = _AdjustParam,
-    .getPower  = _GetPower,
-};
-
-static struct _gcsPLATFORM default_platform =
-{
-    .name = __FILE__,
-    .ops  = &default_ops,
-};
-
-static struct platform_device *default_dev;
-
-static const
-struct of_device_id galcore_dev_match[] = {
-    {
-        .compatible = "amlogic, galcore"
-    },
-    { },
-};
-
-int gckPLATFORM_Init(struct platform_driver *pdrv,
-            struct _gcsPLATFORM **platform)
-{
-    pdrv->driver.of_match_table = galcore_dev_match;
-
-    *platform = &default_platform;
-    return 0;
-}
-
-int gckPLATFORM_Terminate(struct _gcsPLATFORM *platform)
-{
-    if (default_dev) {
-        platform_device_unregister(default_dev);
-        default_dev = NULL;
-    }
-
-    return 0;
-}
diff --git a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.config b/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.config
deleted file mode 100755
index a01a43fcd211..000000000000
--- a/drivers/staging/npu/os/linux/kernel/platform/amlogic/gc_hal_kernel_platform_vim3.config
+++ /dev/null
@@ -1,4 +0,0 @@
-ifeq ($(USE_LINUX_PCIE), 1)
-EXTRA_CFLAGS +=-DgcdIRQ_SHARED
-endif
-EXTRA_CFLAGS += -DNO_DMA_COHERENT=1
diff --git a/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.c b/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.c
index 55a6f1cac156..bcd6b8ac5d07 100644
--- a/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.c
+++ b/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
@@ -55,9 +55,10 @@
 
 #include "gc_hal_kernel_linux.h"
 #include "gc_hal_kernel_platform.h"
+#include "gc_hal_kernel_platform_default.h"
 
 /* Disable MSI for internal FPGA build except PPC */
-#if gcdFPGA_BUILD && !defined(CONFIG_PPC)
+#if gcdFPGA_BUILD
 #define USE_MSI     0
 #else
 #define USE_MSI     1
@@ -76,13 +77,435 @@ _GetGPUPhysical(
     OUT gctPHYS_ADDR_T *GPUPhysical
     );
 
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+_SwitchCoreCount(
+    IN gcsPLATFORM *Platform,
+    OUT gctUINT32 *Count
+    );
+#endif
+
 static struct _gcsPLATFORM_OPERATIONS default_ops =
 {
     .adjustParam   = _AdjustParam,
     .getGPUPhysical = _GetGPUPhysical,
+#if gcdENABLE_MP_SWITCH
+    .switchCoreCount = _SwitchCoreCount,
+#endif
 };
 
-#if USE_LINUX_PCIE
+
+#if gcdSUPPORT_DEVICE_TREE_SOURCE
+static int gpu_parse_dt(struct platform_device *pdev, gcsMODULE_PARAMETERS *params);
+static void gpu_add_power_domains(void);
+
+static struct _gcsPLATFORM default_platform =
+{
+    .name = __FILE__,
+    .ops  = &default_ops,
+};
+
+static gcsPOWER_DOMAIN domains[] =
+{
+    [gcvCORE_MAJOR] =
+    {
+        .base =
+        {
+            .name = "pd-major",
+        },
+    },
+    [gcvCORE_3D1] =
+    {
+        .base =
+        {
+            .name = "pd-3d1",
+        },
+    },
+    [gcvCORE_3D2] =
+    {
+        .base =
+        {
+            .name = "pd-3d2",
+        },
+    },
+    [gcvCORE_3D3] =
+    {
+        .base =
+        {
+            .name = "pd-3d3",
+        },
+    },
+    [gcvCORE_3D4] =
+    {
+        .base =
+        {
+            .name = "pd-3d4",
+        },
+    },
+    [gcvCORE_3D5] =
+    {
+        .base =
+        {
+            .name = "pd-3d5",
+        },
+    },
+    [gcvCORE_3D6] =
+    {
+        .base =
+        {
+            .name = "pd-3d6",
+        },
+    },
+    [gcvCORE_3D7] =
+    {
+        .base =
+        {
+            .name = "pd-3d7",
+        },
+    },
+    [gcvCORE_2D] =
+    {
+        .base =
+        {
+            .name = "pd-2d",
+        },
+    },
+    [gcvCORE_VG] =
+    {
+        .base =
+        {
+            .name = "pd-vg",
+        },
+    },
+#if gcdDEC_ENABLE_AHB
+    [gcvCORE_DEC] =
+    {
+        .base =
+        {
+            .name = "pd-dec",
+        },
+    },
+#endif
+    [gcvCORE_2D1] =
+    {
+        .base =
+        {
+            .name = "pd-2d1",
+        },
+    },
+};
+
+static inline gcsPOWER_DOMAIN *to_gc_power_domain(struct generic_pm_domain *gpd)
+{
+    return gcmCONTAINEROF(gpd, gcsPOWER_DOMAIN, base);
+}
+
+static int gc_power_domain_power_on(    struct generic_pm_domain *gpd)
+{
+    return 0;
+}
+
+static int gc_power_domain_power_off(    struct generic_pm_domain *gpd)
+{
+    return 0;
+}
+
+static int gc_power_domain_probe(struct platform_device *pdev)
+{
+    gceSTATUS status;
+    int ret = 0;
+    struct device_node *np = pdev->dev.of_node;
+    int core_id;
+
+    ret = of_property_read_u32(np, "core-id", &core_id);
+    if (ret)
+    {
+        gcmONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+    if (core_id >= gcvCORE_COUNT)
+    {
+        gcmONERROR(gcvSTATUS_INVALID_ARGUMENT);
+    }
+
+    ret = platform_device_add_data(pdev, (gctPOINTER)&domains[core_id], sizeof(gcsPOWER_DOMAIN));
+    if (ret)
+    {
+        gcmONERROR(gcvSTATUS_NOT_SUPPORTED);
+    }
+
+    return 0;
+OnError:
+    return ret;
+}
+
+static int gc_power_domain_remove(struct platform_device *pdev)
+{
+    gcsPOWER_DOMAIN *domain = pdev->dev.platform_data;
+
+    if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
+    {
+        of_genpd_del_provider(domain->pdev->dev.of_node);
+    }
+
+    return 0;
+}
+
+static const struct of_device_id gc_power_domain_dt_ids[] =
+{
+    {.compatible = "verisilicon,pd-vip",},
+    {.compatible = "verisilicon,pd-gpu2d",},
+    {.compatible = "verisilicon,pd-gpu3d",},
+
+    {/* sentinel */}
+};
+
+static struct platform_driver gc_power_domain_driver =
+{
+    .driver = {
+        .owner = THIS_MODULE,
+        .name = "gc-pm-domains",
+        .of_match_table = gc_power_domain_dt_ids,
+    },
+    .probe = gc_power_domain_probe,
+    .remove = gc_power_domain_remove,
+};
+
+static int gpu_power_domain_init(void)
+{
+    return platform_driver_register(&gc_power_domain_driver);
+}
+
+
+static void gpu_power_domain_exit(void)
+{
+    platform_driver_unregister(&gc_power_domain_driver);
+}
+
+static void gpu_add_power_domains(void)
+{
+    struct device_node *np = gcvNULL;
+    int ret;
+    gceSTATUS status;
+
+    for_each_matching_node(np, gc_power_domain_dt_ids)
+    {
+        struct platform_device *pdev;
+        gcsPOWER_DOMAIN *domain = domains;
+        int core_id;
+
+        if (!of_device_is_available(np))
+        {
+            continue;
+        }
+
+        pdev = of_find_device_by_node(np);
+
+        if (!pdev)
+            break;
+
+        ret = of_property_read_u32(np, "core-id", &core_id);
+        if (ret)
+        {
+            gcmONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        }
+        if (core_id >= gcvCORE_COUNT)
+        {
+            gcmONERROR(gcvSTATUS_INVALID_ARGUMENT);
+        }
+
+        domain[core_id].pdev = pdev;
+        domain[core_id].core_id = core_id;
+
+        domain[core_id].base.power_on = gc_power_domain_power_on;
+        domain[core_id].base.power_off = gc_power_domain_power_off;
+
+        if (IS_ENABLED(CONFIG_PM_GENERIC_DOMAINS))
+        {
+            ret = pm_genpd_init(&domain[core_id].base, gcvNULL, true);
+            if (ret)
+            {
+                continue;
+            }
+
+            ret = of_genpd_add_provider_simple(np, &domain[core_id].base);
+            if (ret)
+            {
+                continue;
+            }
+        }
+    }
+OnError:
+    return;
+}
+
+static int gpu_parse_dt(struct platform_device *pdev, gcsMODULE_PARAMETERS *params)
+{
+    struct device_node *root = pdev->dev.of_node;
+    struct resource* res;
+    gctUINT32 i;
+    const gctUINT32 *value;
+    const char *core_names[] =
+    {
+        "core_major",
+        "core_3d1",
+        "core_3d2",
+        "core_3d3",
+        "core_3d4",
+        "core_3d5",
+        "core_3d6",
+        "core_3d7",
+        "core_2d",
+        "core_vg",
+#if gcdDEC_ENABLE_AHB
+        "core_dec",
+#endif
+        "core_2d1",
+    };
+
+    gcmSTATIC_ASSERT(gcvCORE_COUNT == gcmCOUNTOF(core_names),
+                     "core_names array does not match core types");
+
+    /* parse the irqs config */
+    for (i = 0; i < gcvCORE_COUNT; i++)
+    {
+        res = platform_get_resource_byname(pdev, IORESOURCE_IRQ, core_names[i]);
+        if (res)
+        {
+            params->irqs[i] = res->start;
+        }
+    }
+
+    /* parse the registers config */
+    for (i = 0; i < gcvCORE_COUNT; i++)
+    {
+        res = platform_get_resource_byname(pdev, IORESOURCE_MEM, core_names[i]);
+        if (res)
+        {
+            params->registerBases[i] = res->start;
+            params->registerSizes[i] = res->end - res->start + 1;
+        }
+    }
+
+    /* parse the contiguous mem */
+    value = of_get_property(root, "contiguous-size", gcvNULL);
+    if (value && *value != 0)
+    {
+        gctUINT64 addr;
+
+        of_property_read_u64(root, "contiguous-base", &addr);
+        params->contiguousSize = *value;
+        params->contiguousBase = addr;
+    }
+
+    value = of_get_property(root, "contiguous-requested", gcvNULL);
+    if (value)
+    {
+        params->contiguousRequested = *value ? gcvTRUE : gcvFALSE;
+    }
+
+    /* parse the external mem */
+    value = of_get_property(root, "external-size", gcvNULL);
+    if (value && *value != 0)
+    {
+        gctUINT64 addr;
+
+        of_property_read_u64(root, "external-base", &addr);
+        params->externalSize = *value;
+        params->externalBase = addr;
+    }
+
+    value = of_get_property(root, "phys-size", gcvNULL);
+    if (value && *value != 0)
+    {
+        gctUINT64 addr;
+
+        of_property_read_u64(root, "base-address", &addr);
+        params->physSize = *value;
+        params->baseAddress = addr;
+    }
+
+    value = of_get_property(root, "phys-size", gcvNULL);
+    if (value)
+    {
+        params->bankSize = *value;
+    }
+
+    value = of_get_property(root, "recovery", gcvNULL);
+    if (value)
+    {
+        params->recovery = *value;
+    }
+
+    value = of_get_property(root, "power-management", gcvNULL);
+    if (value)
+    {
+        params->powerManagement = *value;
+    }
+
+    value = of_get_property(root, "enable-mmu", gcvNULL);
+    if (value)
+    {
+        params->enableMmu = *value;
+    }
+
+    value = of_get_property(root, "user-cluster-mask", gcvNULL);
+    if (value)
+    {
+        params->userClusterMask = *value;
+    }
+
+    value = of_get_property(root, "stuck-dump", gcvNULL);
+    if (value)
+    {
+        params->stuckDump = *value;
+    }
+
+    value = of_get_property(root, "gpu-profiler", gcvNULL);
+    if (value)
+    {
+        params->gpuProfiler = *value;
+    }
+
+    value = of_get_property(root, "show-args", gcvNULL);
+    if (value)
+    {
+        params->showArgs = *value;
+    }
+
+    value = of_get_property(root, "mmu-page-table-pool", gcvNULL);
+    if (value)
+    {
+        params->mmuPageTablePool = *value;
+    }
+
+    value = of_get_property(root, "mmu-dynamic-map", gcvNULL);
+    if (value)
+    {
+        params->mmuDynamicMap = *value;
+    }
+
+    value = of_get_property(root, "all-map-in-one", gcvNULL);
+    if (value)
+    {
+        params->allMapInOne = *value;
+    }
+
+    value = of_get_property(root, "isr-poll-mask", gcvNULL);
+    if (value)
+    {
+        params->isrPoll = *value;
+    }
+
+    return 0;
+}
+
+static const struct of_device_id gpu_dt_ids[] = {
+    { .compatible = "verisilicon,galcore",},
+
+    {/* sentinel */}
+};
+
+#elif USE_LINUX_PCIE
 
 #define MAX_PCIE_DEVICE 4
 #define MAX_PCIE_BAR    6
@@ -167,8 +590,80 @@ _QueryBarInfo(
     *BarSize = size;
 }
 
+static const struct pci_device_id vivpci_ids[] = {
+  {
+    .class = 0x000000,
+    .class_mask = 0x000000,
+    .vendor = 0x10ee,
+    .device = 0x7012,
+    .subvendor = PCI_ANY_ID,
+    .subdevice = PCI_ANY_ID,
+    .driver_data = 0
+  }, { /* End: all zeroes */ }
+};
+
+MODULE_DEVICE_TABLE(pci, vivpci_ids);
+
+
+static int gpu_sub_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
+    static u64 dma_mask = DMA_BIT_MASK(40);
 #else
+    static u64 dma_mask = DMA_40BIT_MASK;
+#endif
 
+    gcmkPRINT("PCIE DRIVER PROBED");
+    if (pci_enable_device(pdev)) {
+        printk(KERN_ERR "galcore: pci_enable_device() failed.\n");
+    }
+
+    if (pci_set_dma_mask(pdev, dma_mask)) {
+        printk(KERN_ERR "galcore: Failed to set DMA mask.\n");
+    }
+
+    pci_set_master(pdev);
+
+    if (pci_request_regions(pdev, "galcore")) {
+        printk(KERN_ERR "galcore: Failed to get ownership of BAR region.\n");
+    }
+
+#if USE_MSI
+    if (pci_enable_msi(pdev)) {
+        printk(KERN_ERR "galcore: Failed to enable MSI.\n");
+    }
+#endif
+
+#if defined(CONFIG_PPC)
+    /* On PPC platform, enable bus master, enable irq. */
+    if (pci_write_config_word(pdev, 0x4, 0x0006) < 0) {
+        printk(KERN_ERR "galcore: Failed to enable bus master on PPC.\n");
+    }
+#endif
+
+    default_platform.pcie_info[default_platform.device_number++].pdev = pdev;
+    return 0;
+}
+
+static void gpu_sub_remove(struct pci_dev *pdev)
+{
+    pci_set_drvdata(pdev, NULL);
+#if USE_MSI
+    pci_disable_msi(pdev);
+#endif
+    pci_clear_master(pdev);
+    pci_release_regions(pdev);
+    pci_disable_device(pdev);
+    return;
+}
+
+static struct pci_driver gpu_pci_subdriver = {
+    .name = DEVICE_NAME,
+    .id_table = vivpci_ids,
+    .probe = gpu_sub_probe,
+    .remove = gpu_sub_remove
+};
+#else
 static struct _gcsPLATFORM default_platform =
 {
     .name = __FILE__,
@@ -182,7 +677,10 @@ _AdjustParam(
     OUT gcsMODULE_PARAMETERS *Args
     )
 {
-#if USE_LINUX_PCIE
+#if gcdSUPPORT_DEVICE_TREE_SOURCE
+    gpu_parse_dt(Platform->device, Args);
+    gpu_add_power_domains();
+#elif USE_LINUX_PCIE
     struct _gcsPLATFORM_PCIE *pcie_platform = (struct _gcsPLATFORM_PCIE *)Platform;
     struct pci_dev *pdev = pcie_platform->pcie_info[0].pdev;
     int irqline = pdev->irq;
@@ -218,6 +716,11 @@ _AdjustParam(
         {
             if (Args->bars[i] != -1)
             {
+                if (i > gcvCORE_3D_MAX)
+                {
+                    core_index = i;
+                }
+
                 Args->irqs[core_index] = pcieDev->irq;
 
                 /* VIV bitfile: Merge last 4 cores to last one bar to support 8 cores. */
@@ -290,7 +793,6 @@ _GetGPUPhysical(
     gctPHYS_ADDR_T sram_gpu_base = pcie_platform->pcie_info[0].sram_gpu_bases[0];
     uint32_t sram_size = pcie_platform->pcie_info[0].sram_sizes[0];
 
-    /* TODO: We should always set axi sram size by insmod parameters, never from feature database. */
     if (!sram_size && Platform->dev && Platform->dev->extSRAMSizes[0])
     {
         sram_size = Platform->dev->extSRAMSizes[0];
@@ -316,82 +818,25 @@ _GetGPUPhysical(
     return gcvSTATUS_OK;
 }
 
-#if USE_LINUX_PCIE
-static const struct pci_device_id vivpci_ids[] = {
-  {
-    .class = 0x000000,
-    .class_mask = 0x000000,
-    .vendor = 0x10ee,
-    .device = 0x7012,
-    .subvendor = PCI_ANY_ID,
-    .subdevice = PCI_ANY_ID,
-    .driver_data = 0
-  }, { /* End: all zeroes */ }
-};
-
-MODULE_DEVICE_TABLE(pci, vivpci_ids);
-
-
-static int gpu_sub_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+#if gcdENABLE_MP_SWITCH
+gceSTATUS
+_SwitchCoreCount(
+    IN gcsPLATFORM *Platform,
+    OUT gctUINT32 *Count
+    )
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 24)
-    static u64 dma_mask = DMA_BIT_MASK(40);
-#else
-    static u64 dma_mask = DMA_40BIT_MASK;
-#endif
-
-    gcmkPRINT("PCIE DRIVER PROBED");
-    if (pci_enable_device(pdev)) {
-        printk(KERN_ERR "galcore: pci_enable_device() failed.\n");
-    }
-
-    if (pci_set_dma_mask(pdev, dma_mask)) {
-        printk(KERN_ERR "galcore: Failed to set DMA mask.\n");
-    }
-
-    pci_set_master(pdev);
-
-    if (pci_request_regions(pdev, "galcore")) {
-        printk(KERN_ERR "galcore: Failed to get ownership of BAR region.\n");
-    }
-
-#if USE_MSI
-    if (pci_enable_msi(pdev)) {
-        printk(KERN_ERR "galcore: Failed to enable MSI.\n");
-    }
-#endif
-    default_platform.pcie_info[default_platform.device_number++].pdev = pdev;
-    return 0;
-}
+    *Count = Platform->coreCount;
 
-static void gpu_sub_remove(struct pci_dev *pdev)
-{
-    pci_set_drvdata(pdev, NULL);
-#if USE_MSI
-    pci_disable_msi(pdev);
-#endif
-    pci_clear_master(pdev);
-    pci_release_regions(pdev);
-    pci_disable_device(pdev);
-    return;
+    return gcvSTATUS_OK;
 }
-
-static struct pci_driver gpu_pci_subdriver = {
-    .name = DEVICE_NAME,
-    .id_table = vivpci_ids,
-    .probe = gpu_sub_probe,
-    .remove = gpu_sub_remove
-};
-
 #endif
 
-static struct platform_device *default_dev;
-
 int gckPLATFORM_Init(struct platform_driver *pdrv,
             struct _gcsPLATFORM **platform)
 {
-    int ret;
-    default_dev = platform_device_alloc(pdrv->driver.name, -1);
+    int ret = 0;
+#if !gcdSUPPORT_DEVICE_TREE_SOURCE
+    struct platform_device *default_dev = platform_device_alloc(pdrv->driver.name, -1);
 
     if (!default_dev) {
         printk(KERN_ERR "galcore: platform_device_alloc failed.\n");
@@ -402,28 +847,36 @@ int gckPLATFORM_Init(struct platform_driver *pdrv,
     ret = platform_device_add(default_dev);
     if (ret) {
         printk(KERN_ERR "galcore: platform_device_add failed.\n");
-        goto put_dev;
+        platform_device_put(default_dev);
+        return ret;
     }
 
-    *platform = (gcsPLATFORM *)&default_platform;
-
 #if USE_LINUX_PCIE
     ret = pci_register_driver(&gpu_pci_subdriver);
+    if (ret)
+    {
+        platform_device_unregister(default_dev);
+        return ret;
+    }
+#endif
+#else
+    pdrv->driver.of_match_table = gpu_dt_ids;
+    ret = gpu_power_domain_init();
+    if (ret) {
+        printk(KERN_ERR "galcore: gpu_gpc_init failed.\n");
+    }
 #endif
 
-    return 0;
-
-put_dev:
-    platform_device_put(default_dev);
-
+    *platform = (gcsPLATFORM *)&default_platform;
     return ret;
 }
 
 int gckPLATFORM_Terminate(struct _gcsPLATFORM *platform)
 {
-    if (default_dev) {
-        platform_device_unregister(default_dev);
-        default_dev = NULL;
+#if !gcdSUPPORT_DEVICE_TREE_SOURCE
+    if (platform->device) {
+        platform_device_unregister(platform->device);
+        platform->device = NULL;
     }
 
 #if USE_LINUX_PCIE
@@ -445,6 +898,8 @@ int gckPLATFORM_Terminate(struct _gcsPLATFORM *platform)
         pci_unregister_driver(&gpu_pci_subdriver);
     }
 #endif
-
+#else
+    gpu_power_domain_exit();
+#endif
     return 0;
 }
diff --git a/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.h b/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.h
new file mode 100644
index 000000000000..95d9ff2517eb
--- /dev/null
+++ b/drivers/staging/npu/os/linux/kernel/platform/default/gc_hal_kernel_platform_default.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+*
+*    The MIT License (MIT)
+*
+*    Copyright (c) 2014 - 2021 Vivante Corporation
+*
+*    Permission is hereby granted, free of charge, to any person obtaining a
+*    copy of this software and associated documentation files (the "Software"),
+*    to deal in the Software without restriction, including without limitation
+*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
+*    and/or sell copies of the Software, and to permit persons to whom the
+*    Software is furnished to do so, subject to the following conditions:
+*
+*    The above copyright notice and this permission notice shall be included in
+*    all copies or substantial portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+*    DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************
+*
+*    The GPL License (GPL)
+*
+*    Copyright (C) 2014 - 2021 Vivante Corporation
+*
+*    This program is free software; you can redistribute it and/or
+*    modify it under the terms of the GNU General Public License
+*    as published by the Free Software Foundation; either version 2
+*    of the License, or (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not, write to the Free Software Foundation,
+*    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+*
+*****************************************************************************
+*
+*    Note: This software is released under dual MIT and GPL licenses. A
+*    recipient may use this file under the terms of either the MIT license or
+*    GPL License. If you wish to use only one license not the other, you can
+*    indicate your decision by deleting one of the above license notices in your
+*    version of this file.
+*
+*****************************************************************************/
+
+
+#ifndef _gc_hal_kernel_platform_default_h_
+#define _gc_hal_kernel_platform_default_h_
+
+#if gcdSUPPORT_DEVICE_TREE_SOURCE
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include "gc_hal.h"
+#include "gc_hal_driver.h"
+#include "gc_hal_kernel.h"
+#include "gc_hal_kernel_platform.h"
+
+typedef struct _gcsPOWER_DOMAIN
+{
+    struct generic_pm_domain base;
+    gceCORE core_id;
+    gctUINT32 flags;
+    struct platform_device *pdev;
+}gcsPOWER_DOMAIN;
+
+#endif
+#endif
diff --git a/drivers/staging/npu/security_v1/gc_hal_ta.c b/drivers/staging/npu/security_v1/gc_hal_ta.c
index b175518ddfcb..46a6a5f264bf 100644
--- a/drivers/staging/npu/security_v1/gc_hal_ta.c
+++ b/drivers/staging/npu/security_v1/gc_hal_ta.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/security_v1/gc_hal_ta.h b/drivers/staging/npu/security_v1/gc_hal_ta.h
index c6b64a98ccd7..0bb9d3bcbd39 100644
--- a/drivers/staging/npu/security_v1/gc_hal_ta.h
+++ b/drivers/staging/npu/security_v1/gc_hal_ta.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/security_v1/gc_hal_ta_hardware.c b/drivers/staging/npu/security_v1/gc_hal_ta_hardware.c
index 8f4d03c6a0e2..afe5cfdedf4b 100644
--- a/drivers/staging/npu/security_v1/gc_hal_ta_hardware.c
+++ b/drivers/staging/npu/security_v1/gc_hal_ta_hardware.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/security_v1/gc_hal_ta_hardware.h b/drivers/staging/npu/security_v1/gc_hal_ta_hardware.h
index dd85d08dabe0..90c89415aa8f 100644
--- a/drivers/staging/npu/security_v1/gc_hal_ta_hardware.h
+++ b/drivers/staging/npu/security_v1/gc_hal_ta_hardware.h
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/security_v1/gc_hal_ta_mmu.c b/drivers/staging/npu/security_v1/gc_hal_ta_mmu.c
index 579721176970..265355cd2999 100644
--- a/drivers/staging/npu/security_v1/gc_hal_ta_mmu.c
+++ b/drivers/staging/npu/security_v1/gc_hal_ta_mmu.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
diff --git a/drivers/staging/npu/security_v1/os/emulator/gc_hal_ta_emulator.c b/drivers/staging/npu/security_v1/os/emulator/gc_hal_ta_emulator.c
index 1f12644047e6..b75b6cc6e158 100644
--- a/drivers/staging/npu/security_v1/os/emulator/gc_hal_ta_emulator.c
+++ b/drivers/staging/npu/security_v1/os/emulator/gc_hal_ta_emulator.c
@@ -2,7 +2,7 @@
 *
 *    The MIT License (MIT)
 *
-*    Copyright (c) 2014 - 2020 Vivante Corporation
+*    Copyright (c) 2014 - 2021 Vivante Corporation
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
@@ -26,7 +26,7 @@
 *
 *    The GPL License (GPL)
 *
-*    Copyright (C) 2014 - 2020 Vivante Corporation
+*    Copyright (C) 2014 - 2021 Vivante Corporation
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
-- 
2.25.1

